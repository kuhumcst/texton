{toolsProg.bra


    Copyright 2014, Bart Jongejan
    This file is part of the DK-ClarinTools.

    DK-ClarinTools is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    DK-ClarinTools is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with DK-ClarinTools.  If not, see <http://www.gnu.org/licenses/>.





Source code for DK-Clarin tools webservice

To neatly re-format this source code, load the file in a running instance of
Bracmat:

    get$"toolsprog.bra"

Now, after you have made changes to the source code in a text editor, reload
the source code in Bracmat using the command:

    !r

This command re-reads the file, renames the previous version from toolsprog.bra
to toolsprog.bak and then saves the source code. Some editors will notice that
the text has changed on disk and offer you to reload the source code.

To change the comment near the start of this file, you need to go to the bottom
of the file and find the text there. A change made to that text takes effect
after saving once and pressing !r two times. Remember to escape quotes " with
a backslash \. Comments elsewhere (i.e. text enclosed by braces { and } is NOT
saved. Use string expressions if you want a comment somewhere.

The following commands can be issued by sending an 'expression' HTTP parameter
to the 'bracmatevaluator' servlet.

To get started from a file containing all tables called 'alltablesxxx' (replace
xxx with actual characters in the file name), e.g., alltables.GPL:

importTables$"alltables.GPL"

This reads the named file and stores each table in a separate file in a folder
structure
work/
    job/
    meta/
        feature/
        style/

(This folder structure must already exist.) Finally, the same file is
rewritten, so all lay-out is normalized (Bracmat style).
This command reads all single file tables from the folder structure and saves
them to 'alltablesxxx'. The command knows the actual name of the file to write
to because that name is stored in the variable AAA, which is itself stored
alongside all tables, and is therefore known after the last time
importTables$alltablesxxx was called. It is possible to change context by
reading an 'alltablesyyy' that is different from 'alltablesxxx'.

If <prod> is the empty string "", then the table tooladm is anonymized by
changing all domains in service URLs "http:\localhost" and by changing all
contact emails to "x@x.xxx".

To export all tables to a different file, do

exportTables$(<prod>."alltableszzz")

where alltableszzz must be a valid file name that starts with 'alltables'.



To do a clean up, removing almost all that is not defined in this file from
Bracmat's memory, call the clean function

    clean$

Changes made to table files take immediately effect. It is advised to use the
admin page to register new tools. Some changes cannot be made using the admin
page, such as adding a new feature or feature value.

Server:
Add following line to /etc/httpd/conf.d/proxy_ajp.conf:
    ProxyPass /toolsdata !
(Restart Apache sudo /etc/init.d/httpd restart)

Make sure bracmat is in JBoss's or Tomcat PATH:
    /usr/lib/libbracmat.so -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1 -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1.0

The conf/properties.xml file has an entry "toolsHome". The value of this entry
is the location of this file, toolsprog.bra.
}

toolsProg=
      (indent=0)
      (logno=0)
      (tabind=0)
      (memoizedTrees=)
      (globval=)
      (runningThreads=0)
      (maxRunningThreads=0)
      (MAXPIPES=10000)
      ( headerTitle
      = "Text Tonsorium - Natural Language Processing workflows automatically composed, scheduled and enacted"
      )
      (hiddenData=)
      ( "Set from boot"
        (toolshome=)
        (documentRoot=)
        (wwwServer=)
        (deleteAfterMillisec=)
        86400000
        (stagingArea=)
        (baseUrlTools=)
        (path=)
        ( password
        = "Fq3vdqxIPqrKGMYh0pD+MY64Acgv8zA9Qhye+S7+mVWujVWuEPUZcEvoKGDLs6tsxJyqVnRzOZFkUBwz2QmiWA=="
        )
        "Empty string as password."
        (salt="CvPAQd7naaqtVD1xJD37eg==")
      )
      (servicedSources=)
      (servicedGoals=)
      (goalPicklists=)
      "Supergoals are goals that fulfil the user's goal, plus
       more. (If the user checks a box and thereby allows it.)"
      (servicedSuperGoals=)
      (updateAvailableWorkflows=)
      ( (‚ü≥ ‚ü≥|"Re-check for bookmarks" "Tjek igen for bogm√¶rker")
      : ?updateAvailableWorkflows
      )
      (helpmespecifymygoal="Zoom in" "Zoom ind")
      (Bookmark=Bookmark Marker)
      (Dryrun="Test workflow" "Test arbejdsgang")
      (Usermsg="Send feed back")
      ("show workflows"="Show available workflows" "Vis mulige arbejdsgange")
      ( "skip zoom"
      =   "Show available workflows  (Not recommended in this phase)"
          "Vis mulige arbejdsgange  (Kan ikke anbefales i dette stadie)"
      )
      (suggestions=" ")
      (StartClk=)
      (startclock=.-1*clk$:?StartClk)
      ( clock
      =   
        .   (!StartClk:&startclock$|)
          & str$("[" jsn$(clk$+!StartClk) "]")
      )
      (path=.str$(!toolshome !arg))
      ( log
      =   c spc i logfile
        .   path$"log.txt":?logfile
          & (   !arg:NEW
              & put$(,!logfile,NEW)
              & startclock$
              & 0:?logno
            |   (!logno|0:?logno)
              &     ( :?spc
                    & 1+!logno:?logno
                    & !indent:?i
                    &   whl
                      ' ( !i+-1:>0:?i
                        & " " !spc:?spc
                        )
                    & str$("[" !indent "] " !logno !spc)
                    )
                    !arg
                : ?arg
              & put$(clock$,!logfile,APP)
              &   whl
                ' ( !arg:%?c ?arg
                  & put$(!c " ",!logfile,APP)
                  )
              & put$(\n,!logfile,APP)
            )
      )
      ( readTable
      =   folder
        .     !arg:%@
            & (   !arg:(AAA|where)
                & (get$(path$!arg):?!arg|`~)
              |   (!where:(?.?) ?|readTable$where)
                & !where:? (? !arg ?.?folder) ?
                & get$(path$(!folder !arg)):?!arg
              )
          | log$("Cannot read " !arg)&~
      )
      ( saveTable
      =   tab saved folder
        .     !arg:
            & :?saved
            & (   !where
                :   ?
                    ( ?Tables
                    .   ?folder
                      &   whl
                        ' ( !Tables
                          :   ( %?tab
                              & saveTable$(!folder.!tab)
                              & !saved !tab:?saved
                              )
                              ?Tables
                          )
                      & ~
                    )
                    ?
              | Saved !saved
              )
          |   !arg:(?folder.?tab)
            & lst$(!tab,path$(!folder !tab),NEW,RAW)
          |     whl
              ' ( !arg:%?tab ?arg
                & (   !where:? (? !tab ?.?folder) ?
                    & lst$(!tab,path$(!folder !tab),NEW,RAW)
                  | 
                  )
                )
            & 
      )
      ( localized
      =   
        .   ( !lANgs:% !LaNg&!arg:% %?arg
            | !arg:%?arg ?
            )
          & !arg
      )
      ( prodtables
      =   CTBs
          jobAbout
          jobNr
          jobs
          Uploads
          zippedresults
          tooladm
          jobNr
          toolprop
          ItemGroupsCache
          footer
          recentTasks
          wrkflws
          feedback
          properties
      )
      ( setLang
      =   full A Z
        .     low$!arg:?arg
            & ( !lANgs:? !arg ?
              |   @(!arg:d (a|k) ?)
                & !lANgs:% ?arg
                & !arg:~
              | !lANgs:%?arg ?
              )
            & !arg:?LaNg
            & readTable$linguae
            & !linguae:? (?full.!LaNg.?) ?
            & localized$!full
            & (   !hiddenData:?A (UIlanguage.?) ?Z
                & !A !Z:?hiddenData
              | 
              )
            & (UIlanguage.!LaNg) !hiddenData:?hiddenData
          | log$("failed to set language to " !arg)&~
      )
      ( setTypeFace
      =   A Z
        .   !arg:?TyPeFaCe
          & (   !hiddenData:?A (TyPeFaCe.?) ?Z
              & !A !Z:?hiddenData
            | 
            )
          & (TyPeFaCe.!TyPeFaCe) !hiddenData:?hiddenData
      )
      ( trim
      =   a z
        .   whl'(@(!arg:?a \r ?z)&str$(!a !z):?arg)
          & whl'@(!arg:(" "|\n|\t) ?arg)
          & whl'@(!arg:?arg (" "|\n|\t))
          & !arg
      )
      ( NCNameStartChar
      =   ~<A:~>Z
        | "_"
        | ~<a:~>z
        | ~<√Ä:~>√ñ
        | ~<√ò:~>√∂
        | ~<√∏:~>Àø
        | ~<Õ∞:~>ÕΩ
        | ~<Õø:~>·øø
        | ~<‚Äå:~>‚Äç
        | ~<‚Å∞:~>‚Üè
        | ~<‚∞Ä:~>‚øØ
        | ~<„ÄÅ:~>Ìüø
        | ~<Ô§Ä:~>Ô∑è
        | ~<Ô∑∞:~>ÔøΩ
        | ~<êÄÄ:~>ÛØøø
      )
      ( NCNameChar
      =   !NCNameStartChar
        | "-"
        | "."
        | ~<0:~>9
        | ¬∑
        | ~<ÃÄ:~>ÕØ
        | ~<‚Äø:~>‚ÅÄ
      )
      (allowedChar=.utf$!sjt&!sjt:!(arg.))
      (NCName=|allowedChar$('$NCNameChar) !NCName)
      ( checkParms
      =   parms parm table val abBr abbrs spec A Z
        .   !arg:(?parms.?parm.?table)
          & :?abbrs
          &   whl
            ' ( !parms:? (!parm.?val) ?parms
              &   (   !hiddenData:?A (!parm.?) ?Z
                    & !A (!parm.!val) !Z
                  | !hiddenData (!parm.!val)
                  )
                : ?hiddenData
              &   whl
                ' ( !val:%?abBr^?spec+?val
                  & !table:? (?.!abBr.?) ?
                  & ( !abbrs:? !abBr ?
                    | !abbrs !abBr:?abbrs
                    )
                  )
              )
          & !abbrs
      )
      (paragraph=.(p.,!arg) \r\n)
      ( fieldset
      =   legend content
        .   !arg:(?legend.?content)
          &   ( fieldset
              .   (class.noborder)
                ,   ( !legend:
                    | (legend.(class.secondpage),!legend)
                    )
                    !content
              )
              \r\n
      )
      ( form
      =   action method
        .   !arg:(?action.?arg)
          & (   !arg
              : ( ?arg
                .   ( post
                    | POST
                    | get
                    | GET
                    )
                  : ?method
                )
            | GET:?method
            )
          & ( form
            .     (   !method:(POST|post)
                    & (enctype.multipart/form-data)
                  | "20121024 GET no enctype?"&
                  | (enctype.application/x-www-form-urlencoded)
                  )
                  (accept-charset.UTF-8)
                  (method.low$!method)
                  (action.!action)
                  (class.formRounded)
              , (div.,!arg)
            )
      )
      ( makeCheckboxFormField
      =   text parm desc state disabled LR
        .     !arg
            : (   ((L|R):?LR,?text)
                | ?text&L:?LR
              . ?parm
              .   ( ? (val.?state) ?
                  | ?&:?state
                  )
                : ( ? (disabled.?disabled) ?
                  | ?&:?disabled
                  )
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
              )
          &   ( !LR:L&(span.,!text) \r\n
              | 
              )
              ( input
              .     (type.checkbox)
                    (tabindex.1+!tabind:?tabind&0)
                    (name.!parm)
                    ( !state:
                    | ( checked
                      .   !state:on&checked
                        | 
                      )
                    )
                    (!disabled:|(disabled.!disabled))
                    (!desc:|(title.!desc))
                , 
              )
              \r\n
              ( !LR:L&
              | (span.,!text) \r\n
              )
      )
      ( makeStaticTextFormField
      =   text val
        .   !arg:(?text.?val)
          & (label.,!text) \r\n !val \r\n
      )
      ( makeTextFormField
      =   text parm val desc readonly size required
        .     !arg
            : ( ?text
              . ?parm
              .   ? (val.?val) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (readonly.?readonly) ?
                  | ?&:?readonly
                  )
                : ( ? (size.?size) ?
                  | ?&:?size
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( label
              .   
                ,   !text
                    ( !required:
                    | " " (span.(class.requiblue),!required)
                    )
              )
              \r\n
              ( input
              .     (tabindex.1+!tabind:?tabind&0)
                    (type.text)
                    (name.!parm)
                    (!val:|(value.trim$!val))
                    (!desc:|(title.!desc))
                    ( !readonly:(|no)
                    | (disabled.disabled)
                    )
                    (!size:|(size.!size))
                , 
              )
              \r\n
      )
      ( makeTextAreaFormField
      =   text parm val required desc
        .     !arg
            : ( ?text
              . ?parm
              .   ? (val.?val) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( label
              .   
                ,   !text
                    ( !required:
                    | " " (span.(class.requiblue),!required)
                    )
              )
              \r\n
              ( textarea
              .     (tabindex.1+!tabind:?tabind&0)
                    (name.!parm)
                    (rows.2)
                    (cols.60)
                    (!desc:|(title.!desc))
                , trim$!val
              )
              \r\n
      )
      ( makeTextAreaFormFieldInv
      =   text parm val required desc
        .     !arg
            : ( ?text
              . ?parm
              .   ? (val.?val) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( textarea
              .     (tabindex.1+!tabind:?tabind&0)
                    (name.!parm)
                    (rows.2)
                    (cols.60)
                    (!desc:|(title.!desc))
                , trim$!val
              )
              \r\n
              (br.,)
              \r\n
              ( label
              .   
                ,   !text
                    ( !required:
                    | " " (span.(class.requiblue),!required)
                    )
              )
      )
      ( ToolTitle
      =   
        .     readTable$tooladm
            & (     !tooladm
                  :   ?
                    + ( ? (ToolID.!arg) ?
                      : ? (Title.?arg) ?
                      )
                    + ?
                & !arg
              | str$("ToolTitle:" !arg " does not exist.")
              )
          | str$("ToolTitle:" !arg " tooladm cannot be read.")
      )
      ( toolID2title
      =   
        .   readTable$tooladm
          &   map
            $ ( ( 
                =   tit
                  .   (   !tooladm
                        :   ?
                          + ( ? (ToolID.!arg) ?
                            : ? (Title.?tit) ?
                            )
                          + ?
                      | 
                      )
                    & (!arg.!tit)
                )
              . !arg
              )
      )
      ( getFeatAndValueNames
      =     feature featvals featname table specificationTables featdesc
          , featval spec full stbl sps featvalspec featvalspecs addFeatvalSpec
        .   ( addFeatvalSpec
            =     !featdesc
                  (!featdesc:|" & ")
                  (   !!table:? (?full.!featval.?) ?
                    & localized$!full
                  | !featval
                  )
                  ( !spec:1&
                  |   "["
                      (   !specificationTables
                        : ? (? (%@:!featval) ?.?stbl) ?
                      & (!!stbl|readTable$!stbl)
                      &     mop
                          $ ( ( 
                              =   full
                                .   "|"
                                    (   !!stbl:? (?full.!arg.?) ?
                                      & localized$!full
                                    | !arg
                                    )
                              )
                            . !spec
                            . (=+)
                            )
                        : ("|" ?sps|?sps)
                      & !sps
                      )
                      "]"
                  )
              : ?featdesc
            )
          & !arg:(?feature,?featvals)
          &   !features
            :   ?
              + ( ? (short.!feature) ?
                : ? (name.?featname) ?
                : ? (table.?table) ?
                : ( ? (specificationTable.?specificationTables) ?
                  | ?&:?specificationTables
                  )
                )
              + ?
          & :?featdesc
          &   whl
            ' ( !featvals:%?featvalspec*?featvals
              &   !featvalspec
                : (   (?featvalspecs.OnE)
                    &   whl
                      ' ( !featvalspecs:%?featval^?spec*?featvalspecs
                        & !addFeatvalSpec
                        )
                  | %?featval^?spec&!addFeatvalSpec
                  )
              )
          & (!featname,!featdesc)
      )
      ( inoutdesc
      =   description sep featdesc
        .     !arg:(?arg.?sep)
            &     map
                $ ( ( 
                    =   
                      .     getFeatAndValueNames$!arg:(?,?featdesc)
                          & !sep str$!featdesc
                        | 
                    )
                  . !arg
                  )
              : !sep ?description
            & !description
          | 
      )
      ( fullinoutdesc
      =   description sep
        .     !arg:(?arg.?sep)
            &     map
                $ ( ( 
                    =   featdesc name
                      .     getFeatAndValueNames$!arg:(?name,?featdesc)
                          & !sep localized$!name " = " !featdesc
                        | 
                    )
                  . !arg
                  )
              : !sep ?description
            & !description
          | 
      )
      ( list2sum
      =   f e S
        .     whl
            ' ( :?S
              & whl'(!arg:%?e %?f ?arg&!f+!e !S:?S)
              & !arg !S:?S
              & !S:% %:?arg
              )
          & !S
      )
      ( OnEify
      =   L A F v
        .   :?L
          &   whl
            ' ( !arg:%?A+?arg
              &     ( 
                    .   map
                      $ ( ( 
                          =   
                            .     !arg:(?F,%*%:?v)
                                & (!F,(!v.OnE))
                              | !arg
                          )
                        . !A
                        )
                    )
                    !L
                : ?L
              )
          &   whl
            ' (!L:(.?A) ?L&!A+!arg:?arg)
          & !arg
      )
      ( dotlist2sum
      =   f e S
        .   "arg must not contain duplicates"
          &   whl
            ' ( !arg:(.%?e) (.%?f) ?arg
              & !e+!f !S:?S
              )
          & ( !arg:
            |   !arg:(.?e)
              & !S:%?f ?S
              & !f+!e !S:?S
            )
          & !S:?arg
          &   whl
            ' ( :?S
              & whl'(!arg:%?e %?f ?arg&!f+!e !S:?S)
              & !arg !S:?S:% %:?arg
              )
          & !S
      )
      ( sort
      =   f L e S
        .   :?L
          &   whl
            ' (!arg:%?e ?arg&(!e.) !L:?L)
          &   whl
            ' ( :?S
              & whl'(!L:%?e %?f ?L&!f+!e !S:?S)
              & !L !S:?S:% %:?L
              )
          &   mop
            $ ( (=.!arg:#*(?arg.)&!arg)
              . !S
              . (=+)
              )
      )
      ( topologicalOrder
      =     edges workflow A Z ABC XYZ
          , 2p Kahn edg pr shorting singles
          , pairs shrtlst nshrtlst kahn Edgs Thing
        .   ( edg
            =   a b
              .   !arg:%?a %?b&edg$!b edg$!a
                | !arg:(?a,?b)&edg$!a+edg$!b
                | !arg:(?a.?b)&!a
            )
          & ( pr
            =   nxt a b c dpt S
              .   !arg:(?dpt.?nxt.?arg)
                & (!nxt:#%*?nxt|)
                & (   !arg:%+%
                    & 0:?S
                    &   whl
                      ' ( !arg:%?a+?arg
                        & pr$(1+!dpt.!nxt.!a)+!S:?S
                        )
                    & !S
                  | !arg:#%*%?a&pr$(1+!dpt.!nxt.!a)
                  |   !arg:%?a %?b
                    &   ( !nxt:&0
                        | (!a.!nxt)
                        )
                      + (   !b:%@?b ?c
                          & (!b.!a)+pr$(1+!dpt.!b.!c)
                        | pr$(1+!dpt.!a.!b)
                        )
                  |   !arg:%@?a ?
                    & (!nxt:&0|(!a.!nxt))
                  | 0
                  )
            )
          & 0:?edges
          &   map
            $ ( ( 
                =   
                  .   whl
                    ' ( !arg:(?,?workflow) ?arg
                      & edg$!workflow+!edges:?edges
                      )
                )
              . !arg
              )
          & (   !edges:@
              & log$"There is only one step."
              & !edges
            |   !edges:?Edgs
              & 0:?edges
              & :?singles
              &   whl
                ' ( !Edgs:#*%?Thing+?Edgs
                  & (   !Thing:@
                      & !singles !Thing:?singles
                    | !edges+!Thing:?edges
                    )
                  )
              &     map
                  $ ( ( 
                      =   
                        .       !edges
                              : (?+(!arg.?)+?|?+(?.!arg)+?)
                            & 
                          | !arg
                      )
                    . !singles
                    )
                : ?singles
              & pr$(0..!edges):?pairs
              & ( 2p
                =   a b
                  .   !arg:%@?a %@?b ?arg&(!a.!b)+2p$(!b !arg)
                    | 0
                )
              & ( Kahn
                =   pairs A Z i S L m n
                  .   "create topological ordering"
                    & !arg:?pairs
                    & :?S:?L
                    & (   !pairs
                        :   ?
                          +   #
                            * (   ?i
                                & ~(!pairs:?+#*(?.!i)+?)
                                & ~(!S:? !i ?)
                                & !i !S:?S
                                & ~
                              . ?
                              )
                          + ?
                      | 
                      )
                    &   whl
                      ' ( !S:%?n ?S
                        & !L !n:?L
                        &   whl
                          ' ( !pairs:?A+#*(!n.?m)+?Z
                            & !A+!Z:?pairs
                            & ( !pairs:?+#*(?.!m)+?
                              | !m !S:?S
                              )
                            )
                        )
                    & ( !pairs:0&!L
                      | "graph has at least one cycle"&
                      )
                )
              & ( shorting
                =   A Z L p S x y shrtlst
                  .   !arg:(?p,?arg:?L)
                    & 0:?S
                    & :?shrtlst
                    &   whl
                      ' ( !L:#*(?x.?y)+?L
                        & !x+!y+!S:?S
                        )
                    & "Edges with node(s) occurring in that edge only are not
                       eligible for deletion.
                       Such nodes have no explicit numerical factor in S."
                    & (   !arg:%+%
                        & (   !arg
                            :   ?A
                              + (     #
                                    * ( ?x&~(!S:?+!x+?)
                                      . ?y&~(!S:?+!y+?)
                                      )
                                  + ?Z
                                & (!p+!A,!Z) !shrtlst:?shrtlst
                                & ~
                                )
                          | !shrtlst
                          )
                      | (!p,0)
                      )
                )
              & (0,!pairs):?shrtlst:?nshrtlst
              & :?kahn
              &   whl
                ' ( !shrtlst:~(0,0)
                  &   whl
                    ' ( !shrtlst:(?ABC,?XYZ) ?shrtlst
                      & Kahn$(!ABC+!XYZ):?kahn:
                      )
                  & !kahn:
                  & !nshrtlst:~
                  & log$("cycle [" !nshrtlst "]")
                  & "Cycle(s) found. Remove one edge, try again. The ABC edges
                     must not be touched. Remove edge from XYZ."
                  &   whl
                    ' ( !nshrtlst:(?ABC,?XYZ) ?nshrtlst
                      & shorting$(!ABC,!XYZ) !shrtlst:?shrtlst
                      )
                  )
              &     map
                  $ ( (=.!kahn:~(? !arg ?)|)
                    . !singles
                    )
                  !kahn
            )
      )
      ( set
      =   S e
        .   0:?S
          &   whl
            ' ( !arg:%?e ?arg
              & (!S:?+!e+?|!e+!S:?S)
              )
          & mop$((=.!arg).!S.(=+))
      )
      ( makeWorkflowsSequential
      =     i nr enumerateToolsDetail
          , disambiguatedworkflowlist groupedworkflowlist n
          , o pat pipe pipes sameToolDifferentRoles
          , toolPlumbing "*" simplify disam reorder
          , wf wfs workflow workflowlist saveio toolPattern
        .   ( reorder
            =     reorderedworkflowlist nr groupIfSameTools
                , workflow weighted presentable
              .   ( presentable
                  =     mul2com accumulateAbbreviations findUnvisitedWF
                      , replace insertNameInFirst
                      , removeWorkflowsPrecedingRefs isReferenced
                      , deleteReference renameReference
                      , abbrevs name newseqno newseqnos nrefs ref
                      , refs seq seqno struct wf
                    .   ( mul2com
                        =   a b n I O i o
                          .     !arg:%?a*%?b
                              & (mul2com$!a,mul2com$!b)
                            |   !arg:(?n.(?i.?o).?I.?O)
                              & (!n.!I.!O)^(!i.!o)*!abbrevs:?abbrevs
                              & (!n..!I.!O)
                            |   !arg:?a_?b
                              & (mul2com$!a)_(mul2com$!b)
                            | !arg
                        )
                      & ( accumulateAbbreviations
                        =   A I O i o exp N list sum
                          .   1:?N
                            & ( sum
                              =   S t
                                .   0:?S
                                  &   whl
                                    ' ( !arg:%?t ?arg
                                      & !S+!t:?S
                                      )
                                  & !S
                              )
                            & ( list
                              =   
                                .   mop
                                  $ ( ( 
                                      =   
                                        .       !arg
                                              : #*((?,?):%?arg)
                                            & !arg
                                          | 
                                      )
                                    . !arg
                                    . (=+)
                                    )
                              )
                            &   whl
                              ' ( !arg:%?A^%?exp*?arg
                                & 0:?I:?O
                                &   whl
                                  ' ( !exp:?*(?i.?o)+?exp
                                    & !I+sum$!i:?I
                                    & !O+sum$!o:?O
                                    )
                                & !A^(list$!I.list$!O)*!N:?N
                                )
                            & !N
                        )
                      & ( findUnvisitedWF
                        =   a b
                          .     !arg:(%?a,%?b)
                              & (findUnvisitedWF$!a|findUnvisitedWF$!b)
                            |   !arg:?a (?..?)
                              & findUnvisitedWF$!a
                            |   !arg:(? (?..?):?arg) ?
                              & !arg
                        )
                      & ( replace
                        =   a b struct wf seqno n m
                          .   !arg:(?struct.?wf.?seqno)
                            & (   !struct:(%?a,%?b)
                                & (replace$(!a.!wf.!seqno),replace$(!b.!wf.!seqno))
                              |   !struct:(!wf:?a (?n..?m)) ?b
                                & !a (.!seqno.!m) !b
                              |   !struct:?a (?n..?m)
                                & replace$(!a.!wf.!seqno) (!n..!m)
                              | !struct
                              )
                        )
                      & ( insertNameInFirst
                        =   struct name seqno a b
                          .   !arg:(?struct.?name.?seqno)
                            & (   !struct:(%?a,%?b)
                                & ( insertNameInFirst$(!a.!name.!seqno):?a
                                  | insertNameInFirst$(!b.!name.!seqno):?b
                                  )
                                & (!a,!b)
                              |   !struct:?a ((?.?.?):?b)
                                & insertNameInFirst$(!a.!name.!seqno):?a
                                & !a !b
                              |   !struct:?a (.!seqno.?b)
                                & !a (!name.!seqno.!b)
                              )
                        )
                      & ( removeWorkflowsPrecedingRefs
                        =   a b
                          .     !arg:(%?a,%?b)
                              & (removeWorkflowsPrecedingRefs$!a,removeWorkflowsPrecedingRefs$!b)
                            |   !arg:? ((.?.?):?b)
                              & !b
                            |   !arg:?a ((?.?.?):?b)
                              & removeWorkflowsPrecedingRefs$!a !b
                            | !arg
                        )
                      & "isReferenced and deleteReference: use these to remove
                         sequence numbers from workflow steps that only feed
                         into the next step. Currently not used."
                      & ( 
                        |   ( isReferenced
                            =   a b seqno struct
                              .     !arg:(?seqno.?struct)
                                  & !struct:(%?a,%?b)
                                  & ( isReferenced$(!seqno.!a)
                                    | isReferenced$(!seqno.!b)
                                    )
                                | !struct:? (.!seqno.?) ?
                                |   !struct:%?a %?b
                                  & ( isReferenced$(!seqno.!a)
                                    | isReferenced$(!seqno.!b)
                                    )
                            )
                          & ( deleteReference
                            =   a b struct seqno n m
                              .   !arg:(?seqno.?struct)
                                & (   !struct:(%?a,%?b)
                                    & ( deleteReference$(!seqno.!a):?a
                                      | deleteReference$(!seqno.!b):?b
                                      )
                                    & (!a,!b)
                                  |   !struct:?a (?n.!seqno.?m) ?b
                                    & !a (!n..!m) !b
                                  |   !struct:%?a %?b
                                    & ( deleteReference$(!seqno.!a):?a
                                      | deleteReference$(!seqno.!b):?b
                                      )
                                    & !a !b
                                  )
                            )
                        )
                      & ( renameReference
                        =   a b struct seq n m seqno nseqno
                          .   !arg:(?seq.?struct)
                            & (   !struct:(%?a,%?b)
                                & (renameReference$(!seq.!a),renameReference$(!seq.!b))
                              |   !struct:%?a %?b
                                & renameReference$(!seq.!a) renameReference$(!seq.!b)
                              |   !seq:(?seqno.?nseqno)
                                & !struct:(?n.!seqno.?m)
                                & (!n.!nseqno.!m)
                              | !struct
                              )
                        )
                      & 1:?abbrevs
                      & "Replace * by , and collect abbrevs (side effect)"
                      & mul2com$!arg:?struct
                      & accumulateAbbreviations$!abbrevs:?abbrevs
                      & 0:?seqno
                      & :?refs
                      &   whl
                        ' ( findUnvisitedWF$!struct:?wf
                          & 1+!seqno:?seqno
                          & !wf:? (?name.?)
                          & (!name.!seqno) !refs:?refs
                          & replace$(!struct.!wf.!seqno):?struct
                          )
                      & :?nrefs
                      &   whl
                        ' ( !refs:%?ref ?refs
                          & !ref !nrefs:?nrefs
                          & insertNameInFirst$(!struct.!ref):?struct
                          )
                      & removeWorkflowsPrecedingRefs$!struct:?struct
                      & :?newseqnos
                      & (48|9311):?newseqno
                      &   whl
                        ' ( !nrefs:(?.?seqno) ?nrefs
                          & 1+!newseqno:?newseqno
                          & (   (|isReferenced$(!seqno.!struct))
                              & (!seqno.!newseqno) !newseqnos:?newseqnos
                            | deleteReference$(!seqno.!struct):?struct
                            )
                          )
                      &   whl
                        ' ( !newseqnos:%?seq ?newseqnos
                          & renameReference$(!seq.!struct):?struct
                          )
                      & (!struct.!abbrevs)
                  )
                & ( weighted
                  =     name Ntools Nsteps n nr countTools
                      , A B T C usedTools struct abbrevs
                      , toolInventory toolsUsed plumbing
                    .   ( plumbing
                        =   a b
                          .     !arg:%?a %?b
                              & plumbing$!a plumbing$!b
                            |   !arg:(%?a,%?b)
                              & (plumbing$!a,plumbing$!b)
                            | !arg:(?a.?b.?)&(!a.!b)
                        )
                      & !arg:(?nr,(?struct.?abbrevs))
                      & 0:?Ntools:?Nsteps:?toolInventory
                      & ( countTools
                        =   A B
                          .     !arg:((?A,?B)|%?A %?B)
                              & countTools$!A+countTools$!B
                            |   !arg:(~:?A.?.?.?)
                              & !A
                            | 0
                        )
                      & countTools$!struct:?toolInventory
                      & ( usedTools
                        =   A B
                          .     !arg:((?A,?B)|%?A %?B)
                              & usedTools$!A usedTools$!B
                            | !arg:(?A.?.?.?)&!A
                            | 
                        )
                      & usedTools$!struct:?toolsUsed
                      &   whl
                        ' ( !toolsUsed:?A %@?T ?B %@!T ?C
                          & !A !T !B !C:?toolsUsed
                          )
                      &   whl
                        ' ( !toolInventory:?n*%@?name+?toolInventory
                          & !n+!Nsteps:?Nsteps
                          & 1+!Ntools:?Ntools
                          )
                      & ( (!Ntools.!toolsUsed.!Nsteps.plumbing$!struct.!nr)
                        , (!abbrevs.!struct)
                        )
                  )
                & ( groupIfSameTools
                  =   L seen a b c B sb
                    .   0:?L
                      & :?seen
                      &   whl
                        ' ( !arg:((?a.?b.?c),?B)+?arg
                          & sort$!b:?sb
                          & ( !seen:? (!sb.?b) ?
                            | (!sb.!b) !seen:?seen
                            )
                          & !L+((!a.!b.!c),!B):?L
                          )
                      & !L
                  )
                & 0:?reorderedworkflowlist
                &   map
                  $ ( ( 
                      =   nr workflow
                        .   whl
                          ' ( !arg:(?nr,?workflow) ?arg
                            &   weighted$(!nr,presentable$!workflow)+!reorderedworkflowlist
                              : ?reorderedworkflowlist
                            )
                      )
                    . !arg
                    )
                & groupIfSameTools$!reorderedworkflowlist:?reorderedworkflowlist
                &   ( 
                    =   L p n a b c d e B
                      .   :?L
                        & :?p
                        & 0:?n
                        &   whl
                          ' ( !arg:((?a.?b.?c.?d.?e),?B)+?arg
                            & (   !d:~!p:?p
                                & 1+!n:?n
                              | 
                              )
                            & ((!a.!b.!c.!n.!e),!B) !L:?L
                            )
                        & 0:?arg
                        &   whl
                          ' (!L:%?a ?L&!a+!arg:?arg)
                        & !arg
                    )
                  $ !reorderedworkflowlist
            )
          & ( enumerateToolsDetail
            =   tool o i predecessors myfold I,a b
              .       !arg
                    : ( ?tool
                      , ( ?o
                        . ?I
                        .   (?i.?predecessors)
                          |   ?i
                            & "If input is composed of x and y, i must be '(x*y.OnE)'. Perhaps we could just always use I instead of i?"
                            & !I:?i
                            & :?predecessors
                        )
                      )
                  & ( myfold
                    =   a b A B F R v1 v2
                      .     !arg:%?a*%?b
                          & myfold$!b:?b
                          & (     !a
                                :   ?
                                    ( ?F
                                    ,   ?v1
                                      &   !b
                                        : ?A (!F,~!v1:?v2) ?B
                                      & !A (!F,!v1*!v2) !B:?R
                                    )
                                    ?
                              & !R
                            | 
                            )
                        | !arg
                    )
                  &   ( !predecessors:
                      | enumerateToolsDetail$!predecessors
                      )
                      (!tool.myfold$!i.!o)
                |   !arg:%?a*%?b
                  & enumerateToolsDetail$!a*enumerateToolsDetail$!b
                |   !arg:%?a+%?b
                  & enumerateToolsDetail$!a+enumerateToolsDetail$!b
                | !arg:(?o.?i)&enumerateToolsDetail$!i
                | 1
            )
          & ( simplify
            =     WF S dun sortout n f i I
                , o feat val A Z O IO replace
              .   ( sortout
                  =   L R
                    .   !arg:(?.?)&!arg !S:?S
                      |   !arg:%?L_%?R
                        & sortout$!L
                        & sortout$!R
                  )
                & :?S
                & sortout$!arg
                & :?dun
                & ( replace
                  =   n r p L R WF
                    .   !arg:(?WF.?n.(=?p).(=?r))
                      & (   !WF:(=?.?)
                          & (   !WF:(=!n.!p)
                              & !r:?r
                              & '($n.$r)
                            | !WF
                            )
                        |   !WF:(=%?L_%?R)
                          &   
                            '   
                              $   ($(replace$('$L.!n.'$p.'$r)))
                                _ ($(replace$('$R.!n.'$p.'$r)))
                        )
                  )
                & '$arg:?WF
                &   whl
                  ' ( !S:(?n.?f) ?S
                    & ( !dun:? !n ?
                      |   !n !dun:?dun
                        & (   !S:? (!n.~!f) ?
                            & !f:((?i.?o).?IO)
                            &   whl
                              ' ( !i:(?feat,?val) ?i
                                & (   !S
                                    :   ?
                                        ( !n
                                        . (? (!feat,~!val) ?.?)
                                        . ?
                                        )
                                        ?
                                  |     replace
                                      $ ( !WF
                                        . !n
                                        .   
                                          ' ( ( ?A ($feat,$val) ?Z
                                              . ?O
                                              )
                                            . ?IO
                                            )
                                        . ( 
                                          = (!A ? !Z.!O).!IO
                                          )
                                        )
                                    : ?WF
                                  )
                                )
                            &   whl
                              ' ( !o:(?feat,?val) ?o
                                & (   !S
                                    :   ?
                                        ( !n
                                        . (?.? (!feat,~!val) ?)
                                        . ?
                                        )
                                  |     replace
                                      $ ( !WF
                                        . !n
                                        .   
                                          ' ( (?I.?A ($feat,$val) ?Z)
                                            . ?IO
                                            )
                                        . (=(!I.!A ? !Z).!IO)
                                        )
                                    : ?WF
                                  )
                                )
                          |   replace$(!WF.!n.(=?).(=?))
                            : ?WF
                          )
                      )
                    )
                & !WF
            )
          & ( toolPattern
            =   pat tool lhs rhs lpat rpat Wf feats
              .   :?pat
                & !arg:(=?Wf)
                &   whl
                  ' ( (   '$Wf:(=?Wf (?tool.?feats))
                        & (   '$feats:(=?feats.?)
                            & '($feats.?):(=?feats)
                          | 
                          )
                        & ( :!pat&'($tool.$feats)
                          | '(($tool.$feats) ()$pat)
                          )
                      |   '$Wf:(=?Wf %?lhs*%?rhs)
                        & "*"$('$lhs):(=?lpat)
                        & "*"$('$rhs):(=?rpat)
                        & ( :!pat&'($lpat*$rpat)
                          | '($lpat*$rpat ()$pat)
                          )
                      )
                    : (=?pat)
                    )
                & '$pat
            )
          & "Same code, but a bit faster because of short names. (intensively used code!)"
          & ( "*"
            =   "#" "%" "[" "]" "(" ")" "-" "="
              .   :?"#"
                & !arg:(=?"-")
                &   whl
                  ' ( (   '$"-":(=?"-" (?"%".?"="))
                        & (   '$"=":(=?"=".?)
                            & '($"=".?):(=?"=")
                          | 
                          )
                        & ( :!"#"&'($"%".$"=")
                          | '(($"%".?) ()$"#")
                          )
                      |   '$"-":(=?"-" %?"["*%?"]")
                        & "*"$('$"["):(=?"(")
                        & "*"$('$"]"):(=?")")
                        & ( :!"#"&'($"("*$")")
                          | '($"("*$")" ()$"#")
                          )
                      )
                    : (=?"#")
                    )
                & '$"#"
            )
          & ( sameToolDifferentRoles
            =     delta Delta replac I O
                , simple tool tree
                , details flatlist updat
                , fx fy reps sx sy
              .   ( delta
                  =   this other L f v
                    .   !arg:(?this.?other)
                      & :?L
                      & (   !this
                          :   ?
                              ( (?f,?v)
                              & ( !other:? (!f,!v) ?
                                | (!f,!v) !L:?L
                                )
                              & ~
                              )
                              ?
                        | !L
                        )
                  )
                & ( Delta
                  =   AI AO BI BO
                    .   !arg:((?AI.?AO),(?BI.?BO))
                      & (delta$(!AI.!BI).delta$(!AO.!BO))
                  )
                & ( replac
                  =   t s r a b
                    .   !arg:(?t.?s,?r)
                      & ( !t:!s&!r
                        |   !t:%?a %?b
                          & replac$(!a.!s,!r) replac$(!b.!s,!r)
                        |   !t:(%?a,%?b)
                          & (replac$(!a.!s,!r),replac$(!b.!s,!r))
                        | !t
                        )
                  )
                & ( flatlist
                  =   p q
                    .     !arg
                        : ( @
                          . (?.?)
                          . (?,?) ?
                          . (?,?) ?
                          )
                      |   !arg:((?p,?q)|%?p %?q)
                        & flatlist$!p+flatlist$!q
                  )
                & ( updat
                  =   reps tool i o id,od I O details A Z
                    .     !arg
                        : (?reps.?tool.(?i.?o),(?id.?od).?details)
                      & (     !reps
                            : ?A (!tool.(?I.?O).!details) ?Z
                          &   !A
                              ( !tool
                              . (set$(!I !i !id).set$(!O !o !od))
                              . !details
                              )
                              !Z
                        |   (!tool.(set$(!i !id).set$(!o !od)).!details)
                            !reps
                        )
                  )
                &   map
                  $ ( ( 
                      =   
                        .   !arg:(?n,?tree)
                          & :?reps
                          & (   flatlist$!tree
                              :   ?
                                + ?*(?tool.?sx.?fx)
                                + ?
                                + ?*(!tool.?sy.?fy)
                                + ( ?
                                  &     updat
                                      $ (!reps.!tool.!sx,Delta$(!fx,!fy).!fx)
                                    : ?reps
                                  &     updat
                                      $ (!reps.!tool.!sy,Delta$(!fy,!fx).!fy)
                                    : ?reps
                                  & ~
                                  )
                            |     whl
                                ' ( !reps:(?tool.?simple.?details) ?reps
                                  &     replac
                                      $ ( !tree
                                        .   (!tool.?.!details)
                                          , (!tool.!simple.!details)
                                        )
                                    : ?tree
                                  )
                              & (!n,!tree)
                            )
                      )
                    . !arg
                    )
            )
          & ( saveio
            =   n i o x y
              .     !arg:(?n.?i.~(?.?):?o)
                  & (!n.(!i.!o).!i.!o)
                | !arg:%?x*%?y&saveio$!x*saveio$!y
                | !arg:(?x.OnE)&!arg
                | !arg:?x_?y&(saveio$!x)_(saveio$!y)
                | !arg
            )
          & ( disam
            =     nextvar ding nextn nextvars wfs wflw N toolPlumbing
                , demul demultiply inmul inmultiply c2m cm
              .     0:?nextn
                  & :?nextvars
                  & ( nextvar
                    =   bang quest var squest
                      .   !nextn+1:?nextn
                        & !nextvars (str$(a !nextn):?var):?nextvars
                        & glf$('(`%?.$var)):?quest
                        & glf$('(!.$var)):?bang
                        & glf$('(?.$var)):?squest
                        & (!quest.!bang.!squest)
                    )
                  & ( ding
                    =     bang bangA bangZ bangT featval o
                        , quest questA questZ questT bangIO questIO
                        , questionpattern-tio questiontemplate
                        , questiontemplate-lhs question
                        , questiontemplate-rhs
                        , replacement replacementtemplate
                        , replacementtemplate-lhs replacementtemplate-rhs
                        , rynaps synaps wf1
                        , i w ws wf1 tmp REPLACE IO
                      .     !arg
                          : ( ?wf1
                            . (=?questiontemplate)
                            . (=?replacementtemplate)
                            )
                        & "questiontemplate is macro '(...$synaps...)"
                        & (     (=?t.(?i.?o).?IO)
                              : (=?synaps)
                            & !questiontemplate:(=?questionpattern-tio)
                            & !wf1:!questionpattern-tio
                            &   nextvar$
                              : ((=?questT).(=?bangT).?)
                            &   nextvar$
                              : (?.(=?bangA).(=?questA))
                            &   nextvar$
                              : (?.(=?bangZ).(=?questZ))
                            &   nextvar$
                              : (?.(=?bang).(=?quest))
                            &   nextvar$
                              : (?.(=?bangIO).(=?questIO))
                            & "If a feature is shared by all workflows, remove it."
                            & ( REPLACE
                              =   !questiontemplate:(=?question)
                                & ( (,!toolPlumbing):!question
                                  |   !wfs:?ws
                                    &   whl
                                      ' ( !ws:%?w ?tmp
                                        & !w:!question
                                        & !tmp:?ws
                                        )
                                    & (   !ws:
                                        & !wfs:?ws
                                        & :?wfs
                                        &   whl
                                          ' ( !ws:%?w ?ws
                                            & !w:!question
                                            & !wfs !replacement:?wfs
                                            )
                                      | 
                                      )
                                  )
                              )
                            &     
                                ' ( $bangT
                                  . ($bangA ()$bangZ.$bang)
                                  . $bangIO
                                  )
                              : (=?rynaps)
                            & !replacementtemplate:(=?replacement)
                            &   whl
                              ' ( !i:%?featval ?i
                                &     
                                    ' ( $questT
                                      . ( $questA ()$featval ()$questZ
                                        . $quest
                                        )
                                      . $questIO
                                      )
                                  : (=?synaps)
                                & !REPLACE
                                )
                            &     
                                ' ( $bangT
                                  . ($bang.$bangA ()$bangZ)
                                  . $bangIO
                                  )
                              : (=?rynaps)
                            & !replacementtemplate:(=?replacement)
                            &   whl
                              ' ( !o:%?featval ?o
                                &     
                                    ' ( $questT
                                      . ($quest.$questA ()$featval ()$questZ)
                                      . $questIO
                                      )
                                  : (=?synaps)
                                & !REPLACE
                                )
                          |   (=%?_%?):(=?synaps)
                            & !questiontemplate:(=?question)
                            & !wf1:!question
                            &   nextvar$
                              : ((=?quest).(=?bang).?)
                            &   '$(%?:$($synaps))_($quest)
                              : (=?synaps)
                            & !questiontemplate:(=?questiontemplate-lhs)
                            &   '$($($rynaps))_($bang)
                              : (=?rynaps)
                            &   !replacementtemplate
                              : (=?replacementtemplate-lhs)
                            &   '$($quest)_(%?:$($synaps))
                              : (=?synaps)
                            & !questiontemplate:(=?questiontemplate-rhs)
                            &   '$($bang)_($($rynaps))
                              : (=?rynaps)
                            &   !replacementtemplate
                              : (=?replacementtemplate-rhs)
                            &   ding
                              $ ( !wf1
                                . '('$questiontemplate-lhs)
                                . '('$replacementtemplate-lhs)
                                )
                            &   ding
                              $ ( !wf1
                                . '('$questiontemplate-rhs)
                                . '('$replacementtemplate-rhs)
                                )
                          )
                    )
                  & "de/inmul(tiply) are used to replace (commutative) * operators
                     with (noncommutative) , operators. And back again. Reason:
                     During simplification factors can swap place, leading to
                     mismatch with the tool plumbing pattern."
                  & ( demul
                    =   a b
                      .     !arg:%?a*%?b
                          & demul$!a:?a
                          & demul$!b:?b
                          & !(glf$('($arg.$a,$b)))
                        | !arg:(?a.OnE)&(demul$!a.OnE)
                        | !arg:?a_?b&(demul$!a)_(demul$!b)
                        | !arg
                    )
                  & ( demultiply
                    =   wf n
                      .   map
                        $ ( ( 
                            =   
                              .   !arg:(?n,?wf)
                                & (!n,demul$!wf)
                            )
                          . !arg
                          )
                    )
                  & ( cm
                    =   x
                      .   !arg:(?x,?arg)&!x*cm$!arg
                        | !arg
                    )
                  & ( c2m
                    =   x
                      .   !arg:(?x,?arg)&c2m$!x*c2m$!arg
                        | !arg:(?x.OnE)&(cm$!x.OnE)
                        | !arg
                    )
                  & ( inmul
                    =   a b
                      .     !arg:(@?a,?b)
                          & (!a,c2m$!b:?a)
                        | !arg:(?a.OnE)&(cm$!a.OnE)
                        | !arg:?a_?b&(inmul$!a)_(inmul$!b)
                        | !arg
                    )
                  & ( inmultiply
                    =   wf n
                      .   map
                        $ ( ( 
                            =   
                              .   !arg:(?n,?wf)
                                & (!n,inmul$!wf)
                            )
                          . !arg
                          )
                    )
                  & !arg:((=?toolPlumbing).?wfs)
                  & demul$!toolPlumbing:?toolPlumbing
                  & demultiply$!wfs:?wfs
                  & !wfs:%?wflw ?
                  & :?nextvars
                  & 0:?nextn
                  & "ding changes wfs !!"
                  &   ding
                    $ ( !wflw
                      . (='(?N,$synaps))
                      . (='(!N,$rynaps))
                      )
                  & tbl$(!nextvars,0)
                  & inmultiply$!wfs:?wfs
                  & !wfs
                | 
            )
          & !arg:?pipes
          & "pipes is an unnumbered list sorted on directly on full workflow tree."
          & :?workflowlist
          & 0:?n
          & log$"Create workflowlist from pipes"
          &   whl
            ' ( 1+!n:?n:<1000000
              & !pipes:%?pipe+?pipes
              & saveio$(!n.enumerateToolsDetail$!pipe) !workflowlist:?workflowlist
              )
          & ( !n:<1000000
            | "while enumerateToolsDetail: MAX NUMBER OF WORKFLOW OPERATIONS REACHED (1000000)"
            )
          & "workflowlist is numbered list of workflows, with equal branches not merged yet, and with I/O duplicated."
          & :?groupedworkflowlist
          & :?toolPlumbing
          & :?disambiguatedworkflowlist
          &   whl
            ' ( 1+!n:?n:<1000000
              & !workflowlist:(#?nr.?workflow) ?workflowlist
              & toolPattern$(simplify$!workflow):(=?toolPlumbing)
              & (!nr,!workflow):?wfs
              &     map
                  $ ( ( 
                      =   
                        .     !arg:(#?nr.!toolPlumbing:?wf)
                            & 1+!n:?n:<1000000
                            & (!nr,!wf) !wfs:?wfs
                            & 
                          | !arg
                      )
                    . !workflowlist
                    )
                : ?workflowlist
              & '$toolPlumbing:?toolPlumbing
              & "The function disam spots the differences between workflows
                 that have the same tools in the same structure: the 'smaller'
                 differences. For example, in the example below, (.app,nrm)
                 indicates that the workflow differs from another workflow as
                 to the appearance of the output, which is 'normalized', while
                 another workflow has e.g. 'unnormalized' output. The field
                 left of the dot is empty, which tells us that there is no
                 difference in the input.
                      ( JSON to ORG-mode converter
                      . (.app,nrm)
                      .   (ambig,pru)
                          (app,drty)
                          (facet,stlp^Menotas)
                          (format,json^xid)
                          (lang,da)
                          (period,c21)
                          (pres,nml)
                      .   (ambig,pru)
                          (app,nrm)
                          (facet,tlp^Menotas)
                          (format,dipl)
                          (lang,da)
                          (period,c21)
                          (pres,nml)
                      )"
              & "'sameToolDifferentRoles' does something similar to 'disam'.
                 Whereas 'disam' looks at different uses of the same tool in
                 different workflows, 'sameToolDifferentRoles' looks at
                 different uses of the same tool in the same workflow."
              &   sameToolDifferentRoles$(disam$(!toolPlumbing.!wfs)) !disambiguatedworkflowlist
                : ?disambiguatedworkflowlist
              )
          & ( !n:<1000000
            | "while groupedworkflowlist: MAX NUMBER OF WORKFLOW OPERATIONS REACHED (1000000)"
            )
          & (reorder$!disambiguatedworkflowlist.topologicalOrder$!disambiguatedworkflowlist)
      )
      ( Circle
      =   
        .   !arg:~#&!arg
          | ( strong
            .   
              ,     !arg:<128
                  & ( !arg:~<48&!arg+-48
                    | chr$!arg
                    )
                | chu$!arg
            )
      )
      ( SpotInput
      =   spotInput subt diff
        .   ( subt
            =   plus A f v a x y z
              .   !arg:(?plus.?A)
                &   whl
                  ' ( !A:(?f,?v) ?A
                    &   !plus
                      : ?a (!f,?x*(!v.OnE)*?y|?x*!v*?y) ?z
                    & ( !x*!y:1
                      | !a (!f,!x*!y) !z:?plus
                      )
                    )
                & !plus
            )
          & ( diff
            =   plus minus A
              .   !arg:(?plus.?minus)
                & ( !minus:
                  |   mop
                    $ ( ( 
                        =   
                          .   !arg:? (?.?.?.?A)
                            & subt$(!plus.!A):?plus
                        )
                      . !minus
                      . (=,)
                      )
                  )
                & !plus
            )
          & ( spotInput
            =     max nrefs N A B spotting
                , refs inputs name P a N DATA
              .   !arg:?spotting
                & (     !arg
                      : ?A ((?name.?refs [?nrefs.?inputs.?):?B)
                    &   ( !name:&spotInput$!A
                        |   0:?nrefs
                          & 1:?max
                          & (   !inputs
                              :   ?
                                  ( ?
                                  ,   ?
                                    * ( [?P
                                      & !P:>!max:?max
                                      )
                                  )
                                  (?&~)
                            | 
                            )
                          & !A:?a
                          & 0:?N
                          & ( !a:
                            |   -1:?N
                              &   whl
                                ' ( !a:(?,?a)
                                  & !N+-1:?N
                                  )
                            )
                          & (   !max+!N+!nrefs:0
                              & spotInput$!A
                            |   diff$(!inputs.!A):?DATA
                              & ( !A:&(.‚àµ..!DATA)
                                | (spotInput$!A,(.‚àµ..!DATA))
                                )
                            )
                        )
                        !B
                  | !arg:(?A,?B)&(spotInput$!A,spotInput$!B)
                  | !arg
                  )
            )
          & spotInput$!arg
      )
      ( makeWorkflowRadioButtons
      =     i Nsteps Ntools n o
          , toolPlumbing translateManyToHumanLanguage
          , abbR reorderedworkflowlist struct
          , toolsUsed topologicalOrderedTools candidateList
        .   ( translateManyToHumanLanguage
            =   description seqno struct abbrevs o,describeShort
              .   ( describeShort
                  =   describe circle nice arrow
                    .   ( circle
                        =   
                          .   !arg:~#&!arg
                            | ( strong
                              .   
                                ,     !arg:<128
                                    &   ":"
                                        (   !arg:~<48
                                          & !arg+-48
                                        | chr$!arg
                                        )
                                  | chu$!arg
                              )
                        )
                      & ( nice
                        =   i o
                          .   !arg:(?i.?o)
                            & inoutdesc$(!i.", "):?i
                            & inoutdesc$(!o.", "):?o
                            & ( :!i:!o
                              |   "("
                                  !i
                                  ( !i:
                                  | !o:
                                  | " ; "
                                  )
                                  !o
                                  ")"
                              )
                        )
                      & (nice=."Leave all I/O details out."&)
                      & ( arrow
                        =   b i
                          .   !arg:(?arg.?b)
                            & !b:(?.?.?i.?) ?
                            & ( div
                              .     (class.tooltip)
                                    (tabindex.0)
                                    (title.str$(fullinoutdesc$(!i.", ")))
                                ,   !arg:1&" ‚Üí "
                                  | !arg:2&" ‚áí "
                                  | !arg:3&" ‚áõ "
                                  | " ‚≠Ü "
                              )
                        )
                      & ( describe
                        =   a b c m n an bn cn h L tit
                          .   !arg:(?h.?arg)
                            & (   !arg:(?a,?b)
                                & describe$(.!a):(?L.?an)
                                & (   !L
                                        mop
                                      $ ( ( 
                                          =   
                                            .   "+"
                                                (   describe$(h.!arg)
                                                  : (?arg.?cn)
                                                & !an+!cn:?an
                                                & !arg
                                                )
                                          )
                                        . !b
                                        . (=,)
                                        )
                                  . !an
                                  )
                              |   !arg:%?a %?b
                                & describe$(.!a):(?a.?an)
                                & (       !a
                                          (   !a:(div.?,‚àµ ?)
                                            & 
                                          | arrow$(!an.!b)
                                          )
                                          ( describe$(.!b):(?b.?bn)
                                          & !b
                                          )
                                      : ?c
                                    & ( !h:&!c
                                      | "[" !c "]"
                                      )
                                  . !bn
                                  )
                              |   !arg:(?m.?seqno.?n)
                                & ( !m::?tit
                                  |   !tooladm
                                    :   ?
                                      + ( ? (ToolID.!m) ?
                                        : ? (Title.?tit) ?
                                        )
                                      + ?
                                  )
                                & (   (   !tit:
                                        & ( !seqno:‚àµ&
                                          | Circle$!seqno
                                          )
                                      | !tit circle$!seqno
                                      )
                                      (   !tit:
                                        & (   !seqno:‚àµ
                                            & !n:(?.?c)
                                            & ( !c:
                                              | ( div
                                                .     (class.tooltip)
                                                      (tabindex.0)
                                                      ( title
                                                      . str$(fullinoutdesc$(!c.", "))
                                                      )
                                                  , ‚àµ
                                                )
                                              )
                                          | 
                                          )
                                      |   !abbrevs:?*(!m.!n)^?n*?
                                        & nice$!n
                                      )
                                  . 1
                                  )
                              )
                        )
                      & describe$(.!arg):(?arg.?)
                      & !arg
                  )
                & !arg:(?abbrevs.?struct)
                & describeShort$!struct:?description
                & (   !description:~
                    & !struct:? (?.?.?.?o)
                    &   !description
                        ( div
                        .     (class.tooltip)
                              (tabindex.0)
                              (title.str$(inoutdesc$(!o.", ")))
                          , ‚à¥
                        )
                  |   log$"It seems that the input already matches your goal"
                    &   localized
                      $ ( "It seems that the input already matches your goal. Or we haven't enough information about the input. Use the back button to change your choice."
                          "Det ser ud til at inputtet allerede opfylder dit m√•l. Eller vi har ikke fundet de n√∏dvendige oplysninger om inputtet. Brug knappen \"Forrige\" for at √¶ndre dine valg."
                        )
                  )
            )
          & ( candidateList
            =     reorderedworkflowlist nsteps ntools
                , theUsedTools infoAboutTool toolRows transpose
                , currNsteps currNtools currToolPlumbing currToolsUsed2
                , hyperlinks nth thead toolSetID buttons
                , toolTable toolUsageList topologicalOrderedTools
              .   ( nsteps
                  =   
                    . p
                    .   
                      ,   "("
                          !arg
                          " "
                            localized
                          $ ( ( !arg:1&step
                              | steps
                              )
                              trin
                            )
                          ")"
                  )
                & ( ntools
                  =   below
                    .   !arg:(?arg.?below)
                      & ( p
                        .   !below:|(id.below)
                          , ( strong
                            .   
                              ,   (üó±|üíà)
                                  " "
                                  !arg
                                  " "
                                    localized
                                  $ (   !arg:1
                                      & tool v√¶rkt√∏j
                                    | tools v√¶rkt√∏jer
                                    )
                            )
                        )
                  )
                & ( theUsedTools
                  =   ID
                    .       !toolUsageList
                            ( str$(T (1+!toolSetID:?toolSetID)):?ID
                            . !arg
                            )
                        : ?toolUsageList
                      & (     map
                            $ ( ( 
                                =   
                                  .   !arg:(?.?arg)
                                    & ", " !arg
                                )
                              . !arg
                              )
                          : ", " ?arg
                        | 
                        )
                      & (p.(id.!ID),(strong.,!arg))
                  )
                & ( infoAboutTool
                  =   Description Title
                    .   !arg:(?arg.?Title)
                      &   !tooladm
                        :   ?
                          + ( ? (ToolID.!arg) ?
                            : ? (Description.?Description) ?
                            )
                          + ?
                      & ( div
                        .     (class.tooltip)
                              (tabindex.0)
                              (title.str$!Description)
                          , !Title
                        )
                  )
                & ( toolRows
                  =   tool tools row rows
                    .     !arg:(%?tool ?tools.(?.?row) ?rows)
                        &   ( tr
                            .   
                              ,   (td.,infoAboutTool$!tool)
                                  map$((=.td.,!arg).!row)
                            )
                            toolRows$(!tools.!rows)
                      | 
                  )
                & ( transpose
                  =   L ID a
                    .   !arg:(?.) ?&
                      |       map
                            $ ( ( 
                                =   ID a
                                  .   !arg:(?ID.%?a ?arg)
                                    & (!a.!ID.!arg)
                                )
                              . !arg
                              )
                          : ?L
                        &   ( 
                            .   map
                              $ ( ( 
                                  = .!arg:(?arg.?)&!arg
                                  )
                                . !L
                                )
                            )
                              transpose
                            $ ( map
                              $ ( ( 
                                  = .!arg:(?.?arg)&!arg
                                  )
                                . !L
                                )
                              )
                  )
                & !arg:(?reorderedworkflowlist.?topologicalOrderedTools)
                & 0:?nth
                & ( !reorderedworkflowlist:((?currNsteps.?),?)+?
                  | 1:?currNsteps
                  )
                & :?currToolPlumbing:?currToolsUsed2
                & 0:?currNtools
                & :?toolUsageList
                & 0:?toolSetID
                &     mop
                    $ ((=..!arg).!reorderedworkflowlist.(=+))
                  : ?reorderedworkflowlist
                &       map
                      $ ( ( 
                          =     Nsteps Ntools abbR nr
                              , struct toolPlumbing toolsUsed toolsUsed2
                            .     !arg
                                : ( 
                                  .   (?Ntools.?toolsUsed.?Nsteps.?toolPlumbing.?nr)
                                    , (?abbR.?struct)
                                  )
                              & SpotInput$!struct:?struct
                              & toolID2title$!toolsUsed:?toolsUsed2
                              & 1+!nth:?nth
                              &   (   !nth:1
                                    & !Ntools:?currNtools
                                    & !toolsUsed2:?currToolsUsed2
                                    & !Nsteps:?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    &   (hr.,)
                                        (hr.,)
                                        ntools$(!Ntools.below)
                                        theUsedTools$!toolsUsed2
                                        nsteps$!Nsteps
                                  |   !Ntools:~!currNtools:?currNtools
                                    & !toolsUsed2:?currToolsUsed2
                                    & !Nsteps:?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    &   (hr.,)
                                        (hr.,)
                                        ntools$(!Ntools.)
                                        theUsedTools$!toolsUsed2
                                        nsteps$!Nsteps
                                  |     !toolsUsed2
                                      : ~!currToolsUsed2
                                      : ?currToolsUsed2
                                    & !Nsteps:?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    &   (hr.,)
                                        theUsedTools$!toolsUsed2
                                        nsteps$!Nsteps
                                  |   !Nsteps:~!currNsteps:?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    & nsteps$!Nsteps
                                  |     !toolPlumbing
                                      : ~!currToolPlumbing
                                      : ?currToolPlumbing
                                    & 
                                  | 
                                  )
                                  !nth
                                  \r\n
                                  ( input
                                  .     (type.submit)
                                        (name.str$(bview- !nth))
                                        (value.üëÅ)
                                    , 
                                  )
                                  \r\n
                                  ( input
                                  .     (type.submit)
                                        (name.str$(bsubmit- !nth))
                                        (value.‚ñ∫)
                                    , 
                                  )
                                  \r\n
                                  translateManyToHumanLanguage$(!abbR.!struct)
                                  (br.,)
                                  (br.,)
                          )
                        . !reorderedworkflowlist
                        )
                      (br.,)
                  : ?buttons
                &   (       map
                          $ ( ( 
                              =   ID cur
                                .   !arg:(?ID.?cur)
                                  & ( !ID
                                    .   map
                                      $ ( ( 
                                          =   
                                            .     !cur:? !arg ?
                                                & (‚óº|‚ñ†)
                                              | " "
                                          )
                                        . !topologicalOrderedTools
                                        )
                                    )
                              )
                            . !toolUsageList
                            )
                        : ?toolTable
                      & (   !toolUsageList:? [>0
                          &     map
                              $ ( ( 
                                  =   ID
                                    .   !arg:(?ID.?)
                                      & ( th
                                        .   
                                          , ( a
                                            .     (href.str$("#" !ID))
                                                  (tabindex.0)
                                              , ‚¨á
                                            )
                                        )
                                  )
                                . !toolTable
                                )
                            : ?hyperlinks
                          &   ( thead
                              .   
                                , ( tr
                                  .   
                                    , ( th
                                      .   
                                        ,   localized$(tools v√¶rkt√∏jer)
                                            ü†ì
                                            ( 
                                            | " ‚ßπ " localized$hyperlinks ü†í
                                            )
                                      )
                                  )
                              )
                            : ?thead
                        | 
                        )
                      & transpose$!toolTable:?toolTable
                      &   ( table
                          .   (id.t01)
                            ,   ( !toolUsageList:? [>1&!thead
                                | 
                                )
                                (tbody.,toolRows$(!topologicalOrderedTools.!toolTable))
                                (   !toolUsageList:? [>1
                                  & ( thead
                                    .   
                                      , ( tr
                                        .   
                                          ,   ( th
                                              .   
                                                ,   ( 
                                                    |   localized$(tools v√¶rkt√∏jer)
                                                        ü†ë
                                                        " ‚ß∏ "
                                                    )
                                                    localized$hyperlinks
                                                    ü†í
                                              )
                                              !hyperlinks
                                        )
                                    )
                                | 
                                )
                          )
                          ( p
                          .   
                            ,   (br.,)
                                  localized
                                $ ( "Move the mouse pointer over the tool names for a short explanation of what the tool does."
                                    "Du f√•r en kort forklaring for hvert v√¶rkt√∏j ved at flytte musepilen over v√¶rkt√∏jets navn."
                                  )
                                (br.,)
                                  localized
                                $ ( "Each column represents a combination of the tools that are marked with ‚óº."
                                    "Hver kolonne repr√¶senterer en kombination af de v√¶rkt√∏jer som er markeret med ‚óº."
                                  )
                                (br.,)
                                  localized
                                $ ( "Click on the hyperlink ‚¨á below the preferred combination and find all workflows that can be generated by the involved tools."
                                    "Klik p√• hyperlinket ‚¨á under din foretrukne kombination og se alle arbejdgange som inkluderer de markerede v√¶rkt√∏jer."
                                  )
                                (br.,)
                                  localized
                                $ ( "Select a workflow by pressing a üëÅ (View details) or ‚ñ∫ (Submit) button."
                                    "V√¶lg en arbejdsgang ved at trykke p√• üëÅ (Se detaljer) eller ‚ñ∫ (Submit)."
                                  )
                          )
                    | 
                    )
                    !buttons
            )
          & !arg:(?reorderedworkflowlist.?topologicalOrderedTools)
          & toolID2title$!topologicalOrderedTools:?topologicalOrderedTools
          & candidateList$(!reorderedworkflowlist.!topologicalOrderedTools)
      )
      ( makeWorkflowVisualisation
      =   n o struct boxes getNodesAndLinks breaks nodes edges
        .   ( getNodesAndLinks
            =   titlelinks planettitles extractEdges nameedges
              .   ( extractEdges
                  =   volgnr trav collect ou
                    .   48:?volgnr
                      & ( trav
                        =   A B ou in
                          .     !arg:%?A %?B
                              & trav$!A:?A
                              & trav$!B !A
                            |   !arg:(%?A,%?B)
                              & (trav$!A,trav$!B)
                            |   !arg:(.?A.?.?ou)
                              & (.!A:~‚àµ|48.!ou)
                            |   !arg:(?A.?B.?in.?ou)
                              & 1+!volgnr:?volgnr
                              & !B:(|!volgnr)
                              & (!A.!volgnr.!ou)
                        )
                      & !arg:? (?.?.?.?ou)
                      & trav$(!arg (‚à¥..!ou.)):?arg
                      & ( collect
                        =   A B
                          .   !arg:%?A %?B&collect$!A
                            |   !arg:(%?A,%?B)
                              & collect$!A collect$!B
                            | !arg:(?.?A.?B)&(!A.!B)
                        )
                      & ( trav
                        =   A B X ou v
                          .     !arg:%?A %?B
                              & !A:(?X.?v.?ou)
                              &     map
                                  $ ( ( 
                                      =   
                                        .   !arg:(?arg.?ou)
                                          & (!X,!arg !v.!ou)
                                      )
                                    . collect$!B
                                    )
                                  trav$!B
                            | !arg:(%?A,%?B)&trav$!A trav$!B
                            | 
                        )
                      & "trav has a side effect: it increments volgnr"
                      & trav$!arg:?arg
                      &   map
                        $ ( ( 
                            =   n a b
                              .   !arg:(?n,#%?a #%?b.?ou)
                                & (!n,!a+-48 !b+-48.!ou)
                            )
                          . !arg
                          )
                  )
                & readTable$tooladm
                & 0:?planettitles
                & extractEdges$!arg:?nameedges
                &     map
                    $ ( ( 
                        =   a b desc fr to
                          .   !arg:(?toolID,#%?fr #%?to.?desc)
                            & ( !planettitles:?+(!to.?)+?
                              |   (   !fr:0
                                    &   (0.‚àµ.Input)+!planettitles
                                      : ?planettitles
                                  | 
                                  )
                                &     ( !to
                                      .       !tooladm
                                            :   ?
                                              + ( ? (ToolID.!toolID) ?
                                                : ? (Title.?Title) ?
                                                )
                                              + ?
                                          & (!to.!Title)
                                        | (‚à¥.Result)
                                      )
                                    + !planettitles
                                  : ?planettitles
                              )
                            & (str$(fullinoutdesc$(!desc.\n)),!fr !to)
                        )
                      . !nameedges
                      )
                  : ?titlelinks
                &     mop
                    $ ( ( 
                        =   
                          .   !arg:#*((?.?.?):?arg)
                            & !arg
                        )
                      . !planettitles
                      . (=+)
                      )
                  : ?planettitles
                & (!planettitles.!titlelinks)
            )
          & SpotInput$!arg:?arg
          & getNodesAndLinks$!arg:(?nodes.?edges)
          & ( breaks
            =   
              . table
              .   (class.datadetails)
                ,   vap
                  $ ( ( 
                      =   
                        . tr
                        .   
                          ,   vap
                            $ ( ( 
                                =   
                                  . td
                                  .   
                                    ,     @(!arg:? "&" ?)
                                        & ( ul
                                          .   
                                            ,   vap
                                              $ ( (=.li.,!arg)
                                                . !arg
                                                . "&"
                                                )
                                          )
                                      | !arg
                                )
                              . !arg
                              . "="
                              )
                      )
                    . !arg
                    . \n
                    )
            )
          & ( boxes
            =   nodes edges links
              .   !arg:(?nodes.?edges)
                & 0:?links
                &   map
                  $ ( ( 
                      =   desc from to
                        .   !arg:(?desc,%?from %?to)
                          & (!from.!to.!desc)+!links:?links
                      )
                    . !edges
                    )
                & ( dl
                  .   
                    ,   map
                      $ ( ( 
                          =   no step name
                            .   !arg:(?no.?step.?name)
                              &   ( dt
                                  .   
                                    ,   (strong.(style."font-size: x-large"),!no)
                                        " - "
                                        (   !step:‚àµ
                                          &   localized$("Input data " "Inputdata ")
                                              (strong.,‚àµ)
                                        |   !step:‚à¥
                                          &   localized$("Result " "Resultat ")
                                              (strong.,‚à¥)
                                        | !name
                                        )
                                  )
                                  ( dd
                                  .   
                                    , ( dl
                                      .   
                                        ,   !step:‚à¥&
                                          |   (   !step:‚àµ
                                                & 
                                              | ( dt
                                                .   
                                                  ,     localized
                                                      $ ( "Receiving input from"
                                                          "Modtager input fra"
                                                        )
                                                      ( dl
                                                      .   
                                                        ,   mop
                                                          $ ( ( 
                                                              =   from desc
                                                                .       !arg
                                                                      : ( ?from
                                                                        . !no
                                                                        . ?
                                                                        )
                                                                    &   !nodes
                                                                      :   ?
                                                                          ( !from
                                                                          . ?
                                                                          . ?desc
                                                                          )
                                                                          ?
                                                                    & ( dd
                                                                      .   
                                                                        ,   str
                                                                          $ ( !from
                                                                              ": "
                                                                              !desc
                                                                            )
                                                                      )
                                                                  | 
                                                              )
                                                            . !links
                                                            . (=+)
                                                            )
                                                      )
                                                )
                                              )
                                              ( dt
                                              .   
                                                ,     !step:‚àµ
                                                    & localized$(Details Detaljer)
                                                  |   localized
                                                    $ ("Output details" Output-detaljer)
                                              )
                                              ( dd
                                              .   
                                                ,       !links
                                                      : ?+(!no.?.?desc)+?
                                                    & breaks$!desc
                                                  | "(No description)"
                                              )
                                              ( dt
                                              .   
                                                ,   (   !step:‚àµ
                                                      &   localized
                                                        $ ("Sent to " "Sendt til ")
                                                    |   localized
                                                      $ ( "Output sent to "
                                                          "Output sendt til "
                                                        )
                                                    )
                                                    ( dl
                                                    .   
                                                      ,   mop
                                                        $ ( ( 
                                                            =   to desc
                                                              .       !arg
                                                                    : (!no.?to.?)
                                                                  &   !nodes
                                                                    :   ?
                                                                        ( !to
                                                                        . ?
                                                                        . ?desc
                                                                        )
                                                                        ?
                                                                  & ( dd
                                                                    .   
                                                                      ,   str
                                                                        $ ( !to
                                                                            ": "
                                                                            !desc
                                                                          )
                                                                    )
                                                                | 
                                                            )
                                                          . !links
                                                          . (=+)
                                                          )
                                                    )
                                              )
                                      )
                                  )
                          )
                        . !nodes
                        )
                  )
            )
          & (boxes$(!nodes.!edges).workflowSVG$(!nodes.!edges))
      )
      ( makePasswordFormField
      =   text parm desc size required
        .     !arg
            : ( ?text
              . ?parm
              .   ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (size.?size) ?
                  | ?&:?size
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( !required:
              | (span.(class.requiblue),!required)
              )
              (span.,!text)
              \r\n
              ( input
              .     (tabindex.1+!tabind:?tabind&0)
                    (type.password)
                    (name.!parm)
                    (value.)
                    (!desc:|(title.!desc))
                    (!size:|(size.!size))
                , 
              )
              \r\n
      )
      ( makeSelectFormField
      =   text parm options desc required
        .     !arg
            : ( ?text
              . ?parm
              .   ? (options.?options) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( label
              .   
                ,   !text
                    ( !required:
                    | " " (span.(class.requiblue),!required)
                    )
              )
              \r\n
              ( select
              .     (tabindex.1+!tabind:?tabind&0)
                    (name.!parm)
                    (!desc:|(title.!desc))
                , \r\n !options
              )
              \r\n
      )
      ( submit
      =   button title
        .   !arg:%?button ?title
          &   ( input
              .     (type.submit)
                    (tabindex.1+!tabind:?tabind&0)
                    (name.bsubmit)
                    (value.!button)
                    (!title:|(title.!title))
                , 
              )
              \r\n
      )
      ( submit2
      =   button name title
        .   !arg:(?name.%?button ?title)
          &   ( input
              .     (type.submit)
                    (tabindex.1+!tabind:?tabind&0)
                    (name.!name)
                    (value.!button)
                    (!title:|(title.!title))
                    (   !button:‚ü≥
                      & (style."font-size : 38px; width: 100%;")
                    | 
                    )
                , 
              )
              \r\n
      )
      ( submitNR
      =   button
        .   !arg:?button
          &   ( input
              .     (class.notRecommended)
                    (type.submit)
                    (tabindex.1+!tabind:?tabind&0)
                    (name.bsubmit)
                    (value.!button)
                , 
              )
              \r\n
      )
      ( Style
      =   ( style
          .   
            ,   \r\n
                (html|"Use this together with min-height:100%" "html {height: 100%;}")
                \r\n
                (   ~
                  & ".bodycanvas {background: linear-gradient(179deg, rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204));background-repeat: no-repeat; }"
                |   ~
                  &   "min-height:100% is not nice as soon as you begin to scroll. The previously unseen content gets a white background."
                      ".bodycanvas {min-height: 100%; background: linear-gradient(179deg, rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204));background-repeat: no-repeat; }"
                |   ~
                  & ".bodycanvas {background: linear-gradient(rgb(254,254,254), rgba(0,210,255,0.2));background-repeat: no-repeat;}"
                | ".bodycanvas {background: linear-gradient(rgb(254,254,254), rgba(200,200,200,0.2));background-repeat: no-repeat;}"
                )
                \r\n
                "a:link, a:visited {color: #000;}"
                \r\n
                ".datadetails tr:nth-child(odd) {background-color: #C8E9E9;}"
                \r\n
                "a, dd, dt, label, h1, h2, h3, span, p, td, input, legend, textarea, li {font-family:"
                (   !TyPeFaCe:sans-serif
                  & "Calibri,WorkSans,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,sans-serif,Comic Sans MS"
                | "Comic Sans MS,Calibri,WorkSans,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,sans-serif"
                )
                ";text-rendering: optimizeLegibility;line-height: 1.4;}"
                \r\n
                "div.canvasdiv {margin:0px auto;width:72em;text-align:left;}"
                \r\n
                "input { font-size: 12pt; }"
                \r\n
                "textarea {font-size: 10pt;}"
                \r\n
                "ol li {font-size: 10pt;}"
                \r\n
                "legend.firstpage {font-weight: bold;}"
                \r\n
                "legend.secondpage {border:none;color:black;background-color:rgba(154,186,206,0.6);text-align:left;display:block;margin:0;padding:10px;float:left;width:100%;position:relative;font-size:15px;}"
                \r\n
                ".required {color:red; font-size:90%;width: auto; line-height: normal;}"
                \r\n
                ".requiblue {color:blue; font-size:90%;width: auto; line-height: normal;}"
                \r\n
                "p {margin: 0}"
                \r\n
                "p.indent {text-indent: 20px}"
                \r\n
                "#t01 tr:nth-child(2n+0) { background-color: #eee; }"
                \r\n
                "*:target {background: yellow;}"
                \r\n
                "body { font-size: 100%; }"
                \r\n
                ".formRounded input[type='submit'] {color:#FFFFFF; background-color:#5d9cec; border-color:#68A9fb; text-align:center; vertical-align:middle; cursor:pointer; border:1px solid black; padding:6px 6px; font-size:14px; border-radius:4px; }"
                \r\n
                "input[type=submit].notRecommended {background-color:#a8c6ed; font-size:10px; }"
                \r\n
                "fieldset {padding: 10px;border-style: solid;border-radius: 5px;}"
                \r\n
                "fieldset.noborder {padding: 10px; border-style: none;}"
                \r\n
                "tr.specialrow {background-color: #ddd;}"
                \r\n
                "td.textareawide {width:70%}"
                \r\n
                ".smallmargin {margin-top:0.5em; margin-bottom:0.5em;}"
                \r\n
                ".fileupload {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                ".typein {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                ".URLs {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                "label.firstpage {font-weight: bold; display: block; width: 250px; float: left; padding-left: 9px;}"
                \r\n
                "div.topmargin label.firstpage  {font-weight: bold; display: block; width: 250px; float: left; padding-left: 19px;}"
                \r\n
                "label.firstpage:after { content: ' ' }"
                \r\n
                ".alt {padding: 10px;}"
                \r\n
                "/* Tooltip container */"
                \r\n
                ".tooltip { position: relative; display: inline-block; border-bottom: 1px dotted black; /* If you want dots under the hoverable text */ }"
                \r\n
                "/* Tooltip text */"
                \r\n
                ".tooltip .tooltiptext  { visibility: hidden; width: 330px; background-color: #555; color: #fff; text-align: left; padding: 5px 10px; border-radius: 6px; /* Position the tooltip text */ position: absolute; z-index: 1; bottom: 125%; left:  0%; margin-left: 0px; /* Fade in tooltip */ opacity: 0; transition: opacity 0.3s; }"
                \r\n
                ".tooltip .tooltiptextL { visibility: hidden; width: 220px; background-color: #555; color: #fff; text-align: left; padding: 5px 10px; border-radius: 6px; /* Position the tooltip text */ position: absolute; z-index: 1; bottom: 125%; right: 0%; margin-left: 0px; /* Fade in tooltip */ opacity: 0; transition: opacity 0.3s; }"
                \r\n
                "/* Tooltip arrow */"
                \r\n
                ".tooltip .tooltiptext::after, .tooltip .tooltiptextL::after { position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #555 transparent transparent transparent; }"
                \r\n
                "/* Show the tooltip text when you mouse over the tooltip container */"
                \r\n
                ".tooltip:hover .tooltiptext,.tooltip:hover .tooltiptextL, .tooltip:focus .tooltiptext,.tooltip:focus .tooltiptextL  { visibility: visible; opacity: 1; }"
                \r\n
                "div.row{display:table-row;} .row * {vertical-align: middle;} .row label{display: table-cell; text-align: right; padding: 5px;} span.autogen{font-style:italic; width:auto; display: table-cell; text-align: left; padding: 5px;} .row input{display: table-cell;} .row textarea{display: table-cell;} span.required{width: 20px;}"
                \r\n
                ".italics {font-style:italic; width:auto;}"
                \r\n
                ".overflowing {overflow:auto;}"
                \r\n
                ".rightfloating {float:right;}"
                \r\n
                ".leftfloating {float:left;}"
                \r\n
                ".topmargin {margin-top:10px;}"
                \r\n
                ".smallfont {font-size:small}"
                \r\n
                "#wrapper {width: 100%; overflow: hidden;}"
                \r\n
                "#left {width: 500px; float: left;}"
                \r\n
                "#content {margin-left: 620px;}"
                \r\n
                "}"
          )
          \r\n
      )
      ( StyleFront
      =   ( style
          .   
            ,   \r\n
                (|"html {height: 100%;}")
                \r\n
                (   ~
                  & ".bodycanvas {background: linear-gradient(181deg, rgb(0,91,188),rgb(0,91,188),rgb(0,91,188),rgb(0,91,188),rgb(0,91,188),rgb(0,91,188), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0));background-repeat: no-repeat;}"
                |   ~
                  & "min-height:100% is not nice as soon as you begin to scroll. The previously unseen content gets a white background."
                  & ".bodycanvas {min-height: 100%; background: linear-gradient(181deg, rgb(0,91,188),rgb(0,91,188),rgb(0,91,188),rgb(0,91,188),rgb(0,91,188),rgb(0,91,188), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0));background-repeat: no-repeat;}"
                |   ~
                  & ".bodycanvas {background: linear-gradient(179deg, rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204));background-repeat: no-repeat;}"
                |   ~
                  & ".bodycanvas {background: linear-gradient(rgb(254,254,254), rgba(0,210,255,0.2));background-repeat: no-repeat;}"
                | ".bodycanvas {background: linear-gradient(rgb(254,254,254), rgba(200,200,200,0.2));background-repeat: no-repeat;}"
                )
                \r\n
                "a:link, a:visited {color: #000;}"
                \r\n
                "a, dd, dt, label, h1, h2, h3, span, p, td, input, legend, textarea, li {font-family:"
                (   !TyPeFaCe:sans-serif
                  & "Calibri,WorkSans,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,sans-serif,Comic Sans MS"
                | "Comic Sans MS,Calibri,WorkSans,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,sans-serif"
                )
                ";text-rendering: optimizeLegibility;line-height: 1.4;}"
                \r\n
                "div.canvasdiv {margin:0px auto;width:72em;text-align:left;}"
                \r\n
                "input { font-size: 12pt; }"
                \r\n
                "textarea {font-size: 10pt;}"
                \r\n
                "ol li {font-size: 10pt;}"
                \r\n
                "legend.firstpage {font-weight: bold;}"
                \r\n
                "legend.secondpage {border:none;color:black;background-color:rgba(154,186,206,0.6);text-align:left;display:block;margin:0;padding:10px;float:left;width:100%;position:relative;font-size:15px;}"
                \r\n
                ".required {color:red; font-size:90%;width: auto; line-height: normal;}"
                \r\n
                ".requiblue {color:blue; font-size:90%;width: auto; line-height: normal;}"
                \r\n
                "p {margin: 0}"
                \r\n
                "p.indent {text-indent: 20px}"
                \r\n
                "#t01 tr:nth-child(2n+0) { background-color: #eee; }"
                \r\n
                "*:target {background: yellow;}"
                \r\n
                "body { font-size: 100%; }"
                \r\n
                ".formRounded input[type='submit'] {color:#FFFFFF; background-color:#5d9cec; border-color:#68A9fb; text-align:center; vertical-align:middle; cursor:pointer; border:1px solid black; padding:6px 6px; font-size:14px; border-radius:4px; }"
                \r\n
                "fieldset {padding: 10px;border-style: solid;border-radius: 5px;}"
                \r\n
                "fieldset.noborder {padding: 10px; border-style: none;}"
                \r\n
                "tr.specialrow {background-color: #ddd;}"
                \r\n
                "td.textareawide {width:70%}"
                \r\n
                ".smallmargin {margin-top:0.5em; margin-bottom:0.5em;}"
                \r\n
                ".fileupload {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                ".typein {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                ".URLs {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                "label.firstpage {font-weight: bold; display: block; width: 250px; float: left; padding-left: 9px;}"
                \r\n
                "div.topmargin label.firstpage  {font-weight: bold; display: block; width: 250px; float: left; padding-left: 19px;}"
                \r\n
                "label.firstpage:after { content: ' ' }"
                \r\n
                ".alt {padding: 10px;}"
                \r\n
                "/* Tooltip container */"
                \r\n
                ".tooltip { position: relative; display: inline-block; border-bottom: 1px dotted black; /* If you want dots under the hoverable text */ }"
                \r\n
                "/* Tooltip text */"
                \r\n
                ".tooltip .tooltiptext  { visibility: hidden; width: 330px; background-color: #555; color: #fff; text-align: left; padding: 5px 10px; border-radius: 6px; /* Position the tooltip text */ position: absolute; z-index: 1; bottom: 125%; left:  0%; margin-left: 0px; /* Fade in tooltip */ opacity: 0; transition: opacity 0.3s; }"
                \r\n
                ".tooltip .tooltiptextL { visibility: hidden; width: 220px; background-color: #555; color: #fff; text-align: left; padding: 5px 10px; border-radius: 6px; /* Position the tooltip text */ position: absolute; z-index: 1; bottom: 125%; right: 0%; margin-left: 0px; /* Fade in tooltip */ opacity: 0; transition: opacity 0.3s; }"
                \r\n
                "/* Tooltip arrow */"
                \r\n
                ".tooltip .tooltiptext::after, .tooltip .tooltiptextL::after { position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #555 transparent transparent transparent; }"
                \r\n
                "/* Show the tooltip text when you mouse over the tooltip container */"
                \r\n
                ".tooltip:hover .tooltiptext,.tooltip:hover .tooltiptextL { visibility: visible; opacity: 1; }"
                \r\n
                "div.row{display:table-row;} .row * {vertical-align: middle;} .row label{display: table-cell; text-align: right; padding: 5px;} span.autogen{font-style:italic; width:auto; display: table-cell; text-align: left; padding: 5px;} .row input{display: table-cell;} .row textarea{display: table-cell;} span.required{width: 20px;}"
                \r\n
                ".italics {font-style:italic; width:auto;}"
                \r\n
                ".overflowing {overflow:auto;}"
                \r\n
                ".rightfloating {float:right;}"
                \r\n
                ".leftfloating {float:left;}"
                \r\n
                ".topmargin {margin-top:10px;}"
                \r\n
                ".smallfont {font-size:small}"
                \r\n
                "#wrapper {width: 100%; overflow: hidden;}"
                \r\n
                "#left {width: 500px; float: left;}"
                \r\n
                "#content {margin-left: 620px;}"
                \r\n
                "}"
          )
          \r\n
      )
      (HTMLbodyContainer=XHTMLbodyContainer)
      ( XHTMLbodyContainer
      =   
        .   "iso-8859-1 and not utf-8, because of problematic handling of UTF-8 by JNI
             (Or rather Java, which uses UTF-16 and converts surrogate pairs to 6 bytes of UTF-8 !)"
          &   ("?"."xml version='1.0' encoding='iso-8859-1'")
              \r\n
              ( "!DOCTYPE"
              . " html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'"
              )
              \r\n
              ( html
              .     (xmlns."http://www.w3.org/1999/xhtml")
                    ("xml:lang".!LaNg)
                    (lang.!LaNg)
                ,   \r\n
                    (head.,\r\n (title.,!headerTitle) \r\n !Style)
                    \r\n
                    (body.(class.bodycanvas),!arg)
              )
              \r\n
      )
      ( XHTML-SVG-bodyContainer
      =   
        .   "iso-8859-1 and not utf-8, because of problematic handling of UTF-8 by JNI
             (Or rather Java, which uses UTF-16 and converts surrogate pairs to 6 bytes of UTF-8 !)"
          &   ("?"."xml version='1.0' encoding='iso-8859-1'")
              \r\n
              ( "!DOCTYPE"
              . " html PUBLIC '-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN' 'http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd'"
              )
              \r\n
              ( html
              .     (xmlns."http://www.w3.org/1999/xhtml")
                    ("xmlns:svg"."http://www.w3.org/2000/svg")
                    ("xml:lang".!LaNg)
                    (lang.!LaNg)
                ,   \r\n
                    ( head
                    .   
                      ,   \r\n
                          (title.,!headerTitle)
                          \r\n
                          ( meta
                          .     (http-equiv.content-type)
                                (content."text/html; charset=UTF-8")
                            , 
                          )
                          \r\n
                          !Style
                    )
                    \r\n
                    (body.(class.bodycanvas),!arg)
              )
              \r\n
      )
      ( HTML-SVG-bodyContainer
      =   tit bod
        .     !arg:(?tit.?bod)
            &   ("!DOCTYPE"." html")
                ( html
                .   
                  ,   ( head
                      .   
                        ,   (title.,!tit)
                            ( meta
                            .     (http-equiv.content-type)
                                  (content."text/html; charset=UTF-8")
                              , 
                            )
                            \r\n
                            !Style
                            ( style
                            .   (type.text/css)
                              , ".demo div {float: left; clear: none;} .illustration {border: none;text-align: right;margin-left: 0;margin-right: auto;border-spacing: 0pt;font-size: 80%;font-family: Verdana, sans-serif;} .illustration td {margin-left: 0%;margin-right: 0%;border: 0px;padding: 0em;width: 3em;text-align: center;} caption {font-style: italic;} "
                            )
                      )
                      (body.,!bod)
                )
          | AAP
      )
      ( refreshingXHTMLbodyContainer
      =   seconds body URL
        .   !arg:(%?seconds ?URL.?body)
          &   ("?"."xml version='1.0' encoding='iso-8859-1'")
              \r\n
              ( "!DOCTYPE"
              . " html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'"
              )
              \r\n
              ( html
              .     (xmlns."http://www.w3.org/1999/xhtml")
                    ("xml:lang".!LaNg)
                    (lang.!LaNg)
                ,   \r\n
                    ( head
                    .   
                      ,   \r\n
                          (title.,!headerTitle)
                          \r\n
                          ( meta
                          .     (http-equiv.refresh)
                                ( content
                                .   str
                                  $ ( !seconds
                                      (!URL:|"; " !URL)
                                    )
                                )
                            , 
                          )
                          \r\n
                          !Style
                    )
                    \r\n
                    (body.(class.bodycanvas),!body)
              )
              \r\n
      )
      ( atts
      =   name value
        .     !arg:(?name,?value) ?arg
            & (!name.!value) atts$!arg
          | 
      )
      ( Table
      =   attributes heading content
        .   !arg:(?attributes.?heading.?content)
          &   (table.atts$!attributes,(thead.,!heading) \r\n (tbody.,!content))
              \r\n
      )
      (row=.(tr.,!arg) \r\n)
      (cell=.td.,!arg)
      ( xml-id
      =   car cdr
        .   str
          $ ( ( @(!arg:%@?car ?cdr)
              &   str
                $ ( (!car:!NCNameStartChar|A !car)
                      vap
                    $ ((=.!arg:!NCName|"_").!cdr)
                  )
              )
              !tabind
            )
      )
      ( makeOptionList
      =   table aBbR full selected prefix stable slx spc fulls
        .     !arg
            : ( ?table
              .   (?selected.?prefix)
                | ?selected&:?prefix
              )
          & !( 
             ' (     map
                   $ ( ( 
                       =   f a
                         .   !arg:(?f.(?a.?)|?a)
                           & (low$(localized$!f:?f).!f.!a)
                       )
                     . $table
                     )
                 : ?stable
               & (!stable:? [<5|sort$!stable:?stable)
               )
             )
          & !( 
             ' ( (option.(id.str$(b !tabind)) (value.),chu$8239)
                 \r\n
                 (   $selected:%*%
                   &     mop
                       $ ( ( 
                           =   
                             .   !arg:%?slx^?spc
                               & (   $stable:? (?.?full.!slx) ?
                                   &   ", "
                                       !full
                                       ( !spc:1&
                                       | "[" !spc "]"
                                       )
                                 | 
                                 )
                           )
                         . $selected
                         . (=*)
                         )
                     : ", " ?fulls
                   &   ( option
                       .     (id.xml-id$($selected))
                             (value.str$($prefix ()$selected))
                             (selected.selected)
                         , !fulls
                       )
                       \r\n
                 | 
                 )
                   map
                 $ ( ( 
                     =   
                       .   !arg:(?.?full.?aBbR)
                         &   ( option
                             .     (id.xml-id$!aBbR)
                                   (value.str$($prefix !aBbR))
                                   (   $selected:!aBbR
                                     & (selected.selected)
                                   | 
                                   )
                               , !full
                             )
                             \r\n
                     )
                   . $stable
                   )
               )
             )
      )
      ( makeOptgroupList
      =   featTbl selected prefix stable valueExpandedListPairs hum
        .     !arg
            : ( ?valueExpandedListPairs,?featTbl
              .   (?selected.?prefix)
                | ?selected&:?prefix
              )
          & ( hum
            =   H
              .       mop
                    $ ( ( 
                        =   
                          .   !arg:%@?arg^?
                            & !featTbl:? (?H.!arg.?) ?
                            & ", " localized$!H
                        )
                      . !arg
                      . (=*)
                      )
                  : ", " ?arg
                & !arg
            )
          &     (option.(id.str$(b !tabind)) (value.),chu$8239)
                \r\n
                (   !valueExpandedListPairs:? (?.? %*% ?) ?
                  &   map
                    $ ( ( 
                        =   f F exp
                          .   !arg:(?F.?exp)
                            & !featTbl:? (?f.!F.?) ?
                            & ( optgroup
                              .   (label.low$(localized$!f))
                                ,   map
                                  $ ( ( 
                                      =   
                                        .   ( option
                                            .     (id.xml-id$!arg)
                                                  (value.str$(!prefix !arg))
                                                  (   !selected:!arg
                                                    & (selected.selected)
                                                  | 
                                                  )
                                              , str$(hum$!arg)
                                            )
                                            \r\n
                                      )
                                    . !exp
                                    )
                              )
                        )
                      . !valueExpandedListPairs
                      )
                |     map
                    $ ( ( 
                        =   F
                          .   !arg:(?F.?)
                            & ( option
                              .     (id.xml-id$!F)
                                    (value.str$(!prefix !F))
                                    (   !selected:!F
                                      & (selected.selected)
                                    | 
                                    )
                                , str$(hum$!F)
                              )
                        )
                      . !valueExpandedListPairs
                      )
                    \r\n
                )
            : ?stable
          & !stable
      )
      ( listToThreeColumnTable
      = .map$((=.low$!arg.!arg.xml-id$!arg).!arg)
      )
      ( makeOptionListSimple
      =   idval full stable prefix
        .   !arg:(?stable.?prefix)
          & (!stable:? [<5|sort$!stable:?stable)
          &   (option.(id.str$(b !tabind)) (value.),chu$8239)
              \r\n
                map
              $ ( ( 
                  =   
                    .   !arg:(?.?full.?idval)
                      &   (option.(id.!idval) (value.!full),!full)
                          \r\n
                  )
                . !stable
                )
      )
      ( getShort
      =   feat full ABBR table
        .   !arg:(?feat.?full)
          & (     !features
                :   ?
                  + (? (short.!feat) ?:? (table.?table) ?)
                  + ?
              & readTable$!table
              & !!table:? (? !full ?.?ABBR.?) ?
              & !ABBR
            | !full
            )
      )
      ( getFeatName
      =   
        .   (   !features
              : ?+(? (short.!arg) ?:? (name.?arg) ?)+?
            | 
            )
          & localized$!arg
      )
      ( makeHiddenFields
      =   par val
        .   map
          $ ( ( 
              =   
                .     !arg:(?par.?val)
                    & ( input
                      .     (type.hidden)
                            (name.!par)
                            (value.str$!val)
                        , 
                      )
                  |   str
                    $ ("Error encountered in makeHiddenFields. arg=" lst$(arg,MEM RAW LIN))
              )
            . !arg
            )
      )
      ( percentEncode
      =   c
        .     @(!arg:%@?c ?arg)
            & "%" d2x$(asc$!c) percentEncode$!arg
          | 
      )
      ( queryEncode
      =   
        .   str
          $ ( vap
            $ ( ( 
                =   
                  .   !arg:" "&"+"
                    |   !arg
                      : ( ~<a:~>z
                        | ~<A:~>Z
                        | ~<0:~>9
                        | "-"
                        | "_"
                        | "."
                        | "~"
                        )
                    | str$(percentEncode$!arg)
                )
              . !arg
              )
            )
      )
      ( changeloglink
      =   linktext offset title
        .   ( !arg:? (linktext.?linktext) ?
            | changelog √¶ndringer:?linktext
            )
          & ( !arg:? (offset.?offset) ?
            | :?offset
            )
          & ( !arg:? (title.?title) ?
            | :?title
            )
          & ( a
            .     ( href
                  .   str
                    $ ( "changelog?UIlanguage="
                        !LaNg
                        "&TyPeFaCe="
                        queryEncode$(!TyPeFaCe|"Comic Sans MS")
                        (!offset:|"#" !offset)
                      )
                  )
                  (!title:|(title.!title))
                  (tabindex.0)
              , localized$!linktext
            )
      )
      ( contactlink
      =   usedonly linktext title
        .   ( !arg:? (usedonly.?usedonly) ?
            | y:?usedonly
            )
          & ( !arg:? (linktext.?linktext) ?
            | contact kontakt:?linktext
            )
          & ( !arg:? (title.?title) ?
            | :?title
            )
          & ( a
            .     ( href
                  .   str
                    $ ( "contact?UIlanguage="
                        !LaNg
                        "&usedonly="
                        !usedonly
                        "&TyPeFaCe="
                        queryEncode$(!TyPeFaCe|"Comic Sans MS")
                      )
                  )
                  (!title:|(title.!title))
                  (tabindex.0)
              , localized$!linktext
            )
      )
      ( helplink
      =   usedonly linktext offset title
        .   ( !arg:? (usedonly.?usedonly) ?
            | y:?usedonly
            )
          & ( !arg:? (linktext.?linktext) ?
            | help hj√¶lp:?linktext
            )
          & ( !arg:? (offset.?offset) ?
            | :?offset
            )
          & ( !arg:? (title.?title) ?
            | :?title
            )
          & ( a
            .     ( href
                  .   str
                    $ ( "help?UIlanguage="
                        !LaNg
                        "&usedonly="
                        !usedonly
                        "&TyPeFaCe="
                        queryEncode$(!TyPeFaCe|"Comic Sans MS")
                        (!offset:|"#" !offset)
                      )
                  )
                  (!title:|(title.!title))
                  (tabindex.0)
              , localized$!linktext
            )
      )
      ( denumerizeSum
      =   A L
        .   :?L
          &   whl
            ' ( !arg:%?A+?arg
              & (!A:#%*?A|)
              & (!A:?A^#%|)
              & (.!A) !L:?L
              )
          & 0:?arg
          &   whl
            ' (!L:(.%?A) ?L&!A+!arg:?arg)
          & !arg
      )
      ( removeNumFactors
      =   L a N
        .   :?L
          &   mop
            $ ( ( 
                =   
                  .   (!arg:#%*?arg|)
                    & (.!arg) !L:?L
                )
              . !arg
              . (=+)
              )
          & 0:?N
          & whl'(!L:(.?a) ?L&!a+!N:?N)
          & !N
      )
      "
/*
 * wrapper
 *
 * Generate a web service wrapper from tool metadata.
 * Usage: wrapper$(PHP.<toolID>)
 * (Other languages may be supported in the future.)
 */"
      ( wrapper
      =     combineToolIncarnations getBoilerPlate specTable
          , getFeatSpecTable getFeatTable listAlts outputFileName
          , makeName DATA DATATEXT FEATURES FEATURETEXT Features
          , IO STYLES STYLETEXT basejobpost2mode boilerPlate
          , boolfunc boolvar data declarations ech featname fname
          , fname1 fname2 fval helperFunctions httpparm iolist
          , lastWord mainfunc name o sptable stringfunc stringvar
          , toolParmTests toolprop value values var logInvalid
          , voidfunc i tooladm features svalues edata stuff
          , getFeatValues toolid output TUPTUO reverselist escape
          , facets fileFormats linguae presentations combineFeats
        .   !arg:(?arg.?toolid)
          & :?TUPTUO
          & (output=.str$!arg !TUPTUO:?TUPTUO)
          & ( reverselist
            =   L E
              .   :?L
                & whl'(!arg:%?E ?arg&!E !L:?L)
                & str$!L
            )
          & (   !arg:PHP
              & "function ":?stringfunc:?boolfunc:?voidfunc
              & "$":?stringvar:?boolvar:?var
              &   "<?php
header('Content-type:text/plain; charset=UTF-8');
/*
 * This PHP script is generated by CLARIN-DK's tool registration form
 * (http://localhost/texton/register). It should, with no or few adaptations
 * work out of the box as a dummy for your web service. The output returned
 * to the Text Tonsorium (CLARIN-DK's workflow manager) is just a listing of
 * the HTTP parameters received by this web service from the Text Tonsorium,
 * and not the output proper. For that you have to add your code to this script
 * and deactivate the dummy functionality. (The comments near the end of this
 * script explain how that is done.)
 *
 * Places in this script that require your attention are marked 'TODO'.
 */
"
                : ?boilerPlate
              &   "    }
catch (SystemExit $e)
    {
    header('HTTP/1.0 404 An error occurred: ' . $ERROR);
    logit('An error occurred' . $ERROR);
    echo $ERROR;
    }
?>
"
                : ?lastWord
            |   !arg:java
              & "public String ":?stringfunc
              & "public bool ":?boolfunc
              & "public void ":?voidfunc
              & "String ":?stringvar
              & "bool ":?boolvar
              & :?var
              & :?boilerPlate:?lastWord
            )
          & ( listAlts
            =     alt featF opts rsr rsrc stl Stl alts
                , term DATA FEATURES STYLES rsrcs stls
              .   !arg:(?alts.?IO.?featname.?DATA.?FEATURES.?STYLES)
                &   whl
                  ' ( !alts:(%(%?alt ?opts):?term)+?alts
                    & (   (!alt:%*%|!opts:% ?)
                        & ( featF
                          =   IO featname rsr DATA
                            .   !arg:(?DATA.?IO.?featname.?rsr)
                              & (!IO.!featname.!rsr.F)+!DATA
                          )
                      | ( featF
                        = DATA.!arg:(?DATA.?)&!DATA
                        )
                      )
                    &   whl
                      ' ( !alt:%?rsrc*?alt
                        & 1:?stls
                        & ( !rsrc:@?rsr
                          |   (   !rsrc:(?rsrcs.OnE)
                                &     str
                                    $ ( mop
                                      $ ( ( 
                                          =   
                                            .   !arg:%@?rsr^?Stl
                                              &   whl
                                                ' ( !Stl:%?stl+?Stl
                                                  & ( !stl:1
                                                    |     str$("__" !rsr "_" !stl)
                                                        * !stls
                                                      : ?stls
                                                    )
                                                  )
                                              & "_" !rsr
                                          )
                                        . !rsrcs
                                        . (=*)
                                        )
                                      )
                                  : ?rsr
                              |   !rsrc:?rsr^%?Stl
                                &   whl
                                  ' ( !Stl:%?stl+?Stl
                                    & !stls*!stl:?stls
                                    )
                              )
                            & (!IO.!featname.!rsr)\L!stls+!STYLES:?STYLES
                          )
                        & (!IO.!featname)\L!rsr+!FEATURES:?FEATURES
                        & featF$(!DATA.!IO.!featname.!rsr):?DATA
                        )
                    &   whl
                      ' ( !opts:%?rsrc ?opts
                        & (   !rsrc:?rsr^%?Stl
                            &   whl
                              ' ( !Stl:%?stl+?Stl
                                & (!IO.!featname.!rsr)\L!stl+!STYLES:?STYLES
                                )
                          | !rsrc:?rsr
                          )
                        & (!IO.!featname)\L!rsr+!FEATURES:?FEATURES
                        & (!IO.!featname.!rsr.F)+!DATA:?DATA
                        )
                    )
                & (!DATA.!FEATURES.!STYLES)
            )
          & ( makeName
            =   camel
              .   (camel=.!arg)
                &   str
                  $ ( vap
                    $ ( ( 
                        =   
                          .       !arg
                                : ( ~<0:~>9
                                  | "_"
                                  | ~<a:~>z
                                  | ~<A:~>Z
                                  )
                              & camel$!arg:?arg
                              & (camel=.!arg)
                              & !arg
                            | (camel=.upp$!arg)&
                        )
                      . !arg
                      )
                    )
            )
          & readTable$toolprop
          & readTable$tooladm
          & readTable$fileFormats
          & readTable$facets
          & readTable$presentations
          & readTable$linguae
          & readTable$features
          & readTable$periods
          & ( getBoilerPlate
            =   id field val
              .     !arg:(?id.?field)
                  &   !tooladm
                    :   ?
                      + ( ? (ToolID.!id) ?
                        : ? (!field.?val) ?
                        )
                      + ?
                  & !val
                | 
            )
          & ( getFeatTable
            =   table
              .     !features
                  :   ?
                    + ( ? (short.!arg) ?
                      : ? (table.?table) ?
                      )
                    + ?
                & !table
            )
          & ( getFeatValues
            =   featname value fval fvalAlt featTable
              .   !arg:(?featname.?value)
                & !(getFeatTable$!featname):?featTable
                &   (     !featTable
                        : ? (%?fval ? @?fvalAlt.!value.?) ?
                      & !fval (!fvalAlt:|" (" !fvalAlt ")")
                    |       vap
                          $ ( ( 
                              =   fval fvalAlt
                                .   !arg:
                                  |     !featTable
                                      :   ?
                                          (%?fval ? @?fvalAlt.!arg.?)
                                          ?
                                    &   " and "
                                        !fval
                                        ( !fvalAlt:
                                        | " (" !fvalAlt ")"
                                        )
                              )
                            . !value
                            . "_"
                            )
                        : (" and " ?value|?value)
                      & !value
                    )
                  : ?value
                & !value
            )
          & ( getFeatSpecTable
            =   table val
              .   !arg:(?arg.?val)
                &   !features
                  :   ?
                    + ( ? (short.!arg) ?
                      :   ?
                          (specificationTable.? (? !val ?.?table) ?)
                          ?
                      )
                    + ?
                & !table
            )
          & ( logInvalid
            =   fname1 fname2 toolid feats
              .   !arg:(?toolid.?feats)
                & (     !feats
                      :   ?
                          (?fname1,? (?+(%?*%? ?)+?.?) ?)
                          ?
                          (?fname2,? (?+(%?*%? ?)+?.?) ?)
                          ?
                    &   log
                      $ ( str
                        $ ( "Tool "
                            !toolid
                            ": inputs differ in two features: "
                            !fname1
                            " and "
                            !fname2
                            " in the same tool incarnation. This is currently not supported."
                          )
                        )
                  |     !feats
                      :   ?
                          (?fname1,? (?.?+(%*% ?)+?) ?)
                          ?
                          (?fname2,? (?.?+(%*% ?)+?) ?)
                          ?
                    &   log
                      $ ( str
                        $ ( "Tool "
                            !toolid
                            ": outputs differ on two features: "
                            !fname1
                            " and "
                            !fname2
                            " in the same tool incarnation. This is currently not supported."
                          )
                        )
                  | 
                  )
            )
          & ( combineFeats
            =   A B M Z b c
              .     whl
                  ' ( !arg:?A (?B,?b) ?M (!B,?c) ?Z
                    & !A (!B,!b+!c) !M !Z:?arg
                    )
                & !arg
            )
          & ( combineToolIncarnations
            =   featK toolprop toolid
              .   !arg:(?toolprop.?toolid)
                &   combineFeats
                  $ ( mop
                    $ ( ( 
                        =   
                          .     !arg:(!toolid.?featK)
                              & logInvalid$(!toolid.!featK)
                              & mop$((=.!arg).!featK.(=+))
                            | 
                        )
                      . !toolprop
                      . (=+)
                      )
                    )
            )
          & combineToolIncarnations$(!toolprop.!toolid):?Features
          & 0:?DATA
          & 0:?FEATURES
          & 0:?STYLES
          & (     !Features
                :   ?
                    ( facet
                    ,   ?+#*(?+(%*%|% %)+?.?)+?
                      : ?fval
                    )
                    ?
              & (     !fval
                    : ?+#*(?+(%@^?|(?.OnE))+?.?)+?
                  & "IF in some cases, IfeatvalF in other cases"
                  & (I...F)+!DATA:?DATA
                | "Never IF, always IfeatvalF"
                )
            | "Always IF, never IfeatvalF"&(I...F)+!DATA:?DATA
            )
          & "Always OF, never OfeatvalF"
          & (O...F)+!DATA:?DATA
          &   whl
            ' ( !Features:(?fname,?iolist) ?Features
              &   whl
                ' ( !iolist:#*(?i.?o)+?iolist
                  &   listAlts$(!i.I.!fname.!DATA.!FEATURES.!STYLES)
                    : (?DATA.?FEATURES.?STYLES)
                  &   listAlts$(!o.O.!fname.!DATA.!FEATURES.!STYLES)
                    : (?DATA.?FEATURES.?STYLES)
                  )
              )
          & str$(!var makeName$!toolid file):?outputFileName
          & ( escape
            =   
              .   str
                $ ( vap
                  $ ( ( 
                      =   
                        .   (   !arg:("\\"|\")
                              & "\\"
                            | 
                            )
                            !arg
                      )
                    . !arg
                    )
                  )
            )
          &   (   getBoilerPlate$(!toolid.MultiInp):(y|#>1)
                &   "    function requestFile($requestParm) // e.g. \"IfacettokF\"
        {
        global $params; // $params can contain multiple parameters with the same name. $_REQUEST and $_GET remove duplicates.
        $inputfiles = array();
        logit(\"requestFile({$requestParm})\");

        if(isset($params[$requestParm]))
            {
            $urlbase = isset($params[\"base\"]) ? $params[\"base\"][0] : \"http://localhost/toolsdata/\";
            $items = $params[$requestParm];
            foreach($items as $item)
                {
                $url = $urlbase . urlencode($item);

                $handle = fopen($url, \"r\");
                if($handle == false)
                    {
                    logit(\"Cannot open url[$url]\");
                    return \"\";
                    }
                else
                    {
                    $tempfilename = tempFileName(\""
                    makeName$!toolid
                    "_{$requestParm}_\");
                    $temp_fh = fopen($tempfilename, 'w');
                    if($temp_fh == false)
                        {
                        fclose($handle);
                        logit(\"handle closed. Cannot open $tempfilename\");
                        return \"\";
                        }
                    else
                        {
                        while (!feof($handle))
                            {
                            $read = fread($handle, 8192);
                            fwrite($temp_fh, $read);
                            }
                        fclose($temp_fh);
                        fclose($handle);
                        $inputfiles[$tempfilename] = $item;
                        //return $tempfilename;
                        }
                    }
                }
            }
        return $inputfiles;
        }
"
              |   "    function requestFile($requestParm) // e.g. \"IfacettokF\"
        {
        logit(\"requestFile({$requestParm})\");

        if(isset($_REQUEST[$requestParm]))
            {
            $urlbase = isset($_REQUEST[\"base\"]) ? $_REQUEST[\"base\"] : \"http://localhost/toolsdata/\";

            $item = $_REQUEST[$requestParm];
            $url = $urlbase . urlencode($item);
            logit(\"requestParm:$requestParm\");
            logit(\"urlbase:$urlbase\");
            logit(\"item:$item\");
            logit(\"url[$url]\");

            $handle = fopen($url, \"r\");
            if($handle == false)
                {
                logit(\"Cannot open url[$url]\");
                return \"\";
                }
            else
                {
                $tempfilename = tempFileName(\""
                  makeName$!toolid
                  "_{$requestParm}_\");
                $temp_fh = fopen($tempfilename, 'w');
                if($temp_fh == false)
                    {
                    fclose($handle);
                    logit(\"handle closed. Cannot open $tempfilename\");
                    return \"\";
                    }
                else
                    {
                    while (!feof($handle))
                        {
                        $read = fread($handle, 8192);
                        fwrite($temp_fh, $read);
                        }
                    fclose($temp_fh);
                    fclose($handle);
                    return $tempfilename;
                    }
                }
            }
        logit(\"empty\");
        return \"\";
        }
"
              )
            : ?function-requestFile
          &     "/*"
                \n
                "ToolID         : "
                !toolid
                \n
                "PassWord       : "
                getBoilerPlate$(!toolid.PassWord)
                \n
                "Version        : "
                getBoilerPlate$(!toolid.Version)
                \n
                "Title          : "
                getBoilerPlate$(!toolid.Title)
                \n
                "Path in URL    : "
                  ( 
                  =   path
                    .   @( str$(getBoilerPlate$(!arg.ServiceURL))
                         : ? "://" ? "/" ?path
                         )
                      & !path
                  )
                $ !toolid
                \t
                "*** TODO make sure your web service listens on this path and that this script is readable for the webserver. ***"
                \n
                "Publisher      : "
                getBoilerPlate$(!toolid.Publisher)
                \n
                "ContentProvider: "
                getBoilerPlate$(!toolid.ContentProvider)
                \n
                "Creator        : "
                getBoilerPlate$(!toolid.Creator)
                \n
                "InfoAbout      : "
                getBoilerPlate$(!toolid.InfoAbout)
                \n
                "Description    : "
                getBoilerPlate$(!toolid.Description)
                \n
                "ExternalURI    : "
                getBoilerPlate$(!toolid.ExternalURI)
                \n
                "MultiInp       : "
                getBoilerPlate$(!toolid.MultiInp)
                \n
                "PostData       : "
                getBoilerPlate$(!toolid.PostData)
                \n
                "Inactive       : "
                getBoilerPlate$(!toolid.Inactive)
                \n
                "*/

/*******************
* helper functions *
*******************/
$toollog = '../log/"
                makeName$!toolid
                ".log'; /* Used by the logit() function. TODO make sure the folder exists and is writable. Adapt if needed */

/*  TODO Set $dodelete to false if temporary files in /tmp should not be deleted before returning. */
$dodelete = true;
$tobedeleted = array();
"
                (   getBoilerPlate$(!toolid.MultiInp):(y|#>1)
                  & "$params = array();
"
                | 
                )
                "
function loginit()  /* Wipes the contents of the log file! TODO Change this behaviour if needed. */
    {
    global $toollog,$ftemp;
    $ftemp = fopen($toollog,'w');
    if($ftemp)
        {
        fwrite($ftemp,$toollog . \"\\n\");
        fclose($ftemp);
        }
    }

function logit($str) /* TODO You can use this function to write strings to the log file. */
    {
    global $toollog,$ftemp;
    $ftemp = fopen($toollog,'a');
    if($ftemp)
        {
        fwrite($ftemp,$str . \"\\n\");
        fclose($ftemp);
        }
    }

function scripinit($inputF,$input,$output)  /* Initialises outputfile. */
    {
    global $fscrip, "
                !outputFileName
                ";
    $fscrip = fopen("
                !outputFileName
                ",'w');
    if($fscrip)
        {"
                \n
                "        fwrite($fscrip,\"/*\\n\");"
                \n
                "        fwrite($fscrip,\" * ToolID           : "
                escape$!toolid
                "\\n\");"
                \n
                  map
                $ ( ( 
                    =   L
                      .       str
                            $ ( "        fwrite($fscrip,\" * "
                                !arg
                                "                                                         "
                              )
                          : ?L
                        & @(!L:?L [44 ?)
                        & !L ": " escape$(getBoilerPlate$(!toolid.!arg)) "\\n\");" \n
                    )
                  .   (|PassWord)
                      Version
                      Title
                      ServiceURL
                      Publisher
                      ContentProvider
                      Creator
                      InfoAbout
                      Description
                      ExternalURI
                  )
                "        fwrite($fscrip,\" * inputF \" . $inputF . \"\\n\");"
                \n
                "        fwrite($fscrip,\" * input  \" . $input  . \"\\n\");"
                \n
                "        fwrite($fscrip,\" * output \" . $output . \"\\n\");"
                \n
                "        fwrite($fscrip,\" */\\n\");"
                \n
                "        fwrite($fscrip,\"\\ncd \" . getcwd() . \"\\n\");
        fclose($fscrip);
        }
    }

function scrip($str) /* TODO send comments and command line instructions. Don't forget to terminate string with new line character, if needed.*/
    {
    global $fscrip, "
                !outputFileName
                ";
    $fscrip = fopen("
                !outputFileName
                ",'a');
    if($fscrip)
        {
        fwrite($fscrip,$str . \"\\n\");
        fclose($fscrip);
        }
    }

class SystemExit extends Exception {}
try {
    "
                !boolfunc
                "hasArgument ("
                !stringvar
                "parameterName)
        {
        return isset($_REQUEST[\""
                !stringvar
                "parameterName\"]);
        }

    "
                !stringfunc
                "getArgument ("
                !stringvar
                "parameterName)
        {
        return isset($_REQUEST[\""
                !stringvar
                "parameterName\"]) ? $_REQUEST[\""
                !stringvar
                "parameterName\"] : \"\";
        }

    "
                !boolfunc
                "existsArgumentWithValue ("
                !stringvar
                "parameterName, "
                !stringvar
                "parameterValue)
        {
        /* Check whether there is an argument <parameterName> that has value
           <parameterValue>.
           There may be any number of arguments with name <parameterName> !
        */
        $query  = explode('&', $_SERVER['QUERY_STRING']);

        foreach( $query as $param )
            {
            list($name, $value) = explode('=', $param);
            if("
                !stringvar
                "parameterName === urldecode($name) && "
                !stringvar
                "parameterValue === urldecode($value))
                return true;
            }
        return false;
        }

    function tempFileName($suff) /* TODO Use this to create temporary files, if needed. */
        {
        global $dodelete;
        global $tobedeleted;
        $tmpno = tempnam('/tmp', $suff);
        if($dodelete)
            $tobedeleted[$tmpno] = true;
        return $tmpno;
        }

"
                !function-requestFile
            : ?helperFunctions
          &     "
/***************
* declarations *
***************/

/*
 * TODO Use the variables defined below to configure your tool for the right
 * input files and the right settings.
 * The input files are local files that your tool can open and close like any
 * other file.
 * If your tool needs to create temporary files, use the tempFileName()
 * function. It can mark the temporary files for deletion when the webservice
 * is done. (See the global dodelete variable.)
 */"
                \n
                "        $base = \"\";"
                \t
                "/* URL from where this web service downloads input. The generated script takes care of that, so you can ignore this variable. */"
                \n
                "        $job = \"\";"
                \t
                "/* Only used if this web service returns 201 and POSTs result later. In that case the uploaded file must have the name of the job. */"
                \n
                "        $post2 = \"\";"
                \t
                "/* Only used if this web service returns 201 and POSTs result later. In that case the uploaded file must be posted to this URL. */"
                \n
                "        $mode = \"\";"
                \t
                "/* If the value is 'dry', the wrapper is expected to return a script of what will be done if the value is not 'dry', but 'run'. */"
                \n
                "        $inputF = \"\";"
                \t
                "/* List of all input files. */"
                \n
                "        $input = \"\";"
                \t
                "/* List of all input features. */"
                \n
                "        $output = \"\";"
                \t
                "/* List of all output features. */"
                \n
                "        "
                !stringvar
                "echos = \"\";"
                \t
                "/* List arguments and their actual values. For sanity check of this generated script. All references to this variable can be removed once your web service is working as intended. */"
                \n
            : ?declarations
          & :?toolParmTests
          &     "
        if( hasArgument(\"base\") )
            {
            "
                !var
                "base = getArgument(\"base\");
            }
        if( hasArgument(\"job\") )
            {
            "
                !var
                "job = getArgument(\"job\");
            }
        if( hasArgument(\"post2\") )
            {
            "
                !var
                "post2 = getArgument(\"post2\");
            }
        if( hasArgument(\"mode\") )
            {
            "
                !var
                "mode = getArgument(\"mode\");
            }
        "
                !var
                "echos = \"base=$base job=$job post2=$post2 mode=$mode \";
"
            : ?basejobpost2mode
          & "
/*********
* input  *
*********/
":?DATATEXT
          &   whl
            ' ( !DATA:#*(?IO.?featname.?value.F)+?DATA
              & "Restriction: There is exactly one output file."
              &   (!featname:|I) !featname !value F
                : ?httpparm
              & (   !IO:I
                  &     !declarations
                        "        "
                        !stringvar
                        !httpparm
                        " = \"\";"
                        \t
                        "/* "
                        ( Input
                          (   !featname:
                            &   " (ONLY used if there is exactly ONE "
                                (     getBoilerPlate$(!toolid.MultiInp)
                                    : (y|#>1)
                                  & "kind of "
                                | 
                                )
                                "input to this workflow step)"
                          |   " with "
                              low$(getFeatName$!featname)
                              " "
                              getFeatValues$(!featname.!value)
                          )
                        )
                        " */\n"
                    : ?declarations
                  &     !DATATEXT
                        "        if( hasArgument(\""
                        !httpparm
                        "\") )
            {
            "
                        !var
                        !httpparm
                        " = requestFile(\""
                        !httpparm
                        "\");
            if("
                        !var
                        !httpparm
                        " === '')
                {
                header(\"HTTP/1.0 404 Input "
                        ( !featname:
                        |   "with "
                            low$(getFeatName$!featname)
                            " '"
                            getFeatValues$(!featname.!value)
                            "' "
                        )
                        "not found ("
                        !httpparm
                        " parameter). \");
                return;
                }
            "
                        !var
                        "echos = "
                        !var
                        "echos . \""
                        !httpparm
                        "="
                        !var
                        !httpparm
                        " \";
            $inputF = $inputF . \" \\$"
                        !httpparm
                        " \";
            }
"
                    : ?DATATEXT
                | 
                )
              )
          &   "
/************************
* input/output features *
************************/
"
            : ?FEATURETEXT
          &   whl
            ' ( !FEATURES:#*(?IO.?data)\L?svalues+?FEATURES
              &   !FEATURETEXT "        if( hasArgument(\"" !IO !data "\") )
            {
"
                : ?FEATURETEXT
              & :?ech:?stuff
              &   whl
                ' ( !svalues:%?values+?svalues
                  &   whl
                    ' ( !values:%@?value^?*?values
                      &     !declarations
                            "        "
                            !stringvar
                            !IO
                            !data
                            !value
                            " = false;"
                            \t
                            "/* "
                            ( getFeatName$!data
                              " in "
                              ( !IO:I&input
                              | output
                              )
                              " is "
                              getFeatValues$(!data.!value)
                            )
                            " if true */
"
                        : ?declarations
                      &   !ech " . \"" !IO !data !value "=" !var !IO !data !value " \""
                        : ?ech
                      &     !stuff
                            " . ($"
                            !IO
                            !data
                            !value
                            " ? \" \\$"
                            !IO
                            !data
                            !value
                            "\" : \"\") "
                        : ?stuff
                      &     !FEATURETEXT
                            "            "
                            !var
                            !IO
                            !data
                            !value
                            " = existsArgumentWithValue(\""
                            !IO
                            !data
                            "\", \""
                            !value
                            "\");\n"
                        : ?FEATURETEXT
                      )
                  )
              &     !FEATURETEXT
                    "            $echos = $echos"
                    !ech
                    ";\n"
                    "            "
                    ( !IO:I&"$input = $input"
                    | "$output = $output"
                    )
                    !stuff
                    ";
            }
"
                : ?FEATURETEXT
              )
          &   "
/*******************************
* input/output features styles *
*******************************/
"
            : ?STYLETEXT
          &   whl
            ' ( !STYLES:#*(?IO.?featname.?data)\L?svalues+?STYLES
              &   !STYLETEXT "        if( hasArgument(\"" !IO !featname !data "\") )
            {
"
                : ?STYLETEXT
              & :?ech:?stuff
              &   whl
                ' ( !svalues:%?values+?svalues
                  &   whl
                    ' ( !values:%@?value^?*?values
                      &     !ech
                            " . \""
                            !IO
                            !featname
                            !data
                            !value
                            "="
                            !var
                            !IO
                            !featname
                            !data
                            !value
                            " \""
                        : ?ech
                      &     !stuff
                            " . ($"
                            !IO
                            !featname
                            !data
                            !value
                            " ? \" \\$"
                            !IO
                            !featname
                            !data
                            !value
                            "\" : \"\") "
                        : ?stuff
                      &     !STYLETEXT
                            "            "
                            !stringvar
                            !IO
                            !featname
                            !data
                            !value
                            " = existsArgumentWithValue(\""
                            !IO
                            !featname
                            !data
                            "\", \""
                            !value
                            "\");\n"
                        : ?STYLETEXT
                      &     !declarations
                            "        "
                            !stringvar
                            !IO
                            !featname
                            !data
                            !value
                            " = false;"
                            \t
                            "/* Style of "
                            low$(getFeatName$!featname)
                            " "
                            getFeatValues$(!featname.!data)
                            " in "
                            ( !IO:I&input
                            | output
                            )
                            " is "
                            (   getFeatSpecTable$(!featname.!data):?sptable
                              &   ( !!sptable
                                  | readTable$!sptable&!!sptable
                                  )
                                : ?specTable
                              & (   !specTable:? (?fval.!value.?) ?
                                  & !fval
                                | 
                                )
                            |   @(!value:"__" ?edata "_" ?value)
                              & getFeatSpecTable$(!featname.!edata):?sptable
                              &   ( !!sptable
                                  | readTable$!sptable&!!sptable
                                  )
                                : ?specTable
                              &   (     !specTable
                                      : ? (?fval.!value.?) ?
                                    & !fval
                                  | 
                                  )
                                  " for the "
                                  getFeatValues$(!featname.!edata)
                                  " component"
                            )
                            " if true */
"
                        : ?declarations
                      )
                  )
              &     !STYLETEXT
                    "            $echos = $echos"
                    !ech
                    ";\n"
                    "            "
                    ( !IO:I&"$input = $input"
                    | "$output = $output"
                    )
                    !stuff
                    ";
            }
"
                : ?STYLETEXT
              )
          &   output
            $ ( !boilerPlate
                !helperFunctions
                "\n    "
                !voidfunc
                (str$("do_" makeName$!toolid):?mainfunc)
                "()
        {
        global "
                !outputFileName
                ";
        global $dodelete;
        global $tobedeleted;
        global $mode;"
                !declarations
                !basejobpost2mode
                !DATATEXT
                !FEATURETEXT
                !STYLETEXT
                \n
                "//* DUMMY CODE TO SANITY CHECK GENERATED SCRIPT (TODO Remove one of the two solidi from the beginning of this line to activate your own code)"
                "\n        "
                !outputFileName
                " = tempFileName(\""
                makeName$!toolid
                "-results\");
        $command = \"echo $echos >> "
                !outputFileName
                "\";
        logit($command);

        if(($cmd = popen($command, \"r\")) == NULL)
            {
            throw new SystemExit(); // instead of exit()
            }

        while($read = fgets($cmd))
            {
            }

        pclose($cmd);
/*/
// YOUR CODE STARTS HERE.
//        TODO your code!
        "
                !outputFileName
                " = tempFileName(\""
                makeName$!toolid
                "-results\");
        if("
                !var
                "mode === 'dry')
            scripinit($inputF,$input,$output);
// YOUR CODE ENDS HERE. OUTPUT EXPECTED IN "
                !outputFileName
                "
//*/
        $tmpf = fopen("
                !outputFileName
                ",'r');

        if($tmpf)
            {
            //logit('output from "
                makeName$!toolid
                ":');
            while($line = fgets($tmpf))
                {
                //logit($line);
                print $line;
                }
            fclose($tmpf);
            }

        if($dodelete)
            {
            foreach ($tobedeleted as $filename => $dot)
                {
                if($dot)
                    unlink($filename);
                }
            unset($tobedeleted);
            }
        }
    loginit();
    "
                (   getBoilerPlate$(!toolid.MultiInp):(y|#>1)
                  & "$query  = explode('&', $_SERVER['QUERY_STRING']);
    foreach( $query as $param )
        {
        if(strpos($param, '=') === false)
            $param .= '=';

        list($name, $value) = explode('=', $param, 2);
        $params[urldecode($name)][] = urldecode($value);
        }
    "
                | 
                )
                !mainfunc
                "();\n"
                !lastWord
              )
          & reverselist$!TUPTUO
      )
      ( removePercentEncodings
      =   A g h
        .   @( !arg
             :   ?A
                 "%"
                 ( %@
                 : ( ~<0:~>9
                   | ~<a:~>f
                   | ~<A:~>F
                   )
                 : ?g
                 )
                 ( %@
                 : ( ~<0:~>9
                   | ~<a:~>f
                   | ~<A:~>F
                   )
                 : ?h
                 )
                 ?arg
             )
          & !A chr$(x2d$(str$(!g !h))) removePercentEncodings$!arg
      )
      ( element
      =   name attr content
        .   !arg:(?name.?attr.?content)
          & \r\n (!name.atts$!attr,\r\n !content \r\n) \r\n
      )
      ( select
      =   car cdr a z writeList
        .     ( writeList
              =   pat a z el
                .   !arg:(?pat.?el.?arg)
                  & (   !arg:!pat
                      & element$(!el..select$!a) writeList$(!pat.!el.!z)
                    | element$(!el..select$!arg)
                    )
              )
            & !arg:%+%
            & writeList$(%?a+%?z.or.!arg)
          | !arg:%*%&writeList$(%?a*%?z.and.!arg)
          |   !arg:%?car %?cdr
            & " " select$!car " " element$(opt..select$!cdr)
          |   !arg:%?car^%?cdr
            & " " select$!car " " element$(spec..select$!cdr)
          | !arg:(0|1)&
          | !arg
      )
      (XMLdeclaration=("?"."xml version='1.0' encoding='UTF-8'") \r\n)
      ( shared
      =   gspc isp ispc ispcs
        .   !arg:(?gspc.?ispcs)
          & 0:?ispc
          & (   !gspc+!ispcs
              :   ?
                + ( 2*%@?isp+?
                  & !isp+!ispc:?ispc
                  & ~
                  )
            | !ispc:~0
            | 1
            )
      )
      ( unify
      =   source goal gfield ss R tail U,A Z other gvalues svalues gs
        .   ( U
            =   ss g go gp gs a z sp so tail ngs
              .   !arg:(?ss.?gs)
                & "take the first factor of the goal feature value"
                & !gs:%?g*?ngs
                & (!g:(?g.OnE)|)
                & !g:%?g^?gp ?go
                & "Match it with a source feature value"
                & !ss:?a*(!g^?sp ?so)*?z
                & "At this point we may have failure."
                & "Make sure subspecifications match."
                & ( !go:!so
                  | !go:
                  | !so:
                  )
                & "At this point we may have failure."
                &   ( !gp:1&!sp
                    | !sp:1&!gp
                    | shared$(!gp.!sp):~1
                    )
                  : ?sp
                & "At this point we may have failure."
                & (   !ngs:1
                    & "All goal feature values are matched. We're done."
                    & !g^!sp !so
                  |   "Match remaining goal feature values with remaining source feature values."
                    & U$(!a*!z.!ngs):?tail
                    & (!g^!sp !so)*!tail
                  )
            )
          & !arg:(?source.?goal)
          & ( !goal:&!source
            |   !goal:(?gfield,?gvalues) ?goal
              & (   ~(!source:? (!gfield,?) ?)
                  & (   unify$(!source.!goal):?other
                      & (!gfield,!gvalues) !other
                    | `~
                    )
                |   !source:?A (!gfield,?svalues) ?Z
                  & "All gvalues must be satisfied by svalues.
                   There may be svalues that are not satisfied by gvalues."
                  &   !gvalues
                    :   ( ~
                        :   ?
                          + ( `%?gs
                            &   !svalues
                              :   ?
                                + `%( ?ss
                                    & "Satisfy first gvalue by some svalue. If success, satisfy remaining gvalues."
                                    & U$(!ss.!gs):?R
                                    & "R is the result of the unification"
                                    & "Unify remaining goal features with remaining source features."
                                    & unify$(!A !Z.!goal):?other
                                    )
                                + ?
                            )
                          + ?
                        )
                        ?
                  & (!gfield,!R) !other
                )
            )
      )
      "fold: input and output are products of feature lists.
      (1) If two feature lists are equal, with the exception of a single common
          feature with different values, then these two feature lists are
          collapsed into one feature list, multiplying the values to create a
          new common feature value.
      (2) If a feature list has the same feature twice, then these occurrences
          are collapsed into one occurrence, with the product of the original
          values as new value.
      "
      ( fold
      =   A M Z B a f v1 v2 z
        .       !arg
              :   ?A
                * ( `%?B*?Z
                  &   !B
                    :   ?a
                        (?f,?v1)
                        ( ?z
                        & !Z:?M*(!a (!f,?v2) !z)*?Z
                        )
                  )
            & fold$(!A*(!a (!f,!v1*!v2) !z)*!M*!Z)
          |   !arg:?A*(?a (?f,?v1) ?M (!f,?v2) ?z)*?Z
            & fold$(!A*(!a (!f,!v1*!v2) !M !z)*!Z)
          | !arg
      )
      ( supplyMissingFields
      =     features x outfeat infeat childfeaturevalue
          , childfeaturevalues featurename featurevalue
          , xs
        .     !arg:(?outfeat.(?infeat.?)|?infeat.?features)
            & fold$!infeat:?infeat
            &   map
              $ ( ( 
                  =   
                    .     !arg:(?featurename,?featurevalue)
                        & (   !outfeat:? (!featurename,?) ?
                            & 
                          |     !infeat
                              : ? (!featurename,?childfeaturevalues) ?
                            & 0:?xs
                            &   whl
                              ' (   !childfeaturevalues
                                  : %?childfeaturevalue^?+?childfeaturevalues
                                &   whl
                                  ' (   !featurevalue
                                      :   ?
                                        + (?+!childfeaturevalue^?+? ?.?x)
                                        + ?featurevalue
                                    & !x+!xs:?xs
                                    )
                                )
                            & (!featurename,removeNumFactors$!xs)
                          | 
                          )
                      | 
                  )
                . !features
                )
          | !outfeat
      )
      ( differentOutput
      =     fields otherPath otherPaths otherFields
          , same other A Z apathfld apathflds
        .   !arg:(?fields.?otherPaths)
          & 0:?same:?other
          &   whl
            ' ( !otherPaths:((?,(?otherFields.?)):?otherPath)+?otherPaths
              & !fields:?apathflds
              &   whl
                ' ( !apathflds:%?apathfld ?apathflds
                  & !otherFields:?A !apathfld ?Z
                  & !A !Z:?otherFields
                  )
              & (   !apathflds:
                  & !otherFields:
                  & !same+!otherPath:?same
                | !other+!otherPath:?other
                )
              )
          & !other:~0
          & (!same.!other)
      )
      ( unfoldIfDivertingOutputs
      =     tool ou apath A Z fields
          , pathsWithSameOutputAsApath pathsWithOtherOutputAsApath
          , goal inputprop
        .     !arg:(?tool,(?ou.?inputprop.((?,(?fields.?)):?apath)+?Z))
            &   differentOutput$(!fields.!Z)
              : (?pathsWithSameOutputAsApath.?pathsWithOtherOutputAsApath)
            &   (!tool,(!ou.!inputprop.!apath+!pathsWithSameOutputAsApath))
              + unfoldIfDivertingOutputs$(!tool,(!ou.!inputprop.!pathsWithOtherOutputAsApath))
          |   !arg:(?goal.%?A+%?Z)
            & (!goal.unfoldIfDivertingOutputs$!A)+(!goal.unfoldIfDivertingOutputs$!Z)
          | !arg
      )
      ( nofoldCount
      =   tool ou inputprop childstuff A Z goal inputprop
        .   !arg:%?A*%?Z&nofoldCount$!A*nofoldCount$!Z
          | !arg:%?A+%?Z&nofoldCount$!A+nofoldCount$!Z
          | !arg:(?goal.?childstuff)&nofoldCount$!childstuff
          |   !arg:(?tool,(?ou.?inputprop.?childstuff))
            & nofoldCount$!childstuff:?childstuff
          | 1
      )
      ( unfoldCount
      =   tool ou ou2 inputprop childstuff A Z goal,inputprop feature
        .   !arg:%?A*%?Z&unfoldCount$!A*unfoldCount$!Z
          | !arg:%?A+%?Z&unfoldCount$!A+unfoldCount$!Z
          | !arg:(?goal.?childstuff)&unfoldCount$!childstuff
          |     !arg
              : (?tool,(?A (?feature,%?ou+%?ou2) ?Z.?inputprop.?childstuff))
            &     unfoldCount
                $ (!tool,(!A (!feature,!ou) !Z.!inputprop.!childstuff))
              +   unfoldCount
                $ (!tool,(!A (!feature,!ou2) !Z.!inputprop.!childstuff))
          |   !arg:(?tool,(?ou.?inputprop.?childstuff))
            & unfoldCount$!childstuff:?childstuff
          | 1
      )
      ( graphCount
      =   ou parent siblings child A seen ret sibl
        .   !arg:(?parent.?siblings.?child)
          & (   !child:%*%:?seen
              & 1:?sibl
              &   whl
                ' ( !child:%?A*?arg
                  & graphCount$(!parent !seen.!sibl.!A):(?sibl.?ret)
                  )
              & !seen
            |   !arg:%+%:?seen
              & 0:?ret
              &   whl
                ' ( !arg:%?A+?arg
                  & !ret+(!seen.!A.graphCount$!A):?ret
                  )
              & !ret
            | !arg:(?.?child)&graphCount$!child
            |   !arg:(?,(?ou.?.?child))
              & graphCount$!child:?seen
              & ( 
                |   whl
                  ' ( !ou:? ((?,%+%):?A) ?ou
                    & !seen*!A:?seen
                    )
                )
              & !seen
            | 1
            )
      )
      ( leaveFeat
      =   A
        .   !arg:%?A*%?arg&leaveFeat$!A*leaveFeat$!arg
          | !arg:(?,(?.?.?.?arg))&leaveFeat$!arg
          | !arg:(?,(?.?.?arg))&!arg
          | !arg:(?.(?,?):?arg)&leaveFeat$!arg
          | !arg:(@,?) ?
      )
      ( subtract
      =   all org
        .   !arg:(?all.?org)
          &   map
            $ ( ( 
                =   f
                  .   !arg:(?f,?)
                    & ( !org:? (!f,?) ?&
                      | !arg
                      )
                )
              . !all
              )
      )
      ( selectCommonTracks
      =   sum eliminate result term recur len spitSums spotSums
        .   ( spitSums
            =   a
              .     !arg:%*%
                  & whl'(!arg:%?a*?arg&spitSums$!a)
                | !arg:(?,(?.?.?.?arg))&spitSums$!arg
                |   !arg:%+%
                  & !arg^Q*!sums:?sums
                  & whl'(!arg:%?a+?arg&spitSums$!a)
                | 
            )
          & ( spotSums
            =   a
              .     !arg:%*%
                  & whl'(!arg:%?a*?arg&spotSums$!a)
                | !arg:(?,(?.?.?.?arg))&spotSums$!arg
                |   !arg:%+%
                  & !arg*!sums:?sums
                  & whl'(!arg:%?a+?arg&spitSums$!a)
                | 
            )
          & (len=.!arg:?+[?arg&!arg)
          & ( eliminate
            =   term O R T o i W S J D s sum
              .   !arg:(?arg.?sum.?term)
                & !arg:(?O.?W)
                & (   !W:%+%
                    & !W:!sum
                    & !W:?+!term+?
                    & (!O.!term)
                  |   !W:%*%:?S
                    & 1:?R
                    & 0:?D
                    &   whl
                      ' ( !S:%?s*?S
                        &     !R
                            * (   !s:(?T,(?o.?i.?J))
                                & eliminate$(!J.!sum.!term):?J
                                & 1:?D
                                & (!T,(!o.!i.!J))
                              | !s
                              )
                          : ?R
                        )
                    & !D:1
                    & (!O.!R)
                  |   !W:(?T,(?o.?i.?J))
                    & !J:(?.?)
                    & eliminate$(!J.!sum.!term):?J
                    & (!O.!T,(!o.!i.!J))
                  )
            )
          & ( recur
            =   OUT WAY WAYS sum term result Term sums isum
              .   0:?result
                &   whl
                  ' ( !arg:#*(?OUT.?WAYS)+?arg
                    &   whl
                      ' ( !WAYS:%?WAY+?WAYS
                        & (   1:?sums
                            & spotSums$!WAY
                            & "Sums that have a Q in the exponent are children of another sum.
                           We only want unshielded sums, working out way down."
                            &   !sums
                              : ( ?*(%+%:?sum)*?
                                | ?*(%+%:?sum)^#*?
                                )
                            & !sum:?isum
                            &   whl
                              ' ( !isum:%?term+?isum
                                & (     eliminate$((!OUT.!WAY).!sum.!term)
                                      : ?Term
                                    & recur$!Term:?Term
                                    & !result+!Term:?result
                                  | !result+!term:?result
                                  )
                                & len$!result:~>1001
                                )
                          | !result+(!OUT.!WAY):?result
                          )
                        )
                    & len$!result:~>1001
                    )
                & !result
            )
          & 0:?result
          &   whl
            ' ( !arg:%?term+?arg
              & !result+recur$!term:?result
              )
          & !result
      )
      ( createNewGoal
      =   toolFeatures rfield rvals rins rin newGoal RI
        .   !arg:(?newGoal.?toolFeatures)
          &   !newGoal
                map
              $ ( ( 
                  =   
                    .   !arg:(?rfield,?rvals)
                      & 0:?rins
                      &   whl
                        ' ( !rvals:(?rin.?)+?rvals
                          &   whl
                            ' ( !rin:%?RI+?rin
                              & ( !rins:?+!RI+?
                                | !RI+!rins:?rins
                                )
                              )
                          )
                      & (!rfield,!rins)
                  )
                . !toolFeatures
                )
      )
      (NA=|"?"|0)
      ( product
      =   a
        .   !arg:%?a %?arg&!a*product$!arg
          | !arg
      )
      (log1=.!lg:1&log$!arg|)
      ( matchGoalWithFeatures
      =     goaly toolFeatures
          , newGoal pathfields gfield gvaluesAlts ngoal
          , Ar Zr gvaluePoss gspc ispc gvaluesAlt
          , input A Z oinput gval done
          , matchAlternative matchOutputAlternative
          , nnewGoal toolfeat xispc updateInput
        .   ( matchOutputAlternative
            =   outAlt gvaluesAlt len gvaluePoss gspc ispc,PathPart
              .   !arg:(?outAlt.?gvaluesAlt)
                & (!gvaluesAlt:(?gvaluesAlt.OnE)|)
                & "gvaluesAlt can have % prefix.
                   If so, outAlt must match all factors.
                   If not, outAlt must match exactly one factor."
                & !outAlt:?*[?len
                & !gvaluesAlt:?*[!len
                & 1:?PathPart
                &   whl
                  ' ( !outAlt:~1
                    & !gvaluesAlt:%@?gvaluePoss^?gspc*?gvaluesAlt
                    &   !outAlt
                      :     !gvaluePoss
                          ^ (   (1|!gspc)
                              & !PathPart*!gvaluePoss^!gspc:?PathPart
                            |   ?ispc
                              & ( !gspc:1
                                |   shared$(!gspc.!ispc):?xispc
                                  & !xispc:~1:?ispc
                                )
                              & !PathPart*!gvaluePoss^!ispc:?PathPart
                            )
                        * ?outAlt
                    )
                & 1:!gvaluesAlt:!outAlt
                & !PathPart
            )
          & ( updateInput
            =     Nw Inp inp nip in pu osp NW val In Ins
                , sip NIN
              .   !arg:(?Inp.?val)
                & 0:?Nw
                &   whl
                  ' ( !Inp:%?inp+?Inp
                    & :?sip
                    &   whl
                      ' ( !inp:%?Ins ?inp
                        & 1:?NW
                        &   whl
                          ' ( !Ins:%?In*?Ins
                            & (   !In:(?In.OnE)
                                & 1:?NIN
                                &   whl
                                  ' ( !In:%@?in^?pu*?nip
                                    &     !NIN
                                        *   !in
                                          ^ (   !pu:1
                                              & (   !val:?*!in^?osp*?
                                                  & !osp
                                                | 1
                                                )
                                            | !pu
                                            )
                                      : ?NIN
                                    & !nip:?In
                                    )
                                & !NW*(!NIN.OnE):?NW
                              |   !In:%@?in^?pu
                                &     !NW
                                    *   !in
                                      ^ (   !pu:1
                                          & (   !val:?*!in^?osp*?
                                              & !osp
                                            | 1
                                            )
                                        | !pu
                                        )
                                  : ?NW
                              )
                            )
                        & ( !Ins:1&!sip !NW:?sip
                          | 
                          )
                        )
                    & (!sip:|!Nw+!sip:?Nw)
                    )
                & !Nw:~0
            )
          & ( matchAlternative
            =     toolfeat gvaluesAlt toolAlt input gfield
                , oinput A Z done newGoal
                , PathPart outAlt ninput inp
              .   !arg:(?toolfeat.?gfield,?gvaluesAlt.?newGoal)
                & 0:?done
                & "Input can be a sum. Each term can have optional values,
                   but optional values cannot be products of two or more values.
                   E.g. (test.facet,((lex kwic)+(headmov*lem wrdsplt npr).Ngram))"
                &   whl
                  ' ( !toolfeat:%?toolAlt+?toolfeat
                    & (   !toolAlt
                        : ( ?input
                          .   !NA
                            |     ?
                                + ( `%?outAlt
                                  &   matchOutputAlternative$(!outAlt.!gvaluesAlt)
                                    : ?PathPart
                                  )
                                + ?
                              & updateInput$(!input.!PathPart):?input
                              &   (   !pathfields:?A (!gfield,?gval) ?Z
                                    &   !A
                                        ( !gfield
                                        ,   !gval:?+!PathPart+?
                                          | !gval+!PathPart
                                        )
                                        !Z
                                  | !pathfields (!gfield,!PathPart)
                                  )
                                : ?pathfields
                              &   (   !newGoal:?A (!gfield,?oinput) ?Z
                                    & !oinput:?ninput
                                    &   whl
                                      ' ( !input:%?inp+?input
                                        & ( !ninput:?+!inp+?
                                          | !inp+!ninput:?ninput
                                          )
                                        )
                                    & (   !oinput:!ninput
                                        & (!gfield,!ninput)
                                      | !A (!gfield,!ninput) !Z
                                      )
                                  | !newGoal (!gfield,!input)
                                  )
                                : ?newGoal
                              & 1+!done:?done
                          )
                      | 
                      )
                    )
                & !done:~0
                & !newGoal
            )
          & !arg:(?goaly.?toolFeatures)
          & "ALL of goaly must be satisfied by a single tool.
             goaly can be a single factor of a complex goal that must be satisfied by multiple tools.
             If the goal is complex, but must be satisfied by a single tool with a complex output,
             then goaly is complex and structured as (%*%.OnE)."
          & :?newGoal
          & :?pathfields
          & 0:?done
          &   whl
            ' ( !goaly:(?gfield,?gvaluesAlts) ?ngoal
              & "Each goaly field must be satisfied."
              & (   ~(!toolFeatures:? (!gfield,?) ?)
                  & "Assume that tool leaves field unchanged: percolate output requirement to input."
                  &     !pathfields
                        ( !gfield
                        ,   !gvaluesAlts:(?A.OnE)&!A
                          | !gvaluesAlts
                        )
                    : ?pathfields
                  & !newGoal (!gfield,!gvaluesAlts):?newGoal
                |   !gfield:sml
                  & !gvaluesAlts:nsl
                  & !toolFeatures:? (sml,(?.?)) ?
                |   !toolFeatures:?Ar (!gfield,?toolfeat) ?Zr
                  & "toolfeat is a sum of alternative (input.output) specs."
                  & !Ar !Zr:?toolFeatures
                  & 0:?done
                  & "gvaluesAlts is a sum of alternative goaly specifications for a single feature.
                     A term can be the product of multiple feature values, e.g. (lem*pos*syn.OnE) for the feature 'facet'."
                  &   whl
                    ' ( !gvaluesAlts:%?gvaluesAlt+?gvaluesAlts
                      & (       matchAlternative
                              $ (!toolfeat.!gfield,!gvaluesAlt.!newGoal)
                            : ?newGoal
                          & 1:?done
                        | 
                        )
                      )
                  & "If this test fails, none of the goaly feature values is
                     satisfied by the current tool.
                       Consequence: whl loop is exited and 'goaly' does not get
                                    nil, causing matchGoalWithFeatures to fail.
                    "
                  & !done:1
                )
              & !ngoal:?goaly
              )
          & "Each field must match"
          & !goaly:
          & createNewGoal$(!newGoal.!toolFeatures):?nnewGoal
          & !nnewGoal:?newGoal
          & (!pathfields.sort$!newGoal)
      )
      "
/*
 * illegalSolution
 *
 * Check that pipes having multiple tasks running in parallel have compatible features and feature specialisations.
 */"
      ( illegalSolution
      =     goal pipes toolA toolB outputA outputB inputA inputB
          , vA featA vB agree explicitlySanctioned
          , WRONGPIPES OKPIPES pipe
        .   ( agree
            =   a ea b eb E
              .     !arg
                  : ( %?a^?ea
                    .   (?b.OnE)&1:?eb
                      | %?b^?eb
                    )
                & !a:!b
                & ( !ea:1
                  | !eb:1
                  | !ea:?+(%@?E&!eb:?+!E+?)+?
                  )
            )
          & ( explicitlySanctioned
            =   feat v goal v2
              .   !arg:(?feat,?v.?goal)
                &   !goal
                  : ?*(? (!feat,?v2&agree$(!v.!v2)) ?)*?
            )
          & !arg:(?goal.?pipes)
          & 0:?OKPIPES
          & 0:?WRONGPIPES
          &   whl
            ' ( !pipes:%?pipe+?pipes
              & (     !pipe
                    :   ?
                      * (?toolA,(?outputA.?inputA.?))
                      * ?
                      * ( ?toolB
                        ,   (?outputB.?inputB)
                          &   !outputA
                            :   ?
                                ( ?featA
                                ,   ?vA
                                  & !outputB:? (!featA,?vB) ?
                                  & ~(agree$(!vA.!vB))
                                  & ( ~(explicitlySanctioned$(!featA,!vA.!goal))
                                    | ~(explicitlySanctioned$(!featA,!vB.!goal))
                                    )
                                )
                                ?
                        )
                      * ?
                  &   (!featA vA !vA vB !vB outputB !outputB.!pipe)+!WRONGPIPES
                    : ?WRONGPIPES
                | !pipe+!OKPIPES:?OKPIPES
                )
              )
          & !WRONGPIPES:~0
          & (!WRONGPIPES.!OKPIPES)
      )
      ( refold
      =     A M Z AM MM ZM AZ MZ ZZ ag zg feat
          , val valZ feats featsZ tool g gZ substitute
          , ZMM
        .   ( substitute
            =   a b s d
              .   !arg:(?arg.?s.?d)
                & ( !arg:!s&!d
                  |   !arg:?a_?b
                    & (substitute$(!a.!s.!d))_(substitute$(!b.!s.!d))
                  | !arg
                  )
            )
          &   whl
            ' (   !arg
                :   ?A
                  + `%?M
                  + ( ?Z
                    &   !Z
                      :   ?AZ
                        + ( `%?MZ
                          &   !M
                            :   ?AM
                              * `%?MM
                              * ( ?ZM
                                & !MZ:!AM*?ZMM*!ZM
                                & !MM:~!ZMM
                                & !MM:(?g.?tool,?feats)
                                & !ZMM:(?gZ.!tool,?featsZ)
                                &   !g
                                  :   ?ag
                                      (?feat,?val)
                                      ( ?zg
                                      & !gZ:!ag (!feat,?valZ) !zg
                                      & !val:~!valZ
                                      &   substitute$(!feats.!feat,!val.)
                                        : substitute$(!featsZ.!feat,!valZ.)
                                      )
                                )
                          )
                        + ?ZZ
                    )
              &     !A
                  + !AM*substitute$(!MM.!feat,!val.!feat,!val+!valZ)*!ZM
                  + !AZ
                  + !ZZ
                : ?arg
              )
          & !arg
      )
      "20111024 collect worked only if the first argument was output from a
       previous step, not if it was the very first input.

      collect:
      The first argument is output from previous steps, and can be ambiguous.
      It can alternatively be the very input to the workflow.

      The second argument is a feature name 'f' and its value 'v'. The value
      can be composed of several values, but is not ambiguous, i.e. just a
      single term. The second argument derives from the current goal.

      The third argument is the ambiguous list of feature values in which 'v'
      is one of the terms.
      "
      ( collect
      =     f v outp a featprod alts opts partOf V remainder
          , actualOptions A Z common partOfFunc vs strictPartOf
        .   !arg:(?alts.?f,?v.?vs)
          & ( partOf
            =   a z S Z spc
              .   !arg:(1.?a)&!a
                |     !arg
                    : ( ( %@?S^?spc*?Z
                        .   ?a
                          * `( !S
                             ^ ( !spc
                               | ?&1:!spc
                               | 1
                               )
                             )
                          * ?z
                        )
                      | (((?.OnE):?S)*?Z.?a*!S*?z)
                      | ((?S.OnE)*?Z.?a)&partOf$(!S.!a)
                      )
                  & partOf$(!Z.!a*!z)
            )
          & ( strictPartOf
            =   a z S Z
              .   !arg:(1.?a)&!a
                |   !arg:(%?S*?Z.?a*`!S*?z)
                  & strictPartOf$(!Z.!a*!z)
            )
          &   (     fct$!vs
                  :   ?
                    * %(%?V+#*!V^%+?&!v:? ?*!V^?*? ?)
                    * ?
                & "vs looks like a*b*c+a*b^x*c+a*b^x*c
                   or            a*b*c+a*b^x*c+a*b^y*c
                   etc., giving factors (b+2*b^x) resp. (b+b^x+b^y)
                  "
                & '$strictPartOf
              | '$partOf
              )
            : (=?partOfFunc)
          & ( actualOptions
            =   a z S Z spc spc2
              .   !arg:(1.?)&1
                |   !arg:(%@?S^?spc*?Z.?z)
                  & (     !z
                        :   ?a
                            `( !S
                             ^ ( !spc
                               | ?spc2&1:!spc
                               )
                             )
                            ?z
                      & !S^!spc2*actualOptions$(!Z.!a !z)
                    | actualOptions$(!Z.!z)
                    )
            )
          & 0:?outp
          & (!v:%?v %?opts|1:?opts)
          & "step through the alternative paths"
          &   whl
            ' ( !alts:%?a+?alts
              & (   !a:(?featprod.?)
                  & "There are previous workflow steps (the ?)."
                  & (     fold$!featprod
                        :   ?
                          * ( ?
                              ( !f
                              ,   ?
                                + ( `%?V
                                  & partOfFunc$(!v.!V):?remainder
                                  & partOf$(!remainder.!opts)
                                  )
                                + ?
                              )
                              ?
                            )
                          * ?
                      & !a+!outp:?outp
                    | 
                    )
                |   !a:?featprod
                  & "The input itself is ambiguous!
                     (TODO: can it really be a product?)
                    "
                  & (     fold$!featprod
                        :   ?A
                            ( !f
                            ,   ?V
                              & partOf$(!v.!V):?remainder
                              & !v*actualOptions$(!remainder.!opts):?common
                            )
                            ?Z
                      & (!A (!f,!common) !Z)+!outp:?outp
                    | 
                    )
                | !a+!outp:?outp
                )
              )
          & !outp
      )
      " distribute:
      The first argument is a feature list designating a goal, the second
      argument is input that matches the goal, but is structured differently.
      If the goal has a multivalued feature (i.e. a product of values), then
      the input either
      (1) has a feature list for each value
      (2) has a feature list with a multivalued value, just like the goal.
      The second is the case if the multivalued feature in the goal is
      annotated as '(val1*val2*val3.OnE)'. (Assuming three values).

      The input can be the very input to the workflow or the potential outputs
      from previous steps. In the second case, the input is a sum of
      alternative paths, each term structured as (output.path-to-output), where
      'output' can be a product of paths coming together.

      The very input to the workflow can consist of more than one file.

      The purpose of 'distribute' is to handle all features that have
      alternating values, i.e. values that are sums of two or more values
      or products of values. The result of 'distribute' is a sum of
      disambiguated feature lists, each feature list paired with the
      corresponding workflow(s).
      "
      ( distribute
      =   Res prop input a f vs z aa v,incarnationInput
        .   !arg:(?prop.?input)
          & (   !prop:?a (?f,%+%:?vs) ?z
              & 0:?Res
              & !vs:?aa
              &   whl
                ' ( !aa:`%?v+?aa
                  & collect$(!input.!f,!v.!vs):?incarnationInput
                  &     ( !incarnationInput:0
                        | distribute$(!a (!f,!v) !z.!incarnationInput)
                        )
                      + !Res
                    : ?Res
                  )
              & !Res
            | !arg
            )
      )
      (assert=.!arg)
      ( restrictOutputParms
      =     pathh toolFeatures outp tool ou prop in nou
          , v e es A f a b Z I
        .   !arg:(?pathh.?toolFeatures)
          &   whl
            ' ( !pathh:(?tool,(?ou.?prop.?in))+?pathh
              &     map
                  $ ( ( 
                      =   f vs val nvs i v e
                        .       !arg
                              : ( ?f
                                ,   ( %+%:?vs
                                    |   ?v^(%+%:?es)
                                      & 0:?vs
                                      &   whl
                                        ' ( !es:%?e+?es
                                          & !v^!e+!vs:?vs
                                          )
                                    )
                                  & !toolFeatures:? (!f,?val) ?
                                )
                            & 0:?nvs
                            &   whl
                              ' ( !vs:%?v^?e+?vs
                                & (     !val
                                      : ( 0
                                        |   ?
                                          + ( (?i.?+?*!v^(?+!e+?)*?+?)
                                            &   !i
                                              :   ?
                                                + `%?I
                                                + ( ?
                                                  &   !prop
                                                    :   ?
                                                        (!f,?+?*!I^?*?+?)
                                                        ?
                                                  )
                                            )
                                          + ?
                                        )
                                    & !nvs+!v^!e:?nvs
                                  | 
                                  )
                                )
                            & (!f,!nvs)
                          | !arg
                      )
                    . !ou
                    )
                : ?nou
              & :?outp
              &   whl
                ' ( !nou:?A (?f,%?a+%?b) ?Z
                  &   !outp (!tool,(!A (!f,!a) !Z.!prop.!in))
                    : ?outp
                  & !A (!f,!b) !Z:?nou
                  )
              & !outp (!tool,(!nou.!prop.!in)):?outp
              )
          & !outp
      )
      ( getActiveTools
      =   T F L S tlprp
        .   :?L
          & readTable$tooladm
          & readTable$toolprop
          & !toolprop:?tlprp
          &   whl
            ' ( !tlprp:(?T.?F)+?tlprp
              & (     !tooladm
                    :   ?
                      + ( ? (ToolID.!T) ?
                        : ? (ServiceURL.~) ?
                        : ? (Inactive.) ?
                        )
                      + ?
                  & (!T.!F) !L:?L
                | 
                )
              )
          & 0:?S
          & whl'(!L:%?T ?L&!T+!S:?S)
          & !S
      )
      ( makeSuperGoals
      =   name os Os c o v vs ss s collector SuperSets,SimpleSets
        .   "makeSuperGoals only returns value sets for features
             that have at least one composed feature value."
          & :?SuperSets:?SimpleSets
          & !arg:?collector
          &   whl
            ' ( !collector:%?name^%(?os:?Os)*?collector
              & :?c
              & 0:?vs
              &   whl
                ' ( !os:?+#*~#%?o+?os
                  & whl'(!o:%?v*?o&!v+!vs:?vs)
                  )
              &   whl
                ' ( !vs:?+#*~#%@?v+?vs
                  & !Os:?os
                  & :?ss
                  &   whl
                    ' ( !os:?+(?*!v*?:#*(~#%@*?:?s))+?os
                      & !ss !s:?ss
                      )
                  & !c (!v.!ss):?c
                  )
              & (   !c:? (?.? %*% ?) ?
                  & !SuperSets (!name.!c):?SuperSets
                | !SimpleSets (!name.!c):?SimpleSets
                )
              )
          & (!SuperSets.!SimpleSets)
      )
      ( makeExpandedSelectLists
      =   servicedSuperGoals
        .   !arg:?servicedSuperGoals
          & readTable$features
          &   map
            $ ( ( 
                =   featName valueExpandedListPairs tbl
                  .   !arg:(?featName.?valueExpandedListPairs)
                    &   !features
                      :   ?
                        + ( ? (short.!featName) ?
                          : ? (table.?tbl) ?
                          )
                        + ?
                    & readTable$!tbl:?tbl
                    & (!featName.makeOptgroupList$(!valueExpandedListPairs,!tbl.))
                )
              . !servicedSuperGoals
              )
      )
      ( namecell
      =   featurs short name table description
        .   !arg:(?featurs.?short.?name)
          &   cell
            $ (     !featurs
                  :   ?
                    + ( ? (short.!short) ?
                      : ? (description.?description) ?
                      : ? (table.?table) ?
                      )
                    + ?
                &   helplink
                  $ ( (title.localized$!description)
                      (offset.!table)
                      (linktext.!name)
                    )
              | !name
              )
      )
      ( featurehelpcell
      =   featurs short inorout help
        .   
          |   !arg:(?featurs.?short.?inorout)
            &   cell
              $ (     !featurs
                    :   ?
                      + ( ? (short.!short) ?
                        : ? (!inorout.?help) ?
                        )
                      + ?
                  & ( div
                    .     (class.tooltip)
                          (tabindex.0)
                          (title.str$(localized$!help))
                      , (small.,(small.,chu$10068))
                    )
                | 
                )
      )
      ( selectServicedValues
      =   short table pat Pat
        .     !arg:(?short.?table.(=?pat))
            & "Important! Next map fuction has local variable 'abbr', spelled just like that. '!abbr' occurs in pattern 'pat'."
            &   map
              $ ( ( 
                  =   tool Full abbr YYy
                    .   !arg:(?Full.?abbr.?YYy)
                      & !pat:(=?Pat)
                      & (   !( 
                             ' ( $toolprop
                               :   ?
                                 + ( ?tool
                                   .   ? ($short,$Pat) ?
                                     &   $tooladm
                                       :   ?
                                         + `( ? (ToolID.!tool) ?
                                            : ? (Inactive.) ?
                                            )
                                         + ?
                                   )
                                 + ?
                               )
                             )
                          & (!Full.!abbr.!YYy)
                        | 
                        )
                  )
                . !table
                )
          | !table
      )
      ( createGoalPickLists
      =   preselvalsrows,expandedSelectLists including OP
        .   !arg:(?preselvalsrows.?expandedSelectLists.?including)
          & "When called from sourcesAndGoals, including is set to 'including'.
             When called from ShowZoomedInForm, including is empty.
             So initially we create O parameters. When zooming in, P parameters.
             e.g. first Ofacet=lem*tok and then, when zooming in, Pfacet=lem*pos*tok"
          &   (!including:&P|O)
            : ?OP
          &   map
            $ ( ( 
                =   short name table servicedGoalsTable optgroups help
                  .     !arg:(?.?short.?name.?table.)
                      & ( !servicedGoals:? (!short.?servicedGoalsTable) ?
                        |       selectServicedValues
                              $ ( !short
                                . !table
                                . ( 
                                  = '(?+(?.?+?*$abbr^?*?+? ?)+?)
                                  )
                                )
                            : ?servicedGoalsTable
                          &   (!short.!servicedGoalsTable) !servicedGoals
                            : ?servicedGoals
                        )
                      & (     !features
                            :   ?
                              + ( ? (short.!short) ?
                                : ? (goalhelp.?help) ?
                                )
                              + ?
                          & (desc.localized$!help):?help
                        | :?help
                        )
                      &   row
                        $ ( namecell$(!features.!short.localized$!name)
                            featurehelpcell$(!features.!short.goalhelp)
                            (     !expandedSelectLists
                                : ? (!short.?optgroups) ?
                              &     cell
                                  $ ( makeSelectFormField
                                    $ (.str$(!OP !short).!help (options.!optgroups))
                                    )
                                  ( !including:
                                  |   cell
                                    $ ( makeCheckboxFormField
                                      $ (   R
                                          ,   localized
                                            $ ( "Combination with other values allowed (= less specific)"
                                                "Evt. i kombination med andre v√¶rdier (= mindre specifikt)"
                                              )
                                        . str$(SuperSet- !short)
                                        .   (val.on)
                                            ( desc
                                            .   localized
                                              $ ( "Check this box if your requirements are MINIMAL requirements. For example, if your requirement is to have PoS tags, you may also want to see workflows that produce PoS tags AND lemmas, at the same time."
                                                  "Marker hvis dit m√•l er minimal, fx hvis du udover PoS tags ogs√• godt vil se lemmaer, i kombination med PoS tags."
                                                )
                                            )
                                        )
                                      )
                                  )
                            |   cell
                              $ ( makeSelectFormField
                                $ ( 
                                  . str$(!OP !short)
                                  . !help (options.makeOptionList$(!servicedGoalsTable.))
                                  )
                                )
                            )
                          )
                    | 
                )
              . !preselvalsrows
              )
      )
      ( saveTask
      =   
        .   (!recentTasks:?recentTasks [30 ?|)
          & !arg !recentTasks:?recentTasks
          & saveTable$recentTasks
      )
      ( Pipelines
      =     i o o-SUpPLEMENT reqtool FP fP fp msg
          , superset userInput prunePipes windFW fintool
          , calls nth parms furtherCheck o2o extractIOfeaturesFromHTTParg
          , A Z reorderedworkflowlist topologicalOrderedTools
          , B Npipes Y features nFP nr oo ou pp lastt
          , restr returnCode supers uiin uiou haz noPathReason
        .   ( windFW
            =   nth ZZ pipes pipe
              .   !arg:(?pipes.?nth)
                & log$(nth !nth)
                & ( !nth:&!pipes
                  |   !pipes:?ZZ
                    & UNKNOWNS!:?pipe
                    &   whl
                      ' ( !nth:>0
                        & !ZZ:%?pipe+?ZZ
                        & !nth+-1:?nth
                        )
                    & log$(nthNOW !nth)
                    & !pipe
                  )
            )
          & ( extractIOfeaturesFromHTTParg
            =   fs IorOorP f short p A v Z,feat spec io V a z
              .   "Collects features of the input(s) or of the output. Each feature
                   is mentioned once. If there are more than one input, one feature
                   will have more than one value. These values are the factors in a
                   product."
                & !arg:(?fs.?IorOorP.?arg)
                & :?io
                &   whl
                  ' ( !fs:%?f+?fs
                    & !f:? (short.?short) ?
                    & str$(!IorOorP !short):?p
                    &   whl
                      ' ( !arg:?A (!p.?v) ?Z
                        & !A !Z:?arg
                        & (   !v:%*%
                            &     mop
                                $ ( ( 
                                    =   
                                      .     !arg:@(?:?feat "^" ?spec)
                                          & !feat^!spec
                                        | !arg
                                    )
                                  . !v
                                  . (=*)
                                  )
                              : ?v
                          |   str$!v:?v
                            &     vap
                                $ ( ( 
                                    =   feat spec
                                      .     !arg:@(?:?feat "^" ?spec)
                                          & !feat^!spec
                                        | !arg
                                    )
                                  . !v
                                  . "*"
                                  )
                              : ?v
                          )
                        & ( !v:
                          |   ( !io:?a (!short,?V) ?z
                              |   1:?V
                                & !io:?z
                                & :?a
                              )
                            &   map
                              $ ( ( 
                                  =   
                                    .   !V:?*!arg*?
                                      | !arg*!V:?V
                                  )
                                . !v
                                )
                            & !a (!short,!V) !z:?io
                          | (!short,!v) !io:?io
                          )
                        )
                    )
                & sort$!io
            )
          & ( noPathReason
            =     source goal feature sourceValue goalValue getEdges getFullNames recur
                , valueSeq bridges edges go so
              .   ( getEdges
                  =   T F L removeExponents is
                    .   ( removeExponents
                        =   i
                          .   1:?i
                            &   mop
                              $ ( ( 
                                  =   
                                    .   !arg:?arg^?
                                      & !i*!arg:?i
                                      & 
                                  )
                                . !arg
                                . (=*)
                                )
                            & !i
                        )
                      & :?L
                      & !arg:?F
                      &   sort
                        $ ( mop
                          $ ( ( 
                              =   T IOS
                                .     !arg:(?T.? (!F,?IOS) ?)
                                    & (     !tooladm
                                          :   ?
                                            + ( ? (ToolID.!T) ?
                                              : ? (ServiceURL.~) ?
                                              : ? (Inactive.) ?
                                              )
                                            + ?
                                        &   mop
                                          $ ( ( 
                                              =   I O
                                                .   !arg:(?I.?O)
                                                  &   mop
                                                    $ ( ( 
                                                        =   
                                                          .       !arg
                                                                : %?arg ?
                                                              &   !arg
                                                                : ?is^?
                                                              &   mop
                                                                $ ( ( 
                                                                    =   i
                                                                      .     !arg
                                                                          : ?i^?
                                                                        & (     !i
                                                                              : ( ?i
                                                                                . OnE
                                                                                )
                                                                            &     removeExponents
                                                                                $ !i
                                                                              : ?i
                                                                          | 
                                                                          )
                                                                        &   mop
                                                                          $ ( ( 
                                                                              =   
                                                                                .         removeExponents
                                                                                        $ !arg
                                                                                      : ?arg
                                                                                    &   !i
                                                                                      : ~!arg
                                                                                    & ( !i
                                                                                      . !arg
                                                                                      )
                                                                                  | 
                                                                              )
                                                                            . !O
                                                                            . ( 
                                                                              =   
                                                                                + 
                                                                              )
                                                                            )
                                                                    )
                                                                  . !is
                                                                  . ( 
                                                                    = *
                                                                    )
                                                                  )
                                                            | 
                                                        )
                                                      . !I
                                                      . (=+)
                                                      )
                                              )
                                            . !IOS
                                            . (=+)
                                            )
                                      | 
                                      )
                                  | 
                              )
                            . !toolprop
                            . (=+)
                            )
                          )
                  )
                & ( valueSeq
                  =   selected stable fulls
                    .   !arg:(?selected.?stable)
                      & !( 
                         ' (     mop
                               $ ( ( 
                                   =   slx spc full
                                     .   !arg:%?slx^?spc
                                       & (     $stable
                                             : ? (?full.!slx.?) ?
                                           &   ", "
                                               !full
                                               (   !spc:1
                                                 & 
                                               | "[" !spc "]"
                                               )
                                         | 
                                         )
                                   )
                                 . $selected
                                 . (=*)
                                 )
                             : ", " ?fulls
                           | :?fulls
                           )
                         )
                      & !fulls
                  )
                & ( getFullNames
                  =   feature sourceValue goalValue table so go
                    .   !arg:(?feature,?sourceValue,?goalValue.?)
                      &   !features
                        :   ?
                          + ( ? (short.!feature) ?
                            : ? (table.?table) ?
                            )
                          + ?
                      & readTable$!table
                      & valueSeq$(!sourceValue.!!table):?so
                      & valueSeq$(!goalValue.!!table):?go
                      & (!so.!go)
                  )
                & !arg:(?source.?goal.?reqtool,?fintool.?)
                & readTable$tooladm
                & readTable$toolprop
                & :?bridges
                & (   !source
                    :   ?
                        (?feature,?sourceValue)
                        ( ?
                        &   !goal
                          :   ?
                              (!feature,?goalValue)
                              ( ?
                              & !sourceValue:~!goalValue
                              &     ( !feature,!sourceValue,!goalValue
                                    . getEdges$!feature
                                    )
                                    !bridges
                                : ?bridges
                              & ~
                              )
                        )
                  | 
                  )
                & (   "Failure reason 1: A feature cannot change at all"
                    &     map
                        $ ( ( 
                            =   
                              .     !arg:(?feature,?,?.)
                                  &   str
                                    $ (   localized
                                        $ ( "There are currently no tools in the Text Tonsorium that can transform the \""
                                            "Der er ikke nogen v√¶rkt√∏jer i Text Tonsorium der kan transformere \""
                                          )
                                        getFeatName$!feature
                                        localized$("\" feature." "\". ")
                                      )
                                | 
                            )
                          . !bridges
                          )
                      : ~
                  |   "Failure reason 2: A specific feature value cannot be transformed to or from any other value for that feature."
                    &     map
                        $ ( ( 
                            =   
                              .     !arg
                                  : (?feature,?sourceValue^?,?goalValue.?edges)
                                & (   getFullNames$!arg:(?so.?go)
                                    & (     !edges
                                          : ~(? (!sourceValue.?) ?)
                                        &   str
                                          $ (   localized
                                              $ ( "There is no tool that can transform feature \""
                                                  "Der er ikke noget v√¶rkt√∏j der kan tranformere \""
                                                )
                                              getFeatName$!feature
                                              "\" = \""
                                              localized$!so
                                                localized
                                              $ ("\" to another value." "\" til en anden v√¶rdi.")
                                            )
                                      |     !edges
                                          : ~(? (?.!goalValue) ?)
                                        &   str
                                          $ (   localized
                                              $ ( "There is no tool that can produce feature \""
                                                  "Der er ikke noget v√¶rkt√∏j der kan producere \""
                                                )
                                              getFeatName$!feature
                                              "\" = \""
                                              localized$!go
                                                localized
                                              $ ("\" from another value." "\" fra en anden v√¶rdi.")
                                            )
                                      | 
                                      )
                                  | getFullNamesFAILED
                                  )
                            )
                          . !bridges
                          )
                      : ~
                  |   "Failure reason 3: There is no chance that for a specific feature, the source value can be transformed to the goal value. There is no path through the DAG for that feature."
                    & ( recur
                      =   edges sourceValue goalValue aValue
                        .   !arg:(?edges.?sourceValue,?goalValue)
                          &     map
                              $ ( ( 
                                  =   
                                    .   !arg:(?.~!sourceValue)
                                      | 
                                  )
                                . !edges
                                )
                            : ?edges
                            : ( ? (!sourceValue.!goalValue) ?
                              |   ?
                                  ( !sourceValue
                                  .   ?aValue
                                    & recur$(!edges.!aValue,!goalValue)
                                  )
                                  ?
                              )
                      )
                    &     map
                        $ ( ( 
                            =   
                              .       !arg
                                    : (?feature,?sourceValue,?goalValue.?edges)
                                  & recur$(!edges.!sourceValue,!goalValue)
                                  & 
                                |   getFullNames$!arg:(?so.?go)
                                  &   str
                                    $ (   localized
                                        $ ( "There is no tool chain leading from feature \""
                                            "Der er ikke nogen v√¶rkt√∏jsk√¶de der f√∏rer fra \""
                                          )
                                        getFeatName$!feature
                                        "\" = \""
                                        localized$!so
                                        localized$("\" to \"" "\" til \"")
                                        getFeatName$!feature
                                        "\" = \""
                                        localized$!go
                                        "\"."
                                      )
                            )
                          . !bridges
                          )
                      : ~
                  |   "Failure reason 4: The combination of feature values."
                    & (   !goal:
                        & ( !reqtool:
                          | !fintool:
                          |   " "
                                localized
                              $ ( "The two tools you specified cannot occur together."
                                  "De to valgte v√¶rkt√∏jer kan ikke optr√¶de sammen."
                                )
                          )
                      |     localized
                          $ ( "The combination of feature values cannot be realized in any workflow."
                              "Kombinationen af tr√¶kv√¶rdier kan ikke realiseres i en eneste arbejdsgang."
                            )
                          ( !reqtool:
                          | !fintool:
                          |   " "
                                localized
                              $ ( "It is also possible that the two tools you specified cannot occur together."
                                  "En anden mulighed er at de to valgte v√¶rkt√∏jer ikke kan optr√¶de sammen."
                                )
                          )
                      )
                  )
            )
          & ( fp
            =     tool source goal reqtool superset makeSmell feat implGoal
                , fulfil memoizedSteps activeTools Calls smell resembling
                , memos duplic impassages notttcnt getSuperGoals fintool
                , sourcegoalmatch unfulfillable notThisTool fulfilGoal reasons
                , isfulfilled hasfulfilled fulfilGoalProduct unfoldGoal
                , getGoals getImpliedGoals inner smellCache viableIncarnations
              .   0:?smell
                & :?smellCache
                & ( makeSmell
                  =   A Z o tool sml
                    .   !arg:(?tool.?arg)
                      & (   !arg:?A (sml,(?o.nsl)) ?Z
                          &   ( !smellCache:? (!tool.?sml) ?
                              |     (!tool.1+!smell:?smell:?sml)
                                    !smellCache
                                : ?smellCache
                              )
                              ?
                          & !A (sml,(!o.str$(S !sml))) !Z
                        | !arg
                        )
                  )
                & ( isfulfilled
                  =   source src goal gl tool pipe pipes
                    .   !arg:(?source.?goal.?tool)
                      & product$!source:?src
                      & product$!goal:?gl
                      & 0:?pipes
                      & (   !memoizedSteps
                          :   ?
                            + ( !src
                              . !gl
                              .   ?
                                + ( (!tool,?):?pipe
                                  & !pipe+!pipes:?pipes
                                  & ~
                                  )
                                + ?
                              )
                            + ?
                        | !pipes:~0&(!source.!goal.!pipes)
                        )
                  )
                & ( hasfulfilled
                  =   source src goal gl term a b m,pipe
                    .   !arg:(?source.?goal.?pipe)
                      &   (product$!source:?src.product$!goal:?gl.!pipe)
                        : ?term
                      & (   !memoizedSteps:?+!term+?
                          & 1+!duplic:?duplic
                        |   !memoizedSteps:?a+(!src.!gl.?m)+?b
                          & (   !m:?+!pipe+?
                              & 1+!duplic:?duplic
                            | !a+(!src.!gl.!m+!pipe)+!b:?memoizedSteps
                            )
                        | !term+!memoizedSteps:?memoizedSteps
                        )
                      & !arg
                  )
                & ( inner
                  =   A BB L M a b wrong
                    .     ( wrong
                          =   F A tool f v
                            .   1:?F
                              &   whl
                                ' ( !arg:?*(?tool,(%?A.?))*?arg
                                  &   whl
                                    ' ( !A:(?f,%@?v^?) ?A
                                      & !f^!v*!F:?F
                                      )
                                  )
                              & !F:?*?^(%+%)*?*?^(%+%)*?
                          )
                        & !arg:%?A*%?BB
                        &     mop
                            $ ( ( 
                                =   
                                  .   !arg:?a
                                    &   mop
                                      $ ( ( 
                                          =   
                                            .   wrong$(!a*!arg)&
                                              | !a*!arg
                                          )
                                        . !BB
                                        . (=+)
                                        )
                                )
                              . !A
                              . (=+)
                              )
                          : ?L
                        &   whl
                          ' ( !L:% %
                            & :?M
                            &   whl
                              ' ( !L:%?a %?b ?L
                                & !a+!b !M:?M
                                )
                            & !L !M:?L
                            )
                        & !L
                      | !arg
                  )
                & ( resembling
                  =   I O
                    .   !arg:(?I.?O)
                      &   map
                        $ ( ( 
                            =   v w f
                              .   !arg:(?f,%?v ?w)
                                & ( !f
                                  ,   !v
                                        map
                                      $ ( ( 
                                          =   
                                            .       !O
                                                  : ?*(? (!f,!arg) ?)*?
                                                & !arg
                                              | 
                                          )
                                        . !w
                                        )
                                  )
                            )
                          . !I
                          )
                  )
                & ( fulfilGoal
                  =     tools forkk goaly
                      , toolspath pathsonetool tool ltools path1
                      , toolFeatures pathh pathfields newGoal infeat
                      , memopaths fintool
                      , goal source I IO O Os sourcePlus
                    .   "Check whether source and goal already have been connected by tool and stored as a step."
                      & !arg:(?source.?goaly.?tools.?fintool.?forkk)
                      & !forkk:~0
                      &     (     (unfulfillable..find)$(str$!goaly)
                                : ? (?.!source) ?
                              & 1+!impassages:?impassages
                              & 0
                            |   unify$(!source.fold$!goaly):?sourcePlus
                              & 1+!sourcegoalmatch:?sourcegoalmatch
                              & sort$!sourcePlus
                            |   !tools:?ltools
                              & 0:?toolspath
                              &   whl
                                ' ( !forkk:~0
                                  & !ltools:(?tool.?)+?
                                  & ( !fintool:
                                    | !tool:!fintool
                                    |     whl
                                        ' ( !ltools:%+?ltools
                                          & !ltools:(?tool.?)+?
                                          & !tool:~!fintool
                                          )
                                      & !tool:!fintool
                                    )
                                  & 0:?pathsonetool
                                  & (     (notThisTool..find)$(str$!goaly)
                                        : ? (?.!tool.!source) ?
                                      & whl'(!ltools:(!tool.?)+?ltools)
                                      & 1+!notttcnt:?notttcnt
                                    |     isfulfilled$(!source.!goaly.!tool)
                                        : (?source.?goal.?memopaths)
                                      & 1+!memos:?memos
                                      & whl'(!ltools:(!tool.?)+?ltools)
                                      &   denumerizeSum$(!toolspath+!memopaths)
                                        : ?toolspath
                                      & 1+!pathsonetool:?pathsonetool
                                    |   whl
                                      ' (   !ltools
                                          : ?+(!tool.~:?toolFeatures)+?ltools
                                        &   makeSmell$(!tool.!toolFeatures)
                                          : ?toolFeatures
                                        & (       matchGoalWithFeatures
                                                $ (!goaly.!toolFeatures)
                                              : (?pathfields.?newGoal)
                                            & (       fulfil
                                                    $ ( !tools
                                                      . !source
                                                      . !newGoal
                                                      . !indent+1
                                                      . 
                                                      )
                                                  : ?pathh
                                                &   removeNumFactors$!pathh
                                                  : ?infeat
                                                &   distribute$(!newGoal.!infeat)
                                                  : ?IO
                                                & 0:?memopaths
                                                &   whl
                                                  ' ( !IO:(?I.?Os)+?IO
                                                    &   whl
                                                      ' ( !Os:%?O+?Os
                                                        &   ( !tool
                                                            , (   sort
                                                                $ ( !pathfields
                                                                      supplyMissingFields
                                                                    $ ( !pathfields
                                                                      . !O
                                                                      . !toolFeatures
                                                                      )
                                                                  )
                                                              . resembling$(!I.!O)
                                                              . !O
                                                              )
                                                            )
                                                          : ?pathh
                                                        & (   assert
                                                            ' ( !pathh
                                                              : ~( ?
                                                                 + `( ?
                                                                    , (   ?
                                                                          ( ?
                                                                          ,   %+%
                                                                            |   %
                                                                              ^ ( %
                                                                                + %
                                                                                )
                                                                          )
                                                                          ?
                                                                      . ?
                                                                      . ?
                                                                      )
                                                                    )
                                                                 + ?
                                                                 )
                                                              )
                                                          |     restrictOutputParms
                                                              $ (!pathh.!toolFeatures)
                                                            : ?pathh
                                                          )
                                                        &   whl
                                                          ' (   !pathh
                                                              : %?path1 ?pathh
                                                            & ( !( 
                                                                 ' ( $toolspath
                                                                   :   ?
                                                                     + $path1
                                                                     + ?
                                                                   )
                                                                 )
                                                              |       !toolspath
                                                                    + !path1
                                                                  : ?toolspath
                                                                &     !memopaths
                                                                    + !path1
                                                                  : ?memopaths
                                                              )
                                                            )
                                                        )
                                                    )
                                                &   1+!pathsonetool
                                                  : ?pathsonetool
                                                &   hasfulfilled
                                                  $ (!source.!pathfields.!memopaths)
                                                & ( !goaly:!pathfields
                                                  |   hasfulfilled
                                                    $ (!source.!goaly.!memopaths)
                                                  )
                                              | 0:?pathh
                                              )
                                          | "Tool's output does not match goal"
                                          )
                                        & !Calls:>0
                                        )
                                    )
                                  & !Calls:>0
                                  & (   !pathsonetool:0
                                      &   (notThisTool..insert)
                                        $ (str$!goaly.!tool.!source)
                                    | 
                                    )
                                  )
                              & !Calls:>0
                              & "forkk will become zero if no tools can fulfil goaly!"
                              & (   !toolspath:0
                                  & (unfulfillable..insert)$(str$!goaly.!source)
                                | 
                                )
                              & !toolspath
                            | log$BLANK0&0
                            )
                          * !forkk
                        : ?forkk
                      & inner$!forkk:?forkk
                      & !Calls:>0
                      & !forkk
                  )
                & ( fulfilGoalProduct
                  =   goalterm tools forkk goaly fintool source
                    .   "Check whether source and goal already have been connected by tool and stored as a step."
                      & !arg:(?source.?goalterm.?tools.?fintool)
                      & 1:?forkk
                      &   whl
                        ' ( !forkk:~0
                          & 1+!Calls:?Calls
                          & (   mod$(!Calls,100):0
                              & log$!Calls
                              & clk$+!StartClk:>100
                              & -1*!Calls:?Calls
                            | 
                            )
                          & !Calls:>0
                          & !goalterm:%?goaly*?goalterm
                          &   fulfilGoal$(!source.!goaly.!tools.!fintool.!forkk)
                            : ?forkk
                          )
                      & !Calls:>0
                      & 1+!forkk+-1
                  )
                & " unfoldGoal:
                   Construct all 2^n combinations of n options,
                   and unfold all alternatives.
                   Output: a list of disambiguated goals."
                & ( unfoldGoal
                  =     A Z AA ZZ AAA ZZZ M1 M2 prod
                      , gfield gopts convertOptionsToAlternatives
                    .   ( convertOptionsToAlternatives
                        =   gopt gopts gvaluesAlts
                          .   !arg:%?gvaluesAlts ?gopts
                            &   whl
                              ' ( !gopts:%?gopt ?gopts
                                & !gvaluesAlts+!gvaluesAlts*!gopt:?gvaluesAlts
                                )
                            & !gvaluesAlts
                        )
                      &   whl
                        ' (   !arg
                            :   ?A
                              +   ?AA
                                * ( ?AAA
                                    ( ?gfield
                                    , (% %|%+%):?M1
                                    )
                                    ?ZZZ
                                  )
                                * ?ZZ
                              + ?Z
                          & convertOptionsToAlternatives$!M1:?M1
                          & !A+!Z:?arg
                          &   whl
                            ' ( !M1:%?M2+?M1
                              &   !arg+!AA*(!AAA (!gfield,!M2) !ZZZ)*!ZZ
                                : ?arg
                              )
                          )
                      &   whl
                        ' (   !arg
                            :   ?A
                              +   ?AA
                                * (?AAA (?gfield,%?M1*%?M2:?prod) ?ZZZ)
                                * ?ZZ
                              + ?Z
                          &     !A
                              +   !AA
                                * (!AAA (!gfield,!M1) !ZZZ)
                                * (!AAA (!gfield,!M2) !ZZZ)
                                * !ZZ
                              + !Z
                            : ?arg
                          )
                      &   whl
                        ' ( !arg:?A+#%@*?M1+?Z
                          & !A+!M1+!Z:?arg
                          )
                      & !arg
                  )
                & ( fulfil
                  =     tools source goal sourcePlus forkk found
                      , goals goalterm nnnpathh indent accPipelines
                      , Pipeline WRONGPIPES OKPIPES fintool
                    .   !arg:(?tools.?source.?goal.?indent.?fintool)
                      & "Restrict path length to max 20"
                      & !indent:<20
                      & (|1+!Calls:?Calls)
                      & 0:?accPipelines
                      & unfoldGoal$!goal:?goals
                      & 0:?found
                      &   whl
                        ' ( !goals:%?goalterm+?goals
                          & (     (   unify$(!source.fold$!goalterm):?sourcePlus
                                    & 1+!Calls:?Calls
                                    & sort$!sourcePlus
                                  |       fulfilGoalProduct
                                        $ (!source.!goalterm.!tools.!fintool)
                                      : ?forkk
                                    & !Calls:>0
                                    &   (     !forkk
                                            : ( 0
                                              | 1
                                              | ?+[>2000
                                              )
                                          & 0
                                        |   ~
                                          &   illegalSolution$(!goalterm.!forkk)
                                            : (?WRONGPIPES.?OKPIPES)
                                          & log$(WRONGPIPES !WRONGPIPES OKPIPES !OKPIPES)
                                          & (!goalterm.!OKPIPES)
                                        | (!goalterm.!forkk)
                                        )
                                      : ~0
                                      : ?nnnpathh
                                    & refold$!nnnpathh
                                  )
                                : ?Pipeline
                              & 1+!found:?found
                              & !Pipeline+!accPipelines:?accPipelines
                            | 
                            )
                          & !Calls:>0
                          )
                      & !Calls:>0
                      & ( !accPipelines:~0&!accPipelines
                        | !found:~0&0
                        )
                  )
                & ( getGoals
                  =   AllFs Inca FS Ios allOs Os X A FN a b Y Z
                    .   0:?AllFs
                      &   whl
                        ' ( !arg:(.?Inca) ?arg
                          &     map
                              $ ( ( 
                                  =   
                                    .     !arg:(?FN,?Ios)
                                        & 0:?allOs
                                        &   whl
                                          ' ( !Ios:(?.?Os)+?Ios
                                            & !Os+!allOs:?allOs
                                            )
                                        & (!FN,denumerizeSum$!allOs)
                                      | log$(WHAAAT !arg)&
                                  )
                                . !Inca
                                )
                            : ?FS
                          &   whl
                            ' ( !FS:?X+#*(?A (?FN,%?a+%?b) ?Z)+?Y
                              &     !X
                                  + (!A (!FN,!a) !Z)
                                  + (!A (!FN,!b) !Z)
                                  + !Y
                                : ?FS
                              )
                          & !FS+!AllFs:?AllFs
                          )
                      & removeNumFactors$!AllFs
                  )
                & ( getImpliedGoals
                  =   allios tools fintool ios
                    .   !arg:(?tools.?fintool)
                      & :?allios
                      & !( 
                         ' ( whl
                           ' ( !tools
                             :   ?
                               + ( $fintool
                                 .   ?ios
                                   & (.!ios) !allios:?allios
                                 )
                               + ?tools
                             )
                           )
                         )
                      & getGoals$(sort$!allios)
                  )
                & ( getSuperGoals
                  =   goal nwg
                    .   !arg:?goal
                      & "'goal' is a sum of lists of features with their featurevalues. A featurevalue can be composed as a product of atomic values, with or without a specifiation exponent."
                      & 0:?nwg
                      & "Traverse Supersets"
                      &   map
                        $ ( ( 
                            =     feat vals A Z goalval supervals
                                , NVALS VAL VALS Vsp
                                , a agg n21s vsp z newgoal
                              .     !arg:(?feat.?supervals)
                                  & 0:?newgoal
                                  &   mop
                                    $ ( ( 
                                        =   alts sp val
                                          .     !arg:?goal
                                              & !goal+!newgoal:?newgoal
                                              &   !goal
                                                : ?A (!feat,?goalval) ?Z
                                              & (   !goalval:@?val^?sp
                                                  &   !supervals
                                                    : ? (!val.?alts) ?
                                                  &   map
                                                    $ ( ( 
                                                        =   a z
                                                          .       ( !A
                                                                    ( !feat
                                                                    ,       !sp
                                                                          : 1
                                                                        & !arg
                                                                      |     !arg
                                                                          :   ?a
                                                                            * !val
                                                                            * ?z
                                                                        &   !a
                                                                          * !goalval
                                                                          * !z
                                                                    )
                                                                    !Z
                                                                  )
                                                                + !newgoal
                                                              : ?newgoal
                                                            | 
                                                        )
                                                      . !alts
                                                      )
                                                |   0:?agg
                                                  &   map
                                                    $ ( ( 
                                                        =   L
                                                          .   !arg:(?.?L)
                                                            &   map
                                                              $ ( ( 
                                                                  =   
                                                                    .   !arg+!agg
                                                                      : ?agg
                                                                  )
                                                                . !L
                                                                )
                                                        )
                                                      . !supervals
                                                      )
                                                  & "elements in list 'supervals' are terms in 'agg'"
                                                  & 0:?n21s
                                                  &   whl
                                                    ' ( !agg:%?vals+?agg
                                                      & ( !vals:#%*?vals
                                                        | 
                                                        )
                                                      & "Each factor in goalval must be present in current superval, so we seek to reduce VALS to 1 by ticking of each factor."
                                                      & !goalval:?VALS
                                                      &   whl
                                                        ' (   !VALS
                                                            : %@?VAL^?Vsp*?NVALS
                                                          &   !vals
                                                            : ?a*!VAL^?vsp*?z
                                                          &   (   !Vsp:1
                                                                & !vsp
                                                              |   !vsp:1
                                                                & !Vsp
                                                              | !Vsp:!vsp
                                                              )
                                                            : ?Vsp
                                                          &   !a*!VAL^!Vsp*!z
                                                            : ?vals
                                                          & !NVALS:?VALS
                                                          )
                                                      & (   !VALS:1
                                                          &     ( !A
                                                                  (!feat,!vals)
                                                                  !Z
                                                                )
                                                              + !newgoal
                                                            : ?newgoal
                                                        | "Not every factor in goal is found in expanded value. Ignore expanded value."
                                                        )
                                                      )
                                                | log$UNREACHABLE
                                                )
                                            | "This goal has not the current expandable feature."
                                        )
                                      . !goal
                                      . (=+)
                                      )
                                  & !newgoal:?goal
                                | log$UNREACHABLE2
                            )
                          . !SuperSets
                          )
                      & denumerizeSum$!goal
                  )
                & !arg:(?source.?goal.?reqtool,?fintool.?superset)
                & readTable$toolprop
                & getActiveTools$:?activeTools
                & :?reasons
                & ( !fintool:
                  |   getImpliedGoals$(!activeTools.!fintool):?implGoal
                    & ( viableIncarnations
                      =   goal implGoal action superset
                        .   !arg:(?goal.?implGoal.(=?action).?superset)
                          & (   map
                              $ ( ( 
                                  =   sel goly tgoal
                                    .     !arg:(?feat,?goly)
                                        & !implGoal:?tgoal
                                        & 0:?sel
                                        & !( 
                                           '   mop
                                             $ ( ( 
                                                 =   igo
                                                   .       !arg
                                                         : ~( ?
                                                              ($feat,?)
                                                              ?
                                                            )
                                                       &     !sel
                                                           +   sort
                                                             $ ( ($feat,$goly)
                                                                 !arg
                                                               )
                                                         : ?sel
                                                       & 
                                                     |     !arg
                                                         :   ?
                                                             ($feat,?igo)
                                                             ?
                                                       & (   !igo:$goly
                                                           &   !sel+!arg
                                                             : ?sel
                                                           & 
                                                         |       mop
                                                               $ ( ( 
                                                                   =   
                                                                     .     !igo
                                                                         : ~( ?
                                                                            *   !arg
                                                                              ^ ?
                                                                            * ?
                                                                            )
                                                                       | 
                                                                   )
                                                                 . $goly
                                                                 . ( 
                                                                   = *
                                                                   )
                                                                 )
                                                             : ~
                                                           &   str
                                                             $ ( "NOT all "
                                                                 ()$goly
                                                                 " is in "
                                                                 !igo
                                                               )
                                                         |   !superset:
                                                           & (       mop
                                                                   $ ( ( 
                                                                       =   
                                                                         .       !arg
                                                                               :   @?arg
                                                                                 ^ ?
                                                                             &     
                                                                                 $ goly
                                                                               : ~( ?
                                                                                  * !arg
                                                                                  * ?
                                                                                  )
                                                                           | 
                                                                       )
                                                                     . !igo
                                                                     . ( 
                                                                       = *
                                                                       )
                                                                     )
                                                                 : 
                                                               &   !sel+!arg
                                                                 : ?sel
                                                               & 
                                                             |   str
                                                               $ ( "Some "
                                                                   !igo
                                                                   " are not in "
                                                                   ()$goly
                                                                 )
                                                             )
                                                         |     !sel+!arg
                                                             : ?sel
                                                           & 
                                                         )
                                                 )
                                               . !implGoal
                                               . (=+)
                                               )
                                           )
                                        & !action
                                      | "No exact match:" !arg
                                  )
                                . !goal
                                )
                            . !implGoal
                            )
                      )
                    & "`sel' a few lines below is declared in the nameless function included in `map' !"
                    &     viableIncarnations
                        $ ( !goal
                          . !implGoal
                          . ( 
                            =   !sel:~0&
                              |   str
                                $ ( localized$("Your specification of " "Din specifikation af ")
                                    "'"
                                    ( getFeatAndValueNames$!arg:(?feat,?)
                                    & localized$!feat
                                    )
                                    "'"
                                      localized
                                    $ ( " cannot be fulfilled by the tool "
                                        " er ikke forenelig med v√¶rkt√∏jet "
                                      )
                                    "'"
                                    ToolTitle$!fintool
                                    "'. "
                                  )
                            )
                          . !superset
                          )
                      : (?reasons.?implGoal)
                    & (   !reasons:
                        & "`sel' a few lines below is declared in the nameless function included in `map' !"
                        &     viableIncarnations
                            $ ( !goal
                              . !implGoal
                              . ( 
                                =     !sel:~0:?implGoal
                                    & 
                                  |   localized
                                    $ ( "Given the tool, the combination of feature specifications is too restrictive. Remove one of them."
                                        "For det givne v√¶rkt√∏j er kombinationen af tr√¶kv√¶rdier for restriktiv. Fjern en af dem."
                                      )
                                )
                              . !superset
                              )
                          : (?reasons.?implGoal)
                      | 0:?implGoal&log$!reasons
                      )
                    & !implGoal:?goal
                  | :?fintool
                  )
                & (   !goal:0
                    |   ( !reqtool:&0:?reqtool
                        | 
                        )
                      & ( !superset:
                        | !fintool:~
                        |   ( !servicedSuperGoals:?SuperSets
                            | readTable$SuperSets
                            )
                          & getSuperGoals$!goal:?goal
                        )
                      & OnEify$!goal:?goal
                      &   0
                        : ?memoizedSteps
                        : ?memos
                        : ?duplic
                        : ?sourcegoalmatch
                        : ?impassages
                        : ?notttcnt
                      & new$hash:?unfulfillable
                      & new$hash:?notThisTool
                      & 0:?Calls
                      & log$("Calling fulfil" !goal fintool !fintool)
                      & ( fulfil$(!activeTools.!source.!goal.0.!fintool)
                        | !Calls
                        )
                  . !reasons
                  )
            )
          & "+-----------+
             | Pipelines |
             +-----------+"
          & !arg:(?arg:?parms.?nth)
          & ( !arg:? (reqtool.?reqtool) ?
            | :?reqtool
            )
          & ( !arg:? (fintool.?fintool) ?
            | :?fintool
            )
          & 0:?Npipes
          &     map
              $ ( ( 
                  =   
                    .     !arg:(@(?:SuperSet- ?arg).?)
                        & !arg
                      | 
                  )
                . !arg
                )
            : ?superset
          & "superset lists the features where the user has a check mark saying
             that more than just the specified values are acceptable."
          & readTable$features
          & extractIOfeaturesFromHTTParg$(!features.I.!arg):?i
          & extractIOfeaturesFromHTTParg$(!features.O.!arg):?o
          & extractIOfeaturesFromHTTParg$(!features.P.!arg):?o-SUpPLEMENT
          & (   !o-SUpPLEMENT:
              & "If the user has checked a supplement box, but the feature
                 value is unspecified, then ignore the supplement mark."
              &     map
                  $ ( ( 
                      =   
                        .       !o
                              : ( ~(? (!arg,?) ?)
                                | ? (!arg,) ?
                                )
                            & 
                          | !arg
                      )
                    . !superset
                    )
                : ?superset
            | 
            )
          & "If there is a filled Pxyz, remove it from superset. Additional
             user data is supposed to be exactly what the user wants. (There
             is no checkbox for the user to allow more compounded values.)"
          &     map
              $ ( ( 
                  =   
                    .     !o-SUpPLEMENT:? (!arg,~) ?
                        & 
                      | !arg
                  )
                . !superset
                )
            : ?superset
          & "P values come from a subset of select boxes, when the user has
             asked for assistance to fill out the remaining fields.
             Example: If the user initially chooses the compound facet value
                     lem*tok
             this will create a parameter
              Ofacet=lem*tok
             The Text Tonsorium will propose a value from a list of compound
             values that all contain lem and tok. Suppose the user chooses
                      lem*pos*tok
             This will then give rise to a new parameter
               Pfacet=lem*pos*tok
             The original Ofacet parameter is still there.
             "
          & !o-SUpPLEMENT:?pp
          & "Make pp a list of Pxyz features that do not occur as Oxyz. At the
             same time, make oo a list of Oxyz with elements replaced by Pxyz,
             if they exist."
          &     map
              $ ( ( 
                  =   f fv a z
                    .     !arg:(?f,?)
                        & !pp:?a ((!f,?):?fv) ?z
                        & !a !z:?pp
                        & !fv
                      | !arg
                  )
                . !o
                )
            : ?oo
          &   ( !i
              .   sort$(!oo !pp)
                : ( ? (!superset,?) ?
                  | ?&:?superset
                  )
              . !reqtool,!fintool
              . !superset
              )
            : ?userInput
          & ( furtherCheck
            =   uiou wfs output nwfs wf A B
              .   !arg:(?wfs.?uiou)
                & 0:?nwfs
                &   whl
                  ' ( !wfs:((?A,(?output.?B)):?wf)+?wfs
                    & (     map
                          $ ( ( 
                              =   uf uv wv len u
                                .   !arg:(?uf,?uv)
                                  & (     !output
                                        :   ?
                                            (!uf,(?wv.OnE)|?wv)
                                            ?
                                      & !uv:?*[?len
                                      & !wv:?*[!len
                                      &   whl
                                        ' ( !uv:%?u*?uv
                                          & !wv:!u^?*?wv
                                          )
                                      & !wv:1
                                      & !uv:1
                                      & 
                                    |   !output:~(? (!uf,?) ?)
                                      & log$(LACKING !uf)
                                      & "The feature may be missing when looking at unpruned, raw pipes"
                                      & ( !uf:sml&
                                        | 
                                        |     (!A,(!arg !output.!B))
                                            : ?wf
                                          & 
                                        | STOP
                                        )
                                    | !arg
                                    )
                              )
                            . !uiou
                            )
                        : ( &!nwfs+!wf:?nwfs
                          | STOP&0:?wfs:?nwfs
                          )
                      | 
                      )
                    )
                & !nwfs:~0
            )
          & ( haz
            =   rstr S F T notfound
              .   !arg:(?arg.?rstr)
                & :?notfound
                &   whl
                  ' ( :!notfound
                    & !arg:%?T+?arg
                    &   whl
                      ' ( :!notfound
                        & !T:%?F*?T
                        & (   ( !F:(!rstr,?)
                              |   !F:(?,(?.?.?.?S))
                                & haz$(!S.!rstr)
                              )
                            & false:?notfound
                          | 
                          )
                        )
                    )
                & !notfound:false
            )
          & ( prunePipes
            =     As NNN Z incarnationpipes parms NIncarnationPipes
                , newpipes pipe pipes pipesN reqtool filter fintool
                , wantThis unfoldTree sources calls Npipes supplement
                , DownStream UpStream percolateForgottenFeatures
              .   ( unfoldTree
                  =     tool ou ou2 inputprop childstuff
                      , A Z goal b
                      , inputprop feature stop a ret
                      , As stp sp
                      , projectOnto rt af bf compatibleFeatureSets
                    .   "Returns sum. Each term is a dot separated structure:
                             (<stop list> . <user provided output specs> . <sum of unambiguous trees>)
                         The stop list is a product of (<key>.<value>) pairs, where the key is an (ambiguous) tree and the value
                         is a disambiguated solution. The stop list is passed down to the leafs and also up again as part of the
                         return value. In that way some consistency is assured and many inviable solutions are never attempted.
                         The ambiguities (declared as terms in sums) in the original tree can be in feature values and in tool choices.

                         The argument consists of a product of already found unfoldings and the (sub)tree to unfold, separated by a dot.
                         Each factor in the product of already found unfoldings consists of the tree to unfold (the key) and the tree
                         it was unfolded to (the value). Factors can have an exponent.

                         Expects that the variable 'sources' is a list of input feature/value pairs.
                         (A single pair can contain more than one value. That is the case if there are more than one inputs.)"
                      & ( compatibleFeatureSets
                        =   A B C D F V
                          .   ~(!arg:%*%)
                            |   1:?B
                              &   whl
                                ' (   !arg
                                    : ((?,?) ?:?A)^?*?arg
                                  & subtract$(!A.!sources)*!B:?B
                                  )
                              & ~( !B
                                 :   %?C
                                   * ( %?D
                                     &   !C
                                       :   ?
                                           ( ?F
                                           ,   ?V
                                             &   !D
                                               : ?*(? (!F,~!V) ?)*?
                                           )
                                           ?
                                     )
                                 )
                        )
                      & !arg:(?stop.?arg)
                      & 1+!calls:?calls:<567890
                      & (   @(!calls:? 000)
                          & log$(calls !calls)
                        | 
                        )
                      & (   !arg:%?A*%?arg
                          & "Multiply each term in unfolded first factor with each term in unfolded remaining factors."
                          & 0:?ret
                          & unfoldTree$(!stop.!A):(?stp.?a)
                          & unfoldTree$(!stop*!stp.!arg):(?sp.?b)
                          & leaveFeat$!a:?af^?
                          & leaveFeat$!b:?bf^?
                          & (   compatibleFeatureSets$(!af*!bf)
                              & !ret+(!sp.!a*!b):?ret
                            | 
                            | log$(NOTCOMPATIBLE !af AND !bf)
                            )
                          & !ret
                        |   !calls:<567890
                          & !arg:%+%
                          & log$SUMDETECTED
                          & (   !stop:?*(!arg.?projectOnto)^?*?
                              & "This removes perhaps some solutions that assume incompatible input specs."
                              & (!stop.!projectOnto)
                            |   0:?ret
                              & !arg:?As
                              &   whl
                                ' ( !As:%?A+?As
                                  & unfoldTree$(!stop.!A):?Z
                                  & !calls:<567890
                                  &   whl
                                    ' ( !Z:(?stp.?a)+?Z
                                      & !ret+((!arg.!a)*!stop.!a):?ret
                                      )
                                  )
                              & !ret
                            )
                        |   !calls:<567890
                          & !arg:(?goal.?childstuff)
                          & unfoldTree$(!stop.!childstuff):?Z
                          & !calls:<567890
                          & 0:?ret
                          &   whl
                            ' ( !Z:(?stp.?A)+?Z
                              & !ret+(!stp.!goal.!A):?ret
                              )
                          & !ret
                        |   !calls:<567890
                          &   !arg
                            : ( ?tool
                              , ( ?A (?feature,%+%:?ou) ?Z
                                . ?inputprop
                                . ?childstuff
                                )
                              )
                          & (   !stop:?*(!ou.?projectOnto)*?
                              &   unfoldTree
                                $ ( !stop
                                  .   !tool
                                    , ( !A (!feature,!projectOnto) !Z
                                      . !inputprop
                                      . !childstuff
                                      )
                                  )
                            |   !calls:<567890
                              & !ou:?ou2
                              & 0:?ret
                              &   whl
                                ' ( !ou2:%?a+?ou2
                                  &     unfoldTree
                                      $ ( !stop*(!ou.!a)
                                        .   !tool
                                          , ( !A (!feature,!a) !Z
                                            . !inputprop
                                            . !childstuff
                                            )
                                        )
                                    : ?rt
                                  & !ret+!rt:?ret
                                  )
                              & !calls:<567890
                              & !ret
                            )
                        |   !calls:<567890
                          & !arg:(?tool,(?ou.?inputprop.?childstuff))
                          & unfoldTree$(!stop.!childstuff):?Z
                          & 0:?ret
                          &   whl
                            ' ( !Z:(?stp.?A)+?Z
                              & !ret+(!stp.!tool,(!ou.!inputprop.!A)):?ret
                              )
                          & !ret
                        | !calls:<567890&(!stop.!arg)
                        )
                  )
                & "supplement: tgt and src can be very different features bundles.
                   If src has a feature that tgt hasn't, then it is added to tgt.
                   If src has a feature element with the same unsubspecified value as a feature element of tgt,
                   then the tgt feature element inherits the subspecifications of the src feature.
                   A feature (F,a*b*c) has elements a, b and c.
                  "
                & ( supplement
                  =   f v tgt src A Z updateWithSubSpec
                    .   ( updateWithSubSpec
                        =   vn v e nv ve w0 ws a
                          .   !arg:(?vn.?ve:@?v^%?e)
                            & (   !vn:?a*!v*?vn
                                & !a*!ve*!vn:?vn
                              | 
                              )
                            & 1:?nv
                            &   whl
                              ' ( !vn:?w0*(?ws.One)*?vn
                                &     !nv
                                    * !w0
                                    * (     !ws:?a*!v*?ws
                                          & !a*!ve*!ws
                                        | !ws
                                      . OnE
                                      )
                                  : ?nv
                                )
                            & !nv*!vn
                        )
                      & !arg:(?tgt.?src)
                      &   map
                        $ ( ( 
                            =   f vsc vN vtg nv A Z ve vs
                              .   !arg:(?f,?vsc)
                                & (     !tgt
                                      : ?A (!f,?vN:?vtg) ?Z
                                    &   whl
                                      ' ( !vsc:%?nv*?vsc
                                        & (   !nv:(?vs.OnE)
                                            &   whl
                                              ' (   !vs
                                                  : ?*(%^%:?ve)*?vs
                                                &   updateWithSubSpec$(!vtg.!ve)
                                                  : ?vtg
                                                )
                                          |   !nv:%^%
                                            &   updateWithSubSpec$(!vtg.!nv)
                                              : ?vtg
                                          | 
                                          )
                                        )
                                    & ( !vtg:!vN
                                      | !A (!f,!vtg) !Z:?tgt
                                      )
                                  |     (   !vsc:%*%
                                          & (!f,(!vsc.OnE))
                                        | !arg
                                        )
                                        !tgt
                                    : ?tgt
                                  )
                                & 
                            )
                          . !src
                          )
                      & sort$!tgt
                  )
                & "'wantThis' looks workflow-wide at the subspecifications occurring in the inputs and outputs of each tool.
                  If the same tool occurs with differently subspecified values, then it is checked whether unification is possible.
                  If so, unification is done. If unification is not possible, the workflow is discarded by returning 0.
                  "
                & ( wantThis
                  =     sig nsig copySpecs Clashing clsh
                      , signatures unifySignaturesAtSpecLevel
                      , mergeOIbundlesWherePossible Nsig SubspecHarmonize
                      , separate signatureDotSep trySignatures unspec
                    .   "SubspecHarmonize: In a given workflow, replace all occurrences of (Output.Input)
                        feature bundle pairs with the possibly richer (at subspec level) version
                        found in the second argument."
                      & ( SubspecHarmonize
                        =     toolSignatures Requireds h h1 aRequired O containedBy
                            , savearg nSources pipe Sources walkTree rpl
                          .   "containedBy takes two feature bundles, 'short' and 'long'.
                               It tries to prove that the short bundle is compatible with the long one.
                               If 'long' has a value subspecification while 'short' doesn't, then
                               'short' copies the subspecification from 'long'. All features in 'short'
                               must match a feature in 'long'.
                               The returned value is 'short', enriched with subspecifications.
                              "
                            & ( containedBy
                              =     short long fea val e E
                                  , rem Val P nval nVal
                                  , saves savel v
                                .     !arg
                                    : (?short:?saves.?long:?savel)
                                  & ( !short:
                                    |   !short:(?fea,@?val^?e) ?short
                                      & !long:? (!fea,!val^?E) ?
                                      & (   !e:(1|!E)
                                          & containedBy$(!short.!long):?rem
                                          & (!fea,!val^!E) !rem
                                        |   !E:1
                                          & containedBy$(!short.!long):?rem
                                          & (!fea,!val^!e) !rem
                                        )
                                    |     !short
                                        : (?fea,(?val.OnE)) ?short
                                      & !long:? (!fea,?Val) ?
                                      & ( !Val:(?Val.OnE)
                                        | 
                                        )
                                      & 1:?P
                                      &   whl
                                        ' ( !val:%@?v^?e*?nval
                                          & !Val:!v^?E*?nVal
                                          & (   !e:(1|!E)
                                              & !P*!v^!E:?P
                                            |   !E:1
                                              & !P*!v^!e:?P
                                            )
                                          & (!nval.!nVal):(?val.?Val)
                                          )
                                      & 1:!val:!Val
                                      & containedBy$(!short.!long):?rem
                                      & (!fea,(!P.OnE)) !rem
                                    |     !short
                                        : (?fea,%*%:?val) ?short
                                      & !long:? (!fea,?Val) ?
                                      & 1:?P
                                      &   whl
                                        ' ( !val:%@?v^?e*?nval
                                          & !Val:!v^?E*?nVal
                                          & (   !e:(1|!E)
                                              & !P*!v^!E:?P
                                            |   !E:1
                                              & !P*!v^!e:?P
                                            )
                                          & (!nval.!nVal):(?val.?Val)
                                          )
                                      & 1:!val:!Val
                                      & containedBy$(!short.!long):?rem
                                      & (!fea,!P) !rem
                                    )
                              )
                            & ( rpl
                              =   vals fea gold A B exp aa zz SAVEARG
                                .   !arg:(?vals.?fea.?gold):?SAVEARG
                                  & (   !vals:%?A*%?B
                                      & rpl$(!A.!fea.!gold):?A
                                      & rpl$(!B.!fea.!gold):?B
                                      & !A*!B
                                    |   !vals:%?A %?B
                                      & rpl$(!A.!fea.!gold):?A
                                      & ( rpl$(!B.!fea.!gold):?B
                                        | 
                                        )
                                      & !A !B
                                    |   !vals:@?A^?B
                                      & (     !gold
                                            : ?*(? (!fea,!vals) ?)*?
                                          & !vals
                                        |     !gold
                                            :   ?
                                              * ( ?
                                                  (!fea,?aa*!A^?exp*?zz)
                                                  ?
                                                )
                                              * ?
                                          &   ( !B:!exp
                                              |   !exp:1
                                                & !B
                                              |   !B:1
                                                & !exp
                                              )
                                            : ?B
                                          & !A^!B
                                        | !A^!B
                                        )
                                    |   !vals:(?.OnE)
                                      & "Instead of prepending with %, we group the product and mark it with OnE."
                                      & (     !gold
                                            :   ?
                                              * ( ?
                                                  (!fea,?*!vals*?:?B)
                                                  ?
                                                )
                                              * ?
                                          & !B
                                        | !vals
                                        )
                                    )
                              )
                            & ( walkTree
                              =     toolSignatures I aSource o i sub prog nsub
                                  , H O Sources gold noValueSpecConflict
                                .   ( noValueSpecConflict
                                    =   A B f e g s t
                                      .   !arg:(?A.?B)
                                        & ( !A:!B
                                          | ~( !A
                                             :   ?
                                                 (   ?f
                                                   &   !B
                                                     : ? (!f,?g) ?
                                                 ,   ?
                                                   * ( %@?e^?s
                                                     & ~( !g:?*%@!e^?t*?
                                                        & ( !s:!t
                                                          | !s:1
                                                          | !t:1
                                                          )
                                                        )
                                                     )
                                                   * ?
                                                 )
                                                 ?
                                             )
                                          )
                                    )
                                  & !arg:(?Sources.?toolSignatures)
                                  & (   !Sources:%?aSource*%?Sources
                                      & walkTree$(!aSource.!toolSignatures):?H
                                      & ( !H:0
                                        | !H*walkTree$(!Sources.!toolSignatures)
                                        )
                                    |   !Sources:(%@?prog,(?o.?i.?sub))
                                      & (   !toolSignatures:?*(!prog.?O.?I)*?
                                          & (   noValueSpecConflict$(!O.!o)
                                              & noValueSpecConflict$(!I.!i)
                                              &   SubspecHarmonize$(!sub.!toolSignatures)
                                                : ?nsub
                                              & (   !nsub:(0.?)
                                                  & 0
                                                | ( !prog
                                                  , ( !O
                                                    .       !nsub
                                                          : (     ( (?,?)
                                                                    ?
                                                                  )
                                                                * ?
                                                              : ?gold
                                                            . ?
                                                            )
                                                        &   map
                                                          $ ( ( 
                                                              =   fea vals
                                                                .     !arg
                                                                    : (?fea,?vals)
                                                                  & ( !fea
                                                                    ,   rpl
                                                                      $ ( !vals
                                                                        . !fea
                                                                        . !gold
                                                                        )
                                                                    )
                                                              )
                                                            . !I
                                                            )
                                                      | !I
                                                    . !nsub
                                                    )
                                                  )
                                                )
                                            | 0
                                            )
                                        |     SubspecHarmonize$(!sub.!toolSignatures)
                                            : ?nsub
                                          & (   !nsub:(0.?)
                                              & 0
                                            | (!prog,(!o.!i.!nsub))
                                            )
                                        )
                                    | "Input Resource"&!Sources
                                    )
                              )
                            & !arg:(?pipe.?toolSignatures):?savearg
                            & "pipe is a pipe line.

                                 toolSignatures is a product of tool names with exponents.
                                 Each exponent is a term or sum of terms.
                                 A term is a dotted pair (output features.input features).
                                 A term can have a numeral factor."
                            & (     !pipe
                                  : (((?,?) ?)*?:?Requireds.?Sources)
                                & "If single input, Requireds is e.g

                                    (ambig,una)
                                    (app,nrm)
                                    (facet,(lem*mrf*pos^Uni*stx.OnE))
                                    (format,txtann)
                                    (lang,da)
                                    (period,c21)
                                    (pres,nml)

                                  Multiple input e.g.
                                    ( (ambig,una)
                                      (app,nrm)
                                      (facet,sent)
                                      (format,txtann)
                                      (lang,da)
                                      (period,c21)
                                      (pres,nml)
                                    )
                                  * ( (ambig,una)
                                      (app,nrm)
                                      (facet,tok^simple)
                                      (format,txtann)
                                      (lang,da)
                                      (period,c21)
                                      (pres,nml)
                                    )
                                  "
                                & walkTree$(!Sources.!toolSignatures):?nSources
                                & ( !nSources:0&(0.0)
                                  |   1:?h
                                    & "Check that the updated outputs from the tools still match the requirements.
                                       If they do, also update the requirements.
                                       Otherwise, return 0."
                                    &   whl
                                      ' ( !Requireds:%?aRequired*?Requireds
                                        & "aRequired is input expected to come from one tool (or one input resource)."
                                        & (     !nSources
                                              : (   ?
                                                  * ( ?
                                                    , (   ?O
                                                        &     containedBy
                                                            $ (!aRequired.!O)
                                                          : ?h1
                                                      . ?
                                                      )
                                                    )
                                                  * ?
                                                |   ?
                                                  * ( `%?O
                                                    & ~(!O:(?,(?.?)))
                                                    &   containedBy$(!aRequired.!O)
                                                      : ?h1
                                                    )
                                                  * ?
                                                )
                                            & !h*!h1:?h
                                          | 0:?h
                                          )
                                        & !h:~@
                                        )
                                    & (!h.!nSources)
                                  )
                              | "input resource"&!pipe
                              )
                        )
                      & "signatures: create a product of tool names with
                         exponents that descibe output and input features, as
                         dotted pairs.

                         clashing: check whether a tool exists with two
                         signatures with a common feature that would be equal
                         if subspecifications were stripped off.
                        "
                      & ( signatures
                        =   A prog o i sub
                          .     !arg:(((?,?) ?)*?.?arg)
                              & signatures$!arg
                            |   !arg:%?A*%?arg
                              & signatures$!A*signatures$!arg
                            |   !arg:(%@?prog,(?o.?i.?sub))
                              & !prog^(!o.!i)*signatures$!sub
                            | 1
                        )
                      & ( copySpecs
                        =   Ao Ai Bo Bi
                          .   !arg:((?Ao.?Ai),(?Bo.?Bi))
                            & (supplement$(!Ao.!Bo).supplement$(!Ai.!Bi))
                        )
                      & ( mergeOIbundlesWherePossible
                        =   oi1 oi2 Z
                          .       !arg
                                : ((?.?):?oi1) ((?.?):?oi2) ?Z
                              &   mergeOIbundlesWherePossible
                                $ (copySpecs$(!oi2,copySpecs$(!oi1,!oi2)) !Z)
                            | !arg
                        )
                      & ( unifySignaturesAtSpecLevel
                        =   tool A sigs nsigs
                          .       !arg
                                : ?A*%@?tool^(?*(% %)*?:?sigs)*?arg
                              & 1:?nsigs
                              &   mop
                                $ ( ( 
                                    =   
                                      .     !nsigs
                                          * (   !arg:% %
                                              & mergeOIbundlesWherePossible$!arg
                                            | !arg
                                            )
                                        : ?nsigs
                                    )
                                  . !sigs
                                  . (=*)
                                  )
                              & !A*!tool^!nsigs*unifySignaturesAtSpecLevel$!arg
                            | !arg
                        )
                      & ( unspec
                        =   A B
                          .   !arg:%@?A^%&!A
                            |   !arg:?A_?B
                              & (unspec$!A)_(unspec$!B)
                            | !arg
                        )
                      & ( separate
                        =   A a B sims nonsims
                          .   !arg:0
                            |   !arg:#*((?.?):%?A)+?arg
                              & unspec$!A:?a
                              & !A:?sims
                              & 0:?nonsims
                              &   whl
                                ' ( !arg:#*((?.?):%?B)+?arg
                                  & (   unspec$!B:!a
                                      & !sims !B:?sims
                                    | !nonsims+!B:?nonsims
                                    )
                                  )
                              &   (!sims:% %|0)
                                + separate$!nonsims
                        )
                      & ( signatureDotSep
                        =   tool V L v
                          .   1:?L
                            &   whl
                              ' ( !arg:%@?tool^?V*?arg
                                & separate$!V:?V
                                & "Note that each v can be a list with two or more elements, separated by space: Those with equal signatures, apart from subspecs."
                                &   whl
                                  ' ( !V:%?v+?V
                                    & !L*(!tool.!v):?L
                                    )
                                )
                            & !L
                        )
                      & ( clsh
                        =   A B F vs a e f
                          .   !arg:(?A.?B)
                            &   !A
                              :   ?
                                  (?F,?vs)
                                  ( ?
                                  &   !B
                                    :   ?
                                        ( !F
                                        ,   ?
                                          * `%@?a^%?e
                                          * ( ?
                                            & !vs:?*!a^%?f*?
                                            & !e*!f:%*%
                                            )
                                        )
                                        ?
                                  )
                        )
                      & ( Clashing
                        =   i o I O
                          .   !arg
                            :   ?
                              * ( ?
                                .   ?
                                    (?i.?o)
                                    ?
                                    (?I.?O)
                                    ( ?
                                    & (clsh$(!i.!I)|clsh$(!o.!O))
                                    )
                                )
                              * ?
                        )
                      & 1:?sig
                      &   mop
                        $ ( ( 
                            =   
                              .     !arg:?^(%+%)
                                  & !sig*!arg:?sig
                                | 
                            )
                          . signatures$!arg
                          . (=*)
                          )
                      & "sig is a product of tool IDs that occur multiple times with different parameters.
                        Each ID has an exponent
                        that is the sum of all (O.I) specs occuring in the
                        current computed workflow. Here, O and I are feature
                        bundles."
                      & signatureDotSep$!sig:?Nsig
                      & "In Nsig, parameter sets that are equal if all subspecs are ignored,
                         are combined in space separated lists "
                      & "Discard solutions that contain steps that are
                        equal (or at least compatible) at the un-
                        subspecified level, but clash at the spec level.
                        Such solutions are not 'wrong', but unlikely what
                        the user wants."
                      & "Clashing example:
                        ...
                        * ( RTFread
                        .   (   (app,nrm)
                            (facet,seg*tok^PT)
                            (format,plainD)
                            .   (app,ocr)
                            (facet,txt)
                            (format,flat)
                            )
                            (   (app,nrm)
                            (facet,seg*tok^simple)
                            (format,plainD)
                            .   (app,ocr)
                            (facet,txt)
                            (format,flat)
                            )
                        )
                        * ...


                        Not Clashing example:

                        ...
                        * ( RTFread
                        .   (   (app,nrm)
                            (facet,seg*tok^PT)
                            (format,plainD)
                            .   (app,ocr)
                            (facet,txt)
                            (format,flat)
                            )
                            (   (app,nrm)
                            (facet,seg*tok)
                            (format,plainD)
                            .   (app,ocr)
                            (facet,txt)
                            (format,flat)
                            )
                        )
                        * ...
                        "
                      & ( Clashing$!Nsig&0
                        |   unifySignaturesAtSpecLevel$!Nsig:?nsig
                          & "nsig is a product of maximally compressed
                       signatures. If two (O.I) feature bundle pairs can
                       enrich each other without clashing, then those
                       pairs are merged into one. These enriched (O.I)
                       pairs do nowhere occur in the current workflow, so
                       now we substitute the rich O.I pairs for the
                       original ones."
                          & "Nsig only contains ambiguous signatures: those that need unification."
                          & ( trySignatures
                            =   Feats tool f pAth nsig,pipes R goodpipes
                              .   !arg:(?pAth.?nsig.?pipes.?goodpipes)
                                & (   !nsig:(%?tool.%?Feats)*?nsig
                                    & "Again, Feats (v above) can be a list!"
                                    &   whl
                                      ' ( !Feats:%?f ?Feats
                                        &     trySignatures
                                            $ (!pAth*(!tool.!f).!nsig.!pipes.!goodpipes)
                                          : ?goodpipes
                                        )
                                    & !goodpipes
                                  |     ( !pAth:1&!pipes
                                        | SubspecHarmonize$(!pipes.!pAth):(~0.?)
                                        )
                                      : ?R
                                    & !goodpipes+!R
                                  | !goodpipes
                                  )
                            )
                          & "Make pipes more complete subspec-wise.
                       Either each tool is used in exactly one way, or the
                       different ways ALL differ more than only at the
                       subspec level."
                          & trySignatures$(1.!Nsig.!arg.0)
                        )
                  )
                & ( filter
                  =   pipes reqtool o pipe1 has S
                    .   !arg:(?pipes.?reqtool)
                      &     
                          ' ( S
                            .   !arg:?*($reqtool,?)*?
                              |   !arg:?*(?,(?.?.?.?S))*?arg
                                & (has$!S|has$!arg)
                            )
                        : (=?has)
                      &   map
                        $ ( ( 
                            =   
                              .   !arg:(?o.?pipe1)
                                & ( has$!pipe1&!arg
                                  | 
                                  )
                            )
                          . !pipes
                          )
                  )
                & ( percolateForgottenFeatures
                  =     pipes F NN
                      , harmonizeSubspecsOnSimilarFeatures
                      , Results pipe1 pipe2 pipe3 pipe4
                      , fromMethods fromInputTowardOutput fromToolOrSource
                      , toMethods fromOutputTowardInput toTool
                      , UpdateResultzFromMethods oUts Union
                      , validateInputsForEachTool sig
                      , Mem Results1
                    .   "TODO sig is not meaningful if we can have multiple OnE complexes
                   (a*b*c.OnE)*d*(a*f*g.OnE)*z
                   One of the problems is 'a' occuring two places.
                   Better to keep OnE!
                  "
                      & ( sig
                        =   a
                          .     !arg:%?a*?arg
                              &   ( !a:(?a.OnE)&sig$!a
                                  | !a:%@?a^?&!a
                                  )
                                * sig$!arg
                            | 1
                        )
                      & ( UpdateResultzFromMethods
                        =     results methods nres result A method
                            , Sig SR SM B loop
                            , f v e E VS NVS
                          .   ( Sig
                              =   
                                .   map
                                  $ ( ( 
                                      =   
                                        .     !arg:(sml,nsl)
                                            & 
                                          |   !arg:(?f,?v)
                                            & (!f,sig$!v)
                                      )
                                    . !arg
                                    )
                              )
                            & !arg:(?results.?methods)
                            & "'results' can have 'OnE' groups. 'methods' is at least as rich as 'results', and can e.g. have 'sml' features"
                            & 1:?nres
                            &   whl
                              ' ( !results:%?result*?results
                                & Sig$!result:?SR
                                & "'SR' is (feature,value*value*...) (feature,value*value*...) ...,
                                   also if (some of) the values are in a 'OnE' group in 'result'."
                                &     map
                                    $ ( ( 
                                        =   
                                          .     !arg:(?f,(?v.OnE))
                                              & (!f,!v)
                                            | !arg
                                        )
                                      . !result
                                      )
                                  : ?B
                                &     (   !methods:?A*!B*?methods
                                        & !A*!methods:?methods
                                        & !result
                                      |   "Each {feature,value} pair in the SR (signature of the result) must
                                                     either be (smell,new smell)
                                                     or occur in the same factor of SM (the signature of one of the methods).
                                           So we must find a method for which we can prove that there are
                                               no features different from (sml,nsl) in SR
                                               that are not represented in the signature of that method SM.
                                           "
                                        &   !methods
                                          :   ?A
                                            * `%( ?method
                                                & Sig$!method:?SM
                                                & !( 
                                                   ' ( $SR
                                                     : ~( ?
                                                          `[%($SM:~(? !sjt ?))
                                                          ?
                                                        )
                                                     )
                                                   )
                                                )
                                            * ?methods
                                        & !A*!methods:?methods
                                        &     
                                            ' ( whl
                                              ' ( !VS:%@?v^?e*?VS
                                                &     !NVS
                                                    *   !v
                                                      ^ (   !e:1
                                                          & (     $method
                                                                :   ?
                                                                    ( !f
                                                                    , ?*!v^?E*?
                                                                    )
                                                                    ?
                                                              & !E
                                                            | 1
                                                            )
                                                        | !e
                                                        )
                                                  : ?NVS
                                                )
                                              )
                                          : (=?loop)
                                        &   map
                                          $ ( ( 
                                              =   
                                                .   !arg:(?f,?v)
                                                  & ( !f
                                                    ,     !v:(?VS.OnE)
                                                        & 1:?NVS
                                                        & !loop
                                                        & (!NVS.OnE)
                                                      |   !v:@?v^?e
                                                        &   !v
                                                          ^ (   !e:1
                                                              & (     !method
                                                                    :   ?
                                                                        ( !f
                                                                        ,   ?
                                                                          * !v^?E
                                                                          * ?
                                                                        )
                                                                        ?
                                                                  & !E
                                                                | 1
                                                                )
                                                            | !e
                                                            )
                                                    )
                                              )
                                            . !result
                                            )
                                      | !result
                                      )
                                    * !nres
                                  : ?nres
                                )
                            & !nres
                        )
                      & "harmonizeSubspecsOnSimilarFeatures:
                         enrich first argument using second argument,
                         enrich and update second argumemt using first argument.
                         In the output, the second argument is hoisted to the level of the first.
                         This function is used in both directions, downstream and upstream.
                         "
                      & ( harmonizeSubspecsOnSimilarFeatures
                        =   
                          .   ( !Mem:? (!arg.?arg) ?
                              |   (!arg.supplement$!arg:?arg) !Mem
                                : ?Mem
                              )
                            & !arg
                        )
                      & ( oUts
                        =   R F X Y V Z
                          .   1:?R
                            &   whl
                              ' (   !arg
                                  :   ( (?,(?F.?))
                                      | (?,?) ?:?F
                                      )
                                    * ?arg
                                & !F*!R:?R
                                )
                            & "Check that only one feature can have conflicting values."
                            & (   !R:%?X*%?Y
                                &   !X
                                  :   ?
                                      (?F,?V)
                                      ( ?Z
                                      & !Y:?*(? (!F,~!V) ?)*?
                                      &   !Z
                                        :   ?
                                            (?F,?V)
                                            ( ?
                                            &   !Y
                                              : ?*(? (!F,~!V) ?)*?
                                            )
                                      )
                                & 0:?R
                              | 
                              )
                            & !R
                        )
                      & "Union: result includes all features of the bundles combined.
                         The result of 'Union' can be percolated downstream. (Towards the output.)"
                      & ( Union
                        =   x y f e g vs ys A Z
                          .   !arg:(?x.?y)
                            &   sort
                              $ (   map
                                  $ ( ( 
                                      =   
                                        .   !arg:(?f,?vs)
                                          & (   !y:?A (!f,?ys) ?Z
                                              & !A !Z:?y
                                              & 1:?g
                                              &   mop
                                                $ ( ( 
                                                    =   
                                                      .     !g
                                                          * (     !arg
                                                                :   ?arg
                                                                  ^ ( #%*?e
                                                                    | 1+?e
                                                                    )
                                                              & !arg^!e
                                                            | !arg
                                                            )
                                                        : ?g
                                                    )
                                                  . !vs*!ys
                                                  . (=*)
                                                  )
                                              & (   !g:1
                                                  & 
                                                | (!f,!g)
                                                )
                                            | !arg
                                            )
                                      )
                                    . !x
                                    )
                                  !y
                                )
                        )
                      & ( Results
                        =   L R OF RF
                          .     !arg:(%?L*%?R.?OF)
                              & Results$(!R.!OF):(?R.?RF)
                              & harmonizeSubspecsOnSimilarFeatures$(!L.!OF):?L
                              & (!L*!R.Union$(!RF.!L))
                            | (harmonizeSubspecsOnSimilarFeatures$!arg:?L.!L)
                        )
                      & ( Results1
                        =   L R OF
                          .     !arg:(%?L*%?R.?OF)
                              & Results1$(!R.!OF):?R
                              & harmonizeSubspecsOnSimilarFeatures$(!L.!OF):?L
                              & !L*!R
                            | harmonizeSubspecsOnSimilarFeatures$!arg
                        )
                      & ( fromToolOrSource
                        =   OF LF RF tool meta output sub A F V Z L
                          .     !arg:(?tool,(?output.?meta.?sub).?OF)
                              & fromInputTowardOutput$(!sub.!OF):(?sub.?RF)
                              & ( !sub:0&(0.0)
                                |     harmonizeSubspecsOnSimilarFeatures$(!output.!RF)
                                    : ?output
                                    : ?LF
                                  & (   !output:?A (?F,(?V.OnE)) ?Z
                                      & !A (!F,!V) !Z:?output
                                    | 
                                    )
                                  & ( !tool,(!output.supplement$(!meta.!RF).!sub)
                                    . !LF
                                    )
                                )
                            | (harmonizeSubspecsOnSimilarFeatures$!arg:?L.!L)
                        )
                      & ( fromMethods
                        =   L R OF LF RF sLF sRF
                          .   !arg:(?arg.?OF)
                            & (   !arg:%?L*%?R
                                & fromMethods$(!R.!OF):(?R.?RF)
                                & ( !R:0&(0.0)
                                  |   fromToolOrSource$(!L.!OF):(?L.?LF)
                                    & (   ( !L:0
                                          |     !RF
                                              : ? (sml,?sRF) ?
                                            &   !LF
                                              : ? (sml,?sLF) ?
                                            & ~(!sRF:!sLF)
                                          )
                                        & (0.0)
                                      | (!L*!R.Union$(!RF.!LF))
                                      )
                                  )
                              | fromToolOrSource$(!arg.!OF)
                              )
                        )
                      & ( fromInputTowardOutput
                        =   results methods OF NF
                          .     !arg:((?results.?methods).?OF)
                              & fromMethods$(!methods.!OF):(?methods.?NF)
                              & (   ( !methods:0
                                    | oUts$!methods:?OF:0
                                    )
                                  & (0.0)
                                |   UpdateResultzFromMethods$(!results.!OF):?results
                                  & ((!results.!methods).!NF)
                                )
                            | Results$!arg
                        )
                      & ( toTool
                        =     OF tool meta output sub
                            , a A f z Z x y
                          .   !arg:(?arg.?OF)
                            & (   !arg:(?tool,(?output.?meta.?sub))
                                &   harmonizeSubspecsOnSimilarFeatures$(!output.!OF)
                                  : ?output
                                & fromOutputTowardInput$(!sub.!output):?sub
                                & supplement$(!meta.!output):?meta
                                & (     !meta
                                      : ?a (?f,?A*(?x.OnE)*?Z) ?z
                                    &   !sub
                                      : ( ?*(!a (!f,?*(?y.OnE)*?) !z)*?
                                        . ?
                                        )
                                    & !x*!y:?y
                                    & 1:?x
                                    &   mop
                                      $ ( ( 
                                          =   e
                                            .     !x
                                                * (     !arg
                                                      :   ?arg
                                                        ^ ( #%*?e
                                                          | 1+?e
                                                          )
                                                    & !arg^!e
                                                  | !arg
                                                  )
                                              : ?x
                                          )
                                        . !y
                                        . (=*)
                                        )
                                    &   !a (!f,!A*(!x.OnE)*!Z) !z
                                      : ?meta
                                  | 
                                  )
                                & (!tool,(!output.!meta.!sub))
                              | harmonizeSubspecsOnSimilarFeatures$(!arg.!OF)
                              )
                        )
                      & ( toMethods
                        =   L R OF
                          .   !arg:(?arg.?OF)
                            & (   !arg:%?L*%?R
                                & toMethods$(!R.!OF):?R
                                & toTool$(!L.!OF):?L
                                & !L*!R
                              | toTool$(!arg.!OF)
                              )
                        )
                      & ( fromOutputTowardInput
                        =   results methods OF NF
                          .   !arg:(?arg.?OF)
                            & (   !arg:(?results.?methods)
                                & Results$(!results.!OF):(?results.?NF)
                                & (!results.toMethods$(!methods.!NF))
                              | Results1$(!arg.!OF)
                              )
                        )
                      & ( validateInputsForEachTool
                        =   recr
                          .   "Every input spec shall be identical to an output
                   spec of an immediately preceding tool."
                            & ( recr
                              =   a b A aa t
                                .     !arg:%?a*%?b
                                    & recr$!a
                                    & recr$!b
                                  | !arg:(?t,(?.?.(?,?) ?))
                                  | !arg:(?,~(?.?)) ?
                                  |   !arg:(?t,(?.?.?a:?aa.?b))
                                    & recr$!b
                                    &   whl
                                      ' ( !a
                                        :   ( %?A
                                            &     map
                                                $ ( ( 
                                                    =   f vs v nvs
                                                      .   !arg:(?f,?vs)
                                                        & 1:?nvs
                                                        &   whl
                                                          ' ( !vs:%?v*?vs
                                                            & (   !v
                                                                : (?v.OnE)
                                                              | 
                                                              )
                                                            &   !nvs*!v
                                                              : ?nvs
                                                            )
                                                        & (!f,!nvs)
                                                    )
                                                  . !A
                                                  )
                                              : ?A
                                            &   !b
                                              : ( ?*(?,(!A.?))*?
                                                | ?*!A*?
                                                )
                                            )
                                          * ?a
                                        )
                                    & ( !a:1
                                      | 
                                      |   
                                        &   log
                                          $ ( "XXXXXXXXX In feature bundle"
                                              !A
                                              str$(\n "of tool")
                                              !t
                                              str$(\n "with input")
                                              !aa
                                                str
                                              $ (\n "mismatch with outputs of preceding tools")
                                              oUts$!b
                                              "arg (suppressed)"
                                            )
                                        & !arg:?CULPRIT
                                        & lst$(CULPRIT,path$CULPRIT,RAW,NEW)
                                        & ~
                                      )
                              )
                            & !arg:(?.?arg)
                            & recr$!arg
                        )
                      & :?pipes
                      & :?Mem
                      & !arg:? [?NN
                      &   map
                        $ ( ( 
                            =   
                              .   !arg:%?pipe1
                                & (   @(!NN:? 0)
                                    & log$(NN !NN)
                                  | 
                                  )
                                & -1+!NN:?NN
                                & !DownStream:?Mem
                                & fromInputTowardOutput$(!pipe1.):(?pipe2.?F)
                                & !Mem:?DownStream
                                & ( !pipe2:0
                                  |   !UpStream:?Mem
                                    & fromOutputTowardInput$(!pipe2.!F):?pipe3
                                    & !Mem:?UpStream
                                    & (   !pipe3:0
                                        & log$ZEEROOED
                                      |   validateInputsForEachTool$!pipe3
                                        & (     wantThis$!pipe3
                                              : ~0
                                              : ?pipe4
                                            & !pipe4 !pipes:?pipes
                                          | 
                                          )
                                      | log$INVALID
                                      )
                                  )
                            )
                          . !arg
                          )
                      & !pipes
                  )
                & !arg:(?pipes.?parms.?sources)
                & log$prunePipes
                & 0:?calls
                & :?newpipes
                & 0:?Npipes:?NIncarnationPipes
                & :?DownStream:?UpStream
                &   whl
                  ' ( !calls:<567890
                    & !pipes:((?.?):?incarnationpipes)+?pipes
                    & "incarnationpipes is (<(user or declared tool) provided output specs> . <sum of unambiguous trees>)"
                    & "TODO 20190917: do not have workflows with two or more tools that do exactly the same thing.
                Strategy:
                (1) search for a sum.
                (2) Iterate over that sum.
                (3) For each term, produce a (possibly still ambiguous) workflow by projecting each sum that contains that
                    term on that term. So if a sum contains the current term, ignore all terms but the current term.
                (4) Repeat this for each new workflow.
                (5) The result is a list of unambiguous workflows in which no task is performed by two different tools."
                    & log$selectCommonTracks
                    & selectCommonTracks$!incarnationpipes:?As
                    & log$selectCommonTracksDONE
                    & !As:?+[?NIncarnationPipes
                    & !NIncarnationPipes+!Npipes:?Npipes
                    & !Npipes:~>!MAXPIPES
                    & log$unfoldTree
                    &     mop
                        $ ( ( 
                            =   
                              .   !arg:#*((?.?):?arg)
                                & !arg
                            )
                          .   list2sum
                            $ ( mop
                              $ ( ( 
                                  =   
                                    .   mop
                                      $ ( ( 
                                          =   
                                            .   !arg:(?.?arg)
                                              & !arg
                                          )
                                        . unfoldTree$(1.!arg)
                                        . (=+)
                                        )
                                  )
                                . !As
                                . (=+)
                                )
                              )
                          . (=+)
                          )
                      : ?pipesN
                    & "The 1 is the initial stop list, which is formed as a product."
                    & "pipesN is (<user provided output specs> . <unfolded tree>) + ..."
                    & !pipesN:? [?NNN
                    & (   (   !parms:? (reqtool.?reqtool) ?
                            & !reqtool:~
                            & filter$(!pipesN.!reqtool):?pipesN
                          | 0:?reqtool
                          )
                        & !parms:? (fintool.?fintool) ?
                        & !fintool:~:~!reqtool
                        & filter$(!pipesN.!fintool):?pipesN
                      | 
                      )
                    & percolateForgottenFeatures$!pipesN !newpipes:?newpipes
                    & log$percolateForgottenFeaturesDONE
                    )
                & (removeNumFactors$(list2sum$!newpipes).!Npipes)
            )
          & :?msg
          & (   ( !recentTasks
                | readTable$recentTasks
                | :?recentTasks&saveTable$recentTasks
                )
              & log$("look in recentTasks for" !userInput)
              &   !recentTasks
                : ?A (!userInput.?reorderedworkflowlist.?topologicalOrderedTools) ?Z
              &   (!userInput.!reorderedworkflowlist.!topologicalOrderedTools) !A !Z
                : ?recentTasks
              & saveTable$recentTasks
              & log$(windFW !nth)
              & windFW$(!reorderedworkflowlist.!nth):?reorderedworkflowlist
              & log$woundFW
              & (!userInput.(!reorderedworkflowlist.!topologicalOrderedTools).allRight.)
            |   log$"Not in recentTasks"
              & "memoizedTrees: global variable"
              & (!memoizedTrees|:?memoizedTrees)
              & 0:?indent:?calls
              & (   log$("Look in meMOizedTrees for" !userInput)
                  & !userInput:(?uiin.?uiou.?reqtool,?fintool.?superset)
                  & "o1o The userInput may be more strict than what is found in
                     memoized trees. So each output feature in a memoized tree
                     must occur in the userInput's output specs."
                  & ( o2o
                    =   FP nFP ou wf uou uiou superset
                      .   !arg:(?FP.?uiou.?superset)
                        & "Remember: o-SUpPLEMENT is the list of P features e.g. Pfacet,
                           where P features are those that the user specifies when zooming
                           in. P features do not allow being a subset of a larger set of
                           compound values; they must match exactly, except for subspecs.
                           o-SUpPLEMENT  (facet,lem*mrf*ner*pos*seg*stx*tok)"
                        & 0:?nFP
                        &   whl
                          ' ( !FP:(?ou.?wf)+?FP
                            & "need  (ambig,una)  (app,nrm)  (facet,                 stx         )  (format,conll    )  (lang,la)               (pres,nml)
                               have  (ambig,una)  (app,nrm)  (facet,(lem*mrf*pos*seg*stx*tok.OnE))  (format,conll^clU)  (lang,la)  (period,c1)  (pres,nml)

                               need  (ambig,una)  (app,nrm)  (facet, lem*mrf*ner*pos    *seg*stx*tok)       (format,conll    )  (lang,da)  (period,c21)  (pres,nml)
                               have  (ambig,una)  (app,nrm)  (facet,(lem*mrf*ner*pos^Uni*seg*stx*tok.OnE))  (format,conll^clU)  (lang,da)  (period,c21)  (pres,nml)
                               ZYX  (facet,(lem*mrf*ner*pos^Uni*seg*stx*tok.OnE))
                              "
                            & !uiou:?uou
                            & (       map
                                    $ ( ( 
                                        =     ft us nus u Vs
                                            , A Z a z V
                                          .   !arg:(?ft,?V)
                                            & (     !uou
                                                  : ?a (!ft,?us) ?z
                                                & "The user has specified this recorded feature.
                                                   Check that all that the user wants of this
                                                   feature is also satisfied by the record."
                                                & !a !z:?uou
                                                & (   !V:!us^?
                                                    & "MATCH (modulo subspec, which the user cannot specify)"
                                                    & 
                                                  |   !V:(?Vs.OnE)
                                                    &   whl
                                                      ' ( !us:%?u*?nus
                                                        & !Vs:?a*!u^?*?z
                                                        & !a*!z:?Vs
                                                        & !nus:?us
                                                        )
                                                    & !us:1
                                                    & "all user specs were found. All good."
                                                    & (     !o-SUpPLEMENT
                                                          : ~(? (!ft,?) ?)
                                                        & "User says nothing about feature "
                                                        &   !superset
                                                          : ? !ft ?
                                                        & "User has marked that compounder outputs are ok for feature "
                                                      |   !Vs:1
                                                        & "Exact match between compound feature values.
                                                           No need to supplement this feature with a superset,
                                                           (WHO DECIDES THAT?) so remove it if it is there."
                                                        & (     !superset
                                                              : ?A !ft ?Z
                                                            &   !A !Z
                                                              : ?superset
                                                          | 
                                                          )
                                                      )
                                                    & 
                                                  | !arg
                                                  )
                                              |   "The user didn't say anything about this feature. Then it must be OK.
                                                   (Is this branch at all reachable? We said that
                                                   'all recorded specs must also be user specs'.
                                                   Yes: before we talked about the user specs that had been recorded,
                                                   but here we look at the actual specs of each of the recorded workflows.
                                                   The latter are in general much more complete than the recorded user
                                                   specs and can easily contain features that users never gave a thought.)"
                                                & 
                                              )
                                        )
                                      . !ou
                                      )
                                  : 
                                &     !nFP
                                    + ( !uou:&(!ou.!wf)
                                      |   "Not all user specs were found in workflow output.
                                           Find them in the output of the last tool in the workflow.
                                           (An example would be nice.)"
                                        & (sort$(!ou !uou).furtherCheck$(!wf.!uou))
                                      )
                                  : ?nFP
                              | 
                              )
                            )
                        & !nFP:~0
                    )
                  &   !memoizedTrees
                    :   ?
                        (   (!uiin.?ou.?restr,?lastt.?supers)
                          & "We have something that matches the input knowns.
                             Now check whether all output specs in this record correspond to a user spec.
                             So there may be fewer recorded specs than user specs, but all recorded specs
                             must also be user specs.
                             (NOT)FISHY. The following says that if facet x is recorded and also specified by the user,
                             then all values (factors) in the record must accur in the user spec. What if the user
                             spec is lem*pos*tok and the record has only lem*tok? Shouldn't that be the other way
                             around?
                             No. The user who asked for lem*tok and allowed compound outputs containing lem and tok
                             got many more workflows to choose from, also the ones that contain lem and pos and tok.
                             "
                          &     map
                              $ ( ( 
                                  =   vs f nvs V v
                                    .     !uiou:? !arg ?
                                        & 
                                      |   !arg:(?f,?vs)
                                        & !uiou:? (!f,?V) ?
                                        &   whl
                                          ' ( !vs:%?v*?nvs
                                            & !V:?*!v*?
                                            & !nvs:?vs
                                            )
                                        & !vs:1
                                        & 
                                      | !arg
                                  )
                                . !ou
                                )
                            : 
                          &   (!restr,!lastt.!supers)
                            : ( !reqtool,!fintool
                              .   !superset
                                |   ?
                                  & !superset:
                                  & !ou:~
                              )
                        .   ?FP
                          & log$MEMOIZED!
                          & "o2o Now we have a set of memoized trees based on
                             weaker requirements than the current userInput
                             output specs. So we have to filter away all
                             memoized trees that conflict with the current
                             specs."
                          & o2o$(!FP.!uiou.!superset):?nFP
                        )
                        ?
                  & log$SUCCESS
                  & "o3o Probably not all user features ('uiou') where present
                     in the output specs of the memoized workflows. So we need
                     to have a closer look at the workflows actually computed
                     and filter away the workflows that do not comply with the
                     user requirements formulated in the features that were not
                     represented in the output specs."
                  &       map
                        $ ( ( 
                            =   A Z f v V
                              .   !arg:(?f,?v)
                                & ( !f
                                  ,       !o-SUpPLEMENT
                                        : ?A (!f,~:?V) ?Z
                                      & !A !Z:?o-SUpPLEMENT
                                      & !V
                                    | !v
                                  )
                            )
                          . !o
                          )
                        !o-SUpPLEMENT
                    : ?o
                  &     ((!i.!o.!reqtool,!fintool.!superset).!nFP)
                        !memoizedTrees
                    : ?memoizedTrees
                  & !nFP:?FP
                |   "The next call fails if no workflows found."
                  & (   !userInput:(?A.?B (sml,?) ?Y.?Z)
                      & (!A.!B !Y.!Z):?userInput
                    | 
                    )
                  & log$"Call fp"
                  & log$(userInput !userInput)
                  & fp$!userInput:(?FP.?msg)
                  & log$(msg !msg)
                  & !FP:~#
                  & !msg:
                  & log$"Calling fp success"
                  & "prunePipes fails if tooComplex"
                  & (   !FP
                      : ((?,?) ?|~(?+(?.?)+?))
                    |   prunePipes$(!FP.!parms.!i):(?FP.?Npipes)
                      & !Npipes:~>!MAXPIPES
                      & (   !FP:~0
                          & log$"Calling prunePipes success"
                          & (!userInput.!FP) !memoizedTrees:?memoizedTrees
                          & ( !memoizedTrees:?memoizedTrees [100 ?
                            | 
                            )
                        |   0:?Npipes
                          & log$"all pipes were pruned."
                          & ~
                        )
                    )
                )
              & ( !userInput
                .       !FP
                      : ((?,?) ?|~(?+(?.?)+?))
                    & ((!FP.).triviallyFulfilled.)
                  |   !FP:?+[>!MAXPIPES
                    & !FP:?+[?NNNN
                    & log$(tooMany !NNNN)
                    & ((!FP.).tooMany.)
                  |   ( !reqtool:
                      |   !FP
                        : ?+(?.?fP&haz$(!fP.!reqtool))+?
                      )
                    & (   !nth:
                        & "The returned structure is still unpruned and would
                           also be very large in serialized form. Pruning can
                           take a long time, however, so we first let the user
                           have the chance to refine the goal by looking which
                           feature values are represented in the computed
                           workflows."
                        & ((!FP.!arg).workflowsFound.)
                      |   "This is unusual. If the user chooses a specific
                           workflow, it will normally not have to be
                           recomputed. Instead, it will be found in
                           recentTasks."
                        & log$UNUSUAL!
                        & (     makeWorkflowsSequential$!FP
                              : (?reorderedworkflowlist.?topologicalOrderedTools)
                            & allRight:?returnCode
                          |   0:?reorderedworkflowlist
                            & :?topologicalOrderedTools
                            & log$(makeWorkflowsSequential tooComplex)
                            & tooComplex:?returnCode
                          )
                        & !reorderedworkflowlist:?+[?nr
                        & log$(UNUSUALsaveTask !userInput length !nr)
                        & saveTask$(!userInput.!reorderedworkflowlist.!topologicalOrderedTools)
                        & windFW$(!reorderedworkflowlist.!nth):?reorderedworkflowlist
                        & ((!reorderedworkflowlist.!topologicalOrderedTools).!returnCode.)
                      )
                  | ((!FP.).onlyWithoutRestriction.)
                )
            |   !msg:~
              & (!userInput.(0.).notFulfillable.!msg)
            |   !FP:#:<0
              & log$(!FP "!FP:#:<0 gives tooMany")
              & (!userInput.(0.).tooMany.)
            |   !Npipes:0
              & log$(NOTFULFILLABLE FP !FP)
              & (!userInput.(0.).notFulfillable.noPathReason$!userInput)
            |   log$(Npipes !Npipes ">" !MAXPIPES)
              & (!userInput.(0.).tooMany.)
            )
      )
      ( composeValueString
      =   valstr v s vals specs
        .   :?valstr
          & 0:?specs
          & !arg:?vals
          &   whl
            ' ( !vals:%@?v^?s*?vals
              & !valstr "_" !v:?valstr
              & ( !s:(|1)
                | !specs+(str$("__" !v "_" !s).0):?specs
                )
              )
          & (str$!valstr.!specs)
      )
      " convert2URLs receives a list of job steps, each step describing the
step's tool, its output and its inputs. The inputs not only tell the type of
each input, but also which step produced that input. The first step's input is
taken from the Items list. Following steps can, but need not take an item in
the Items list as input. Step descriptions in the JobStack can look like this:
  ( step1                                 STEP
  . pdf2htmlEX                            TOOL
  .   (facet,txt^ocr)                     ------
      (format,html)
      (lang,da)                           INPUT
      (pres,nml)                          -----
  .   (facet,txt)                         ------
      (format,pdf)
      (lang,da)                           OUTPUT
      (pres,nml)                          ------
  )
...
  ( step8                                  STEP
  . CST-Lem                                TOOL
  .   (facet,lem)                          ------
      (format,flat)
      (lang,da)                            INPUT
      (pres,alf)                           ------
  .   (pres,nml)                           ------
      (lang,da)
      (format,txtann)                      OUTPUT
      (facet,(pos^Par.step7))
      (facet,(tok.step5))                  ------
  )
"
      ( convert2URLs
      =     requestString Items items file files newJobs feats
          , base post2 val vals JobStack Val item In
          , jobIDoffset A M Z OffSet addOutputsToRequestString
          , extension ID forceFeed jobNr jobID maxjobID
          , Short DiscerningFeature getDisFe
          , DATE Tool URL dep discerningFeature
          , feat in ou spec v nfiles fileTerm notIncompatible
          , inputs moreinputs firstinput other fh oh
          , compact compatible simpleInput someinputs
          , getDepsAndAddInputsToRequestString
          , distillInputsFromRequestString dryORrun
        .   "getDisFe establishes the feature that the given tool has to look
             for among the input Items, if it needs an item from that list.
             It is not useful for steps that only take input from earlier
             steps."
          & ( getDisFe
            =   f
              .     !arg:? (?f,?) ? (!f,?) ?
                  & (!f.n)
                | (.1)
            )
          & ( Short
            =   
              .   (   !features
                    :   ?
                      + ( ? (name.? !arg ?) ?
                        : ? (short.?arg) ?
                        )
                      + ?
                  | 
                  )
                & !arg
            )
          & ( compact
            =   A B C D E x
              .       whl
                    ' ( !arg:?A+(#*%?x.?B)+?C+(#*!x.?D)+?E
                      & !A+(!x.!B+!D)+!C+!E:?arg
                      )
                  &   whl
                    ' ( !arg:?A+#%*%?x+?C
                      & !A+!x+!C:?arg
                      )
                  & 0:?E
                  &   whl
                    ' ( !arg:?A+(?B.?C)+?arg
                      & !E+!A+(!B.compact$!C):?E
                      )
                  & !arg+!E:?arg
                | FOUT
            )
          & ( OffSet
            =   ID
              .   !jobIDoffset:&!arg
                | @(!arg:step #?ID)&str$(step !ID+!jobIDoffset)
                | !arg
            )
          & ( simpleInput
            =   a b c d e,f g h i j k
              .     !arg
                  : ( ?+(I.?.?.?+(F.?)+?)+?+(I.?.?.?+(F.?)+?)+?
                    | ?+(F.?)+?
                    )
                |   !arg:?a+(I.?b+(?c.?d+(?e.?f+(F.?g)+?h)+?i)+?j)+?k
                  & !a+(F.!g)+(I.!b+(!c.!d+(!e.!f+!h)+!i)+!j)+!k
            )
          & ( forceFeed
            =   requestString item file
              .   0:?requestString
                & !arg:?items
                &   whl
                  ' ( !items:(Item.%?item ?) ?items
                    & !Uploads:? (?.!item.?file.?) ?
                    & ( !dep !files:? !file ?
                      | !files !file:?files
                      )
                    & !requestString+(F.!file):?requestString
                    )
                & !requestString
            )
          & ( notIncompatible
            =   feats In f
              .   !arg:(?feats.?In)
                & ~( !feats
                   :   ?
                       (?f.?v)
                       (?&!In:? (!f,(!v^?.?)) ?)
                   )
            )
          & ( compatible
            =   f r v rs fv
              .   !arg:(?.~(? (?,@) ?))
                |   !arg:(?f.? (?r,@?v) ?rs)
                  & ( ~(!f:? (!r.?fv) ?)
                    | !v:!fv
                    | !v:!fv^?
                    | !fv:!v^?
                    )
                  & compatible$(!f.!rs)
            )
          & ( addOutputsToRequestString
            =   ou requestString extension feat val spec vals
              .   !arg:(?ou.?requestString)
                & xml:?extension
                &   whl
                  ' ( !ou:(?feat,?vals) ?ou
                    &   whl
                      ' ( !vals:%@?val^?spec*?vals
                        &     !requestString
                            + ( O
                              . Short$!feat
                              . !val
                              .   !spec:1&0
                                | !spec
                              )
                          : ?requestString
                        & (   !feat:(format|Format)
                            &   ( !val:flat&txt
                                |     !val
                                    : ( xm
                                      | txtbasis
                                      | txtann
                                      | teip5
                                      )
                                  & xml
                                | !val:dipl&org
                                | !val
                                )
                              : ?extension
                          | 
                          )
                        )
                    )
                & (!extension.!requestString)
            )
          & ( getDepsAndAddInputsToRequestString
            =   in nfiles requestString newJobs getCompatibleInputFile
              .   ( getCompatibleInputFile
                  =   Items FiLfeats item feats Uploads,fileitem feats
                    .   !arg:(?Items.?Uploads.?FiLfeats)
                      &   !Items
                        :   ?
                            ( Item
                            .   %?item ?feats
                              &   !Uploads
                                :   ?
                                    ( ?
                                    . !item
                                    . ?fileitem
                                    . ?
                                    .   ?feats
                                      & compatible$(!feats.!FiLfeats)
                                    )
                                    ?
                            )
                            ?
                      & !fileitem
                  )
                & !arg:(?in.?nfiles.?requestString.?newJobs)
                &     map
                    $ ( ( 
                        =     feat vals Val spec file specs
                            , val dep FiLfeats fileitem
                          .   !arg:(?feat,?vals)
                            & :?dep
                            &   whl
                              ' ( !vals:%?Val*?vals
                                & 0:?specs
                                &   !Val
                                  : (   %@?val^?spec
                                      & 0:?fileTerm
                                    |   (   %@?val^?spec
                                          | ?val&1:?spec
                                        . FiL
                                        . ?FiLfeats
                                        )
                                      &   getCompatibleInputFile$(!Items.!Uploads.!FiLfeats)
                                        : ?fileitem
                                      & !dep !fileitem:?dep
                                      & (F.!fileitem):?fileTerm
                                    |   (%@?val^?spec.@?file)
                                      & OffSet$!file:?file
                                      & !dep (!file,pending):?dep
                                      & (   !newJobs
                                          : ? (!file.?.?.?.?file) ?
                                        | log$(OOPS1 !jobNr file !file)
                                        )
                                      & (F.!file):?fileTerm
                                    |   (?val&1:?spec.@?file)
                                      & composeValueString$!val:(?val.?specs)
                                      & ( !file:OnE
                                        |   OffSet$!file:?file
                                          & !dep (!file,pending):?dep
                                          & (   !newJobs
                                              : ? (!file.?.?.?.?file) ?
                                            | log$(OOPS2 !jobNr file !file)
                                            )
                                          & (F.!file):?fileTerm
                                        )
                                    |   ?val
                                      & log$(UNMATCHED !val)
                                      & ~
                                    )
                                &     !requestString
                                    + ( !nfiles:1&!fileTerm
                                      | 0
                                      )
                                    + ( I
                                      . Short$!feat
                                      . !val
                                      .   (   !nfiles:n
                                            & !fileTerm
                                          | 0
                                          )
                                        + (   !spec:(0|1)
                                            & 0
                                          | (!spec.0)
                                          )
                                        + !specs
                                      )
                                  : ?requestString
                                )
                            & !dep
                        )
                      . !in
                      )
                  : ?dep
                & (!dep.!requestString)
            )
          & ( distillInputsFromRequestString
            =     requestString inputs someinputs firstinput
                , moreinputs other oh fh
              .   !arg:?requestString
                &   !requestString
                  : ( ?+(F.@(?:?inputs "-step" #% ?))+?
                    |     ?
                        + ( I
                          .   ?
                            + ( ?
                              .   ?someinputs
                                + (?.?+(F.@(?:?firstinput "-step" #% ?))+?)
                                + ?moreinputs
                              )
                            + ?
                          )
                        + ?
                      & :?inputs
                      & !someinputs+!moreinputs:?moreinputs
                      &   whl
                        ' (   !moreinputs
                            :   ?
                              + ( ?
                                .   ?
                                  + ( F
                                    . @( ?
                                       : (?other "-step" #% ?|?other)
                                       )
                                    )
                                  + ?
                                )
                              + ?moreinputs
                          & @(!firstinput:?fh [%@(!other:?oh !sjt))
                          &     str
                              $ (   ( !fh:
                                    | !oh:
                                    |   @(!fh:!oh "-" #?)
                                      & :?oh
                                    )
                                  & (     !inputs
                                        : (|!firstinput)
                                      &   (   @(!firstinput:? !fh ?)
                                            & 
                                          | !fh
                                          )
                                          (   @(!firstinput:? !oh ?)
                                            & 
                                          | !oh
                                          )
                                          !firstinput
                                    | !inputs "_" !other
                                    )
                                |   ( !inputs:&!fh "_"
                                    | 
                                    )
                                    !oh
                                )
                            : ?inputs
                          )
                    )
                & !inputs
            )
          & log$convert2URLs
          & 0:?maxjobID
          & readTable$features
          & readTable$tooladm
          & readTable$toolprop
          & !arg:(?jobNr.?jobIDoffset.?JobStack.?base.?post2.?Items.?dryORrun)
          & readTable$Uploads
          & :?newJobs
          & (readTable$jobs|:?jobs)
          & ( 
            |   log$"[["
              & lst$(JobStack,path$"log.txt",APP RAW)
              & log$"]]"
            )
          & "Note: this whl'() loop cannot be rewritten as a map$-ping,
             since the constructed list (newJobs) is consulted."
          &   whl
            ' ( !JobStack:(?jobID.?Tool.?ou.?in) ?JobStack
              & OffSet$!jobID:?jobID
              & 1+!maxjobID:?maxjobID
              &   !tooladm
                :   ?
                  + ( ? (ToolID.!Tool) ?
                    : ? (ServiceURL.?URL) ?
                    )
                  + ?
              &   (base.!base)+(post2.!post2)+(job.str$(!jobNr "-" !jobID))
                : ?requestString
              & getDisFe$!in:(?discerningFeature.?nfiles)
              & addOutputsToRequestString$(!ou.!requestString):(?extension.?requestString)
              & !in:?In
              &   getDepsAndAddInputsToRequestString$(!in.!nfiles.!requestString.!newJobs)
                : (?dep.?requestString)
              &     !dep
                    ( :?files
                    & ( !requestString:?+(F.?)+?
                      |   !Items:?items
                        &   whl
                          ' ( !items:(Item.%?item ?feats) ?items
                            &   !Uploads
                              :   ?
                                  ( ?
                                  . !item
                                  . ?file
                                  . ? (DATE.?DATE) ?
                                  . ?feats
                                  )
                                  ?
                            &     !requestString
                                + (   !discerningFeature:
                                    & ( !dep !files:? !file ?
                                      | !files !file:?files
                                      )
                                    & (F.!file)
                                  |     !feats
                                      : ? (!discerningFeature.?v) ?
                                    & getShort$(!discerningFeature.!v):?v
                                    &   getFeatName$!discerningFeature
                                      : ?DiscerningFeature
                                    & notIncompatible$(!feats.!In)
                                    & compatible$(!feats.!In)
                                    &   !In
                                      :   ?
                                          (   !discerningFeature
                                            | !DiscerningFeature
                                          ,   ?+?*!v^?*?+?
                                            | (?+?*!v^?*?+?.?)
                                            | ?+?*!v*?+?
                                            | (?+?*!v*?+?.?)
                                          )
                                          ?
                                    & !v:%@?v^?
                                    & ( !dep !files:? !file ?
                                      | !files !file:?files
                                      )
                                    & (I.!discerningFeature.!v.F.!file)
                                  | 0
                                  )
                              : ?requestString
                            )
                      )
                    & (     !requestString
                          : ( ?+(I.?+(?.?+(?.?+(F.?)+?)+?)+?)+?
                            | ?+(F.?)+?
                            )
                        & simpleInput$!requestString:?requestString
                      |   log$forceFeed
                        & !requestString+forceFeed$!Items:?requestString
                      )
                    & !files
                    )
                : ?inputs
              & compact$!requestString+(mode.!dryORrun):?requestString
              &     !newJobs
                    ( !jobID
                    . !inputs
                    . !URL
                    . !requestString
                    .   "Output from tool:"
                      &   str
                        $ ( (     !inputs
                                : ? (@(?:step ?),?) ?
                              & distillInputsFromRequestString$!requestString
                            |   ( !inputs:@
                                |   @(!jobID:? #?ID)
                                  &   2*mod$(div$(!DATE*(1+clk$),1),4231764527)
                                    + !jobNr*100
                                    + !ID
                                )
                                "-"
                                !jobNr
                            )
                            "-"
                            !jobID
                            "."
                            !extension
                          )
                    )
                : ?newJobs
              )
          &   (   !jobs:?A (!jobNr.?M) ?Z
                & !A (!jobNr.!M !newJobs) !Z
              | !jobs (!jobNr.!newJobs)
              )
            : ?jobs
          & saveTable$jobs
          & !maxjobID
      )
      ( tekstXML
      =     DATE EMAIL TBA AVAILABILITY Description
          , XMLID ITEMS TOOLURIS SPANGRP
          , ret linguae BODYCONTENT niceDate noColon
          , ToolID Title Version toolURL full
          , CTBID LANGUAGE type appdesc
        .     !arg
            : ( ?DATE
              . ?EMAIL
              . ?CTBID
              . ?TBA
              . ?AVAILABILITY
              . ?XMLID
              . ?ITEMS
              . ?TOOLURIS
              . ?SPANGRP
              . ?toolURL
              . ?LANGUAGE
              )
          & ( niceDate
            =   yyyy mm dd
              .     @( !arg
                     :   (% % % %:?yyyy)
                         (% %:?mm)
                         (% %:?dd)
                     )
                  & str$(!yyyy "-" !mm "-" !dd)
                | !arg
            )
          & ( noColon
            =   A Z
              .     whl
                  ' ( @(!arg:?A "::" ?Z)
                    & str$(!A "_" !Z):?arg
                    )
                &   whl
                  ' ( @(!arg:?A ":" ?Z)
                    & str$(!A "_" !Z):?arg
                    )
                & !arg
            )
          & :?Title:?Version:?ToolID:?Description
          & (   !SPANGRP
              : ? ("?".@(?:? xml ? version ?)) ?SPANGRP
            | 
            )
          & (     !SPANGRP
                :   ?
                    ( spanGrp
                    . ? (ana.@(?:"#" ?XMLID)) ?|?
                    )
                    ?
              & :?BODYCONTENT
              & annotation:?type
            |   !SPANGRP:?BODYCONTENT
              & :?SPANGRP
              & text:?type
            )
          &     (   readTable$tooladm
                  &   !tooladm
                    :   ?
                      + ( ? (ServiceURL.!TOOLURIS) ?
                        : ? (ToolID.?ToolID) ?
                        : ? (Title.?Title) ?
                        : ? (Version.?Version) ?
                        : ? (Description.?Description) ?
                        )
                      + ?
                  & !Title
                | !toolURL
                )
                ". "
                !Description
            : ?appdesc
          &     ("?"."xml version='1.0' encoding='UTF-8'")
                \n
                ( TEI
                .     (xmlns."http://www.tei-c.org/ns/1.0")
                      ( "xmlns:schemaLocation"
                      .   "https://www.clarin.dk/schemas/tei/TEIDKCLARIN_ANNO/xml.xsd"
                        |   !type:text
                          & "http://www.clarin.eu/cmd http:/infra.clarin.dk/cmd/dkclarin-text-md-schema.xsd"
                        | "http://www.clarin.eu/cmd http://infra.clarin.dk/cmd/dkclarin-textann-md-schema.xsd"
                      )
                  ,   \n
                      ( teiHeader
                      .   (type.!type)
                        ,   ( fileDesc
                            .   
                              ,   ( titleStmt
                                  .   
                                    , ( respStmt
                                      .   
                                        ,   (resp.,"a_annotation")
                                            ( name
                                            .   
                                              ,   ( note
                                                  . (type.method),!ToolID
                                                  )
                                                  ( date
                                                  . (when.niceDate$!DATE),
                                                  )
                                            )
                                      )
                                  )
                                  (   !type:text
                                    & (Extent.,(num.(type.words),))
                                  | 
                                  )
                                  ( publicationStmt
                                  .   
                                    ,   (idno.(type.ctb),!CTBID)
                                        ( availability
                                        .   (status.free)
                                          , (ab.(type.public),)
                                        )
                                  )
                                  ( sourceDesc
                                  .   
                                    , ( biblStruct
                                      .   
                                        , ( monogr
                                          .   
                                            ,   ( title
                                                .   ("xml:lang".!LaNg)
                                                  ,   "(provided by user)"
                                                    & monogr
                                                )
                                                ( imprint
                                                .   
                                                  ,   ( publisher
                                                      .   (n.n/a)
                                                        , "(provided by user)"
                                                      )
                                                      ( date
                                                      .   (when.niceDate$!DATE)
                                                        , 
                                                      )
                                                )
                                          )
                                      )
                                  )
                            )
                            ( profileDesc
                            .   
                              ,   ( creation
                                  .   
                                    , ( date
                                      .   (cert.high) (when.niceDate$!DATE)
                                        , 
                                      )
                                  )
                                  ( !LANGUAGE:
                                  |   "Three problems with form field for language if it is required:
                                         1) element content must be full name of language
                                         2) @ident must be set to ISO code
                                         3) Can just as well be provided automatically"
                                    & ( langUsage
                                      .   
                                        , ( language
                                          .   (ident.!LANGUAGE)
                                            ,     readTable$linguae
                                                &   !linguae
                                                  :   ?
                                                      (?full.!LANGUAGE.?)
                                                      ?
                                                & localized$!full
                                              | 
                                          )
                                      )
                                  )
                                  ( textDesc
                                  .   
                                    ,   (channel.(mode.w),2)
                                        (constitution.,)
                                        (derivation.,)
                                        ( domain
                                        .   (type.specific)
                                          , "(provided by user)"&general
                                        )
                                        (factuality.,)
                                        (interaction.,)
                                        (preparedness.,)
                                        (purpose.,)
                                  )
                                  (particDesc.,(person.,))
                            )
                            ( revisionDesc
                            .   
                              , ( change
                                .   (when.niceDate$!DATE) (who.!EMAIL)
                                  ,   !type:text&!appdesc
                                    | created
                                )
                            )
                      )
                      \n
                      ( text
                      .   
                        ,   ( body
                            .   
                              ,     !BODYCONTENT:~
                                  & (   !BODYCONTENT
                                      : (   ?
                                            ( text
                                            . ?,? (body.?,?BODYCONTENT) ?
                                            )
                                            ?
                                        | ? (body.?,?BODYCONTENT) ?
                                        |   ?
                                            (body.?)
                                            ?BODYCONTENT
                                            (.body.)
                                            ?
                                        )
                                    | 
                                    )
                                  & !BODYCONTENT
                                | ( ab
                                  .   
                                    ,     !SPANGRP:
                                        & "empty body/no text"
                                      | 
                                  )
                            )
                            \n
                            !SPANGRP
                      )
                )
            : ?ret
          & !ret
      )
      ( inject
      =     userProvidedMetadata autogenerated final recurse
          , Required/optional/automatic val Line tree
          , PlaceInHeader id addOrInsert remove Metadata
          , replaceOrInsert addOrInsertOneOrMoreNames metadataType
        .   ( remove
            =   PlaceInHeader tree subtree,place A Z a attval
              .   !arg:(?PlaceInHeader.?tree)
                & (   !PlaceInHeader:%?place ?PlaceInHeader
                    & (   !PlaceInHeader:
                        & (   !place:(?place,?attval)
                            &   whl
                              ' (   !tree
                                  : ?A (!place.? !attval ?,?) ?Z
                                & !A !Z:?tree
                                )
                          |   whl
                            ' ( !tree:?A (!place.?,?) ?Z
                              & !A !Z:?tree
                              )
                          )
                        & !tree
                      |   (   !place:(?place,?attval)
                            &   !tree
                              :   ?A
                                  (!place.? !attval ?:?a,?subtree)
                                  ?Z
                          | !tree:?A (!place.?a,?subtree) ?Z
                          )
                        &   !A
                            (!place.!a,remove$(!PlaceInHeader.!subtree))
                            remove$(!place !PlaceInHeader.!Z)
                      )
                  | !tree
                  )
            )
          & ( replaceOrInsert
            =     PlaceInHeader val tree subtree
                , place plac at A E Z a z attval
              .   !arg:(?PlaceInHeader.?val.?tree)
                & (   !PlaceInHeader:%?place ?PlaceInHeader
                    & (   !place:(?place.?at)
                        & (     !tree
                              :   ?A
                                  (!place.?a (!at.?) ?z,?E)
                                  ?Z
                            &   !A
                                (!place.!a (!at.!val) !z,!E)
                                !Z
                          | !tree (!place.(!at.!val),)
                          )
                      |   !place:(?plac,?attval)
                        &   !tree
                          : ?A (!plac.? !attval ?:?a,?subtree) ?Z
                        &   !A
                            (!plac.!a,replaceOrInsert$(!PlaceInHeader.!val.!subtree))
                            !Z
                      |   !tree:?A (!place.?a,?subtree) ?Z
                        &   !A
                            (!place.!a,replaceOrInsert$(!PlaceInHeader.!val.!subtree))
                            !Z
                      |   !tree
                          (   !place:(?plac,?attval)
                            & (!plac.!attval,replaceOrInsert$(!PlaceInHeader.!val.))
                          | (!place.,replaceOrInsert$(!PlaceInHeader.!val.))
                          )
                      )
                  | !val
                  )
            )
          & ( recurse
            =   A Z a attval place subtree
              .   !PlaceInHeader:%?place ?PlaceInHeader
                & (   !place:(?place,?attval)
                    & (     !tree
                          : ?A (!place.? !attval ?:?a,?subtree) ?Z
                        & !A (!place.!a,!arg$(!PlaceInHeader.!val.!subtree)) !Z
                      | !tree (!place.!attval,!arg$(!PlaceInHeader.!val.))
                      )
                  |   !tree:?A (!place.?a,?subtree) ?Z
                    & !A (!place.!a,!arg$(!PlaceInHeader.!val.!subtree)) !Z
                  | !tree (!place.,!arg$(!PlaceInHeader.!val.))
                  )
            )
          & ( final
            =   A Z a attval b
              .     !PlaceInHeader:@
                  & (     !tree
                        :   ?A
                            (!PlaceInHeader.?a,?b)
                            (~((!PlaceInHeader.?) ?):?Z)
                      &   !A
                          (!PlaceInHeader.!a,!b)
                          (!PlaceInHeader.!a,!val)
                          !Z
                    | !tree (!PlaceInHeader.,!val)
                    )
                |   !PlaceInHeader:(?PlaceInHeader,?attval)
                  & (     !tree
                        :   ?A
                            (!PlaceInHeader.? !attval ?:?a,?b)
                            ( ~((!PlaceInHeader.? !attval ?,?) ?)
                            : ?Z
                            )
                      &   !A
                          (!PlaceInHeader.!a,!b)
                          (!PlaceInHeader.!a,!val)
                          !Z
                    | !tree (!PlaceInHeader.!attval,!val)
                    )
            )
          & ( addOrInsert
            =   PlaceInHeader val tree
              .   !arg:(?PlaceInHeader.?val.?tree)
                & (final$|recurse$addOrInsert|!val)
            )
          & ( addOrInsertOneOrMoreNames
            =   PlaceInHeader val tree parnt,A Z a b c d e
              .   !arg:(?PlaceInHeader.?val.?tree)
                & (   !PlaceInHeader:@?parnt name
                    & (     !tree
                          :   ?A
                              (!parnt.?a,?b (name.?c,?d) ?e)
                              (~((!parnt.?) ?):?Z)
                        &   !A
                            (!parnt.!a,!b (name.!c,!d) !e)
                            (!parnt.!a,!b (name.!c,!val) !e)
                            !Z
                      |   !tree:?A (!parnt.?a,?b) ?Z
                        & !A (!parnt.!a,(name.,!val) !b) !Z
                      | !tree (!parnt.,(name.,!val))
                      )
                  | final$
                  | recurse$addOrInsertOneOrMoreNames
                  | !val
                  )
            )
          & !arg:(?userProvidedMetadata.?autogenerated.?metadataType)
          & readTable$!metadataType:?Metadata
          &   whl
            ' ( !userProvidedMetadata:(?id.?val) ?userProvidedMetadata
              & trim$!val:?val
              & (     !Metadata
                    :   ?
                        ( ?
                        ,   ?
                            (!id.?.?Required/optional/automatic.?.?PlaceInHeader.?.?.?)
                            ?
                        )
                        ?
                  &   (     !Required/optional/automatic
                          : ( ? r ?
                            | ? o ?&!val:~
                            )
                        & replaceOrInsert$(!PlaceInHeader.!val.!autogenerated)
                      |     !Required/optional/automatic
                          : (   ? (o|zeroOrMore) ?
                              : ~(? a ?)
                            & !val:
                            )
                        & remove$(!PlaceInHeader.!autogenerated):?autogenerated
                      |     !Required/optional/automatic
                          : ( ? oneOrMore ?
                            | ? zeroOrMore ?&!val:~
                            )
                        & remove$(!PlaceInHeader.!autogenerated):?autogenerated
                        &   whl
                          ' ( @( !val
                               : ( ?Line \n ?val
                                 | ?Line&:?val
                                 )
                               )
                            & trim$!Line:?Line
                            & ( !Line:
                              |     (     !Required/optional/automatic
                                        : ? oneOrMore ?
                                      & addOrInsertOneOrMoreNames
                                    | addOrInsert
                                    )
                                  $ (!PlaceInHeader.!Line.!autogenerated)
                                : ?autogenerated
                              )
                            & !val:~
                            )
                        & !autogenerated
                      |   !Required/optional/automatic:? a ?
                        & replaceOrInsert$(!PlaceInHeader.!val.!autogenerated)
                      )
                    : ?autogenerated
                | 
                )
              )
          & !autogenerated
      )
      ( Filename
      =   base
        .   str
          $ ( (@(!arg:?base ".xml")&!base|!arg)
              ".withmetadata.xml"
            )
      )
      ( inputResources
      =   
        .   readTable$Uploads
          &   map
            $ ( ( 
                =   item TITLE
                  .   !arg:(item.?)
                    |     !Uploads
                        :   ?
                            (?.?item.!arg.? (TITLE.?TITLE) ?.?)
                            ?
                      & (item.,(id.,!item) (title.,!TITLE))
                    | 
                )
              . !arg
              )
      )
      ( toolName
      =   
        .   readTable$tooladm
          &   !tooladm
            :   ?
              + (? (ServiceURL.!arg) ?:? (Title.?arg) ?)
              + ?
          & !arg
      )
      ( deleteDepending
      =   jobNr jobID CTBs
        .   !arg:(?jobNr.?jobID)
          & log$(deleteDepending !jobNr !jobID)
          & !( 
             ' (     map
                   $ ( ( 
                       = .!arg:($jobNr.$jobID.?)|
                       )
                     . $CTBs
                     )
                 : ?CTBs
               &     map
                   $ ( (=.!arg:($jobNr.?)|)
                     . $jobAbout
                     )
                 : ?jobAbout
               )
             )
      )
      ( addurl
      =   URL
        .     !arg:(?arg.?URL)
            & !URL:
            & !arg
          |   ( @(!URL:http ?)
              | str$("http://" !URL):?URL
              )
            & (a.(href.!URL),!arg)
      )
      ( letterData
      =     Steps menneskesprog workflow JobNr I O
          , aborted done filelist filename items JobId URL tool
        .   ( menneskesprog
            =   featdesc feature featvals featname features
              .   !arg:(?arg.?features)
                &     mop
                    $ ( ( 
                        =   featsum Feats
                          .   !arg:(?feature.?featsum)
                            &     mop
                                $ ( ( 
                                    =   
                                      .   !arg:(?featvals.?)
                                        &   getFeatAndValueNames$(!feature,!featvals)
                                          : (?featname,?featdesc)
                                        & ( !featdesc:
                                          | "/" !featdesc
                                          )
                                    )
                                  . !featsum
                                  . (=+)
                                  )
                              : ("/" ?Feats|?Feats)
                            & ", " localized$!featname "=" !Feats
                        )
                      . !arg
                      . (=+)
                      )
                  : ", " ?arg
                & str$!arg
            )
          & ( Steps
            =   x items tool JobId,format I O format stage
              .     !arg:(@(?:? #?JobId).?x.?items.?tool.?I.?O.?stage)
                  & ( step
                    .   
                      ,   (JobNr.,!JobNr)
                          (JobId.,!JobId)
                          (name.,!x)
                          (tool.,!tool)
                          (items.,!items)
                          (input.,menneskesprog$(!I.!features))
                          (output.,menneskesprog$(!O.!features))
                          ( format
                          .   
                            ,     !O:?+(format.?format.?)+?
                                & !format
                              | 
                          )
                          (stage.,!stage)
                    )
                | 
            )
          & readTable$features
          & readTable$jobAbout
          & ( !jobAbout:? (!JobNr.? (human.?workflow) ?) ?
            | :?workflow
            )
          & !arg:?JobNr
          & readTable$jobs
          & :?filelist
          &     map
              $ ( ( 
                  =   
                    .   !arg:(!JobNr.?arg)&!arg
                      | 
                  )
                . !jobs
                )
            : ?myjobs
          &   whl
            ' ( :?aborted:?done
              &   !myjobs
                :   ?
                    (   %@?JobId
                        ( aborted:?aborted&:?done
                        | done:?done&:?aborted
                        |   (|starting|waiting)
                          & :?aborted:?done
                        )
                    . ?items&inputResources$!items:?items
                    . ?URL&toolName$!URL:?tool
                    .   ?+(I.?I)+?:?+(O.?O)+?
                      | ?&:?I:?O
                    . ?filename
                    )
                    ?myjobs
              &     !filelist
                    ( !JobId
                    .     !aborted:aborted
                        & (   !items:(|(item.?))
                            & skipped
                          | fejl
                          )
                      | !filename
                    . !items
                    . !tool
                    . !I
                    . !O
                    .     ( !aborted:aborted
                          |   !myjobs
                            : ? (?.? !JobId ?.?) ?
                          )
                        & 
                      | LAST
                    )
                : ?filelist
              )
          & (workflow.,!workflow) (steps.,map$(Steps.!filelist))
      )
      ( doneAllJobSub
      =   JobNr myjobs
        .   readTable$jobs
          & @(!arg:? #?JobNr)
          & readTable$CTBs
          & readTable$jobAbout
          &     map
              $ ( ( 
                  =   JobId
                    .     !arg:(!JobNr.?myjobs)
                        &   map
                          $ ( ( 
                              =   
                                .   !arg:(%@?JobId ?.?.?.?.?)
                                  & deleteDepending$(!JobNr.!JobId)
                                  & 
                              )
                            . !myjobs
                            )
                        & 
                      | !arg
                  )
                . !jobs
                )
            : ?jobs
          & saveTable$jobs
          & saveTable$CTBs
          & saveTable$jobAbout
      )
      (FilenameNoMetadata=.!arg)
      ( setLanguageNotPermanently
      =   
        .   ( !arg:? (UIlanguage.?arg) ?
            | "reset to default"&readTable$UIlanguage:%?arg ?
            )
          & setLang$!arg
      )
      ( setTypefaceNotPermanently
      =   
        .   ( !arg:? (TyPeFaCe.?arg) ?
            | "reset to default"&readTable$Typeface:%?arg ?
            )
          & setTypeFace$!arg
      )
      ( getSingleItemOrNothing
      =   item
        .     !arg:? (Item.?item) ?
            & (@(!item:\" ?item \")|)
            & (Item.get$(!item,X ML,MEM))
          | 
      )
      ( analyzeInput
      =     item feats Items item
          , presels n val
          , retrieveFeatures errors
        .   !arg:(?Items.?errors)
          & readTable$features
          & ( retrieveFeatures
            =   Items item feats n val errors
              .   !arg:(?Items.?errors)
                & (   map
                    $ ( ( 
                        =   
                          .   !arg:(Item.%?item ?feats)
                            & (   !feats:
                                &   !Uploads
                                  : ? (?.!item.?.?.?feats) ?
                              |   !errors:
                                & log$("not found item" !item)
                                &     str
                                    $ ( 404~~~
                                          toML
                                        $ ( !BodyContainer
                                          $ (paragraph$(str$("Item " !item " not found")))
                                          )
                                      )
                                  : ?errors
                              | 
                              )
                            &   map
                              $ ( ( 
                                  =   
                                    .     !arg:(?n.?val)
                                        & getShort$(!n.!val):?val
                                        & (!n.!val.!item)
                                      | 
                                  )
                                . !feats
                                )
                        )
                      . !Items
                      )
                  . !errors
                  )
            )
          & retrieveFeatures$(!Items.!errors):(?presels.?errors)
          & log$(retrieveFeatures-presels !presels)
          & (!Items.!presels.!errors)
      )
      ( initialiseSpecifyGoalShowWorkflowsChosenWorkflow
      =   itms errors hiddenData Items Tool parms BodyContainer
        .   startclock$
          & :?errors:?hiddenData:?Items
          & 0:?tabind
          & ?:?Tool
          & !arg:?parms
          & log$(initialiseSpecifyGoalShowWorkflowsChosenWorkflow !arg)
          & ( !parms:? (itms.?itms) ?
            | 1:?itms
            )
          & log$(itms !itms)
          & readTable$ItemGroupsCache
          &     map
              $ ( ( 
                  =   a v nt CLOCK wfs items
                    .     !arg:(@(?:?a ";" ?nt).?v)
                        & log$(map a !a nt !nt)
                        & ( !nt:!itms&(!a.!v)
                          | 
                          )
                      |       (   !arg:(Item.?)
                                & log$(arg Item !arg)
                                & !arg
                              |   !arg:(itms.?)
                                & log$(arg Item or itms !arg)
                                & (itms.1)
                              |   !arg:(CLOCK.?CLOCK)
                                & log$(CLOCK !CLOCK itms !itms)
                                &   !ItemGroupsCache
                                  :   ?
                                      (!CLOCK.? (!itms.?items.?wfs) ?)
                                      ?
                                & log$(FOUND items !items wfs !wfs)
                                &   map$((=.Item.!arg).!items)
                                  : ?Items
                                & log$(Items !Items)
                                & !arg
                              | 
                              )
                              !hiddenData
                          : ?hiddenData
                        & ( !arg
                          | !arg:~(itms.?)
                          | 
                          )
                  )
                . !parms
                )
            : ?parms
          & !HTMLbodyContainer:?BodyContainer
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & "Consult the 'Uploads'-table to find out what we know about the input(s)."
          & readTable$Uploads
          & (!errors.!hiddenData.!Items.!Tool.!parms.!BodyContainer)
      )
      ( getBatchHandleDesiredtoolSuperset
      =     parms handle rstr hiddenData lexan
          , unpackIOparm unpackIOparms checkIOparms
        .   ( lexan
            =   T A B op ops
              .   !arg:(?ops.?arg)
                & "safe alternative for get$(!arg,MEM). Ignores JBoss-life-threatening (closing) parentheses."
                & (   !arg:?A_?B
                    & (lexan$(!ops.!A))_(lexan$(!ops.!B))
                  |   !ops:%?op ?ops
                    & (   @(!arg:?A !op ?B)
                        &   !op
                          : (   " "
                              &   lexan$(!ops.!A) lexan$(!op !ops.!B)
                                : ?T
                            |   "+"
                              &   lexan$(!ops.!A)+lexan$(!op !ops.!B)
                                : ?T
                            |   "*"
                              &   lexan$(!ops.!A)*lexan$(!op !ops.!B)
                                : ?T
                            |   "^"
                              &   lexan$(!ops.!A)^lexan$(!op !ops.!B)
                                : ?T
                            )
                        & !T
                      | lexan$(!ops.!arg)
                      )
                  | !arg
                  )
            )
          & ( unpackIOparm
            =   A parms parm nparms val
              .   !arg:(?parms.?parm)
                & :?nparms
                &   whl
                  ' ( !parms:?A (!parm.?val) ?parms
                    & ( lexan$(" " "+" "*" "^".!val):?val
                      | 
                      )
                    & !nparms !A (!parm.!val):?nparms
                    )
                & !nparms !parms
            )
          & ( unpackIOparms
            =   f fs short p
              .   readTable$features
                & !features:?fs
                &   whl
                  ' ( !fs:%?f+?fs
                    & !f:? (short.?short) ?
                    & str$(I !short):?p
                    & (unpackIOparm$(!arg.!p):?arg|)
                    & str$(O !short):?p
                    & (unpackIOparm$(!arg.!p):?arg|)
                    )
                & !arg
            )
          & ( checkIOparms
            =   f fs short table p
              .   readTable$features
                & !features:?fs
                &   whl
                  ' ( !fs:%?f+?fs
                    &   !f
                      : ? (short.?short) ?
                      : ? (table.?table) ?
                    & readTable$!table
                    & str$(I !short):?p
                    & (checkParms$(!arg.!p.!!table)|)
                    & str$(O !short):?p
                    & (checkParms$(!arg.!p.!!table)|)
                    )
            )
          & !arg:(?parms.?hiddenData)
          &     ( 
                | "Shall we treat all resources in one job (non-batch) or shall we
                   send each input through a different (though similar) job?"
                )
                ( batch
                .   (     !parms
                        : ( ? (action.batch) ?
                          | ? (batch.on) ?
                          |   ~(? (action.?) ?)
                            & ~(? (batch.?) ?)
                          )
                      & on
                    | off
                    )
                  : ?batch
                )
                (   !parms:? (handle.?handle) ?
                  & (handle.!handle)
                | 
                )
                ( 
                | "Does the user want to decide which tool to use or does she want
                 to let the infrastructure work out a way to reach a set goal?"
                )
                (   !parms:? (reqtool.?rstr) ?
                  & (reqtool.!rstr)
                | 
                )
                (   !parms:? (fintool.?rstr) ?
                  & (fintool.!rstr)
                | 
                )
                  map
                $ ( ( 
                    =   
                      .   !arg:(@(?:SuperSet- ?).?)
                        | 
                    )
                  . !parms
                  )
                !hiddenData
            : ?hiddenData
          & unpackIOparms$!parms:?parms
          & checkIOparms$!parms
          & (!parms.!hiddenData.!batch)
      )
      ( supplementParmsAndHiddenData
      =   Submit batch parms nth A Z
        .   getBatchHandleDesiredtoolSuperset$!arg:(?parms.?hiddenData.?batch)
          & readTable$tooladm
          & (   !parms:?A (eye.?) ?Z
              & !A (bsubmit.eye) !Z:?parms
              & 
            | 
            )
          & (   ( !parms:? (bsubmit.?Submit) ?&
                |     (   !parms:? (@(?:bview- ?nth).?) ?
                        & localized$(localized$("View details" "Se detaljer"))
                      |     !parms
                          : ? (@(?:bsubmit- ?nth).?) ?
                        & Submit
                      )
                    : ?Submit
                  & (nth.!nth)
                )
                !parms
            . !Submit
            . !hiddenData
            . !batch
            )
      )
      ( NotFulfillable
      =   userInput goal
        .   !arg:(?arg.?userInput)
          & !userInput:(?.?goal.?)
          &   str
            $ ( 404~~~
                  toML
                $ ( !BodyContainer
                  $ (   paragraph
                      $ ( str
                        $ (   localized
                            $ ( "Your goal cannot be fulfilled with the currently integrated tools. "
                                "Dit m√•l kan ikke opfyldes med de v√¶rkt√∏jer der p.t. er integreret i infrastrukturen. "
                              )
                            (   !goal:% %
                              &   localized
                                $ ( "Try to make your goal less specific."
                                    "Pr√∏v at lave dit m√•l mindre specifikt."
                                  )
                            | 
                            )
                          )
                        )
                      (p.,map$((=.str$("(" !arg ")") (br.,)).!arg))
                    )
                  )
              )
      )
      ( FulfillableWithoutRestriction
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ ( paragraph
                  $ (   localized
                      $ ( "None of the found workflows involves the tool '"
                          "Ingen af de fundne arbejdsgange anvender v√¶rkt√∏jet '"
                        )
                      ToolTitle$!arg
                      "'."
                    )
                  )
                )
            )
      )
      ( TooExpensive
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ ( paragraph
                  $ ( localized
                    $ ( "The computation takes too much time. It may succeed if you narrow your goal."
                        "Beregningen tager for lang tid. M√•ske vil det lykkes hvis du definerer dit m√•l lidt n√¶rmere."
                      )
                    )
                  )
                )
            )
      )
      ( UnexpectedReturnCode
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ (paragraph$(localized$("Unexpected return code '" "Uvented kode '") !arg "'."))
                )
            )
      )
      ( canConsumeMetadata
      =   a b
        .     !arg
            : (?,txtbasis^?|txtann^?|teip5^?)
          |   !arg:?a_?b
            & (canConsumeMetadata$!a|canConsumeMetadata$!b)
      )
      ( updateOargFromParg
      =   a z A Z val ft
        .     whl
            ' ( !arg:?A (@(?:P ?ft).?val) ?Z
              & ( !val:&!A !Z:?arg
                |   !A !Z:?a (@(?:O !ft).?) ?z
                  & !a (str$(O !ft).!val) !z:?arg
                  & (   !arg:?A (@(?:SuperSet- !ft).?) ?Z
                      & !A !Z:?arg
                    | 
                    )
                )
              )
          & !arg
      )
      ( makeArgsForHiddenFields
      =   superset
        .   !arg:(?arg.?superset)
          &   map
            $ ( ( 
                =   f
                  .       !arg
                        : (   bsubmit
                            | method
                            | DATE
                            | @( ?:SuperSet- ?f
                               & !superset:~(? !f ?)
                               )
                          . ?
                          )
                      & 
                    | !arg
                )
              . !arg
              )
      )
      ( BookMark
      =   bm err
        .   !arg:(?bm.?err)
          &   submit$(localized$!Bookmark)
              (br.,)
                makeTextFormField
              $ ( localized$("Name for this workflow" "Navn for denne arbejdsgang")
                . bm
                .   (val.!bm)
                    ( desc
                    .   localized
                      $ ( "A unique name that tells you and other users what the workflow is about."
                          "Et unikt navn som giver mening for dig og for andre brugere."
                        )
                    )
                    (size.40)
                    (required.span.(class.requiblue),"*")
                )
              ( !bm:
              | !err:&"(" localized$(saved gemt) ")"
              | localized$("Already in use!" "Allerede brugt!")
              )
      )
      ( UserMsg
      =   fb err
        .   !arg:(?fb.?err)
          &     makeTextAreaFormFieldInv
              $ ( 
                . fb
                .   (val.!fb)
                    ( desc
                    .   localized
                      $ ( "Your comments, criticisms, appraisal, suggestions."
                          "Dine kommentarer, forslag, ris og ros."
                        )
                    )
                    (size.40)
                    (required.span.(class.requiblue),)
                )
              submit$(localized$!Usermsg)
              ( !fb:
              | localized$!suggestions:!fb
              | !err:&"(" localized$(saved gemt) ")"
              )
      )
      ( NoNeedForMoreZoomingIn
      =   returnCode pipes,reorderedworkflowlist topologicalOrderedTools userInput
        .     !arg
            : (?returnCode.?pipes.?reorderedworkflowlist.?topologicalOrderedTools.?userInput)
          & (   !returnCode:workflowsFound
              &   (     makeWorkflowsSequential$!pipes
                      : (?reorderedworkflowlist.?topologicalOrderedTools)
                    & log$(topologicalOrderedToolsA !topologicalOrderedTools)
                    & allRight
                  |   0:?reorderedworkflowlist
                    & :?topologicalOrderedTools
                    & tooComplex
                  )
                : ?returnCode
            | 
            )
          &   ShowAllPipesIfNotTooExpensive
            $ (!returnCode.!hiddenData.!userInput.!reorderedworkflowlist.!topologicalOrderedTools)
      )
      ( illustration
      =     stappen steps connections centr polygonPoints
          , A Edgez Shapes canvasX canvasY shapes snoitcennoc
        .   ( polygonPoints
            =   points x y
              .   !arg:((?x.?y).?points)
                & ( points
                  . 
                  .       map
                        $ ( ( 
                            =   X Y
                              .   !arg:(?X.?Y)
                                & " " div$(!x+!X+1/2.1) "," div$(!y+!Y+1/2.1)
                            )
                          . !points
                          )
                      : " " ?points
                    & str$!points
                  )
            )
          & ( centr
            =   cx cy x1 x2 y1 y2 xs ys N points
              .     !arg:?+(cx.?cx)+?:?+(cy.?cy)+?
                  & (!cx.!cy)
                |     !arg
                    : ?+(x1.?x1)+?
                    : ?+(x2.?x2)+?
                    : ?+(y1.?y1)+?
                    : ?+(y2.?y2)+?
                  & (div$(!x1+!x2.2).div$(!y1+!y2.2))
                |     !arg
                    : ?+(x.?x1)+?
                    : ?+(width.?x2)+?
                    : ?+(y.?y1)+?
                    : ?+(height.?y2)+?
                  & (!x1+div$(!x2.2).!y1+div$(!y2.2))
                |   !arg:?+(points..?points)+?
                  & 0:?xs:?ys:?N
                  &   vap
                    $ ( ( 
                        =   x y
                          .   vap$((=.!arg).!arg.","):#%?x #%?y
                            & !x+!xs:?xs
                            & !y+!ys:?ys
                            & 1+!N:?N
                        )
                      . !points
                      . " "
                      )
                  & (div$(!xs.!N).div$(!ys.!N))
            )
          &     ( triangle1
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ (!offset.(-10.9) (10.9) (0.-8))
                                + (fill..lime)
                                + (stroke..blue)
                                + (stroke-width.2)
                                + (fill-rule..evenodd)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( triangle2
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ (!offset.(-10.-9) (10.-9) (0.8))
                                + (fill..lime)
                                + (stroke..blue)
                                + (stroke-width.2)
                                + (fill-rule..evenodd)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( 5-star
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-16)
                                        (-10.12)
                                        (15.-4)
                                        (-15.-4)
                                        (10.12)
                                    )
                                + (stroke..red)
                                + (stroke-width.1)
                                + (fill-rule..nonzero)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( 5-star2
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-16)
                                        (-10.12)
                                        (15.-4)
                                        (-15.-4)
                                        (10.12)
                                    )
                                + (stroke..lightblue)
                                + (stroke-width.1)
                                + (fill-rule..nonzero)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( pentagon
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-16)
                                        (15.-4)
                                        (10.12)
                                        (-10.12)
                                        (-15.-4)
                                    )
                                + (fill..grey)
                                + (stroke..red)
                                + (stroke-width.1)
                                + (fill-rule..evenodd)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( square2
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-16)
                                        (16.0)
                                        (0.16)
                                        (-16.0)
                                    )
                                + (fill..black)
                                + (stroke..red)
                                + (stroke-width.2)
                                + (fill-rule..nonzero)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( romb
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-16)
                                        (8.0)
                                        (0.16)
                                        (-8.0)
                                    )
                                + (fill..white)
                                + (stroke..blue)
                                + (stroke-width.2)
                                + (fill-rule..nonzero)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( 6-star
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-128015258/5000000)
                                        (2131454/500000.-36917871/5000000)
                                        (11086447/500000.-64007626/5000000)
                                        (4262909/500000.0)
                                        (11086447/500000.64007629/5000000)
                                        (2131455/500000.36917869/5000000)
                                        (0.128015259/5000000)
                                        (-2131453/500000.36917869/5000000)
                                        (-11086446/500000.64007629/5000000)
                                        (-4262908/500000.0)
                                        (-11086446/500000.-64007632/5000000)
                                        (-2131454/500000.-36917861/5000000)
                                        (0.-128015258/5000000)
                                    )
                                + (stroke..blue)
                                + (stroke-width.2)
                                + (fill-rule..nonzero)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( ellipse
                . ( 
                  =   chrono step cx cy ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & (   (Create..ellipse)
                          + ( attributes
                            .     (cx.!cx)
                                + (cy.!cy)
                                + (rx.16)
                                + (ry.10)
                                + (fill..yellow)
                                + (stroke..blue)
                                + (stroke-width.1)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( circle
                . ( 
                  =   chrono step cx cy ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & (   (Create..circle)
                          + ( attributes
                            .     (cx.!cx)
                                + (cy.!cy)
                                + (r.13)
                                + (fill..blue)
                                + (stroke..yellow)
                                + (stroke-width.4)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( circle2
                . ( 
                  =   chrono step cx cy ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & (   (Create..circle)
                          + ( attributes
                            .     (cx.!cx)
                                + (cy.!cy)
                                + (r.13)
                                + (fill..grey)
                                + (stroke..blue)
                                + (stroke-width.4)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( ellipsisje
                . ( 
                  =   chrono step cx cy ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & (   (Create..path)
                          + ( attributes
                            .     ( D
                                  . 
                                  .   str
                                    $ ("M " !cx+3 " " !cy+3 " l -6 0 l 0 6 l 6 0 l 0 -6")
                                  )
                                + (fill..grey)
                                + (stroke..blue)
                                + (stroke-width.4)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( ellipsis
                . ( 
                  =   chrono step cx cy ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & (   (Create..path)
                          + ( attributes
                            .     (cx.!cx)
                                + (cy.!cy)
                                + ( d
                                  . 
                                  .   str
                                    $ ( "M "
                                        !cx+-7
                                        " "
                                        -3+!cy
                                        " l -6 0 l 0 -6 l 6 0 l 0 6"
                                        " m "
                                        10
                                        " "
                                        0
                                        " l -6 0 l 0 -6 l 6 0 l 0 6"
                                        " m "
                                        10
                                        " "
                                        0
                                        " l -6 0 l 0 -6 l 6 0 l 0 6"
                                      )
                                  )
                                + (r.13)
                                + (fill..grey)
                                + (stroke..grey)
                                + (stroke-width.1)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( rect
                . ( 
                  =   chrono step cx cy w2 h2 ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & 10:?w2
                      & 10:?h2
                      & (   (Create..rect)
                          + ( attributes
                            .     (x.!cx+-1*!w2)
                                + (y.!cy+-1*!h2)
                                + (width.2*!w2)
                                + (height.2*!h2)
                                + (fill..red)
                                + (stroke..black)
                                + (stroke-width.3)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
            : ?Shapes
          & (500.500):(?canvasX.?canvasY)
          &   (   !arg:createAndEnact
                & (   (0.1.0.triangle1.545/1074.0)
                      (1.6.1.rect.0.963/8023)
                      (2.9.2.romb.115/1074.1502/8023)
                      (3.5.3.6-star.1269/1432.1822/8023)
                      (4.8.4.pentagon.95/537.2403/8023)
                      (5.4.-1.5-star.185/537.3643/8023)
                      (6.3.-1.circle.90/179.4303/8023)
                      (7.2.-1.square2.310/537.4783/8023)
                      (8.13.5.circle.355/1074.5083/8023)
                      (9.20.5.circle.215/537.5563/8023)
                      (10.15.-1.circle2.1.5943/8023)
                      (11.1.6.ellipse.1709/4296.7463/8023)
                      (12.1.7.triangle2.545/1074.1)
                  .   (4.11.23.10)
                      (3.11.22.-1)
                      (5.9.21.-1)
                      (9.11.20.-1)
                      (1.11.19.-1)
                      (6.11.18.-1)
                      (4.10.17.-1)
                      (3.10.16.-1)
                      (10.11.15.-1)
                      (5.8.14.-1)
                      (8.11.13.9)
                      (3.7.12.8)
                      (3.4.11.8)
                      (1.2.10.7)
                      (2.4.9.6)
                      (4.5.8.6)
                      (0.1.7.5)
                      (1.3.6.4)
                      (3.5.5.4)
                      (5.6.4.4)
                      (6.7.3.4)
                      (7.11.2.3)
                      (11.12.1.2)
                  )
              | (   (2.8.7.ellipsis.145/537.1403/8023)
                    (3.7.-1.5-star.265/537.3043/8023)
                    (6.6.-1.ellipsis.370/537.1003/8023)
                    (7.9.-1.ellipsis.440/537.1303/8023)
                    (8.3.8.5-star2.285/537.3043/8023)
                    (10.13.3.circle.355/1074.7083/8023)
                    (20.20.3.ellipse.275/537.7563/8023)
                    (30.8.-1.square2.130/179.6303/8023)
                .   (8.20.21.-1)
                    (8.10.14.-1)
                    (8.30.7.7)
                    (3.20.21.-1)
                    (3.10.14.-1)
                    (7.8.15.-1)
                    (6.8.13.-1)
                    (2.3.16.-1)
                    (3.30.7.7)
                )
              )
            : (?shapes.?snoitcennoc)
          & :?connections
          &   whl
            ' ( !snoitcennoc:%?A ?snoitcennoc
              & !A !connections:?connections
              )
          &     map
              $ ( ( 
                  =   chrono step type offset ill fnc
                    .   !arg:(?step.?chrono.?ill.?type.?offset)
                      & !Shapes:? (!type.(=?fnc)) ?
                      & fnc$(!step.!chrono.!ill.!offset)
                  )
                .   map
                  $ ( ( 
                      =   step chrono shape X Y ill
                        .   !arg:(?step.?chrono.?ill.?shape.?X.?Y)
                          & ( !step
                            . !chrono
                            . !ill
                            . !shape
                            . 20+div$((!canvasX+-40)*!X.1)
                            . 20+div$((!canvasY+-40)*!Y.1)
                            )
                      )
                    . !shapes
                    )
                )
            : ?steps
          &     map
              $ ( ( 
                  =   from to afrom ato text kro x1 x2 y1 y2
                    .   !arg:(?from.?to.?kro.?text)
                      &   !steps
                        :   ?
                            (?+(step.!from)+?:?+(attributes.?afrom,)+?,)
                            ?
                      &   !steps
                        :   ?
                            (?+(step.!to)+?:?+(attributes.?ato,)+?,)
                            ?
                      & centr$!afrom:(?x1.?y1)
                      & centr$!ato:(?x2.?y2)
                      &   ( 
                          | (   (Create..line)
                              + ( attributes
                                .     (x1.!x1)
                                    + (y1.!y1)
                                    + (x2.!x2)
                                    + (y2.!y2)
                                    + (stroke..black)
                                    + (stroke-width.4)
                                  , 
                                )
                              + (from.!from)
                              + (to.!to)
                              + (chrono.!kro)
                              + (ill.!text)
                            , 
                            )
                          )
                          (   (Create..path)
                            + ( attributes
                              .     (stroke..white)
                                  + (stroke-width.4)
                                  + (d..str$(M !x1 " " !y1 " " !x2 " " !y2))
                                , 
                              )
                            + (fromw.!from)
                            + (to.!to)
                            + (chrono.!kro)
                            + (ill.!text)
                          , 
                          )
                          (   (Create..path)
                            + ( attributes
                              .     (stroke..black)
                                  + (stroke-width.3)
                                  + (d..str$(M !x1 " " !y1 " " !x2 " " !y2))
                                , 
                              )
                            + (from.!from)
                            + (to.!to)
                            + (chrono.!kro)
                            + (ill.!text)
                          , 
                          )
                  )
                . !connections
                )
            : ?Edgez
          & jsn$(,!Edgez !steps):?stappen
          & (   !arg:createAndEnact
              &   ( svg
                  .     (id.svgwortel)
                        (width.!canvasX)
                        (height.!canvasY)
                        (viewBox.str$("0 0 " !canvasX " " !canvasY))
                        (onload."main(evt)")
                    ,   ( rect
                        .     (class.Border)
                              (x.1)
                              (y.1)
                              (width.!canvasX+-2)
                              (height.!canvasY+-2)
                              (fill.white)
                              (stroke.lightblue)
                              (stroke-width.3)
                              (stroke-linejoin.round)
                          , 
                        )
                        (g.(id.ip2) (transform."rotate(0)"),)
                        ( text
                        .     (id.input)
                              (x.div$(1/2*!canvasX.1)+-40)
                              (y.21)
                              (font-size.smaller)
                          , input
                        )
                        ( text
                        .     (id.uploaded)
                              (x.div$(1/2*!canvasX.1)+17)
                              (y.21)
                              (font-size.smaller)
                          , "(" localized$("uploaded by the user" "som brugeren har uploadet") ")"
                        )
                        ( text
                        .     (id.output)
                              (x.div$(1/2*!canvasX.1)+-47)
                              (y.!canvasY+-15)
                              (font-size.smaller)
                          , output
                        )
                        ( text
                        .     (id.goal)
                              (x.div$(1/2*!canvasX.1)+17)
                              (y.!canvasY+-15)
                              (font-size.smaller)
                          ,   "("
                                localized
                              $ ("goal as set by the user" "m√•l som brugeren har specificeret")
                              ")"
                        )
                  )
                  ( script
                  .   
                    ,   "
var svgns = 'http://www.w3.org/2000/svg';
var steps = "
                        !stappen
                        ";

function navigationShape(cx,cy,shape,g) {
    var knap = document.createElementNS(svgns, 'path');
    knap.setAttribute('stroke','currentcolor');
    knap.setAttribute('stroke-linecap','round');
    knap.setAttribute('stroke-linejoin','round');
    knap.setAttribute('stroke-width','2');
    d = '';
    switch(shape) {
        case -2:
            d = 'M'+(cx-7)+' '+(cy-14)+' L'+(cx-7)+' '+(cy)+' '+(cx+7)+' '+(cy-14)+' '+(cx+7)+' '+(cy+14)+' '+(cx-7)+' '+(cy)+' '+(cx-7)+' '+(cy+14)+'';
            break;
        case -1:
            d = 'M'+(cx-7)+' '+(cy)+' L'+(cx+7)+' '+(cy-14)+' '+(cx+7)+' '+(cy+14)+' '+(cx-7)+' '+(cy)+'';
            break;
        case 0:
            break;
        case 1:
            d = 'M'+(cx+7)+' '+(cy)+' L'+(cx-7)+' '+(cy-14)+' '+(cx-7)+' '+(cy+14)+' '+(cx+7)+' '+(cy)+'';
            break;
        case 2:
            d = 'M'+(cx+7)+' '+(cy-14)+' L'+(cx+7)+' '+(cy)+' '+(cx-7)+' '+(cy-14)+' '+(cx-7)+' '+(cy+14)+' '+(cx+7)+' '+(cy)+' '+(cx+7)+' '+(cy+14)+'';
            break;
    }
    knap.setAttribute('d', d);
    knap.setAttribute('fill', 'black');
    g.appendChild(knap);
    return knap;
}

function ei(chrono, trin, cx, cy, r) {
    var g = document.createElementNS(svgns, 'g');

    function plotThing(thing) {
        var create = thing['Create'];
        var thng = document.createElementNS(svgns, thing['Create']);
        attrbutes = thing['attributes'];
        var keys = Object.keys(attrbutes);
        var j;
        for(j = 0;j < keys.length;++j){
            thng.setAttribute(keys[j],attrbutes[keys[j]]);
        }

        keys = Object.keys(thing);
        var Here = -1;
        var From = -1;
        var To = -1;
        for (i = 0; i < keys.length; i++) {
            if (keys[i] == 'step') {
                Here = thing['step'];
                name = 'step'+Here;
                break;
            }
            else if (keys[i] == 'from')  {
                From = thing['from'];
                To = thing['to'];
                name = 'from' + From + 'to'+To;
                break;
            }
            else if (keys[i] == 'fromw')  {
                From = thing['fromw'];
                To = thing['to'];
                name = 'fromw' + From + 'to'+To;
                break;
            }
        }
        thng.setAttribute('id',name);
        if(Here == 0 || Here == 12)
            thng.setAttribute('opacity',1);
        else
            thng.setAttribute('opacity',0.15);
        g.appendChild(thng);
    }


    this.chrono = chrono;
    this.trin = trin;
    var svg = this;

    this.homenode = navigationShape("
                        div$(!canvasX*3/4.1)
                        ","
                        53
                        ",-2,g);
    this.previousnode = navigationShape("
                        div$(!canvasX*3/4.1)+30
                        ","
                        53
                        ",-1,g);
    this.nextnode = navigationShape("
                        div$(!canvasX*3/4.1)+60
                        ","
                        53
                        ",1,g);
    this.endnode = navigationShape("
                        div$(!canvasX*3/4.1)+90
                        ","
                        53
                        ",2,g);
    steps.forEach(plotThing);

    this.svg = g;
    //this.root2 = document.getElementById('svgwortel');

    this.homenode.addEventListener('click', clickhome, false);
    this.previousnode.addEventListener('click', clickfewer, false);
    this.nextnode.addEventListener('click', clickmore, false);
    this.endnode.addEventListener('click', clickend, false);

    var ip2 = document.getElementById('ip2');
    ip2.appendChild(this.svg);

    return g;
};

var chrono = -1;
var trin = 0;

function updateVis2(trin) {

    function updateThing(thing) {
        keys = Object.keys(thing);
        var Here = -1;
        var From = -1;
        var To = -1;
        for (i = 0; i < keys.length; i++) {
            if (keys[i] == 'step') {
                Here = thing['step'];
                ill = thing['react'];
                name = 'step'+Here;
                if(Here == trin) {
                    enact = thing['enact'];
                }
                break;
            }
            else if (keys[i] == 'from')  {
                From = thing['from'];
                To = thing['to'];
                name = 'from' + From + 'to'+To;
                break;
            }
            else if (keys[i] == 'fromw')  {
                From = thing['fromw'];
                To = thing['to'];
                name = 'fromw' + From + 'to'+To;
                break;
            }
        }

        if(Here == 0 || Here == 12)
            return;

        thenums = name.match(/\\d+/g);
        visibility = 'visible';
        opacity = 1;
        thenums.forEach(function(thenum) {
            if(thenum > trin) {
                visibility = 'hidden';
                opacity = 0.15;
            }
        });

        thng = document.getElementById(name);

//        thng.setAttribute('visibility',visibility);
        thng.setAttribute('opacity',opacity);
    }
    enact = -1;
    steps.forEach(updateThing);
    for (text = 0;text < 23;++text) {
        id = 'enact'+text;
        li = document.getElementById(id);
        if(li != null) {
            if(text == enact) {
                li.setAttribute('style','background-color:yellow');
            }
            else {
                li.setAttribute('style','background-color:white');
            }
        }
    }
}

function updateVis3(chrono) {

    function updateThing(thing) {
        keys = Object.keys(thing);
        var Here = -1;
        var From = -1;
        var To = -1;
        for (i = 0; i < keys.length; i++) {
            if (keys[i] == 'step') {
                Here = thing['step'];
                name = 'step'+Here;
                break;
            }
            else if (keys[i] == 'from')  {
                From = thing['from'];
                To = thing['to'];
                name = 'from' + From + 'to'+To;
                break;
            }
            else if (keys[i] == 'fromw')  {
                From = thing['fromw'];
                To = thing['to'];
                name = 'fromw' + From + 'to'+To;
                break;
            }
        }

        theChrono = thing['chrono'];

        if(Here == 0 || Here == 12)
            return;

        visibility = 'visible';
        opacity = 1;
        if (theChrono > chrono) {
            visibility = 'hidden';
            opacity = 0.15;
        }
        else if(theChrono == chrono) {
            ill = thing['ill'];
            if(ill != null) {
                theId = ill;
            }
        }


        thng = document.getElementById(name);

        thng.setAttribute('visibility',visibility);
        thng.setAttribute('opacity',opacity);
    }
    theId = 1;
    steps.forEach(updateThing);
    for (text = 0;text < 23;++text) {
        id = 'pole'+text;
        li = document.getElementById(id);
        if(li != null) {
            if(text == theId) {
                li.setAttribute('style','background-color:yellow');
            }
            else {
                li.setAttribute('style','background-color:white');
            }
        }
    }
}

function whiteoutEnact(evt) {
    for (j = 0;j < 23;++j) {
        id = 'enact'+j;
        li = document.getElementById(id);
        if(li != null) {
            li.setAttribute('style','background-color:white');
        }
    }
}

function whiteoutComp(evt) {
    for (j = 0;j < 23;++j) {
        id = 'pole'+j;
        li = document.getElementById(id);
        if(li != null) {
            li.setAttribute('style','background-color:white');
        }
    }
}

function clickhome(evt) {
    chrono = 0;
    trin = 0;
    updateVis3(chrono);
    whiteoutEnact(evt);
}

function clickfewer(evt) {
    if (chrono > 0) {
        chrono -= 1;
        if(chrono <= 23) {
            if(chrono == 23) {
                for (text = 0;text < 23;++text) {
                    id = 'enact'+text;
                    li = document.getElementById(id);
                    if(li != null) {
                        li.setAttribute('style','background-color:white');
                    }
                }
            }
            updateVis3(chrono);
        }
        else {
            trin = chrono - 24;
            updateVis2(trin);
        }
    }
}

function clickmore(evt) {
    if(chrono < (23+12+1)) {
        chrono += 1;
        if(chrono <= 23) {
            updateVis3(chrono);
        }
        else {
            if(chrono == 24) {
                for (text = 0;text < 23;++text) {
                    id = 'pole'+text;
                    li = document.getElementById(id);
                    if(li != null) {
                        li.setAttribute('style','background-color:white');
                    }
                }
            }
            trin = chrono - 24;
            updateVis2(trin);
        }
    }
}

var endat = 0;

function clickend(evt) {
    whiteoutComp(evt);
    whiteoutEnact(evt);
    endat = (1-endat);
    if(endat == 1) {
        chrono = 23;
        trin = 0;
        updateVis3(chrono);
    }
    else {
        chrono = 23+12+1;
        trin = chrono - 24;
        updateVis2(trin);
    }
}

function main(evt) {
    new ei(chrono, trin, 100, 100, 45);
}
"
                  )
            |   ( svg
                .     (id.svgwortel2)
                      (width.!canvasX)
                      (height.!canvasY)
                      (viewBox.str$("0 0 " !canvasX " " !canvasY))
                      (onload."main2(evt)")
                  ,   ( rect
                      .     (class.Border)
                            (x.1)
                            (y.1)
                            (width.!canvasX+-2)
                            (height.!canvasY+-2)
                            (fill.white)
                            (stroke.lightblue)
                            (stroke-width.3)
                            (stroke-linejoin.round)
                        , 
                      )
                      (g.(id.ip3) (transform."rotate(0)"),)
                )
                ( script
                .   
                  ,   "
var steps2 = "
                      !stappen
                      ";
var state = 0;

function yolk(cx, cy, r) {
    var g = document.createElementNS(svgns, 'g');

    function plotThing(thing) {
        var create = thing['Create'];
        var thng = document.createElementNS(svgns, thing['Create']);
        attrbutes = thing['attributes'];
        var keys = Object.keys(attrbutes);
        var j;
        for(j = 0;j < keys.length;++j){
            thng.setAttribute(keys[j],attrbutes[keys[j]]);
        }

        keys = Object.keys(thing);
        var Here = -1;
        var From = -1;
        var To = -1;
        for (i = 0; i < keys.length; i++) {
            if (keys[i] == 'step') {
                Here = thing['step'];
                name = 'sdep'+Here;
                break;
            }
            else if (keys[i] == 'from')  {
                From = thing['from'];
                To = thing['to'];
                name = 'frrom' + From + 'to'+To;
                console.log('name:'+name);
                break;
            }
            else if (keys[i] == 'fromw')  {
                From = thing['fromw'];
                To = thing['to'];
                name = 'frromw' + From + 'to'+To;
                console.log('name:'+name);
                break;
            }
        }
        thng.setAttribute('id',name);
        thng.setAttribute('opacity',1);
        if(From == 3 || From == 8)
            thng.setAttribute('stroke-dasharray','20,10');
        g.appendChild(thng);
    }

    var svg2 = this;

    this.startstate = navigationShape("
                      div$(!canvasX*3/4.1)
                      ","
                      53
                      ",-2,g);
    this.previousstate = navigationShape("
                      div$(!canvasX*3/4.1)+30
                      ","
                      53
                      ",-1,g);
    this.nextstate = navigationShape("
                      div$(!canvasX*3/4.1)+60
                      ","
                      53
                      ",1,g);
    this.endstate = navigationShape("
                      div$(!canvasX*3/4.1)+90
                      ","
                      53
                      ",2,g);

    steps2.forEach(plotThing);

    this.svg2 = g;
    //this.root2 = document.getElementById('svgwortel');

    this.startstate.addEventListener('click', clickStartState, false);
    this.previousstate.addEventListener('click', clickPreviousState, false);
    this.nextstate.addEventListener('click', clickNextState, false);
    this.endstate.addEventListener('click', clickEndState, false);

    var ip3 = document.getElementById('ip3');
    ip3.appendChild(this.svg2);

    return g;
};

function updateVis4(state) {

    function updateThing(thing) {
        keys = Object.keys(thing);
        console.log('keys:'+keys);
        var Here = -1;
        var From = -1;
        var To = -1;
        for (i = 0; i < keys.length; i++) {
            if (keys[i] == 'step') {
                Here = thing['step'];
                name = 'sdep'+Here;
                console.log('Here:'+Here);
                break;
            }
            else if (keys[i] == 'from')  {
                From = thing['from'];
                To = thing['to'];
                console.log('From:'+From+' To:'+To);
                name = 'frrom' + From + 'to'+To;
                break;
            }
            else if (keys[i] == 'fromw')  {
                From = thing['fromw'];
                To = thing['to'];
                console.log('From:'+From+' To:'+To);
                name = 'frromw' + From + 'to'+To;
                break;
            }
        }

        thenums = name.match(/\\d+/g);
        console.log('thenums:'+thenums);
        opacity = 1;

        switch(state) {
            case 1:
                break;
            case 2:
                thenums.forEach(function(thenum) {
                    if(thenum > 5 && thenum < 10) {
                        opacity = 0.15;
                    }
                });
                break;
            case 3:
                if(  From == 8 && (To == 10 || To == 20)
                  || From == 3 && To == 30
                  )
                    opacity = 0.15;
                break;
            case 4:
                if(  From == 8 && (To == 10 || To == 30)
                  || From == 3 && To == 20
                  )
                    opacity = 0.15;
                break;
            case 5:
                if(  From == 8 && (To == 20 || To == 30)
                  || From == 3 && To == 10
                  )
                    opacity = 0.15;
                break;
            case 6:
                if(  From == 8 && To == 10
                  || From == 3 && (To == 20 || To == 30)
                  )
                    opacity = 0.15;
                break;
            case 7:
                if(  From == 8 && To == 20
                  || From == 3 && (To == 10 || To == 30)
                  )
                    opacity = 0.15;
                break;
            case 8:
                if(  From == 8 && To == 30
                  || From == 3 && (To == 10 || To == 20)
                  )
                    opacity = 0.15;
                break;
            case 9:
                thenums.forEach(function(thenum) {
                    if(thenum < 5 ) {
                        opacity = 0.15;
                    }
                });
        }

        thng = document.getElementById(name);
        if(thng) {
            thng.setAttribute('opacity',opacity);
            if(From == 8 || From == 3) {
                if(state == 1) {
                    thng.setAttribute('stroke-dasharray','20,10');
                }
                else {
                    thng.setAttribute('stroke-dasharray','');
                }
            }
        }

    }
    steps2.forEach(updateThing);
    for (text = 0;text < 23;++text) {
        id = 'unprun'+text;
        li = document.getElementById(id);
        if(li != null) {
            if(text == state) {
                li.setAttribute('style','background-color:yellow');
            }
            else {
                li.setAttribute('style','background-color:white');
            }
        }
    }
}

function clickStartState(evt) {
    state = 1;
    updateVis4(state);
}

function clickPreviousState(evt) {
    if (state > 1) {
        state -= 1;
        updateVis4(state);
    }
}

function clickNextState(evt) {
    if(state < 9) {
        state += 1;
        updateVis4(state);
    }
}

function clickEndState(evt) {
    state = 9;
    updateVis4(state);
}


function main2(evt) {
    new yolk(100, 100, 45);
}
"
                )
            )
      )
      ( countGraphNodes
      =   count tools feats feat i o cnt tcnt fcnt tool
        .   "Unfold toolprop. Each subspecification doubles count due to specification.
             Counts 360 tools that are active (not 'inactive') 20130424"
          & readTable$toolprop
          & readTable$tooladm
          & !toolprop:?tools
          & ( count
            =   ret term spcno factor spcs
              .   0:?ret
                &   whl
                  ' ( !arg:%?term+?arg
                    & 1:?spcno
                    &   whl
                      ' ( !term
                        :   ?
                          * ( ((%?factor:~1) %?spcs)*?term
                            &   whl
                              ' ( !spcs:% ?spcs
                                & !spcno+!spcno:?spcno
                                )
                            )
                        )
                    & !ret+!spcno:?ret
                    )
                & !ret
            )
          & 0:?cnt
          &   whl
            ' (   !tools
                :   ?
                  + (   ?tool
                      &   !tooladm
                        :   ?
                          + ( ? (ToolID.!tool) ?
                            : ? (Inactive.) ?
                            )
                          + ?
                    . ?feats
                    )
                  + ?tools
              & 1:?tcnt
              &   whl
                ' ( !feats:(?,?feat) ?feats
                  & 0:?fcnt
                  &   whl
                    ' ( !feat:(?i.?o)+?feat
                      & !fcnt+count$!i*count$!o:?fcnt
                      )
                  & !tcnt*!fcnt:?tcnt
                  )
              & !cnt+!tcnt:?cnt
              )
          & !cnt
      )
      (Uploads=)
      (LaNg=)
      (lANgs=en da)
      "
/*****************************
 * BRACMAT FUNCTIONS         *
 * THAT ARE CALLED FROM JAVA *
 *                           *
 * IN ALPHABETIC ORDER       *
 *****************************
  ChangeLog: called from changelog.java
  abortJob: called from util.java, workflow.java
  chosenworkflow: called from chosenworkflow.java
  clean: called from reloadScript.java
  cleanup: called from cleanup.java
  doneJob: called from util.java
  entry: called from entry.java
  exportTables: called from exportMetadata.java
  getJobArg: called from workflow.java
  getNextJobID: called from workflow.java
  getStatusCode: called from exportMetadata.java, register.java, setLanguage.java, stresstest.java, update.java, upload.java
  goodRunningThreads: called from compute.java, upload.java, workflow.java
  help: called from help.java
  importTables: called from importMetadata.java
  isTEIoutput: called from util.java
  keep: called from cleanup.java
  letter: called from zipresults.java
  parseStatusCode: called from upload.java
  parsemessage: called from upload.java
  percentEncodeURL: called from compute.java, workflow.java
  poll: called from poll.java
  readJobTables: called from cleanup.java
  register: called from register.java
  saveJobTables: called from cleanup.java
  setLanguage: called from setLanguage.java
  showworkflows: called from showworkflows.java
  specifyGoal: called from specifyGoal.java
  storeUpload: called from compute.java
  stresstest: called from stresstest.java
  toolsdata: called from util.java, workflow.java
  unstore: called from compute.java
  update: called from update.java
  upload: called from upload.java
  uploadJobID: called from upload.java
  uploadJobNr: called from upload.java
  usermsg: called from usermsg.java
  waitingJob: called from workflow.java
 "
      "
/**
 * ChangeLog
 *
 * Produce an HTML page with changes to the Text Tonsorium or any of its
 * integrated tools. Read data from the table 'changelog'.
 *
 * Called from changelog.java
 */"
      ( ChangeLog
      =   change dd futureuse mm yyyy
        .   log$CHANGELOG
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & log$(ChangeLog !arg)
          & readTable$changelog:?changelog
          &   toML
            $ ( HTML-SVG-bodyContainer
              $ ( ChangeLog
                .   (h1.,"Text Tonsorium - Changelog")
                    ( dl
                    .   
                      ,   map
                        $ ( ( 
                            =   
                              .     !arg
                                  : ( @( ?
                                       :   (% % % %:?yyyy)
                                           (% %:?mm)
                                           (% %:?dd)
                                       )
                                    . ?futureuse
                                    . ?change
                                    )
                                &   (dt.,!yyyy "-" !mm "-" !dd)
                                    (dd.,localized$!change)
                            )
                          . !changelog
                          )
                    )
                )
              )
      )
      "
/**
 * abortJob
 *
 * Aborts, given a JobNr and a jobID, the specified job and all
 * pending jobs that depend on the output from the (now aborted) job.
 * Rather than removing the aborted jobs from the jobs.table list, they are
 * marked 'aborted'.
 *
 * Called from util.java, workflow.java
 */"
      ( abort-job
      =   abort JobNr jobID todelete jobs myjobs seen
        .   log$abort-job
          & !arg:(?jobs.?JobNr.?jobID)
          &     map
              $ ( ( 
                  =   
                    .   !arg:(!JobNr.?arg)&!arg
                      | 
                  )
                . !jobs
                )
            : ?myjobs
          & notseen:?seen
          &     map
              $ ( ( 
                  =   
                    .     !arg:(!JobNr.?)
                        & (   !seen:notseen
                            & seen:?seen
                            & (!JobNr.!myjobs)
                          | 
                          )
                      | !arg
                  )
                . !jobs
                )
            : ?jobs
          & (!JobNr.!jobID):?todelete
          & ( abort
            =     JobNr jobID jobid2 A Z B Y ZZ a z
                , URL tool items todelete
              .   !arg:(?JobNr.?jobID) ?todelete
                & log$(abort !arg)
                & !jobs:?A (!JobNr.?myjobs) ?Z
                &   !myjobs
                  :   ?B
                      ( !jobID ~aborted
                      . ?items&inputResources$!items:?items
                      . ?URL&toolName$!URL:?tool
                      . ?ZZ
                      )
                      ?Y
                &   !B (!jobID aborted.!items.!URL.!ZZ) !Y
                  : ?myjobs
                &   whl
                  ' (   !myjobs
                      :   ?B
                          ( %?jobid2 ?
                          . ?a (!jobID,pending) ?z
                          . ?URL&toolName$!URL:?tool
                          . ?ZZ
                          )
                          ?Y
                    &   !B (!jobid2.!a !jobID !z.!URL.!ZZ) !Y
                      : ?myjobs
                    & (!JobNr.!jobid2) !todelete:?todelete
                    )
                & !A (!JobNr.!myjobs) !Z:?jobs
                & !todelete
            )
          & whl'(abort$!todelete:?todelete)
          & !jobs
      )
      ( abortJob
      =   abort JobNr jobID todelete
        .   readTable$jobs
          & log$("abortJob " !arg)
          & !arg:(@(?:? #?JobNr).%?jobID ?)
          & abort-job$(!jobs.!JobNr.!jobID):?jobs
          & saveTable$jobs
      )
      ( workflowSVG
      =     M SVG a b calc code
          , dimensions dimpla iterations extractEdges
          , planets pointsTTT x y z nameedges
          , MM col degreeSum desc fr nn to
          , xx1 xx2 xmax xmin yy1 yy2 ymax ymin
          , some breuk F M/planets2 W dampeningDoneDhreshold
          , degrees dimensions epsilon freezing hasCrossing
          , iterations maxn nlinks noCrossing planets q
          , evry planettitles titlelinks
          , NN lineno linkcolour linkcolours ll
          , planetcolour planetcolours planetstates plnt
          , strngth xx xxs xxyy yys
          , G MASS chargeLowerBound circles export extra lines links
          , linkstate linkstates margin planetstate pt
          , q-1 qexp radius shortLine sprintweak xwidth ywidth yy
          , ( UFP
            .   CROSS
                D
                DD
                Diff
                F
                H01
                H23
                K
                LineAcc
                M
                M/planets2
                N
                Nlinks
                product
                Qp
                Qq
                R
                ScalarTimesVector
                StringEnergy
                W
                X
                Y
                acceleration
                addForceBetweenLines
                b
                bestcrossingLink
                block
                btween
                changed
                closestCrossingLink
                coulomb
                cross
                crossedRay
                crosses
                crossingLink
                cumNStringEnergy
                cumPStringEnergy
                d
                dampeningDoneDhreshold
                degrees
                delta
                diagonal
                dimensions
                dist1
                dist2
                divide
                done
                dx
                dy
                elastiek
                epsilon
                extent
                fabs
                factor
                fp
                fq
                fractionGiven
                fractionKept
                fractionTaken
                freezing
                gradient
                hasCrossing
                hypot
                idx
                increase
                init
                initLinkRelations
                initMinDistances
                initPointLinks
                initstrengths
                inn
                inproduct
                iterations
                link
                link2
                maxgain
                maxn
                mobility
                n
                needChangeSide
                needed
                nlinks
                noCrossing
                p
                pA
                pB
                pK
                pM
                perhapsCrossing
                planet
                planets
                point
                pointlinks
                position
                q
                qA
                qB
                qK
                qM
                rand
                ray
                snap
                sqr
                sqrt
                st2
                st8
                strength
                subtract
                unchanged
                uncrossedRay
                unrelatedLink
                updateLinkRelation
                updatePointLink
                vector
                vectorDifference
                velocity
                x
                xtn
                y
            )
        .   !arg:(?planettitles.?titlelinks)
          & !planettitles:? [?planets
          & ( breuk
            =   a b
              .   @(!arg:?a "/" ?b)&str$(!a "_" !b)
                | !arg
            )
          & 2:?dimensions
          & 2200:?iterations
          & 7/10:?freezing
          & -1+!iterations:?maxn
          & "Repelling coulomb force constant."
          & 5000:?MASS
          & !MASS*!planets^-2:?M/planets2
          & 1/50:?chargeLowerBound
          & "Coordinate origin."
          & "Spring constant"
          & 1500:?sprintweak
          & -1*!sprintweak^-1:?F
          & "W non-friction, mobility"
          & 29/30:?W
          & "shortLine: repulsion between line and a vertex is as from a superelipse with lenght/width=linelength/shortLine=K."
          & 8:?shortLine
          & "q: an exponent. The higher, the faster the repelling force from en edge diminishes with distance."
          & 8:?q
          & "q = 2, 4, 6, ...  Even, so we don't need to compute absolute values. If 2, normal Coulomb repulsion."
          & -1*(1+!q^-1):?qexp
          & -1*!q^-1:?qexp
          & !q+-1:?q-1
          & "G: Constant factor of line-repelling force. Higher value implies stronger force.
             Unit of acceleration due to 'PietHein' repulsion between vertex and edge.
             (The Danish Piet Hein invented the superellipse table. (The Dutch one 'won de zilvervloot'.))"
          & 25000:?G
          & !M/planets2:?G
          & 3/10:?dampeningDoneDhreshold
          & 5:?epsilon
          & "As in 1/(epsilon+distance), to get rid of runaway."
          & !dimensions*!planets:?dimpla
          & !titlelinks:? [?nlinks
          & 0:?degreeSum
          &   map
            $ ( ( 
                =   
                  .   !arg:(?,%?a %?b)
                    & (.!a)+(.!b)+!degreeSum:?degreeSum
                )
              . !titlelinks
              )
          &     mop
              $ ( ( 
                  =   n vertex
                    . !arg:?n*(.?vertex)&(,!vertex !n)
                  )
                . !degreeSum
                . (=+)
                )
            : ?degrees
          & "
         pointlinks[0] values:
        "
          & -77:?closestCrossingLink
          & 0:?unrelatedLink
          & 1:?uncrossedRay
          & 2:?crossedRay
          & "
         linkrelation values:
        "
          & -4:?perhapsCrossing
          & -3:?noCrossing
          & -2:?hasCrossing
          & -1:?diagonal
          & "The code below will be evaluated by a UFP object (UnIfancyfied Floating Point)"
          &     
              ' ( (a.links,$nlinks,2) (a.degrees,$planets,2)
                .   tbl$(Diff,$planets,$planets,$dimensions)
                  & tbl$(dist2,$planets,$planets)
                  & "dist1 is just sqrt of dist2"
                  & tbl$(dist1,$planets,$planets)
                  & tbl$(position,$planets,$dimensions)
                  & tbl$(velocity,$planets,$dimensions)
                  & tbl$(acceleration,$planets,$dimensions)
                  & tbl$(xy,2)
                  & tbl$(strength,$nlinks)
                  & tbl$(linkstate,$nlinks,$iterations)
                  & tbl$(planetstate,$planets,$iterations)
                  & "linkrelation[k,l] 
                        if perhaps crossing of line segments: -4; (needs to be computed) $perhapsCrossing
                        if no crossing of line segments:      -3; (has been computed)    $noCrossing
                        if crossing of line segments:         -2; (has been computed)    $hasCrossing
                        if no crossing of line segments:      -1; (diagonal)             $diagonal
                        else:                             number of common vertex
                     "
                  & tbl$(linkrelation,$nlinks,$nlinks)
                  & "pointlinks[planet,link,0]
                       If link is the closest crossing link of a link2 emanating from planet:   3 $closestCrossingLink
                       If planet is enpoint of crossed link:                                    2 $crossedRay
                       If planet is enpoint of uncrossed link:                                  1 $uncrossedRay
                       If planet is not endpoint of link:                                       0 $unrelatedLink
                 pointlinks[planet,link,1]: number of closest crossing link, or -1 (if pointlinks[planet,link,0] != $closestCrossingLink)
                 pointlinks[planet,link,1]: gain if planet moves over the link     (if pointlinks[planet,link,0] == $closestCrossingLink)
                 pointlinks[planet,link,2]: distance from vertex to closest crossing link, initially a large number
                 "
                  & tbl$(pointlinks,$planets,$nlinks,3)
                  & ( initstrengths
                    =   (a.strength)
                      .   $nlinks:?N
                        &   whl
                          ' ( !N:>0
                            & -1+!N:?N
                            & 1:?(idx$(strength,!N))
                            )
                    )
                  & ( initPointLinks
                    =   (a.pointlinks) (a.links)
                      .   $planets:?planet
                        &   whl
                          ' ( !planet:>0
                            & -1+!planet:?planet
                            & $nlinks:?link
                            &   whl
                              ' ( !link:>0
                                & -1+!link:?link
                                &   $unrelatedLink
                                  : ?(idx$(pointlinks,!planet,!link,0))
                                & 0:?(idx$(pointlinks,!planet,!link,1))
                                & 0:?(idx$(pointlinks,!planet,!link,2))
                                )
                            )
                        & $nlinks:?link
                        & "Make planets (uncrossed) endpoints of links."
                        &   whl
                          ' ( !link:>0
                            & -1+!link:?link
                            &   $uncrossedRay
                              : ?(idx$(pointlinks,!(idx$(links,!link,0)),!link,0))
                            &   $uncrossedRay
                              : ?(idx$(pointlinks,!(idx$(links,!link,1)),!link,0))
                            )
                        & 1
                    )
                  & ( initMinDistances
                    =   (a.pointlinks)
                      .   $planets:?planet
                        &   whl
                          ' ( !planet:>0
                            & -1+!planet:?planet
                            & $nlinks:?link
                            &   whl
                              ' ( !link:>0
                                & -1+!link:?link
                                & (   !(idx$(pointlinks,!planet,!link,0))
                                    : $unrelatedLink
                                  |   !pointlinks:$closestCrossingLink
                                    & 0:?(idx$(pointlinks,!planet,!link,1))
                                  |   $uncrossedRay:?pointlinks
                                    & -1:?(idx$(pointlinks,!planet,!link,1))
                                    &   "0x1.fffffffffffffp+1023"
                                      : ?(idx$(pointlinks,!planet,!link,2))
                                  )
                                )
                            )
                        & 1
                    )
                  & ( initLinkRelations
                    =   (a.linkrelation) (a.links)
                      .   $nlinks:?K
                        &   whl
                          ' ( !K:>0
                            & -1+!K:?K
                            & $nlinks:?M
                            &   whl
                              ' ( !M:>0
                                & -1+!M:?M
                                & idx$(linkrelation,!K,!M)
                                & (   !K:!M
                                    & $diagonal:?linkrelation
                                  |   !(idx$(links,!K,0)):?pK
                                    & !(idx$(links,!K,1)):?qK
                                    & !(idx$(links,!M,0)):?pM
                                    & !(idx$(links,!M,1)):?qM
                                    & (   ( !pK:!pM
                                          | !qK:!pM
                                          )
                                        & !pM:?linkrelation
                                      |   ( !pK:!qM
                                          | !qK:!qM
                                          )
                                        & !qM:?linkrelation
                                      )
                                  | $perhapsCrossing:?linkrelation
                                  )
                                )
                            )
                    )
                  & ( updatePointLink
                    =     (a.position)
                          (a.pointlinks)
                          (a.links)
                          (s.planet)
                          (s.link)
                          (s.crossingLink)
                          (s.x)
                          (s.y)
                      .   !(idx$(position,!planet,0)):?X
                        & !(idx$(position,!planet,1)):?Y
                        & subtract$(!X,!x):?dx
                        & subtract$(!Y,!y):?dy
                        & hypot$(!dx,!dy):?dist2
                        & (   !(idx$(pointlinks,!planet,!link,2)):>!dist2
                            & !dist2:?pointlinks
                            & !crossingLink:?(idx$(pointlinks,!planet,!link,1))
                            & "Planet is endpoint of crossed link"
                            & $crossedRay:?(idx$(pointlinks,!planet,!link,0))
                          | 
                          )
                    )
                  & ( updateLinkRelation
                    =     (s.A)
                          (s.B)
                          (a.xy)
                          (a.links)
                          (a.pointlinks)
                          (a.position)
                      .   !(idx$(links,!A,0)):?pA
                        & !(idx$(links,!A,1)):?qA
                        & !(idx$(links,!B,0)):?pB
                        & !(idx$(links,!B,1)):?qB
                        & !(idx$(xy,0)):?x
                        & !(idx$(xy,1)):?y
                        & "Check for each of the four end points of the two crossing lines whether the crossing line
                       is closer to the point than other, already checked crossing lines. Updates pointlinks."
                        & updatePointLink$(position,pointlinks,links,!pA,!A,!B,!x,!y)
                        & updatePointLink$(position,pointlinks,links,!qA,!A,!B,!x,!y)
                        & updatePointLink$(position,pointlinks,links,!pB,!B,!A,!x,!y)
                        & updatePointLink$(position,pointlinks,links,!qB,!B,!A,!x,!y)
                    )
                  & ( init
                    =   (a.matrix) (s.rang)
                      .   extent$(matrix,0):?xtn
                        &   whl
                          ' ( !xtn:>0
                            & -1+!xtn:?xtn
                            & $dimensions:?D
                            &   whl
                              ' ( !D:>0
                                & -1+!D:?D
                                & rand$!rang:?(idx$(matrix,!xtn,!D))
                                )
                            )
                        & 0
                    )
                  & "Return 1 if second value is between first and third value, 0 otherwise."
                  & ( btween
                    =   (s.a) (s.m) (s.z)
                      .   (   (   !a:<!z
                                & !a:<!m
                                & !m:<!z
                              |   !a:>!z
                                & !a:>!m
                                & !m:>!z
                              )
                            & 1:?R
                          | 0:?R
                          )
                        & !R
                    )
                  & ( gradient
                    =   (s.a) (s.b) (s.c) (s.d)
                      . divide$(subtract$(!a,!b),subtract$(!c,!d))
                    )
                  & ( cross
                    =     (s.x0)
                          (s.y0)
                          (s.x1)
                          (s.y1)
                          (s.x2)
                          (s.y2)
                          (s.x3)
                          (s.y3)
                          (a.xy)
                      .   gradient$(!y0,!y1,!x0,!x1):?H01
                        & gradient$(!y2,!y3,!x2,!x3):?H23
                        &     divide
                            $ ( subtract$(!y2+!H01*!x0,!y0+!H23*!x2)
                              , subtract$(!H01,!H23)
                              )
                          : ?x
                        & (   btween$(!x0,!x,!x1):1
                            & btween$(!x2,!x,!x3):1
                            & !y0+subtract$(!x,!x0)*!H01:?y
                            & !y:?(idx$(xy,1))
                            & !x:?(idx$(xy,0))
                            & 1:?R
                          | 0:?R
                          )
                        & !R
                    )
                  & ( point
                    =   (a.position) (s.p) (a.pnt)
                      .   $dimensions:?d
                        &   whl
                          ' ( !d:>0
                            & -1+!d:?d
                            & !(idx$(position,!p,!d)):?(idx$(pnt,!d))
                            )
                        & 0
                    )
                  & ( inproduct
                    =   (a.vectorA) (a.vectorB)
                      .   0:?inn
                        & $dimensions:?d
                        &   whl
                          ' ( !d:>0
                            & -1+!d:?d
                            & !(idx$(vectorA,!d))*!(idx$(vectorB,!d))+!inn:?inn
                            )
                        & !inn
                    )
                  & ( ScalarTimesVector
                    =   (s.scalar) (a.vector) (a.product)
                      .   $dimensions:?d
                        &   whl
                          ' ( !d:>0
                            & -1+!d:?d
                            & !scalar*!(idx$(vector,!d)):?(idx$(product,!d))
                            )
                    )
                  & ( vectorDifference
                    =   (a.vectorA) (a.vectorB) (a.diffvector)
                      .   $dimensions:?d
                        &   whl
                          ' ( !d:>0
                            & -1+!d:?d
                            &   subtract$(!(idx$(vectorA,!d)),!(idx$(vectorB,!d)))
                              : ?(idx$(diffvector,!d))
                            )
                    )
                  & ( vector
                    =   (a.pointA) (a.pointB) (a.vectorAB)
                      .   $dimensions:?d
                        &   whl
                          ' ( !d:>0
                            & -1+!d:?d
                            &   subtract$(!(idx$(pointB,!d)),!(idx$(pointA,!d)))
                              : ?(idx$(vectorAB,!d))
                            )
                    )
                  & ( addForceBetweenLines
                    =     (a.position)
                          (a.acceleration)
                          (s.p)
                          (s.q)
                          (s.t)
                          (s.done)
                          (s.block)
                          (s.n)
                      .   0:?factor
                        & (   tbl$(P,$dimensions)
                            & tbl$(Q,$dimensions)
                            & tbl$(T,$dimensions)
                            & point$(position,!p,P)
                            & point$(position,!q,Q)
                            & point$(position,!t,T)
                            & tbl$(PT,$dimensions)
                            & tbl$(PQ,$dimensions)
                            & tbl$(PS,$dimensions)
                            & tbl$(ST,$dimensions)
                            & tbl$(LineAcc,$dimensions)
                            & vector$(P,T,PT)
                            & vector$(P,Q,PQ)
                            &   divide$(inproduct$(PT,PQ),inproduct$(PQ,PQ))
                              : ?fq
                            & (   !fq:>0
                                & !fq:<1
                                & subtract$(1,!fq):?fp
                                & ScalarTimesVector$(!fq,PQ,PS)
                                & vectorDifference$(PT,PS,ST)
                                & inproduct$(ST,ST):?st2
                                & (   !st2:>0
                                    & ($epsilon+sqrt$!st2)^3:?st8
                                    & (   ( !block:1
                                          | !done:>($freezing)
                                          )
                                        & divide$(300,!st8):?factor
                                      |     divide$(!done^10*300,!st8)
                                          : ?factor
                                        & 0:?factor
                                      )
                                    & ScalarTimesVector$(!factor,ST,LineAcc)
                                    & 0:?d
                                    &   whl
                                      ' ( !d:<($dimensions)
                                        &     !(idx$(acceleration,!t,!d))
                                            + !(idx$(LineAcc,!d))
                                          : ?acceleration
                                        &     subtract
                                            $ (!(idx$(acceleration,!p,!d)),!fp*!LineAcc)
                                          : ?acceleration
                                        &     subtract
                                            $ (!(idx$(acceleration,!q,!d)),!fq*!LineAcc)
                                          : ?acceleration
                                        & 1+!d:?d
                                        )
                                  | 
                                  )
                              | 
                              )
                          | 
                          )
                    )
                  & ( needChangeSide
                    =     (a.pointlinks)
                          (a.linkrelation)
                          (a.links)
                          (a.strength)
                          (a.linkstate)
                          (a.planetstate)
                          (s.n)
                          (a.dist2)
                          (a.dist1)
                      .   "Reset linkstates."
                        & $nlinks:?link
                        &   whl
                          ' ( !link:>0
                            & -1+!link:?link
                            & 0:?(idx$(linkstate,!link,!n))
                            )
                        & "Decide for each planet separately whether it should move to the other
                               side of a line to diminish the number of line crossings."
                        & $planets:?planet
                        &   whl
                          ' ( !planet:>0
                            & -1+!planet:?planet
                            & $nlinks:?link
                            &   whl
                              ' ( !link:>0
                                & -1+!link:?link
                                & (   !(idx$(pointlinks,!planet,!link,0))
                                    : $crossedRay
                                  | !pointlinks:$uncrossedRay
                                  | $unrelatedLink:?pointlinks
                                  )
                                )
                            & $nlinks:?link
                            &   whl
                              ' ( !link:>0
                                & -1+!link:?link
                                & (     !(idx$(pointlinks,!planet,!link,0))
                                      : $crossedRay
                                    & "planet is endpoint of crossed link"
                                    & "Create relation between planet and crossing link."
                                    &   $closestCrossingLink
                                      : ?( idx
                                         $ ( pointlinks
                                           , !planet
                                           , !(idx$(pointlinks,!planet,!link,1))
                                           , 0
                                           )
                                         )
                                  | 
                                  )
                                )
                            & $nlinks:?crossingLink
                            &   whl
                              ' ( !crossingLink:>0
                                & -1+!crossingLink:?crossingLink
                                & (     !(idx$(pointlinks,!planet,!crossingLink,0))
                                      : $closestCrossingLink
                                    & "This link crosses at least one link emanating from planet. Check how many rays do and don't.
                                           First reset gain obtained by letting the planet move over the crossing link."
                                    &   0
                                      : ?(idx$(pointlinks,!planet,!crossingLink,1))
                                    & $nlinks:?ray
                                    &   whl
                                      ' ( !ray:>0
                                        & -1+!ray:?ray
                                        & ( !crossingLink:!ray
                                          |   idx$(pointlinks,!planet,!ray,0)
                                            & ( !pointlinks:$crossedRay
                                              | !pointlinks:$uncrossedRay
                                              )
                                            & "Link radiates from or to planet. Crossed or not."
                                            & idx$(pointlinks,!planet,!crossingLink,1)
                                            & (     !( idx
                                                     $ (linkrelation,!crossingLink,!ray)
                                                     )
                                                  : $hasCrossing
                                                & "crossingLink and ray cross. Moving planet to other side of crossingLink will remove a crossing. Good."
                                                & 1+!pointlinks:?pointlinks
                                              | !linkrelation:~<0
                                              |   "crossingLink and ray have nothing in common. Moving planet to other side of crossingLink will add a crossing. Bad."
                                                & -1+!pointlinks:?pointlinks
                                              | "crossingLink and ray have a planet in common. Moving planet to other side of crossingLink makes no difference."
                                              )
                                          | 
                                          )
                                        )
                                  | 
                                  )
                                )
                            & 0:?maxgain
                            & -1:?bestcrossingLink
                            & $nlinks:?crossingLink
                            &   whl
                              ' ( !crossingLink:>0
                                & -1+!crossingLink:?crossingLink
                                & (     !(idx$(pointlinks,!planet,!crossingLink,0))
                                      : $closestCrossingLink
                                    & (     !(idx$(pointlinks,!planet,!crossingLink,1))
                                          : >!maxgain
                                        & !pointlinks:?maxgain
                                        & !crossingLink:?bestcrossingLink
                                      | 
                                      )
                                  | 
                                  )
                                )
                            & -1:?(idx$(planetstate,!planet,!n))
                            & (   !maxgain:>0
                                & !bestcrossingLink:>-1
                                & "Remember that this planet wants to cross a particular crossing link."
                                & !bestcrossingLink:?planetstate
                                & $nlinks:?link
                                &   whl
                                  ' ( !link:>0
                                    & -1+!link:?link
                                    & (     !(idx$(linkrelation,!bestcrossingLink,!link))
                                          : $hasCrossing
                                        & "This link is crossed by the link that must be crossed. But is this link connecting to the planet?"
                                        & ( !(idx$(links,!link,0)):!planet
                                          | !(idx$(links,!link,1)):!planet
                                          )
                                        & "Yes, this planet is an endpoint. Make the link tighter. (But only if the link is not crossing another link that is also tightening. See further down.)
                                               But don't shorten if the link is already rather short."
                                        & ( 
                                          |   !( idx
                                               $ ( dist1
                                                 , !(idx$(links,!link,0))
                                                 , !(idx$(links,!link,1))
                                                 )
                                               )
                                            : >50
                                          )
                                        &   1+!(idx$(linkstate,!link,!n))
                                          : ?linkstate
                                      | 
                                      )
                                    )
                              | "This planet has no drive to transgress a line."
                              )
                            )
                        & "Finished examining for all planets whether they should move to the other side of a line or stay put.
                               Now do the moving."
                        & tbl$(StringEnergy,$nlinks)
                        & 0:?cumPStringEnergy
                        & 0:?cumNStringEnergy
                        & 0:?unchanged
                        & 0:?changed
                        & "At this point we have linkstate telling whether a link must get stronger or weaker."
                        & $nlinks:?link
                        &   whl
                          ' ( !link:>0
                            & -1+!link:?link
                            &     !(idx$(strength,!link))
                                * !( idx
                                   $ ( dist2
                                     , !(idx$(links,!link,0))
                                     , !(idx$(links,!link,1))
                                     )
                                   )
                              : ?(idx$(StringEnergy,!link))
                            & (   !(idx$(linkstate,!link,!n)):>0
                                & (   100/99*!strength:<($planets)
                                    & "Link gets stronger, because it is not already too strong and linkstate is positive."
                                    & $nlinks:?link2
                                    &   whl
                                      ' ( !link2:>0
                                        & -1+!link2:?link2
                                        & ( !link2:!link
                                          |   !(idx$(linkstate,!link2,!n)):>0
                                            &   !(idx$(linkrelation,!link2,!link))
                                              : $hasCrossing
                                            & "If two crossing links both are set to contract, change the linkstate for one of them."
                                            & 0:?linkstate
                                          | 
                                          )
                                        )
                                    &   !cumPStringEnergy+!StringEnergy
                                      : ?cumPStringEnergy
                                    & 1+!changed:?changed
                                  |   $nlinks:?K
                                    &   whl
                                      ' ( !K:>0
                                        & -1+!K:?K
                                        & (   !(idx$(linkstate,!K,!n)):>0
                                            & !(idx$(strength,!K)):>1
                                          | 1:?(idx$(strength,!K))
                                          )
                                        )
                                    &   !cumNStringEnergy+!StringEnergy
                                      : ?cumNStringEnergy
                                    & -1+!unchanged:?unchanged
                                  )
                              |   "Link gets weaker, because it is at max strength or because linkstate is not positive."
                                & 0:?(idx$(linkstate,!link,!n))
                                & !cumNStringEnergy+!StringEnergy:?cumNStringEnergy
                                & -1+!unchanged:?unchanged
                              )
                            )
                        & (   !unchanged:<0
                            & !cumPStringEnergy:>0
                            & 1/100*!cumPStringEnergy:?needed
                            & "We allow max. 10% to be taken from non-active strings."
                            & ( 10*!needed:<!cumNStringEnergy
                              | divide$(!cumNStringEnergy,10):?needed
                              )
                            & divide$(!needed,!cumPStringEnergy):?fractionGiven
                            & 1+!fractionGiven:?increase
                            & divide$(!needed,!cumNStringEnergy):?fractionTaken
                            & subtract$(1,!fractionTaken):?fractionKept
                            & $nlinks:?link
                            &   whl
                              ' ( !link:>0
                                & -1+!link:?link
                                & idx$(strength,!link)
                                & (   !(idx$(linkstate,!link,!n)):>0
                                    & !increase*!strength:?strength
                                  | !fractionKept*!strength:?strength
                                  )
                                )
                          | 
                          )
                    )
                  & initstrengths$strength
                  & initPointLinks$(pointlinks,links)
                  & initLinkRelations$(linkrelation,links)
                  & init$(position,200)
                  & init$(velocity,1/100000000000)
                  & init$(acceleration,1/100000000000)
                  & extent$(links,0):?Nlinks
                  & tbl$(T,$planets,$dimensions,$iterations)
                  & rank$T:?DD
                  & 0:?b
                  &   whl
                    ' ( !b:<!DD
                      & extent$(T,!b):?R
                      & 1+!b:?b
                      )
                  & -1:?n
                  & 25:?snap
                  &   whl
                    ' ( 1+!n:?n:<($iterations)
                      & divide$(!n,$maxn):?done
                      & "Reset acceleration."
                      & $planets:?p
                      &   whl
                        ' ( !p:>0
                          & -1+!p:?p
                          & $dimensions:?d
                          &   whl
                            ' ( !d:>0
                              & -1+!d:?d
                              & 0:?(idx$(acceleration,!p,!d))
                              )
                          )
                      & $planets:?p
                      &   whl
                        ' ( !p:>0
                          & -1+!p:?p
                          & !p:?q
                          &   whl
                            ' ( !q:>0
                              & -1+!q:?q
                              & 0:?(idx$(dist2,!p,!q))
                              & 0:?d
                              &   whl
                                ' ( !d:<($dimensions)
                                  &     subtract
                                      $ (!(idx$(position,!p,!d)),!(idx$(position,!q,!d)))
                                    : ?(idx$(Diff,!p,!q,!d))
                                  & -1*!Diff:?(idx$(Diff,!q,!p,!d))
                                  & sqr$!Diff+!dist2:?dist2
                                  & 1+!d:?d
                                  )
                              & !dist2:?(idx$(dist2,!q,!p))
                              & sqrt$!dist2:?(idx$(dist1,!p,!q))
                              & !dist1:?(idx$(dist1,!q,!p))
                              )
                          )
                      & $planets:?p
                      &   whl
                        ' ( !p:>0
                          & -1+!p:?p
                          & 2+!degrees:?Qp
                          & !p:?q
                          &   whl
                            ' ( !q:>0
                              & -1+!q:?q
                              & ( !(idx$(dist1,!p,!q)):0
                                |   2+!degrees:?Qq
                                  &     (1+divide$(2,!dist1))
                                      * (!Qp*!Qq)
                                      * $M/planets2
                                      * ($epsilon+!dist1)^-3
                                    : ?coulomb
                                  & 0:?d
                                  &   whl
                                    ' ( !d:<($dimensions)
                                      &     !(idx$(Diff,!p,!q,!d))*!coulomb
                                          + !(idx$(acceleration,!p,!d))
                                        : ?acceleration
                                      &     !(idx$(Diff,!q,!p,!d))*!coulomb
                                          + !(idx$(acceleration,!q,!d))
                                        : ?acceleration
                                      & 1+!d:?d
                                      )
                                )
                              )
                          )
                      & !Nlinks:?K
                      &   whl
                        ' ( !K:>0
                          & -1+!K:?K
                          & !(idx$(links,!K,0)):?p
                          & !(idx$(links,!K,1)):?q
                          & ( !q:!p
                            |   ( $F:?elastiek
                                |   divide$($F,sqrt$(fabs$(subtract$(!p,!q))))
                                  : ?elastiek
                                )
                              & !(idx$(strength,!K))*!elastiek:?elastiek
                              & 0:?d
                              &   whl
                                ' ( !d:<($dimensions)
                                  & !(idx$(Diff,!p,!q,!d))*!elastiek:?delta
                                  &   !delta+!(idx$(acceleration,!p,!d))
                                    : ?acceleration
                                  &   -1*!delta+!(idx$(acceleration,!q,!d))
                                    : ?acceleration
                                  & 1+!d:?d
                                  )
                            )
                          )
                      & ( !done:<($dampeningDoneDhreshold)
                        |   0:?crosses
                          & initMinDistances$pointlinks
                          & !Nlinks:?K
                          &   whl
                            ' ( !K:>0
                              & -1+!K:?K
                              & !(idx$(links,!K,0)):?pK
                              & !(idx$(links,!K,1)):?qK
                              & ( !qK:!pK
                                |   !K:?M
                                  &   whl
                                    ' ( !M:>0
                                      & -1+!M:?M
                                      & ( !(idx$(linkrelation,!K,!M)):~<0
                                        |   !(idx$(links,!M,0)):?pM
                                          & !(idx$(links,!M,1)):?qM
                                          &     cross
                                              $ ( !(idx$(position,!pK,0))
                                                , !(idx$(position,!pK,1))
                                                , !(idx$(position,!qK,0))
                                                , !(idx$(position,!qK,1))
                                                , !(idx$(position,!pM,0))
                                                , !(idx$(position,!pM,1))
                                                , !(idx$(position,!qM,0))
                                                , !(idx$(position,!qM,1))
                                                , xy
                                                )
                                            : ?CROSS
                                          & (   !CROSS:1
                                              &   $hasCrossing
                                                : ?(idx$(linkrelation,!K,!M))
                                              &   $hasCrossing
                                                : ?(idx$(linkrelation,!M,!K))
                                              &   updateLinkRelation
                                                $ ( !K
                                                  , !M
                                                  , xy
                                                  , links
                                                  , pointlinks
                                                  , position
                                                  )
                                              &   updateLinkRelation
                                                $ ( !M
                                                  , !K
                                                  , xy
                                                  , links
                                                  , pointlinks
                                                  , position
                                                  )
                                              & 1+!crosses:?crosses
                                            |     $noCrossing
                                                : ?(idx$(linkrelation,!K,!M))
                                              &   $noCrossing
                                                : ?(idx$(linkrelation,!M,!K))
                                            )
                                        )
                                      )
                                )
                              )
                          & (   !done:<($freezing)
                              &   needChangeSide
                                $ ( pointlinks
                                  , linkrelation
                                  , links
                                  , strength
                                  , linkstate
                                  , planetstate
                                  , !n
                                  , dist2
                                  , dist1
                                  )
                            |   ( $planets:?planet
                                &   whl
                                  ' ( !planet:>0
                                    & -1+!planet:?planet
                                    & -2:?(idx$(planetstate,!planet,!n))
                                    )
                                )
                              & $nlinks:?K
                              &   whl
                                ' ( !K:>0
                                  & -1+!K:?K
                                  & (   !(idx$(strength,!K)):>20/19
                                      & 19/20*!strength:?strength
                                    |   !strength:<1/10
                                      & 1/10:?strength
                                    |   !strength:<19/20
                                      & 20/19*!strength:?strength
                                    | 
                                    )
                                  )
                            )
                          & !Nlinks:?K
                          &   whl
                            ' ( !K:>0
                              & -1+!K:?K
                              & !(idx$(links,!K,0)):?pK
                              & !(idx$(links,!K,1)):?qK
                              & ( !qK:!pK
                                |   $planets:?planet
                                  &   whl
                                    ' ( !planet:>0
                                      & -1+!planet:?planet
                                      & ( !planet:!pK
                                        | !planet:!qK
                                        |   (     !(idx$(planetstate,!planet,!n))
                                                : !K
                                              & 0:?block
                                            | 1:?block
                                            )
                                          &     addForceBetweenLines
                                              $ ( position
                                                , acceleration
                                                , !pK
                                                , !qK
                                                , !planet
                                                , !done
                                                , !block
                                                , !n
                                                )
                                            : ?factor
                                        | 
                                        )
                                      )
                                )
                              )
                        )
                      & 0:?p
                      & $W:?mobility
                      & (   !done:>($freezing)
                          & $W*$W:?mobility
                        | 
                        )
                      &   whl
                        ' ( !p:<($planets)
                          & 0:?d
                          &   whl
                            ' ( !d:<($dimensions)
                              & !(idx$(position,!p,!d)):?(idx$(T,!p,!d,!n))
                              &     !(idx$(acceleration,!p,!d))
                                  + !mobility*!(idx$(velocity,!p,!d))
                                : ?velocity
                              & !velocity+!position:?position
                              & 1+!d:?d
                              )
                          & 1+!p:?p
                          )
                      )
                  & 0
                )
            : ?code
          & "End of UFP code."
          & new$(UFP,!code):?calc
          & ( export
            =   (calc..export)$(N,T):?pointsTTT
              & (calc..export)$(N,planetstate):?planetstate
              & (calc..export)$(N,linkstate):?linkstate
            )
          &   (   :?pointsTTT
                &   (calc..go)
                  $ ( ( 
                      ,   map
                        $ ( ( 
                            = .!arg:(?,?arg)&(,!arg)
                            )
                          . !titlelinks
                          )
                      )
                      (,!degrees)
                    )
                & !export
                & 1000000:?xmin:?ymin
                & -1000000:?xmax:?ymax
                & !pointsTTT:(,?pt)
                & 100*!iterations^-1:?evry
                & (1:<!evry:?evry|)
                & ( some
                  =   dun
                    .   0:?dun
                      &   map
                        $ ( ( 
                            =   
                              .     !dun+!evry:?dun:~<1
                                  & -1+!dun:?dun
                                  & !arg
                                | 
                            )
                          . !arg
                          )
                  )
                & !planetstate:(,?planetstate)
                &     map
                    $ ( ( 
                        =   
                          .   !arg:(,?arg)
                            &     map
                                $ ( ( 
                                    =   
                                      .   ";"
                                          ( !arg:-1&green
                                          |   !arg:-2
                                            & "#C8E9E9"
                                          | red
                                          )
                                    )
                                  . some$!arg
                                  )
                              : ";" ?arg
                            & str$!arg
                        )
                      . !planetstate
                      )
                  : ?planetcolours
                & -1:?plnt
                &     map
                    $ ( ( 
                        =   
                          .     !arg:(,? @?arg)
                              & 1+!plnt:?plnt
                              & (!plnt.!arg)
                            | 
                        )
                      . !planetstate
                      )
                  : ?planetstates
                & !linkstate:(,?linkstate)
                &     map
                    $ ( ( 
                        =   
                          .   !arg:(,?arg)
                            &     map
                                $ ( ( 
                                    =   
                                      .   ";"
                                          (   !arg:0
                                            & "#065b63"
                                          | red
                                          )
                                    )
                                  . some$!arg
                                  )
                              : ";" ?arg
                            & str$!arg
                        )
                      . !linkstate
                      )
                  : ?linkcolours
                & -1:?NN
                &     map
                    $ ( ( 
                        =   
                          .   !arg:(,? @?arg)
                            & 1+!NN:?NN
                            & (!NN,!arg)
                        )
                      . !linkstate
                      )
                  : ?linkstates
                &   map
                  $ ( ( 
                      =   xxs yys
                        .   !arg:(,(,?xxs) (,?yys) ?)
                          &   map
                            $ ( ( 
                                =   
                                  .   ( !arg:<!xmin:?xmin
                                      | 
                                      )
                                    & ( !arg:>!xmax:?xmax
                                      | 
                                      )
                                )
                              . !xxs
                              )
                          &   map
                            $ ( ( 
                                =   
                                  .   ( !arg:<!ymin:?ymin
                                      | 
                                      )
                                    & ( !arg:>!ymax:?ymax
                                      | 
                                      )
                                )
                              . !yys
                              )
                          & 
                      )
                    . !pt
                    )
                &     map
                    $ ( ( 
                        =   
                          .   !arg:(,(,?arg) ?)
                            &   map$((=.";" !arg).some$!arg)
                              : ";" ?arg
                            & (,str$!arg)
                        )
                      . !pt
                      )
                  : ?xx
                &     map
                    $ ( ( 
                        =   
                          .   !arg:(,% (,?arg) ?)
                            &   map$((=.";" !arg).some$!arg)
                              : ";" ?arg
                            & (,str$!arg)
                        )
                      . !pt
                      )
                  : ?yy
                &     map
                    $ ( ( 
                        =   xs
                          .   !arg:(,?arg)
                            & !xx:(,?xs) ?xx
                            & (!xs.!arg)
                        )
                      . !yy
                      )
                  : ?xxyy
                & !xxyy:? [?NN
                & !NN^-1:?MM
                & -1:?nn
                & -1:?lineno
                &     map
                    $ ( ( 
                        =   p q
                          .   !arg:(?title,%?p %?q)
                            & !xxyy:? [!p (?xx1.?yy1) ?
                            & !xxyy:? [!q (?xx2.?yy2) ?
                            & !linkcolours:%?linkcolour ?linkcolours
                            &   ( line
                                .   (stroke-width.16) (opacity."0.01")
                                  ,   (title.,!title)
                                      ( animate
                                      .     (attributeName.x1)
                                            (values.!xx1)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.y1)
                                            (values.!yy1)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.x2)
                                            (values.!xx2)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.y2)
                                            (values.!yy2)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.stroke)
                                            (values.!linkcolour)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                )
                                ( line
                                .   (marker-end."url(#arrow)")
                                  ,   (title.,!title)
                                      ( animate
                                      .     (attributeName.x1)
                                            (values.!xx1)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.y1)
                                            (values.!yy1)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.x2)
                                            (values.!xx2)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.y2)
                                            (values.!yy2)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.stroke)
                                            (values.!linkcolour)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                )
                        )
                      . !titlelinks
                      )
                  : ?lines
                &     map
                    $ ( ( 
                        =   a b col planetcolour text Title
                          .   !arg:(?a.?b)
                            & 1+!nn:?nn
                            & 255+-1*div$(255*!nn*!MM,1):?col
                            & !planetcolours:%?planetcolour ?planetcolours
                            &   !planettitles
                              : (!nn.?text.?Title) ?planettitles
                            &   ( circle
                                .     (r.12)
                                      (stroke.str$("rgb(" !col "," !col "," !col ")"))
                                  ,   ( animate
                                      .     (attributeName.cx)
                                            (values.!a)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.cy)
                                            (values.!b)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.fill)
                                            (values.!planetcolour)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                )
                                ( text
                                .     (text-anchor.middle)
                                      (stroke.black)
                                      (stroke-width.1px)
                                      (dominant-baseline.middle)
                                  ,   !text
                                      ( animate
                                      .     (attributeName.x)
                                            (values.!a)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.y)
                                            (values.!b)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                )
                                ( circle
                                .     (r.12)
                                      (stroke.str$("rgb(" !col "," !col "," !col ")"))
                                      (opacity."0.1")
                                  ,   ( animate
                                      .     (attributeName.cx)
                                            (values.!a)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.cy)
                                            (values.!b)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      ( animate
                                      .     (attributeName.fill)
                                            (values.!planetcolour)
                                            (dur.10s)
                                            (repeatCount.1)
                                            (fill.freeze)
                                        , 
                                      )
                                      (title.,!Title)
                                )
                        )
                      . !xxyy
                      )
                  : ?circles
                & 20:?margin
                & !xmin+-1*!margin:?xmin
                & !ymin+-1*!margin:?ymin
                & !xmax+-1*!xmin+!margin:?xwidth
                & !ymax+-1*!ymin+!margin:?ywidth
                & ( !xwidth:>!ywidth:?ywidth
                  | !ywidth:?xwidth
                  )
                & ( !radius:>!xwidth:?xwidth:?ywidth
                  | 
                  )
                & ( svg
                  .   (viewBox.str$(!xmin " " !ymin " " !xwidth " " !ywidth))
                    ,   (~|("!--"."A marker to be used as an arrowhead"))
                        ( defs
                        .   
                          , ( marker
                            .     (id.arrow)
                                  (viewBox."0 0 20 10")
                                  (refX.30)
                                  (refY.5)
                                  (markerWidth.16)
                                  (markerHeight.16)
                                  (orient.auto-start-reverse)
                                  (fill."#065b63")
                              , (path.(d."M 0 0 L 20 5 L 0 10 z"),)
                            )
                        )
                        (g.(class.wf),!lines !circles)
                  )
              | out$"something wrogn"&wrong
              )
            : ?SVG
          & :?calc
          & !SVG
      )
      ( workflowAsTextAndGraph
      =   visfields SVG formfields
        .   !arg:(?formfields.?visfields.?SVG)
          & ( div
            .   (style."width: 100%; overflow: hidden;")
              ,   ( div
                  .   (style."width: 30%; float: left;")
                    ,   ( div
                        .   (style."height:20vh;")
                          ,   !formfields
                              (h3.,localized$("Workflow steps" "Trin i arbejdsgangen"))
                        )
                        (div.(style."overflow-y:auto; height:80vh;"),!visfields)
                  )
                  ( div
                  .   (style."margin-left: 30%; overflow-y:auto; height:100vh;")
                    , ( figure
                      .   
                        ,   ( figcaption
                            .   
                              ,   ( a
                                  .   (id.Fig1) (tabindex.0)
                                    ,   localized
                                      $ ( "Directed Acyclic Graph (DAG) of the workflow"
                                          "Rettet acyklisk graf (eng. Directed Acyclic Graph, DAG) af arbejdsgangen"
                                        )
                                  )
                                  ". "
                            )
                            !SVG
                      )
                  )
            )
      )
      "
/**
 * chosenworkflow
 *
 * Prepares the enactment of a workflow. If all goes well, the returned
 * HTML data is of the form 200~<Job number>~<Job ID>~<web page>
 * where <web page> is a auto reloading page that polls the current status
 * of the running workflow.
 *
 * Alternative outcomes are:
 *
 * a web page that asks for metadata, to be added
 * to TEI P5 output, or
 *
 * a web page that shows the fine details of the chosen workflow, with a button
 * for bookmarking the workflow, or
 *
 * a page that says that there is nothing to do.
 *
 * Called from chosenworkflow.java
 */"
      ( chosenworkflow
      =     Tool item parms Items
          , val mail2 ERR
          , Submit
          , JobStack JobNr presels
          , errors batch
          , jobIDoffset subjobs
          , nth BodyContainer PIPE
          , makejobstack
          , ApplyThePipelineToTheInput
          , ShowOnlyTheCurrentPipe AddMetadata
          , "The user has selected a workflow."
          , errorInMetadata
          , MetadataInParms
          , rememberMetadata SVG
        .   ( ShowOnlyTheCurrentPipe
            =   formFields struct nth bm visfields
              .   !arg:(?struct.?nth.?bm.?err)
                & makeWorkflowVisualisation$!struct:(?visfields.?SVG)
                &   ( !nth:#<1&
                    |   (br.,)
                        submit$Submit
                        submit$(localized$!Dryrun)
                        BookMark$(!bm.!err)
                    )
                  : ?formFields
                & ( !formFields !visfields:
                  |     form
                      $ ( chosenworkflow
                        .   !formFields
                            ( !nth:#<1&
                            | makeHiddenFields$((nth.!nth) !hiddenData)
                            )
                        )
                    : ?formFields
                  )
                & workflowAsTextAndGraph$(!formFields.!visfields.!SVG):?formFields
                &   str
                  $ ( 200~~~
                        toML
                      $ ( (HTML-SVG-bodyContainer|!BodyContainer)
                        $ ("Workflow details".!formFields)
                        )
                    )
            )
          & ( AddMetadata
            =   formFields nth val,parms ERR metadataType hiddenData
              .   !arg:(?metadataType.?nth.?parms.?ERR.?hiddenData)
                &     !Style
                        map
                      $ ( ( 
                          =     tekst inputs
                              , "Tekst i gr√¶nsefladen"
                              , "Required / optional  / automatic"
                              , "Placering i header" Noter Hj√¶lpetekst id
                              , "line / lines / box / empty" URL
                              , table typeOfError
                            .     !arg:(?tekst,?inputs)
                                &   fieldset
                                  $ ( localized$!tekst
                                    .   map
                                      $ ( ( 
                                          =   
                                            .     !arg
                                                : ( ?id
                                                  . ?"Tekst i gr√¶nsefladen"
                                                  . ?"Required / optional  / automatic"
                                                  . ?"line / lines / box / empty"
                                                  . ?"Placering i header"
                                                  . ?Noter
                                                  . ?Hj√¶lpetekst
                                                  . ?
                                                  . ?URL
                                                  )
                                              & (     !"Required / optional  / automatic"
                                                    :   ?
                                                        ( o
                                                        | r
                                                        | oneOrMore
                                                        | zeroOrMore
                                                        )
                                                        ?
                                                  & ( div
                                                    .   (class.row)
                                                      ,   (     !"line / lines / box / empty"
                                                              : select ?table
                                                            & readTable$!table
                                                            &   makeSelectFormField
                                                              $ (   addurl
                                                                  $ (   localized
                                                                      $ !"Tekst i gr√¶nsefladen"
                                                                    . !URL
                                                                    )
                                                                . !id
                                                                .   ( options
                                                                    .   makeOptionList
                                                                      $ ( !!table
                                                                        .       !parms
                                                                              :   ?
                                                                                  ( !id
                                                                                  . ?val
                                                                                  )
                                                                                  ?
                                                                            & !val
                                                                          | 
                                                                        )
                                                                    )
                                                                    ( desc
                                                                    .   localized
                                                                      $ !Hj√¶lpetekst
                                                                    )
                                                                    ( required
                                                                    .       !"Required / optional  / automatic"
                                                                          :   ?
                                                                              ( r
                                                                              | oneOrMore
                                                                              )
                                                                              ?
                                                                        & ( span
                                                                          .   ( class
                                                                              . requiblue
                                                                              )
                                                                            , "*"
                                                                          )
                                                                      | 
                                                                    )
                                                                )
                                                          |   (     !"line / lines / box / empty"
                                                                  : ( box
                                                                    | lines
                                                                    )
                                                                & makeTextAreaFormField
                                                              | makeTextFormField
                                                              )
                                                            $ (     addurl
                                                                  $ (   localized
                                                                      $ !"Tekst i gr√¶nsefladen"
                                                                    . !URL
                                                                    )
                                                                  (     !"Required / optional  / automatic"
                                                                      : ? a ?
                                                                    & ( span
                                                                      .   ( class
                                                                          . italics
                                                                          )
                                                                        ,   str
                                                                          $ ( " ("
                                                                                localized
                                                                              $ ( "autogenerated if left blank"
                                                                                  "automatisk genereret hvis ikke udfyldt"
                                                                                )
                                                                              ") "
                                                                            )
                                                                      )
                                                                  | 
                                                                  )
                                                              . !id
                                                              .   ( val
                                                                  .       !parms
                                                                        :   ?
                                                                            ( !id
                                                                            . ?val
                                                                            )
                                                                            ?
                                                                      & !val
                                                                    | 
                                                                  )
                                                                  ( desc
                                                                  .   localized
                                                                    $ !Hj√¶lpetekst
                                                                  )
                                                                  ( required
                                                                  .       !"Required / optional  / automatic"
                                                                        :   ?
                                                                            ( r
                                                                            | oneOrMore
                                                                            )
                                                                            ?
                                                                      & ( span
                                                                        .   ( class
                                                                            . requiblue
                                                                            )
                                                                          , "*"
                                                                        )
                                                                    | 
                                                                  )
                                                              )
                                                          )
                                                          (     !ERR
                                                              : (!id.?typeOfError.?)
                                                            & ( span
                                                              .   (class.required)
                                                                , !typeOfError
                                                              )
                                                          | 
                                                          )
                                                    )
                                                |     !"Required / optional  / automatic"
                                                    : ? a ?
                                                  & !"Tekst i gr√¶nsefladen":~
                                                  & ( div
                                                    .   (class.row)
                                                      ,   makeStaticTextFormField
                                                        $ (   localized
                                                            $ !"Tekst i gr√¶nsefladen"
                                                          . span
                                                          .   (class.autogen)
                                                            ,   str
                                                              $ ( " ("
                                                                    localized
                                                                  $ ( autogenerated
                                                                      "automatisk genereret"
                                                                    )
                                                                  ") "
                                                                )
                                                          )
                                                    )
                                                | 
                                                )
                                          )
                                        . !inputs
                                        )
                                    )
                              | 
                          )
                        . readTable$!metadataType
                        )
                  : ?formFields
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ ( !formFields:
                          |   (h1.,localized$("Add metadata" "Tilf√∏j metadata"))
                              (br.,)
                                form
                              $ ( chosenworkflow
                                .   !formFields
                                    ( !nth:<1&
                                    |   makeHiddenFields$((nth.!nth) !hiddenData)
                                        (br.,)
                                        submit$Submit
                                    )
                                )
                          )
                        )
                    )
            )
          & ( makejobstack
            =   NOS stepNo stepping
              .   ( stepping
                  =     a b ID NO I O input
                      , step ad bd deps stp c
                      , x y InoOnE
                    .   !arg:(?arg.?deps)
                      & (   !arg:%?a %?b
                          & stepping$(!a.!deps):(?a.?ad)
                          & stepping$(!b.!ad):(?b.?bd)
                          & (!a !b.!bd)
                        |   !arg:(%?a,%?b)
                          & stepping$(!a.!deps):(?a.?ad)
                          & stepping$(!b.!deps):(?b.?bd)
                          & (!a !b.!ad !bd)
                        |   !arg:(.?NO.?I.?O)
                          & !NOS:? (!NO.?step) ?
                          & (.!step.!O)
                        |   !arg:(?ID.?NO.?I.?O)
                          & str$(step (1+!stepNo:?stepNo)):?step
                          & ( !NO:
                            | (!NO.!step) !NOS:?NOS
                            )
                          & (   !I:?InoOnE
                              &   whl
                                ' ( !InoOnE:?a (?x,(?b.OnE)) ?c
                                  & !a (!x,!b) !c:?InoOnE
                                  )
                              &   !deps
                                : (?stp.!InoOnE:(?a,?b) ?c)
                              & (!a,(!b.!stp)):?I
                              &   whl
                                ' ( !c:%?a ?c
                                  & !a !I:?I
                                  )
                              & ((!step.!ID.!O.!I).!step.!O)
                            |     (     !I
                                      : ?a (?b,%*%:?input) ?c
                                    &   !a
                                          mop
                                        $ ( ( 
                                            =   
                                              .   ( !arg:(?arg.OnE)
                                                  | 
                                                  )
                                                & (     !deps
                                                      :   ?x
                                                          ( ?stp
                                                          .   ?
                                                              (!b,!arg)
                                                              ?
                                                          )
                                                          ?y
                                                    & !x !y:?deps
                                                    & (!b,(!arg.!stp))
                                                  | ( !b
                                                    , ( !arg
                                                      . FiL
                                                      . !a (!b.!arg) !c
                                                      )
                                                    )
                                                  )
                                            )
                                          . !input
                                          . (=*)
                                          )
                                        !c
                                  |   !I:(?b,?input) ?c
                                    & (!b,(!input.FiL.!I)) !c
                                  )
                                : ?I
                              & ((!step.!ID.!O.!I).!step.!O)
                            )
                        )
                  )
                & :?NOS
                & 0:?stepNo
                & stepping$(!arg.):(?arg.?)
                & !arg
            )
          & ( ApplyThePipelineToTheInput
            =     struct batch jobIDoffset parms
                , retrieveMetadataFromParms tXt
                , Items item subjobs mail2 JobId metadataType
                , toolsdataURL toolsUploadURL dryORrun
              .   !arg:(?metadataType.?struct.?batch.?Items.?mail2.?parms.?dryORrun)
                & ( retrieveMetadataFromParms
                  =   metadataType parms
                    .   !arg:(?metadataType.?parms)
                      &   map
                        $ ( ( 
                            =   inputs
                              .     !arg:(?,?inputs)
                                  &   map
                                    $ ( ( 
                                        =   id V
                                          .   !arg:(?id.?)
                                            & (     !parms
                                                  : ? (!id.?V) ?
                                                & (!id.!V)
                                              | 
                                              )
                                        )
                                      . !inputs
                                      )
                                | 
                            )
                          . readTable$!metadataType
                          )
                  )
                & "
                /*
                 * toolsdataURL
                 *
                 * Return the full URL to Tool's staging area.
                 * The input can be a file name: this name is appended to the returned value.
                 *
                 */"
                & ( !baseUrlTools:~
                  |   readTable$properties
                    & !properties:? (baseUrlTools.?baseUrlTools.?) ?
                  )
                & (toolsdataURL=.str$(!baseUrlTools !stagingArea !arg))
                & (toolsUploadURL=.str$(!baseUrlTools "/texton/upload" !arg))
                & makejobstack$!struct:?JobStack
                & ( readTable$jobNr
                  | 0:?jobNr&saveTable$jobNr
                  )
                & !jobNr+1:?jobNr:?JobNr
                & saveTable$jobNr
                & (   !batch:on
                    & 0:?jobIDoffset
                    &   whl
                      ' ( !Items:%?item ?Items
                        &     convert2URLs
                            $ ( !jobNr
                              . !jobIDoffset
                              . !JobStack
                              . toolsdataURL$
                              . toolsUploadURL$
                              . !item
                              . !dryORrun
                              )
                          : ?subjobs
                        & !subjobs+!jobIDoffset:?jobIDoffset
                        )
                  |   convert2URLs
                    $ (!jobNr..!JobStack.toolsdataURL$.toolsUploadURL$.!Items.!dryORrun)
                  )
                & readTable$jobs
                & handleToolsTakingBatchesOfInput$(!jobNr.!jobs):?jobs
                & saveTable$jobs
                & (readTable$jobAbout|:?jobAbout)
                & makeWorkflowVisualisation$!struct:(?tXt.?SVG)
                &     ( !JobNr
                      .   (mail2.!mail2)
                          (human.!tXt)
                          (userProvidedMetadata.retrieveMetadataFromParms$(!metadataType.!parms))
                      )
                      !jobAbout
                  : ?jobAbout
                & saveTable$jobAbout
                & getNextJobID$(!JobNr.justtesting):?JobId
                &   str
                  $ ( 200
                      "~"
                      !JobNr
                      "~"
                      !JobId
                      "~"
                      (   !JobId:
                        &   toML
                          $ ( !BodyContainer
                            $ ( paragraph
                              $ ( localized
                                $ ( "There is nothing to do. The goal seems to be fulfilled already. Go back with the \"back\" button."
                                    "Der er intet at lave. G√• tilbage med knappen \"Forrige\"."
                                  )
                                )
                              )
                            )
                      | poll$(!JobNr.1)
                      )
                    )
            )
          & ( errorInMetadata
            =     pattern metadataType
                , "Tekst i gr√¶nsefladen" id ERR val Metadata ISO639 DATE MEDIATYPE
              .   "ISO639 is a pattern used in the TEImetadata file"
                & ( ISO639
                  = [%( readTable$linguae
                      & !( 
                         ' ( $linguae
                           : ( ? (?.$sjt.?) ?
                             | ? (? ()$sjt ?.?.?) ?
                             )
                           )
                         )
                      )
                  )
                & "DATE is a pattern used in the TEImetadata file"
                & ( DATE
                  =   (   #%@?y1 #%@?y2 #%@?y3 #%@?y4 "-" #%@?m1 #%@?m2 "-" #%@?d1 #%@?d2
                        & 10*!m1+!m2:~<1:~>12
                        & 10*!d1+!d2:~<1:~>31
                      | #%@?y1 #%@?y2 #%@?y3 #%@?y4
                      )
                    & 1000*!y1+100*!y2+10*!y3+!y4:<2100
                  )
                & "MEDIATYPE could be used as a pattern used in the TEImetadata file"
                & ( MEDIATYPE
                  =   ( application
                      | audio
                      | example
                      | image
                      | message
                      | model
                      | multipart
                      | text
                      | video
                      | chemical
                      )
                      "/"
                        ( 
                        =   sub parms suf name
                          .   @(!sjt:(?sub ";" ?parms|?sub))
                            & whl'@(!sub:?sub " ")
                            & @( !sub
                               : (   (vnd|prs|x)
                                     "."
                                     ?name
                                 | ?name
                                 )
                               )
                            & (   @(!name:? "+" ?suf)
                                & (   !suf
                                    : ( xml
                                      | json
                                      | ber
                                      | der
                                      | fastinfoset
                                      | wbxml
                                      | zip
                                      | cbor
                                      | binary
                                      | vrml
                                      )
                                  | `~
                                  )
                              | 
                              )
                            & ?
                        )
                      $ 
                  )
                & !arg:(?metadataType.?arg)
                & readTable$!metadataType:?Metadata
                & :?ERR
                &   !Metadata
                  :   ?
                      ( ?
                      ,   ?
                          ( ?id
                          . ?"Tekst i gr√¶nsefladen"
                          .     (r|oneOrMore)
                              &   !arg
                                : (   ?
                                      ( !id
                                      . ?val&trim$!val:
                                      )
                                      ?
                                  | ~(? (!id.?) ?)
                                  )
                              &   ( !id
                                  . localized$(required kr√¶vet)
                                  . localized$!"Tekst i gr√¶nsefladen"
                                  )
                                : ?ERR
                            | ?
                          . ?
                          . ?
                          . ?
                          . ?
                          .     %?pattern ?
                              & !arg:? (!id.~:?val) ?
                              & ~(@(!val:!!pattern)&)
                              &   ( !id
                                  . localized$(format format)
                                  . localized$!"Tekst i gr√¶nsefladen"
                                  )
                                : ?ERR
                            | &!ERR:~
                          . ?
                          )
                          ?
                      )
                      ?
                & !ERR
            )
          & ( MetadataInParms
            =   id Metadata metadataType
              .   !arg:(?metadataType.?arg)
                & readTable$!metadataType:?Metadata
                &   !Metadata
                  :   ?
                      ( ?
                      ,   ?
                          (   ?id
                            & !arg:? (!id.?) ?
                          . ?
                          )
                          ?
                      )
                      ?
                & !arg
            )
          & ( rememberMetadata
            =   mail2 userProvidedMetadata metadataType
              .   !arg:(?metadataType.?arg)
                & ( MetadataInParms$(!metadataType.!arg)
                  |   (   !arg:? (mail2.?mail2) ?
                        & readTable$jobAbout
                        &   !jobAbout
                          :   ?
                              ( ?
                              .   ?
                                  (mail2.!mail2)
                                  ?
                                  (userProvidedMetadata.?userProvidedMetadata)
                                  ?
                              )
                              ?
                      | :?userProvidedMetadata
                      )
                    & !userProvidedMetadata !parms
                  )
            )
          & ( "The user has selected a workflow."
            =     Submit hiddenData o-SUpPLEMENT
                , parms nth batch Items mail2 ERR
                , allpipes ViewDetails fintool
                , returnCode struct whichButton
                , reqtool sources bm err msg
                , goals topologicalOrderedTools wf
                , getDetailedSource getDetailedGoal
              .   ( getDetailedSource
                  =   
                    .   whl'(!arg:(%?arg %|(?arg,?)))
                      & !arg:(?.?.?arg.?)
                      & !arg
                  )
                & ( getDetailedGoal
                  =   
                    .     whl
                        ' ( !arg
                          : (% ((?.?):%?arg)|(?,?arg))
                          )
                      & !arg:(?.?.?arg.?)
                      & !arg
                  )
                & ( whichButton
                  =   bm
                    .   !arg:?bm
                      & (     !Submit
                            : ( !ViewDetails (" - " ?nth|)
                              | @(?:(prev|next) ?)
                              )
                          & ShowOnlyTheCurrentPipe$(!struct.!nth.!bm.)
                        |   localized$!Bookmark:!Submit
                          & getDetailedSource$!struct:?sources
                          & getDetailedGoal$!struct:?goals
                          & ((!sources.!goals).!struct):?wf
                          & (!wrkflws:|readTable$wrkflws)
                          &   ShowOnlyTheCurrentPipe
                            $ ( !struct
                              . !nth
                              .     !parms:? (bm.?bm) ?
                                  & (   !wrkflws:? (!bm.?) ?
                                      & inuse:?err
                                    |   (!bm.!wf) !wrkflws:?wrkflws
                                      & :?err
                                      & saveTable$wrkflws
                                    )
                                  & !bm
                                | 
                              . !err
                              )
                        |   !Submit:Submit
                          & (     !parms
                                : ~( ?
                                     ( Iformat
                                     .   ( txtbasis
                                         | txtann
                                         | teip5
                                         )
                                       ^ ?
                                     )
                                     ?
                                   )
                              & canConsumeMetadata$!struct
                              & (   MetadataInParms$(TEImetadata.!parms)
                                  & errorInMetadata$(TEImetadata.!parms):?ERR
                                |   ~(MetadataInParms$(TEImetadata.!parms))
                                  &   !parms
                                    :   ?
                                        ( Oformat
                                        .   ( txtbasis
                                            | txtann
                                            | teip5
                                            )
                                          ^ ?
                                        )
                                        ?
                                  & rememberMetadata$(TEImetadata.!parms):?parms
                                )
                              & AddMetadata$(TEImetadata.!nth.!parms.!ERR.!hiddenData)
                            |   ApplyThePipelineToTheInput
                              $ (TEImetadata.!struct.!batch.!Items.!mail2.!parms.run)
                            )
                        |   localized$!Dryrun:!Submit
                          &   ApplyThePipelineToTheInput
                            $ (TEImetadata.!struct.!batch.!Items.!mail2.!parms.dry)
                        )
                  )
                & !arg:(?parms.?Submit.?hiddenData.?batch.?Items.?mail2)
                & 0:?allpipes
                & :?returnCode:?reqtool:?fintool
                &   !parms
                  : ( ? (nth.?nth) ?
                    | ?&1:?nth
                    )
                & localized$("View details" "Se detaljer"):?ViewDetails
                & :?msg
                & (   !nth:#
                    &   Pipelines$(!parms.!nth)
                      : ( (?sources.?goals.?)
                        . ( (?.?.?.?.?),(?.?struct)
                          . ?topologicalOrderedTools
                          )
                        . ?returnCode
                        . ?msg
                        )
                    & "!returnCode:(allRight
                                   |triviallyFulfilled
                                   |tooComplex
                                   |tooMany
                                   |onlyWithoutRestriction
                                   |notFulfillable
                                   )"
                    & (   !returnCode:allRight
                        & log$whichButton
                        & whichButton$
                      | UnexpectedReturnCode$!returnCode
                      )
                  |   !wrkflws:? (!nth.?.?struct) ?
                    & whichButton$!nth
                  |   NotFulfillable
                    $ ( !msg:~|NoPipelinesFound
                      . !sources
                      . !goals
                      . 
                      )
                  )
            )
          & (|log$NEW)
          & log$chosenworkflow-SINGLEWORKFLOWLOGJE
          & :?PIPE
          &   initialiseSpecifyGoalShowWorkflowsChosenWorkflow$!arg
            : (?errors.?hiddenData.?Items.?Tool.?parms.?BodyContainer)
          & (   !Items:
              & getSingleItemOrNothing$!parms:?Items
            | 
            )
          & analyzeInput$(!Items.!errors):(?Items.?presels.?errors)
          & ( !errors:~
            |     supplementParmsAndHiddenData$(!parms.!hiddenData)
                : (?parms.?Submit.?hiddenData.?batch)
              & "The user has selected a workflow."$(!parms.!Submit.!hiddenData.!batch.!Items.!mail2)
            )
      )
      "
/**
 * usermsg
 *
 * Feed back form.
 *
 * Called from usermsg.java
 */"
      ( usermsg
      =   fb
        .   log$(usermsg !arg)
          & !arg:? (fb.?fb) ?
          & str$(vap$((=.!arg).!fb.\r)):?fb
          &     vap
              $ ( ( 
                  =   
                    .   whl'@(!arg:?arg " ")
                      & (!arg:|!arg \n)
                  )
                . !fb
                . \n
                )
            : (?fb \n|?fb)
          & (   !fb:
              &   str
                $ ( 200~~~
                      toML
                    $ ( !HTMLbodyContainer
                      $ ( ( h3
                          .   
                            ,   localized
                              $ ( "Thank you for using the Text Tonsorium."
                                  "Tak fordi du brugte Text Tonsorium."
                                )
                          )
                          ( p
                          .   
                            ,   localized
                              $ ("We appreciate comments, good and bad." "Vi s√¶tter pris p√• ros og ris.")
                          )
                        )
                      )
                  )
            |   readTable$feedback
              & str$!fb !feedback:?feedback
              & saveTable$feedback
              &   str
                $ ( 200~~~
                      toML
                    $ ( !HTMLbodyContainer
                      $ ( ( h3
                          .   
                            ,   localized
                              $ ("Thank you for your feed back." "Tak for din tilbagemelding.")
                          )
                          ( p
                          .   
                            ,   localized
                              $ ("We appreciate comments, good and bad." "Vi s√¶tter pris p√• ros og ris.")
                          )
                        )
                      )
                  )
            )
      )
      "
/**
 * clean
 *
 * Free all variables that shouldn't exist.
 * Such variables are normally undeclared 'local' variables.
 * (In proper coding, all such variables should be declared).
 *
 * Called from reloadScript.java
 */"
      ( clean
      =   
        .   map
          $ ( ( 
              =   
                .         MLencoding
                          abs
                          arg
                          c
                          cat
                          cos
                          fct
                          flt
                          jsn
                          let
                          nestML
                          out
                          sgn
                          sin
                          sub
                          tay
                          toML
                          v
                          w
                          Globals
                          !Globals
                      : ? !arg ?
                    & 
                  | tbl$(!arg,0)&!arg
              )
            . cat$
            )
      )
      "
/**
 * cleanup
 *
 * Delete all references to files that no longer exist.
 * Argument: a list of the files that still exist in the Staging area.
 * cleanup$ does not delete any files. See keep$.
 * Affected tables:
 * A    zippedresults
 *          All mentioned files must exist.
 * B    Uploads
 *          All mentioned files must exist.
 *      Loop:
 * C        ItemGroupsCache
 *              All mentioned files must be mentioned in Uploads.
 * D        jobs
 *              All input files must be mentioned in Uploads. If not, all of job must be deleted.
 *              If a job has two or more inputs, and not all input files are in a single entry in ItemGroupsCache, then these files must be removed from Uploads.
 * E    CTBs
 *          All jobNr/jobID pairs must occur in jobs.
 * F    jobAbout
 *          All jobNr must occur in jobs.
 *
 * It is not the case that all uploaded (Uploads) and grouped (ItemGroupsCache) files must occur in jobs
 *
 * Called from cleanup.java
 */"
      ( cleanup
      =     jobNr jobID jobstatus files toolURL parms file
          , A Z a z F existingFiles
          , feats item meta nr stagingName LeN removedFromUploads
        .   !arg:? [?LeN
          &   log
            $ ( str
              $ ( cleanup
                    map
                  $ ( (=." " !arg)
                    .   !LeN:<5&!arg
                      | !arg:?A [2 ? [-2 ?Z&!A "..." !Z
                    )
                )
              )
          & readTable$ItemGroupsCache
          & readTable$Uploads
          & readTable$jobs
          & readTable$CTBs
          & readTable$jobAbout
          & !arg:?existingFiles
          & "--A-- zippedresults: All mentioned files must exist."
          & log$"--A--"
          &   ( 
              =   existingFiles zippedresults
                .   !arg:?existingFiles
                  & readTable$zippedresults
                  &     map
                      $ ( ( 
                          =   
                            .     !existingFiles:? !arg ?
                                & !arg
                              |   log$(str$("Remove " !arg " from zippedresults"))
                                & 
                          )
                        . !zippedresults
                        )
                    : ?zippedresults
                  & saveTable$zippedresults
              )
            $ !existingFiles
          & "--B--  Uploads: All mentioned files must exist."
          & log$"--B--"
          &     map
              $ ( ( 
                  =   
                    .   !arg:(?nr.?item.?stagingName.?meta.?feats)
                      & ( !existingFiles:? !stagingName ?&!arg
                        |   log$(str$("Remove " !stagingName " from Uploads"))
                          & 
                        )
                  )
                . !Uploads
                )
            : ?Uploads
          &   whl
            ' ( "--C-- ItemGroupsCache: All mentioned files must be mentioned in Uploads."
              & log$"--C--"
              & "Note: ItemGroupsCache mentions original file names. The same file can be uploaded several times, each time under a slightly different staging name."
              & :?removedFromUploads
              &     map
                  $ ( ( 
                      =   2bremoved
                        .       !arg
                              : ( ?
                                .     ?
                                      ( ?
                                      .   ?
                                          ( %@?item
                                          & log$(Is !item in Uploads)
                                          &   !Uploads
                                            : ~(? (?.!item.?) ?)
                                          & log$"No, it isn't"
                                          )
                                          ?
                                      . ?
                                      )
                                      ?
                                  : ?2bremoved
                                )
                            & log$(2bremoved !2bremoved)
                            & 
                          | !arg
                      )
                    . !ItemGroupsCache
                    )
                : ?ItemGroupsCache
              & "--D-- jobs
                        All input files must be mentioned in Uploads. If not, all of job must be deleted.
                        If a job has two or more inputs, and not all input files are in a single entry in ItemGroupsCache, then these files must be removed from Uploads."
              & log$"--D--"
              &     map
                  $ ( ( 
                      =   steps outs inps removedFU
                        .   !arg:(?jobNr.?steps)
                          & :?outs:?removedFU
                          &     map
                              $ ( ( 
                                  =   in ou ins jobId
                                    .     !arg
                                        : (%@?jobId ?.?in.?.?.?ou)
                                      &     map
                                          $ ( ( 
                                              =   OU
                                                .   (   !arg
                                                      : ( item
                                                        .   
                                                          ,   ?
                                                              (id.,?arg)
                                                              ?
                                                        )
                                                    | 
                                                    )
                                                  &   log
                                                    $ (   str
                                                        $ ( "WhatAbout "
                                                            !arg
                                                            " when outs is "
                                                          )
                                                        !outs
                                                      )
                                                  & (   !( 
                                                         ' ( $outs
                                                           :   ?
                                                               ( ($arg.?)
                                                               | ( ?
                                                                 . @( ?OU
                                                                    : ? ()$arg ?
                                                                    )
                                                                 )
                                                               )
                                                               ?
                                                           )
                                                         )
                                                      &   log$(str$"     Is output ")
                                                          !OU
                                                          " from previous step"
                                                      & 
                                                    |   log$"     is really input"
                                                      & !arg
                                                    )
                                              )
                                            . !in
                                            )
                                        : ?ins
                                      & (!jobId.!ou) !outs:?outs
                                      & !ins
                                  )
                                . !steps
                                )
                            : ?inps
                          & log$(inps !inps)
                          & (     !inps
                                :   ?
                                    ( %@?in
                                    & !Uploads:~(? (?.?.!in.?) ?)
                                    & log$(str$(!in " is not in Upload"))
                                    )
                                    ?
                              & !in:?removedFU
                              & "An input is missing in Uploads? Then remove all inputs used in this job."
                              & log$("Remove all " !inps)
                              &     map
                                  $ ( ( 
                                      =   file
                                        .     !arg:(?.?.?file.?)
                                            & !('($inps:? ()$file ?))
                                            & !file !removedFU:?removedFU
                                            & 
                                          | !arg
                                      )
                                    . !Uploads
                                    )
                                : ?Uploads
                            | log$("Do not remove " !inps)
                            )
                          & ( !removedFU:&!arg
                            |   !removedFU !removedFromUploads:?removedFromUploads
                              &   log
                                $ "This forces a new iteration. Remove job completely if one or more inputs are missing"
                              & 
                            )
                      )
                    . !jobs
                    )
                : ?jobs
              & !removedFromUploads:~
              )
          & "--E--  CTBs: All jobNr/jobID pairs must occur in jobs."
          & log$"--E--"
          &     map
              $ ( ( 
                  =   
                    .   !arg:(?jobNr.?jobID.?)
                      & (     !jobs
                            :   ?
                                (!jobNr.? (!jobID ?.?) ?)
                                ?
                          & !arg
                        | log$(str$("Remove CTB " !arg))&
                        )
                  )
                . !CTBs
                )
            : ?CTBs
          & "--F-- jobAbout: All jobNr must occur in jobs."
          & log$"--F--"
          &     map
              $ ( ( 
                  =   
                    .   !arg:(?jobNr.?)
                      & (   !jobs:? (!jobNr.?) ?
                          & !arg
                        | log$(str$("remove from jobAbout " !jobNr))&
                        )
                  )
                . !jobAbout
                )
            : ?jobAbout
          & log$SAVE
          & saveTable$Uploads
          & saveTable$jobs
          & saveTable$CTBs
          & saveTable$jobAbout
          & saveTable$ItemGroupsCache
      )
      "
/**
 * doneJob
 *
 * Marks a job as 'done' in jobs.table
 * Constructs a CTBID from date, JobNr and jobID
 * Makes sure there is a row in table CTBs connecting
 *      JobNr, jobID, email and CTBID
 * Affected tables:
 *      jobs.table
 *      CTBs.table
 * Arguments: jobNR, JobID, spangroup with annotation and date.
 *
 * Called from util.java
 */"
      ( doneJob
      =     A B Y Z JobNr jobID ZZ jobid2 a z files S
          , prevTitle
          , ctb ctbid CTBID filename status
          , toolURL parms file TITLE SPANGRPS
          , DATE EMAIL TBA AVAILABILITY
          , SPANGRP SPANGRPfil SPANGRPfilWithMetadata
          , XMLID ITEMS ZZ LANGUAGE
          , userProvidedMetadata autogenerated Extent
        .     readTable$jobs
            &   
              : ?TITLE
              : ?DATE
              : ?EMAIL
              : ?TBA
              : ?AVAILABILITY
              : ?XMLID
              : ?ITEMS
              : ?LANGUAGE
            & !arg:(@(?:? #?JobNr).%@?jobID ?.?SPANGRPfil.?DATE)
            & "SPANGRPfil is empty string if job step did not produce TEI output."
            & -1+!runningThreads:?runningThreads
            &   log
              $ (str$("doneJob:runningThreads:" !runningThreads " maxRunningThreads:" !maxRunningThreads))
            & str$(!DATE "-" !JobNr "-" !jobID):?CTBID
            & (readTable$CTBs|:?CTBs)
            & ( Extent
              =   n recur
                .   0:?n
                  & ( recur
                    =   S
                      .     !arg:? (w.?) ?
                          &   whl
                            ' ( !arg:? (w.?) ?arg
                              & 1+!n:?n
                              )
                        |   whl
                          ' ( !arg:? (?.?,?S) ?arg
                            & recur$!S
                            )
                    )
                  & recur$!arg
                  & !n
              )
            & readTable$Uploads
            & readTable$facets
            & :?toolURL
            &   !jobs
              :   ?A
                  ( !JobNr
                  .   ?B
                      (   !jobID
                          ( ( 
                            | starting
                            | waiting
                            | done
                            )
                          : ?status
                          )
                      . ?files
                      . ?toolURL
                      . ?parms
                      . ?filename
                      )
                      ?Y
                  )
                  ?Z
            & ( !status:done
              |     !A
                    ( !JobNr
                    .   !B
                        (!jobID done.!files.!toolURL.!parms.!filename)
                        !Y
                    )
                    !Z
                : ?jobs
              )
            & ( !CTBs:? (!JobNr.!jobID.!EMAIL.!CTBID) ?
              | (!CTBs|) (!JobNr.!jobID.!EMAIL.!CTBID):?CTBs
              )
            & :?prevTitle
            &   whl
              ' ( !files:%?file ?files
                & (   !CTBs:? (!JobNr.!file.?ctb.?ctbid) ?
                    & ( !ITEMS:? !ctb "::" !ctbid ?
                      |     !ITEMS
                            (!ITEMS:|" ")
                            !ctb
                            "::"
                            !ctbid
                        : ?ITEMS
                      )
                  | 
                  )
                )
            & (!parms:?+(O.?+(lang.?LANGUAGE.?)+?)+?|)
            & (   !toolURL:
                &   !jobs
                  :   ?
                      (!JobNr.? (!jobID done.?.?toolURL.?.?) ?)
                      ?
              | 
              )
            & !jobs:?A (!JobNr.?myjobs) ?Z
            &   whl
              ' (   !myjobs
                  :   ?B
                      (%@?jobid2 ?S.?a (!jobID,pending) ?z.?ZZ)
                      ?Y
                &   !B (!jobid2 !S.!a !jobID !z.!ZZ) !Y
                  : ?myjobs
                )
            & !A (!JobNr.!myjobs) !Z:?jobs
            & saveTable$CTBs
            & saveTable$jobs
            & (     ( !SPANGRPfil:
                    | nestML$(get$(!SPANGRPfil,X ML))
                    | 
                    )
                  : ?SPANGRP
                &   !SPANGRP
                  : (   ?
                        ( TEI
                        .   ?
                          ,   ?
                              (teiHeader.,)
                              ?
                              (text.,?SPANGRPS)
                              ?
                        )
                        ?
                    |   ? (text.?,? (body.?,?) ?) ?
                      & :?SPANGRPS
                    | ? (spanGrp.?,?) ?:?SPANGRPS
                    )
                & "If a tool produces more than 1 spanGrp, it is obliged to wrap the spanGrps in another element.
                   If the TEI doc has an empty teiHeader, it has the function of a wrapper."
                & Filename$!SPANGRPfil:?SPANGRPfilWithMetadata
                &     tekstXML
                    $ ( !DATE|
                      . !EMAIL
                      . !CTBID
                      . TBA
                      . AVAILABILITY
                      . XMLID
                      . str$!ITEMS
                      . !toolURL
                      .   !SPANGRPS:~
                        | !SPANGRP
                        | 
                      . !toolURL
                      . !LANGUAGE
                      )
                  : ?autogenerated
                &   put
                  $ (   str
                      $ ( toML
                        $ (   readTable$jobAbout
                            &   !jobAbout
                              :   ?
                                  ( !JobNr
                                  .   ?
                                      (userProvidedMetadata.?userProvidedMetadata)
                                      ?
                                  )
                                  ?
                            & (   !userProvidedMetadata:?A (fpi.?) ?Z
                                & !A !Z:?userProvidedMetadata
                              | 
                              )
                            &   inject
                              $ (   (     !autogenerated
                                        :   ?
                                            ( TEI
                                            .   ?
                                              ,   ?
                                                  ( teiHeader
                                                  .   ? (type.text) ?
                                                    , ?
                                                  )
                                                  ?
                                            )
                                            ?
                                      & (fen.Extent$!SPANGRP)
                                    | 
                                    )
                                    !userProvidedMetadata
                                . !autogenerated
                                . TEImetadata
                                )
                          | !autogenerated
                          )
                        )
                    , !SPANGRPfilWithMetadata
                    , NEW
                    )
                & !SPANGRPfilWithMetadata
              | 
              )
          | 
      )
      ( fixedMenuItems
      =     dezilacol UILangNames wheretogo parameters A Z
          , ContentType DestinationDir FieldName LocalFileName Name Size nofonts
        .   ( UILangNames
            =   G R
              .   readTable$linguae
                & !LaNg:?G
                &     map
                    $ ( ( 
                        =   L
                          .     setLang$!arg
                              & !linguae:? (?L.!arg.?) ?
                              & localized$!L
                            | 
                        )
                      . !arg
                      )
                  : ?R
                & setLang$!G
                & !R
            )
          & ( dezilacol
            =   A B G R
              .   !lANgs:?G:%?A ?B
                & !B !A:?lANgs
                & localized$!arg:?R
                & !G:?lANgs
                & !R
            )
          & !arg:(?wheretogo.?parameters)
          & (   !parameters:?A (UIlanguage.?) ?Z
              & !A !Z:?parameters
            | 
            )
          & (   !parameters:?A (TyPeFaCe.?) ?Z
              & !A !Z:?parameters
            | 
            )
          &     map
              $ ( ( 
                  =   att val
                    .       !arg
                          : ( FieldName,?FieldName
                            . Name,?Name
                            . ContentType,%?ContentType ?nofonts
                            . Size,?Size
                            . DestinationDir,?DestinationDir
                            . LocalFileName,?LocalFileName
                            )
                        &   "&"
                            FieldName
                            "="
                              queryEncode
                            $ ( str
                              $ (!ContentType ";" !nofonts ";" !DestinationDir ";" !LocalFileName)
                              )
                      |   !arg:(method|DATE.?)
                        & 
                      |   !arg:(?att.?val)
                        & "&" !att "=" queryEncode$!val
                  )
                .   (UIlanguage.dezilacol$!lANgs)
                    (TyPeFaCe.queryEncode$(!TyPeFaCe|"Comic Sans MS"))
                    !parameters
                )
            : % ?parameters
          & ( div
            .   (class.rightfloating)
              ,   helplink$()
                  " "
                  contactlink$()
                  " "
                  changeloglink$()
                  " "
                  ( a
                  .     (href.str$("/texton/" !wheretogo "?" !parameters))
                        (tabindex.0)
                    , localized$(UILangNames$(dezilacol$!lANgs))
                  )
            )
      )
      "
/**
 * entry
 *
 * Produce the front page of the Text Tonsorium. This is the landing page if
 * the Text Tonsorium is called without parameters indicating uploaded input
 * and (optionally) parameters such as language and desired output features.
 *
 * Called from entry.java
 */"
      ( entry
      =   
        .   setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          &   toML
            $ ( ("!DOCTYPE"." html")
                ( html
                .   (lang.!LaNg)
                  ,   ( head
                      .   
                        ,   ( meta
                            .     (http-equiv.Content-Type)
                                  (content."text/html; charset=UTF-8")
                              , 
                            )
                            ( title
                            .   
                              ,   localized
                                $ ( "Text Tonsorium - Natural Language Processing toolchains automatically composed and scheduled for you"
                                    "Text Tonsorium - automatisk sammens√¶tning og aktivering af sprogteknologiske v√¶rkt√∏jer"
                                  )
                            )
                            !StyleFront
                            ( meta
                            .     (name.description)
                                  ( content
                                  .   localized
                                    $ ( "This NLP workflow managment system automatically combines the necessary natural language processing tools to achieve your goal, in a way similar to how a trip planner computes the best route from your current position to your destination."
                                        "Dette workflow managment system kombinerer automatisk de sprogteknologiske v√¶rkt√∏jer som kan klare det m√•l du vil opn√•, p√• en m√•de som ligner hvordan en routeplanner beregner den bedste route fra din nuv√¶rende position til din destination."
                                      )
                                  )
                              , 
                            )
                      )
                      ( body
                      .   (class.bodycanvas)
                        , ( div
                          .   (class.canvasdiv)
                            ,   ( div
                                .   (class.overflowing)
                                  ,   ( div
                                      .     (class.leftfloating)
                                            (style."width: 50%; height: auto;")
                                        , ( a
                                          .     (href."https://clarin.dk/")
                                                (tabindex.0)
                                            , ( img
                                              .     (src."clarindk-banner.jpg")
                                                    (alt.CLARIN-DK)
                                                    (style."width: 100%; height: auto;")
                                                , 
                                              )
                                          )
                                      )
                                      ( div
                                      .     (class.rightfloating)
                                            (style."width: 50%; height: auto;")
                                        , ( p
                                          .   
                                            ,   ( div
                                                .     (class.rightfloating)
                                                      (style."width: 75%; height: auto;")
                                                  , ( a
                                                    .     (href."/texton/")
                                                          (tabindex.0)
                                                      , ( img
                                                        .     (src."texton.png")
                                                              (alt."Text Tonsorium")
                                                              ( style
                                                              . "width: 80%; height: auto;"
                                                              )
                                                          , 
                                                        )
                                                    )
                                                )
                                                ( div
                                                .     (class.leftfloating)
                                                      (style."width: 75%; height: auto;")
                                                  , fixedMenuItems$(.)
                                                )
                                          )
                                      )
                                )
                                ( div
                                .   
                                  , ( h2
                                    .   (class.smallmargin)
                                      ,   localized
                                        $ ( "A salon de beaut√© for Natural Language Processing"
                                            "En sk√∏nhedssalon for Sprogteknologi"
                                          )
                                    )
                                )
                                ( div
                                .   
                                  ,   ( p
                                      .   
                                        ,   localized
                                          $ ( "Upload your input to the Text Tonsorium using the form on this page. On the next page you specify the desired final result - there are several annotation types, file formats, languages and other traits to choose from. The hard part - orchestrating the Natural Language Processing tools that are needed to achieve your goal - is handled by this service. "
                                              "Upload dit input til Text Tonsorium ved hj√¶lp af formularen p√• denne side. P√• n√¶ste side specificerer du dit m√•l - der er adskillige indholdstyper, filformater, sprog og andre tr√¶k at v√¶lge imellem. Det sv√¶re - at orkestrere de sprogteknologiske v√¶rkt√∏jer som er n√∏dvendige for at opn√• dit m√•l - bliver h√•ndteret af denne service."
                                            )
                                      )
                                      ( form
                                      .     (enctype.multipart/form-data)
                                            (method.post)
                                            (action.specifyGoal)
                                            (class.formRounded)
                                            (accept-charset.UTF-8)
                                        , ( fieldset
                                          .   (class.topmargin)
                                            ,   ( legend
                                                .   (class.firstpage)
                                                  ,   localized
                                                    $ ("Upload input" "Upload input")
                                                )
                                                ( div
                                                .   (class.fileupload)
                                                  ,   ( label
                                                      .     (for.inp)
                                                            (class.firstpage)
                                                        ,   localized
                                                          $ ( "Select one or more files"
                                                              "Selekt√©r en eller flere filer"
                                                            )
                                                      )
                                                      ( input
                                                      .     (type.file)
                                                            (name.input)
                                                            (id.inp)
                                                            (size.50)
                                                            (multiple.multiple)
                                                        , 
                                                      )
                                                )
                                                ( p
                                                .   (class.smallmargin)
                                                  , ( strong
                                                    .   
                                                      , ( small
                                                        .   
                                                          ,   localized
                                                            $ ("... or ..." "... eller ...")
                                                        )
                                                    )
                                                )
                                                ( div
                                                .   (class.URLs)
                                                  ,   ( label
                                                      .     (for.area)
                                                            (class.firstpage)
                                                        ,     localized
                                                            $ ( "Enter addresses of web pages,"
                                                                "Indtast adresser af websider,"
                                                              )
                                                            (br.,)
                                                              localized
                                                            $ ( "one URL per line, each starting with http:// or https://"
                                                                "√©n URL pr. linje, startende med http:// eller https://"
                                                              )
                                                      )
                                                      ( textarea
                                                      .     (name.URLS)
                                                            (rows.3)
                                                            (cols.68)
                                                            (id.area)
                                                        , 
                                                      )
                                                )
                                                ( p
                                                .   (class.smallmargin)
                                                  , ( strong
                                                    .   
                                                      , ( small
                                                        .   
                                                          ,   localized
                                                            $ ("... or ..." "... eller ...")
                                                        )
                                                    )
                                                )
                                                ( div
                                                .   (class.typein)
                                                  ,   ( label
                                                      .     (for.free)
                                                            (class.firstpage)
                                                        ,   localized
                                                          $ ( "Type or copy and paste some text"
                                                              "Skriv eller kopi√©r tekst"
                                                            )
                                                      )
                                                      ( textarea
                                                      .     (name.text)
                                                            (rows.3)
                                                            (cols.68)
                                                            (id.free)
                                                        , 
                                                      )
                                                )
                                                ( div
                                                .   (class.topmargin)
                                                  ,   ( label
                                                      .   (class.firstpage)
                                                        ,   localized
                                                          $ ("Next step: " "N√¶ste trin: ")
                                                      )
                                                      ( input
                                                      .     (type.submit)
                                                            ( value
                                                            .   localized
                                                              $ ( "Specify the required result"
                                                                  "Specificer m√•l"
                                                                )
                                                            )
                                                        , 
                                                      )
                                                )
                                                ( input
                                                .     (type.hidden)
                                                      (name.UIlanguage)
                                                      (value.localized$!lANgs)
                                                  , 
                                                )
                                                ( input
                                                .     (type.hidden)
                                                      (name.TyPeFaCe)
                                                      (value.!TyPeFaCe)
                                                  , 
                                                )
                                                ( input
                                                .     (type.hidden)
                                                      (name.action)
                                                      (value.batch)
                                                  , 
                                                )
                                          )
                                      )
                                      ( p
                                      .   (class.indent)
                                        , ( small
                                          .   
                                            ,     localized
                                                $ ( "Find the most recent source code of the Text Tonsorium on "
                                                    "Find den seneste version af Text Tonsoriums kildekode p√• "
                                                  )
                                                ( a
                                                .     ( href
                                                      . "https://github.com/kuhumcst/texton"
                                                      )
                                                      (tabindex.0)
                                                  , GitHub
                                                )
                                                  localized
                                                $ ( ", where you can also contact us. "
                                                    ". Der kan du ogs√• kontakte os."
                                                  )
                                          )
                                      )
                                      ( p
                                      .   (class.indent)
                                        , ( small
                                          .   
                                            ,   localized
                                              $ ( "This service is free for small amounts of text. Do not send sensitive data to this service and use it at your own risk! "
                                                  "Brug denne side for sm√• m√¶ngder af tekst. Upload aldrig f√∏lsomme data. Brugen af tjenesten er p√• egen risiko!"
                                                )
                                          )
                                      )
                                      ( p
                                      .   (class.indent)
                                        , ( small
                                          .   
                                            ,     localized
                                                $ ("Change typeface to " "Skift skrifttype til ")
                                                ( a
                                                .     ( href
                                                      .   str
                                                        $ ( "/texton/?UIlanguage="
                                                            !LaNg
                                                            "&TyPeFaCe="
                                                              queryEncode
                                                            $ (     !TyPeFaCe
                                                                  : "Comic Sans MS"
                                                                & sans-serif
                                                              | "Comic Sans MS"
                                                              )
                                                          )
                                                      )
                                                      (tabindex.0)
                                                  ,       !TyPeFaCe
                                                        : "Comic Sans MS"
                                                      & sans-serif
                                                    | "Comic Sans MS"
                                                )
                                                ". "
                                                localized$("Why " "Hvorfor ")
                                                ( a
                                                .     ( href
                                                      . "https://theestablishment.co/hating-comic-sans-is-ableist-bc4a4de87093/"
                                                      )
                                                      (tabindex.0)
                                                  , "Comic Sans"
                                                )
                                                "? "
                                          )
                                      )
                                      readTable$footer
                                )
                          )
                      )
                )
              )
      )
      "
/**
 * exportTables
 *
 * Export all tables in a single file. The file's name must start with 'alltables'.
 * Optionally the export of production data can be suppressed.
 * (Production data are those data that are different in different instances of
 * Text Tonsorium.)
 *
 * Called from exportMetadata.java
 */"
      ( exportTables
      =   tabs tab Tables folder error prod mssg readTableFromFolder
        .     ( readTableFromFolder
              =   folder file
                .     !arg:(?folder.?file)
                    & get$(path$(!folder !file)):?!file
                  | str$("Cannot read " !arg)&~
              )
            & (!where:(?.?) ?|readTable$where)
            & !arg:(?prod.?arg)
            & (   @(!arg:(|alltables ?))
                & 0:?tabs
                & :?error
                & (   !where
                    :   ?
                        ( ?Tables
                        .   ?folder
                          &   whl
                            ' ( !Tables
                              :   ( %@?tab
                                  & (   readTableFromFolder$(!folder.!tab)
                                      & !tab+!tabs:?tabs
                                    |   log
                                      $ (str$(" Cannot read [" !tab "] in [" !folder "]."))
                                    )
                                  )
                                  ?Tables
                              )
                          & ~
                        )
                        ?
                  |   ( !tabs:?+where+?
                      | where+!tabs:?tabs
                      )
                    & "Store the name of the export file in the file itself."
                    & (   @(!arg:alltables ?)
                        & !arg:?AAA
                      | 
                      )
                    & (   !prod:
                        & "Do not export production data: empty tables consisting of production data only."
                        & log$(EMPTY !prodtables)
                        &   map
                          $ ( ( 
                              =   
                                .   :?!arg
                                  & log$(emptied !arg)
                              )
                            . !prodtables
                            )
                        & "Do not export contact email and service URL."
                        & 0:?jobNr
                        & readTable$toolprop
                        & readTable$tooladm
                        &     ( 
                              =     anotooladm A Z a z
                                  , ContactEmail ServiceURL
                                .   0:?anotooladm
                                  &   whl
                                    ' (   !arg
                                        :   (?A (ContactEmail.?ContactEmail) ?Z)
                                          + ?arg
                                      &   !A (ContactEmail."x@x.xxx") !Z
                                        : ?A (ServiceURL.?ServiceURL) ?Z
                                      & (   @(!ServiceURL:? "://" ? "/" ?z)
                                          &   str$("http://localhost/" !z)
                                            : ?ServiceURL
                                        | 
                                        )
                                      &     !anotooladm
                                          + (!A (ServiceURL.!ServiceURL) !Z)
                                        : ?anotooladm
                                      )
                                  & !anotooladm
                              )
                            $ !tooladm
                          : ?tooladm
                        &     ( baseUrlTools
                              . "http://localhost:8080"
                              . "Protocol and domain of infrastructure as made known to integrated tools"
                              )
                              ( wwwServer
                              . "http://localhost"
                              . "Protocol and domain of infrastructure as made known to users' browsers"
                              )
                              (password.!password."Empty string as password.")
                              (salt.!salt.)
                          : ?properties
                      | 
                      )
                    &   (   lst$(!tabs,path$!AAA,NEW)
                          & str$("Saved all tables in '" path$!AAA "'. " !error)
                        |   str
                          $ ( "Cannot write to ["
                              path$!AAA
                              "]. Check file access rights for JBoss/Tomcat."
                            )
                        )
                      : ?mssg
                    & (   !prod:
                        & "Reread all production tables, since those in memory are anonymized and thus useless."
                        & map$((=.readTable$!arg).!prodtables)
                        & readTable$jobNr
                        & readTable$tooladm
                        & readTable$properties
                      | 
                      )
                    & !mssg
                  )
              |   str
                $ "'exportTables$' must be called without argument or with the name of a file that must start with 'alltables'."
              )
          | str$"Cannot read table 'where'"&~
      )
      "
/**
 * getProperty
 *
 * Get baseUrlTools, wwwServer, password or salt. Returns empty string if key not available.
 */
"
      ( getProperty
      =   value
        .     readTable$properties
            & !properties:? (!arg.?value.?) ?
            & !value
          | !arg:salt&!salt
          | !arg:password&!password
          | 
      )
      ( handleToolsTakingBatchesOfInput
      =     A B Y Z surl collapse lastjobid jobby jobs JobNr jobID
          , ext newou more dp rl a I b O base jb mode post2 t
        .   !arg:(?JobNr.?jobs)
          & (   readTable$tooladm
              &   !jobs
                :   ?
                    ( !JobNr
                    .   ?
                        ( ?jobID
                        .   ( ?
                            .   ?surl
                              &   !tooladm
                                :   ?
                                  + ( ? (ServiceURL.!surl) ?
                                    :   ?
                                        (MultiInp.y|#>1)
                                        ?
                                    )
                                  + ?
                            . ?
                            )
                          : ?jobby
                        )
                        ?
                    )
                    ?
              & ( collapse
                =     jobby jobs dep url A I B O lastjobid more
                    , base job mode post2 output JobNr jobID myjobs
                  .   !arg:(?jobby.?jobs.?JobNr.?jobID)
                    &   !jobby
                      : ( ?dep
                        . ?url
                        .   ?A
                          + (I.?I)
                          + ?B
                          + (O.?O)
                          + (base.?base)
                          + (job.?job)
                          + (mode.?mode)
                          + (post2.?post2)
                        . ?output
                        )
                    & :?lastjobid
                    & !jobs:? (!JobNr.?myjobs) ?
                    & (   map
                        $ ( ( 
                            =   
                              .       !arg
                                    : ( ?jobid
                                      . ?dp
                                      . ?rl
                                      .   ?a
                                        + (I.!I)
                                        + ?b
                                        + (O.!O)
                                        + (base.!base)
                                        + (job.?jb)
                                        + (mode.!mode)
                                        + (post2.!post2)
                                      . ?ou
                                      )
                                  & ( !lastjobid:
                                    | abort-job$(!jobs.!JobNr.!lastjobid):?jobs
                                    )
                                  & !jobid:?lastjobid
                                  &   (!a:~0|)
                                      (!b:~0|)
                                | 
                            )
                          . !myjobs
                          )
                      . !lastjobid
                      . !jobs
                      )
                )
              & collapse$(!jobby.!jobs.!JobNr.!jobID):(?AB.?lastjobid.?jobs)
              &   !jobs
                :   ?A
                    ( !JobNr
                    .   ?B
                        ( !lastjobid ?more
                        . ?dp
                        . ?rl
                        .   ?a
                          + (I.?I)
                          + ?b
                          + (O.?O)
                          + (base.?base)
                          + (job.?jb)
                          + (mode.?mode)
                          + (post2.?post2)
                        . ?ou
                        )
                        ?Y
                    )
                    ?Z
              &     !A
                    ( !JobNr
                    .   !B
                        ( !lastjobid !more
                        .     map
                            $ ( ( 
                                =   
                                  .     !arg
                                      : (%@?arg ?.?.?.?+(base.!base)+?.?)
                                    & !arg
                                )
                              . !B
                              )
                            !dp
                        . !rl
                        .   list2sum$!AB
                          + (I.!I)
                          + (O.!O)
                          + (base.!base)
                          + (job.!jb)
                          + (mode.!mode)
                          + (post2.!post2)
                        .     !AB:% %
                            & @( !ou
                               : ? ("-" !JobNr "-" !lastjobid ?:?ext)
                               )
                            & str$(combined !ext):?newou
                            & sub$(!Y.!ou.!newou):?Y
                            & !newou
                          | !ou
                        )
                        !Y
                    )
                    !Z
                : ?jobs
            | 
            )
          & !jobs
      )
      "
/**
 * getJobArg
 *
 * Consults tables jobs.table and tooladm.table to answer several requests
 * Arguments: jobNr, jobID and one of the following requests:
 *      endpoint        the URL where the integrated tool lives
 *      filename        the name to be given to the output
 *      method          POST or GET
 *      requestString   the request string as HTTP-parameters or as XML
 *      isXML           y or n
 * Called from workflow.java
 */"
      ( getJobArg
      =   JobNr jobID jobby res A B makeList req servurl loggy
        .     !arg:(@(?:? #?JobNr).?jobID.?arg)
            & "\na:" !JobNr "/" !jobID "/" !arg:?loggy
            & ( !jobs
              | \n "b:readTable$jobs" !loggy:?loggy&readTable$jobs
              )
            & !( 
               ' ( $jobs
                 :   ?
                     ($JobNr.? ($jobID ?.?jobby) ?)
                     ?
                 )
               )
            & "\nc:Found" !loggy:?loggy
            &   !arg
              : (   endpoint
                  & \n "d:endpoint" !loggy:?loggy
                  & !jobby:(?.?arg.?)
                |   method
                  & "\nd:method" !loggy:?loggy
                  & !jobby:(?.?arg.?)
                  & ( !tooladm:~
                    |   \n "e:readTable$tooladm" !loggy:?loggy
                      & readTable$tooladm
                    )
                  &   !tooladm
                    :   ?
                      + ( ? (ServiceURL.!arg) ?
                        : ? (PostData.?arg) ?
                        )
                      + ?
                  & "\nf:" !arg !loggy:?loggy
                  &   (!arg:on&POST|GET)
                    : ?arg
                |   requestString
                  & \n "g:requestString" !loggy:?loggy
                  &   1+!runningThreads
                    : ?runningThreads
                    : (>!maxRunningThreads:?maxRunningThreads|?)
                  & \n "h:maxRunningThreads:" !maxRunningThreads !loggy:?loggy
                  &   log
                    $ ( str
                      $ ( "getJobArg:runningThreads:"
                          !runningThreads
                          " maxRunningThreads:"
                          !maxRunningThreads
                        )
                      )
                  & !jobby:(?.?servurl.?req.?)
                  & ( !tooladm:~
                    |   \n "i:readTable$tooladm" !loggy:?loggy
                      & readTable$tooladm
                    )
                  & !tooladm:?+(? (ServiceURL.!servurl) ?)+?
                  & ( makeList
                    =   B prefix
                      .   !arg:(?prefix.?arg)
                        &   mop
                          $ ( ( 
                              =   
                                .     !arg:(?arg.?B)
                                    &   ( !prefix:
                                        | "&" !prefix "=" !arg
                                        )
                                        makeList$(!prefix !arg.!B)
                                  | !prefix:
                                  | "&" !prefix "=" !arg
                              )
                            . !arg
                            . (=+)
                            )
                    )
                  & \n "j:makeList$" !req !loggy:?loggy
                  & makeList$(.!req):("&" ?arg|?arg)
                |   filename
                  & \n "g:filename" !loggy:?loggy
                  & !jobby:(?.?.?.?arg)
                )
            & str$!arg
          |   lst$(jobs,path$jobsError,NEW,WYD,RAW)
            & str$("SOMETHINGWRONG:[[" \n !loggy \n]])
      )
      "
/**
 * getNextJobID
 *
 * Given the jobNr of a workflow, return the next job that is not pending
 * (=waiting for an another job to produce some of its inputs).
 * Argument: jobNr
 * Returns: jobID (if job found in jobs.table)
 *          empty string (if job not found in jobs.table)
 * Called from workflow.java
 */"
      ( getNextJobID
      =   A B Y Z jobID dep g test err
        .     -11:?err
            & !arg:(?arg.?test)
            & -12:?err
            & @(!arg:? #?arg)
            & -13:?err
            & readTable$jobs
            & -14:?err
            & (     !jobs
                  :   ?A
                      ( !arg
                      .   ?B
                          (@?jobID.~(? (?,pending) ?):?dep.?g)
                          ?Y
                      )
                      ?Z
                & -15:?err
                & (   !test:justtesting
                    & -17:?err
                    & !jobID
                  |       !A
                          (!arg.!B (!jobID starting.!dep.!g) !Y)
                          !Z
                      : ?jobs
                    & -18:?err
                    & (   -19:?err
                        & (   saveTable$jobs
                            & -20:?err
                            & (!jobID|!err)
                          | !err
                          )
                      | !err
                      )
                  | 
                  )
              | 
              )
          | !err
      )
      "
/**
 * getStatusCode
 *
 *  Given a HTTP status code and an informatory text, return an HTML-file
 * with a heading containing the status code and the official short description
 * of the status code, a paragraph containing the informatory text and a
 * paragraph displaying a longer text explaining the code (From wikipedia).
 *
 * This function could just as well have been written in Java.
 *
 * Called from exportMetadata.java, register.java, setLanguage.java, stresstest.java, update.java, upload.java
 */"
      ( getStatusCode
      =   code tekst explanation heading
        .   ( heading
            =   n
              .   !arg:(?n.?arg)
                & (str$(h !n).,!arg) \r\n
            )
          & readTable$HTTP-status-codes
          & !arg:(?code.?tekst)
          & !HTTP-status-codes:? (!code.?arg.?explanation) ?
          &   toML
            $ ( !HTMLbodyContainer
              $ (heading$(1.!code " " !arg) paragraph$!tekst paragraph$!explanation)
              )
      )
      "
/**
 * goodRunningThreads
 *
 * If a tool returns 201, Text Tonsorium, while waiting for the results, can start another tool in a new thread.
 * To ensure that spawning new processes doesn't explode, limit the number of threads to about 8.
 *
 * Called from compute.java, upload.java, workflow.java
 */"
      ( goodRunningThreads
      =   
        .   (|log$(goodRunningThreads !runningThreads))
          & (!runningThreads:<8&y|n)
      )
      ( feedbackform
      =   
        .   paragraph
          $ ( (h2.,localized$("Feedback to the developer" "Feedback til udvikleren"))
              ( p
              .   
                ,   localized
                  $ ("Help us improve the Text Tonsorium." "Hj√¶lp os med at forbedre Text Tonsorium.")
              )
                form
              $ ( usermsg
                .   UserMsg$(localized$!suggestions.)
                    (br.,)
                    makeHiddenFields$!hiddenData
                )
            )
      )
      "
/**
 * contact
 *
 * Creates a web page containing email and box for feedback.
 *
 * Called from contact.java
 */"
      ( contact
      =   
        .   setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          &   toML
            $ ( HTML-SVG-bodyContainer
              $ ( contact
                .   (h1.,"Text Tonsorium ‚∏∫ " localized$(Contact Kontakt))
                    (p.,"Clarin.dk: info@clarin.dk")
                    (p.,localized$("Developer:" "Udvikler:") " bartj@hum.ku.dk")
                    feedbackform$
                )
              )
      )
      "
/**
 * help
 *
 * Creates a web page containing descriptions of tools and parameters.
 * Also explains graphically how tools are combined into workflows and
 * how a workflow is enacted.
 *
 * Called from help.java
 */"
      ( help
      =     tools langlist toolsSorted Title toolNr ToolID
          , features feats cumfeat usedonly usedFeatures
          , UIflowTitle featuresTitle toolsTitle workingTitle
        .   log$HELP
          & ( !arg:? (usedonly.?usedonly) ?
            | y:?usedonly
            )
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & log$(help !arg)
          & readTable$tooladm
          & readTable$toolprop
          & readTable$features
          & ( toolsSorted
            =   tool sorted Title
              .   0:?sorted
                &   whl
                  ' (   !tooladm
                      :   ?
                        + ( ? (Inactive.) ?
                          : ? (Title.?Title) ?
                          : ?tool
                          )
                        + ?tooladm
                    & (low$!Title.!tool)+!sorted:?sorted
                    )
                & mop$((=.!arg).!sorted.(=+))
            )
          & ( langlist
            =   tp L langs a b
              .     !toolprop:?+(!arg.~(? (lang,?) ?))+?
                  & 
                |   !toolprop:?tp
                  & 0:?L
                  &   whl
                    ' ( !tp:?+(!arg.? (lang,?langs) ?)+?tp
                      &   whl
                        ' ( !langs:(?a.?b)+?langs
                          & !L+!a+!b:?L
                          )
                      )
                  & (       mop
                          $ ( ( 
                              = .!arg:#*%@?arg&", " !arg
                              )
                            . !L
                            . (=+)
                            )
                        : ", " ?L
                      & str$!L
                    | 
                    )
            )
          & mop$((=..!arg).!features.(=+)):?feats
          & toolsSorted$:?tools
          & ( usedFeatures
            =   ToolID id tools toolprp cumfeat coll fts
              .   ( coll
                  =   R
                    .   1:?R
                      &   map
                        $ ( ( 
                            =   r e
                              .   1:?r
                                &   whl
                                  ' ( !arg:%?e+?arg
                                    & !e*!r:?r
                                    )
                                & !r*!R:?R
                                & 
                            )
                          . !arg
                          )
                      & !R
                  )
                & !arg:(?tools.?toolprp)
                & 0:?cumfeat
                &   whl
                  ' (   !toolprp
                      :   ?
                        + (   ?ToolID
                            &   !tools
                              :   ?
                                  ( ?
                                  .   ? (ToolID.?id) ?
                                    & !id:!ToolID
                                  )
                                  ?
                          . ?fts
                          )
                        + ?toolprp
                    &   map
                      $ ( ( 
                          =   feat in inou in ou
                            .   !arg:(?feat,?inou)
                              &   whl
                                ' ( !inou:(?in.?ou)+?inou
                                  & !feat\L(coll$!in*coll$!ou)+!cumfeat:?cumfeat
                                  )
                          )
                        . !fts
                        )
                    )
                & !cumfeat
            )
          &   ( !usedonly:y&usedFeatures$(!tools.!toolprop)
              | 
              )
            : ?cumfeat
          & 0:?toolNr
          &   toML
            $ ( HTML-SVG-bodyContainer
              $ ( help
                .   (h1.,"Text Tonsorium")
                    ( p
                    .   
                      ,   localized
                        $ ( "The Text Tonsorium is a workflow management system that not only executes workflows, but also composes workflows from building blocks. Each building block encapsulates a Natural Language Processing tool."
                            "Text Tonsorium er et workflow management system som ikke kun f√∏rer data gennem workflows, men ogs√• designer workflows ved hj√¶lp af 'byggeklodser'. Hver byggeklods indeholder et sprogteknologisk v√¶rkt√∏j."
                          )
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "In contrast to other workflow management systems, the Text Tonsorium focuses on results rather than on tools, so a general understanding of how the desired result is described is useful. Still, you may like to also know which tools currently are integrated in the Text Tonsorium. This page gives you information about both."
                            "N√•r du arbejder med Text Tonsorium, skal dit fokus v√¶re p√• det resultat som du vil opn√•, og ikke p√• de v√¶rkt√∏jer der er i v√¶rkt√∏jskassen. Derfor er det nyttigt at vide hvordan det √∏nskede resultat bedst kan beskrives. Du vil m√•ske alligevel ogs√• vide hvilke v√¶rkt√∏jer er integreret i Text Tonsorium. Denne side giver dig information om begge dele."
                          )
                    )
                    (h2.,localized$(Overview Overblik))
                    ( dl
                    .   
                      ,   ( dt
                          .   
                            , ( a
                              .   (href."#working") (tabindex.0)
                                ,     localized
                                    $ ( "How does the Text Tonsorium compute and enact workflows?"
                                        "Hvordan bliver arbejdsgange beregnet og eksekveret?"
                                      )
                                  : ?workingTitle
                              )
                          )
                          ( dt
                          .   
                            , ( a
                              .   (href."#UIflow") (tabindex.0)
                                ,     localized
                                    $ ( "Working with the Text Tonsorium"
                                        "At arbejde med Text Tonsorium"
                                      )
                                  : ?UIflowTitle
                              )
                          )
                          ( dt
                          .   
                            , ( a
                              .   (href."#features") (tabindex.0)
                                , localized$(Features Tr√¶k):?featuresTitle
                              )
                          )
                          ( dt
                          .   
                            , ( a
                              .   (href."#tools") (tabindex.0)
                                , localized$(Tools V√¶rkt√∏jer):?toolsTitle
                              )
                          )
                    )
                    ( h2
                    . ,(a.(id.working) (name.working),!workingTitle)
                    )
                    ( p
                    .   
                      ,     localized
                          $ ( "A workflow design consists of one or more tools connected by data streams, see Figure 1. In this diagra, we depict tools as shapes (squares, circles, stars, etc.) and data streams as edges between the shapes. "
                              "En arbejdsgang best√•r af et eller flere v√¶rkt√∏jer forbundet ved datastr√∏mme, se Figur 1. I diagrammet afbildes v√¶rkt√∏jer som figurer (firkanter, cirkler, stjerne, o.s.v.) og datastr√∏mme som linjer imellem dem. "
                            )
                          (br.,)
                            localized
                          $ ( "Broadly speaking, the Text Tonsorium can do two things with workflows: compose them and enact them. "
                              "Text Tonsorium kan g√∏re to helt forskellige ting med arbejdsgange: det kan sammens√¶tte arbejdsgange og det kan eksekvere dem. "
                            )
                          localized$("Here we show how it is done. " "Her viser vi hvordan. ")
                    )
                    ( div
                    .   (style."width: 100%; overflow: hidden;")
                      ,   ( div
                          .   (style."width: 550px; float: left;")
                            , ( figure
                              .   
                                ,   ( figcaption
                                    .   
                                      ,   ( a
                                          .   (id.Fig2) (tabindex.0)
                                            , localized$("Figure 1" "Figur 1")
                                          )
                                          ". "
                                            localized
                                          $ ( "Computation and enactment of workflow design."
                                              "Beregning og eksekvering af en arbejdsgang."
                                            )
                                    )
                                    illustration$createAndEnact
                              )
                          )
                          ( div
                          .   (style."margin-left: 550px;")
                            ,   ( h3
                                .   
                                  ,   localized
                                    $ ( "Composition of workflow design"
                                        "At s√¶tte en arbejdsgang sammen"
                                      )
                                )
                                ( ol
                                .   
                                  ,   ( li
                                      .   (id.pole1)
                                        ,     localized
                                            $ ( "Top of the diagram: The user has uploaded one or more documents that she wants to process using the Text Tonsorium. "
                                                "Toppen af diagrammet: Brugeren har uploadet en eller flere dokumenter som hun vil processere ved hj√¶lp af Text Tonsorium. "
                                              )
                                            (br.,)
                                              localized
                                            $ ( "Bottom of the diagram: The user has also specified the output she wishes to get from the Text Tonsorium. "
                                                "Bunden af diagrammet: Brugeren har ogs√• specificeret hvilket resultat hun √∏nsker at f√• fra Text Tonsorium."
                                              )
                                      )
                                      ( li
                                      .   (id.pole2)
                                        ,   localized
                                          $ ( "The first tool the Text Tonsorium adds to the design is in fact the last tool of the workflow: a tool that satisfies the user's goal. From there, it works backwards toward the input. "
                                              "Det f√∏rste v√¶rkt√∏j som Text Tonsorium tilf√∏jer til sit plan er faktisk det sidste v√¶rkt√∏j i arbejdsgangen: et v√¶rkt√∏j som opfylder brugerens m√•l. Derfra g√•r det bagl√¶ns mod inputtet. "
                                            )
                                      )
                                      ( li
                                      .   (id.pole3)
                                        ,   localized
                                          $ ( "Once the last tool of the workflow has been established, its input requirements become the new goal."
                                              "N√•r det sidste v√¶rkt√∏j i arbejdsgangen er valgt, bliver dets inputkrav det nye m√•l."
                                            )
                                      )
                                      ( li
                                      .   (id.pole4)
                                        ,   localized
                                          $ ( "This process of moving the goal repeats for each addition of a tool to the workflow design."
                                              "Dette forl√∏b, hvor m√•let bliver flyttet n√•r et v√¶rkt√∏j er tilf√∏jet, kan blive gentaget adskillige gange."
                                            )
                                      )
                                      ( li
                                      .   (id.pole5)
                                        ,   localized
                                          $ ( "When a tool is found that takes the user's uploaded document as input, it is still too early to claim that a viable workflow design has been found."
                                              "N√•r et v√¶rkt√∏j bliver tilf√∏jet som tager brugerens dokument som input, er det stadig for tidligt at p√•st√• at en arbejdsgang er fundet."
                                            )
                                      )
                                      ( li
                                      .   (id.pole6)
                                        ,     localized
                                            $ ( "Text Tonsorium retraces its path to see whether any of the tools in the path needs more inputs. "
                                                "Text Tonsorium f√∏lger stien bagl√¶ns og unders√∏ger om der undervejs er v√¶rkt√∏jer der forlanger flere inputs. "
                                              )
                                              localized
                                            $ ( "When Text Tonsorium finds such a tool, it again seeks toward the input to pick up the missing data. "
                                                "N√•r Text Tonsorium finder et s√•dant v√¶rkt√∏j, g√•r det igen mod inputtet for at pr√∏ve at opfylde behovet. "
                                              )
                                            (br.,)
                                              localized
                                            $ ( "Sometimes, another tool is added to the workflow design to fulfill the need."
                                                "Sommetider skal endnu et v√¶rkt√∏j tilf√∏jes for at opfylde behovet."
                                              )
                                      )
                                      ( li
                                      .   (id.pole7)
                                        ,   localized
                                          $ ( "In other cases, the needed input is the output of an already established component in the workflow."
                                              "I andre tilf√¶lde kan outputtet fra et andet v√¶rkt√∏j genanvendes."
                                            )
                                      )
                                      ( li
                                      .   (id.pole8)
                                        ,   localized
                                          $ ( "Again, Text Tonsorium crawls back towards the goal and tries to obtain any still missing inputs."
                                              "Text Tonsorium g√•r igen tilbage mod m√•let for at fors√∏ge at opfylde endnu ikke opfyldte inputkrav."
                                            )
                                      )
                                      ( li
                                      .   (id.pole9)
                                        ,     localized
                                            $ ( "Sometimes the Text Tonsorium inserts the same tool in the workflow design multiple times. "
                                                "Nogle gange inds√¶tter Text Tonsorium det samme v√¶rkt√∏j flere gange i arbejdsgangen. "
                                              )
                                              localized
                                            $ ( "In such cases, all incarnations of the tool have different parameters, so they do different things. "
                                                "I s√•danne tilf√¶lde bliver alle forekomster af v√¶rkt√∏jet styret med forskellige parametre, s√• de laver forskellige ting. "
                                              )
                                      )
                                      ( li
                                      .   (id.pole10)
                                        ,   localized
                                          $ ( "The Text Tonsorium has completed the composition of a viable workflow design when the last tool produces the output that the user wants and all tools get the inputs they need."
                                              "Text Tonsorium er f√¶rdig med konstruktionen af en brugbar arbejdsgang n√•r brugeren kan f√• det output hun √∏nsker fra det sidste v√¶rkt√∏j og alle v√¶rkt√∏jer f√•r de n√∏dvendige inputs."
                                            )
                                      )
                                )
                                ( h3
                                .   
                                  ,   localized
                                    $ ("Enactment of a workflow" "At eksekvere en arbejdsgang")
                                )
                                ( ol
                                .   
                                  ,   ( li
                                      .   (id.enact0)
                                        ,   localized
                                          $ ( "Once the Text Tonsorium has designed a workflow, we can ask it to enact the workflow with data that we have uploaded as input."
                                              "N√•r Text Tonsorium har sat en arbejdsgang sammen, kan vi lade Text Tonsorium eksekvere den med input som vi har uploadet."
                                            )
                                      )
                                      ( li
                                      .   (id.enact1)
                                        ,   localized
                                          $ ( "The input data is sent to the first tool in the workflow."
                                              "Inputtet er sent til det f√∏rste v√¶rkt√∏j i arbejdsgangen."
                                            )
                                      )
                                      ( li
                                      .   (id.enact2)
                                        ,   localized
                                          $ ( "The output from the first tool is sent to the second tool."
                                              "Outputtet fra det f√∏rste v√¶rkt√∏j sendes til det andet v√¶rkt√∏j."
                                            )
                                      )
                                      ( li
                                      .   (id.enact3)
                                        ,   localized
                                          $ ( "The output from the first tool is also sent to the third tool. Depending on the involved tools and the availability of processing units, this can happen at the same time."
                                              "Outputtet fra det f√∏rste v√¶rkt√∏j sendes ogs√• til det tredje v√¶rkt√∏j. Afh√¶ngig af de involverede v√¶kt√∏jer, kan v√¶rkt√∏jer aktiveres samtidig."
                                            )
                                      )
                                      ( li
                                      .   (id.enact4)
                                        ,   localized
                                          $ ( "A tool is not activated before all its required inputs are present."
                                              "Et v√¶rkt√∏j aktiveres ikke f√∏rend alle dets inputs er til stede."
                                            )
                                      )
                                      ( li
                                      .   (id.enact5)
                                        ,   localized
                                          $ ( "The same tool, with the same input, but with different parameters and therefore a different output."
                                              "Samme v√¶rkt√∏j, med det samme input, men styret af andre parametere og derfor med et andet output som f√∏lge."
                                            )
                                      )
                                      ( li
                                      .   (id.enact6)
                                        ,   localized
                                          $ ( "Many datastreams come together in the last tool in the workflow. This happens often, since users often wish to see many annotation layers in the output."
                                              "Mange datastr√∏mme kommer sammen i det sidste v√¶rkt√∏j i arbejdsgangen. Dette sker ofte. Brugere √∏nsker ofte at se mange annotationslag i outputtet."
                                            )
                                      )
                                      ( li
                                      .   (id.enact7)
                                        ,   localized
                                          $ ( "A single datstream, containing all required annotation layers, is made available to the user."
                                              "√ân enkel datastr√∏m, som indeholder alle annotationslag, st√•r til brugerens r√•dighed."
                                            )
                                      )
                                )
                          )
                    )
                    ( p
                    .   (style."clear:left;")
                      ,     localized
                          $ ( "The diagram above is a gross simplification. The main omission is that the Text Tonsorium always attempts to find not just one, but all roads leading to a goal."
                              "Ovenst√•ende tegning giver et forenklet billede. Hvad du ikke kan se er at Text Tonsorium altid fors√∏ger at finde ikke kun √©n, men alle veje der f√∏rer til m√•let."
                            )
                          (br.,)
                            localized
                          $ ( "The Text Tonsorium finds all workflows by trying out all tools and all tool parameter combinations."
                              "Text Tonsorium finder alle arbejdsgange ved at afpr√∏ve alle v√¶rkt√∏jer og alle v√¶rkt√∏jsindstillinger."
                            )
                    )
                    (h3.,localized$(Pruning Besk√¶ring))
                    ( p
                    .   
                      ,   localized
                        $ ( "The full set of workflows found by the Text Tonsorium is not presented to the user in its entirety. In general, there will be workflows that do not make much sense to a user. Many workflows will be pruned away."
                            "Brugeren bliver ikke pr√¶senteret for den fulde samling af de arbejdsgange som Text Tonsorium har fundet. Der vil n√¶sten altid v√¶re arbejdsgange som ikke giver s√• meget mening for en bruger. Derfor finder der en kraftig besk√¶ring sted som fjerner mange arbejdsgange."
                          )
                    )
                    ( h4
                    .   
                      ,   localized
                        $ ("Tools that compete for the same goal" "V√¶rkt√∏jer som konkurerer om samme m√•l")
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "In the following example, two tools compete to create output fulfilling the same goal. There are three tools that 'consume' the output. The consuming tools cannot take output from both competing tools. The question is: which of the competing tools should they choose?"
                            "I n√¶ste eksempel er der to v√¶rkt√∏jer som konkurerer om at levere output som opfylder samme m√•l. Der er tre v√¶rkt√∏jer som tager dette output som input. Disse tre v√¶rkt√∏jer kan ikke tage output fra to v√¶rkt√∏jer p√• √©n gang, men m√• v√¶lge."
                          )
                    )
                    ( div
                    .   (style."width: 100%; overflow: hidden;")
                      ,   ( div
                          .   (style."width: 550px; float: left;")
                            , ( figure
                              .   
                                ,   ( figcaption
                                    .   
                                      ,   ( a
                                          .   (id.Fig2) (tabindex.0)
                                            , localized$("Figure 2" "Figur 2")
                                          )
                                          ". "
                                          localized$("Pruning." "Besk√¶ring.")
                                    )
                                    illustration$prune
                              )
                          )
                          ( div
                          .   (style."margin-left: 550px;")
                            ,   ( ol
                                .   
                                  ,   ( li
                                      .   (id.unprun1)
                                        ,   localized
                                          $ ( "Non pruned, ambiguous workflow design containing two tools fulfillng the same goal."
                                              "Ikke-besk√•ret, flertydig arbejdsgang som indeholder to v√¶rkt√∏jer som opfylder det samme m√•l."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun2)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that ignores the second tool completely, configuration 1."
                                              "Besk√•ret, utvetydig arbejdsgang som ignorere det andet af de to v√¶rkt√∏jer, konfiguration 1."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun3)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 2."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 2."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun4)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 3."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 3."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun5)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 4."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 4."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun6)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 5."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 5."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun7)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 6."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 6."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun8)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 7."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 7."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun9)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that ignores the first tool completely, configuration 8."
                                              "Besk√•ret, utvetydig arbejdsgang som ignorere det f√∏rste af de to v√¶rkt√∏jer, konfiguration 8."
                                            )
                                      )
                                )
                                ( p
                                .   
                                  ,   localized
                                    $ ( "If a goal can be satified in M ways and there are N workflow nodes setting that goal, then there are N^M viable configurations. In the example, M = 2 and N = 3, so there are 2^3 = 8 confugurations."
                                        "Hvis et m√•l kan opfyldes p√• M m√•der og der er N knuder i arbejdsgangen som definerer dette m√•l, er der N^M gyldige konfigurationer. I eksemplet er M = 2 og N = 3, s√• der er 2^3 = 8 gyldige konfigurationer."
                                      )
                                )
                                ( p
                                .   
                                  ,   localized
                                    $ ( "As more and more tools were integrated in the the Text Tonsorium, situations where tools were competing arose more often, resulting in enormous amounts (sometimes tens of thousands) of viable workflow designs that the user would not be able to choose from."
                                        "Med tiden blev flere og flere v√¶rt√∏jer integreret i Text Tonsorium, og situationer hvor v√¶rkt√∏jer konkurerer forekom oftere og oftere. Det resulterede i uoverskuelig store m√¶ngder (nogle gange titusinder) af arbejdsgange som brugeren umuligt kunne v√¶lge imellem."
                                      )
                                )
                                ( p
                                .   
                                  ,   localized
                                    $ ( "Pruning reduces the amount of workflows that is presented to the user by excluding all workflow designs that contain two or more competing tools. Thus, in the example, only the first and the last configuration survive the pruning process. So, in the end, there are not N^M, but only M configurations."
                                        "Besk√¶ring nedbringer antallet af arbejdsgange som brugeren f√•r pr√¶senteret. Alle arbejdsgange som indeholder to eller flere konkurerende v√¶rkt√∏jer bliver sk√•ret v√¶k. I eksemplet er det kun den f√∏rste og den sidste konfiguration som overlever besk√¶ringen. Tilbage er derfor ikke N^M, men blot M konfigurationer."
                                      )
                                )
                          )
                    )
                    ( h4
                    .   
                      ,   localized
                        $ ( "Tools repelling another tool by 'smell'"
                            "V√¶rkt√∏jer som frast√∏der et andet v√¶rkt√∏j med 'lugtmarkering'"
                          )
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "Some tools should never occur in the same workflow design. For example, two Optical Character Recognition systems will, in general, output different numbers of tokens when given the same input, e.g. bacause one system sees white space where the other does not."
                            "Nogle v√¶rkt√∏jer b√∏r aldrig forekomme i den samme arbejdsgang. For eksempel vil to OCR-programmer (OCR=Optical Character Recognition) n√¶sten altid v√¶re uenige om antallet af ord i inputtet fordi det ene v√¶rkt√∏j ser blanktegn hvor det andet ikke g√∏r."
                          )
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "In the Text Tonsorium, tools that should not co-occur can be given a value for a 'smell' feature that spreads throughout the workflow. If two different smells collide, the workflow design is discarded."
                            "Text Tonsorium kan give forskellige v√¶rdier for et 'lugt'-attribut til v√¶rkt√∏jer som ikke passer sammen. Lugten spr√¶der sig gennem arbejdsgangen, men hvis den st√∏der in i en anden lugt, bliver arbejdsgangen kasseret."
                          )
                    )
                    (h2.,(a.(id.UIflow) (name.UIflow),!UIflowTitle))
                    ( p
                    .   
                      ,   localized
                        $ ( "The Text Tonsorium may compose many workflows that all lead to your goal. It will then ask you to choose one of the proposed workflows. In general, the more detail you add to your goal, the fewer solutions the Text Tonsorium will find, even zero. "
                            "Ofte beregner Text Tonsorium mange workflows, som alle f√∏rer til dit m√•l, og s√• skal du v√¶lge en af disse. Som tommelfingerregel g√¶lder det at hvis du udtrykker dit m√•l i flere detaljer, vil der v√¶re f√¶rre forslag til workflows, og m√•ske endda ingen."
                          )
                    )
                    ( dl
                    .   
                      ,   (dt.,"1: " localized$Upload)
                          ( dd
                          .   
                            ,     localized
                                $ ( "You can upload your input in three ways:"
                                    "Du kan uploade din tekst p√• tre m√•der:"
                                  )
                                ( dl
                                .   
                                  ,   (dt.,localized$("file upload" "fil upload"))
                                      ( dd
                                      .   
                                        ,     localized
                                            $ ( "Text Tonsorium can handle many different input formats."
                                                "Text Tonsorium kan h√•ndtere mange forskellige inputformater."
                                              )
                                            (br.,)
                                              localized
                                            $ ( "You are not limited to uploading a single file. We have done batches of over 100 files."
                                                "Du er ikke begr√¶nset til upload af en enkel fil. Vi har gode erfaringer med grupper med over 100 filer."
                                              )
                                      )
                                      (dt.,localized$("via URL" "via URL"))
                                      ( dd
                                      .   
                                        ,   localized
                                          $ ( "You can enter a list of URLs. Notice that some web pages require JavaScript to be active in the browser. Such webpages cannot be fetched successfully."
                                              "Du kan give en liste af URLer. Bem√¶rk at nogle websider kr√¶ver at JavaScript er aktiveret i din browser. S√•danne sider kan ikke hentes af Text Tonsorium."
                                            )
                                      )
                                      (dt.,localized$("direct typing" skrive))
                                      ( dd
                                      .   
                                        ,   localized
                                          $ ("You can type in a text" "Du kan skrive en tekst.")
                                      )
                                )
                          )
                          (dt.,"2: " localized$("Specify what you want" "Fort√¶l hvad du vil"))
                          (dd.,Input)
                          (dd.,localized$(Goal M√•l))
                          (dt.,"3: " localized$("Select a workflow" "V√¶lg en arbejdsgang"))
                          ( dt
                          .   
                            ,   "4: "
                                  localized
                                $ ("Launch the selected workflow" "Start den valgte arbejdsgang")
                          )
                          ( dt
                          .   
                            ,   "5: "
                                localized$("Inspect/download results" "Inspicer/Hent resultater")
                          )
                    )
                    ( h2
                    .   
                      , (a.(id.features) (name.features),!featuresTitle)
                    )
                    ( p
                    .   
                      ,     localized
                          $ ( "Data streams, but also the input and output specifications of tools, are described in terms of 'features'. "
                              "Datastr√∏mme, men ogs√• et v√¶rkt√∏js input- og outputspecifikationer, bliver beskrevet ved hj√¶lp af 'tr√¶k'. "
                            )
                            localized
                          $ ( "Features express things such as the language used in a text, file format, and the type of content."
                              "Tr√¶k beskriver ting som sproget som er anvendt i en text, filformat, og indholdstype."
                            )
                          (br.,)
                            localized
                          $ ( "Users are confronted with features and feature values when they specify the goal of a workflow design. "
                              "Brugere bliver konfronteret med tr√¶k og tr√¶kv√¶rdier n√•r de specificerer m√•let for en arbejdsgang. "
                            )
                            localized
                          $ ( "There is a second level of feature specification, a level that users normally aren't bothered with: "
                              "Der findes et andet niveau i tr√¶kspecifikationen, et niveau som brugeren normalt ikke skal bekymre sig om: "
                            )
                            localized
                          $ ( "feature values can be further specified with 'style descriptors'. "
                              "tr√¶kv√¶rdier kan blive beriget med 'stilindikatorer'. "
                            )
                          (br.,)
                            localized
                          $ ( "Feature values and style descriptors are always chosen from predefined sets of values, using drop down lists. "
                              "Tr√¶kv√¶rdier og stilindikatorer skal altid v√¶lges fra foruddefinerede v√¶rdiklasser. Det sker ved hj√¶lp af dropdownlister. "
                            )
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "This is the list of features that currently is defined in this instance of Text Tonsorium:"
                            "Dette er listen over tr√¶k som anvendes i denne version af Text Tonsorium:"
                          )
                    )
                    ( dl
                    .   
                      ,   map
                        $ ( ( 
                            =   n d t
                              .     !arg
                                  : ( 
                                    .   ? (name.?n) ?
                                      : ? (description.?d) ?
                                      : ? (table.?t) ?
                                    )
                                &   ( dt
                                    .   
                                      , (a.(href.str$("#" !t)),localized$!n)
                                    )
                                    (dd.,localized$!d)
                            )
                          . !feats
                          )
                    )
                      map
                    $ ( ( 
                        =   n t s sT description
                          .     !arg
                              : ( 
                                .   ? (name.?n) ?
                                  : ? (table.?t) ?
                                  : ? (short.?s) ?
                                  : ( ? (specificationTable.?sT) ?
                                    | ?&:?sT
                                    )
                                  : ? (description.?description) ?
                                )
                            & readTable$!t
                            &   ( a
                                .   (id.!t) (name.!t) (tabindex.0)
                                  , (h3.,localized$!n)
                                )
                                (p.,localized$!description)
                                ( dl
                                .   
                                  ,   map
                                    $ ( ( 
                                        =   n d a p f
                                          .   !arg:(?n.?a.?d)
                                            & (     !cumfeat
                                                  : ( 
                                                    | ?+!s\L(?*!a^?p*?)+?
                                                    )
                                                &   (dt.,localized$!n)
                                                    ( !d:
                                                    | (dd.,localized$!d)
                                                    )
                                                    (     !sT
                                                        :   ?
                                                            (? !a ?.?f)
                                                            ?
                                                      & readTable$!f
                                                      &   log
                                                        $ ( f
                                                            !f
                                                            cumfeat
                                                            !cumfeat
                                                            s
                                                            !s
                                                            a
                                                            !a
                                                          )
                                                      &   !!f
                                                        :   ?
                                                            ( (?.?short.?)
                                                            &   !cumfeat
                                                              : ( 
                                                                |   ?
                                                                  +   !s
                                                                    \L ( ?
                                                                      *   !a
                                                                        ^ ( ?
                                                                          +   ?
                                                                            * !short
                                                                            * ?
                                                                          + ?
                                                                          )
                                                                      * ?
                                                                      )
                                                                  + ?
                                                                )
                                                            )
                                                            ?
                                                      & ( dd
                                                        .   
                                                          , ( dl
                                                            .   
                                                              ,   ( dt
                                                                  .   
                                                                    ,   localized
                                                                      $ ( "Style options:"
                                                                          "Stilvalg:"
                                                                        )
                                                                  )
                                                                  ( dd
                                                                  .   
                                                                    , ( dl
                                                                      .   
                                                                        ,   map
                                                                          $ ( ( 
                                                                              =     full
                                                                                    short
                                                                                    dsc
                                                                                .       !arg
                                                                                      : ( ?full
                                                                                        . ?short
                                                                                        . ?dsc
                                                                                        )
                                                                                    &   !cumfeat
                                                                                      : ( 
                                                                                        |   ?
                                                                                          +   !s
                                                                                            \L ( ?
                                                                                              *   !a
                                                                                                ^ ( ?
                                                                                                  +   ?
                                                                                                    * !short
                                                                                                    * ?
                                                                                                  + ?
                                                                                                  )
                                                                                              * ?
                                                                                              )
                                                                                          + ?
                                                                                        )
                                                                                    &   ( dt
                                                                                        .   
                                                                                          ,   localized
                                                                                            $ !full
                                                                                        )
                                                                                        (   !dsc
                                                                                          : 
                                                                                        | ( dd
                                                                                          .   
                                                                                            ,   localized
                                                                                              $ !dsc
                                                                                          )
                                                                                        )
                                                                                  | 
                                                                              )
                                                                            . !!f
                                                                            )
                                                                      )
                                                                  )
                                                            )
                                                        )
                                                    | 
                                                    )
                                              | 
                                              )
                                        )
                                      . !!t
                                      )
                                )
                        )
                      . !feats
                      )
                    (h2.,(a.(id.tools) (name.tools),!toolsTitle))
                    ( p
                    .   
                      ,   localized
                        $ ( "These are the currently active tools:"
                            "Her er listen med tilg√¶ngelige v√¶rkt√∏jer:"
                          )
                    )
                    ( table
                    .   
                      ,   ( thead
                          .   
                            ,   (th.,"#")
                                (th.,"Name of the tool")
                                (th.,"Supported languages")
                          )
                          ( tbody
                          .   
                            ,   map
                              $ ( ( 
                                  =   Title
                                    .     !arg
                                        : ( ?
                                          .   ? (Title.?Title) ?
                                            : ? (ToolID.?ToolID) ?
                                          )
                                      & ( tr
                                        .   
                                          ,   (td.,!toolNr+1:?toolNr)
                                              ( td
                                              .   
                                                , ( a
                                                  .     (href.str$("#" !ToolID))
                                                        (tabindex.0)
                                                    , !Title
                                                  )
                                              )
                                              (td.,langlist$!ToolID)
                                        )
                                  )
                                . !tools
                                )
                          )
                    )
                      map
                    $ ( ( 
                        =   Description ToolID Title
                          .       !arg
                                : ( ?
                                  .   ? (ToolID.?ToolID) ?
                                    : ? (Title.?Title) ?
                                    : ? (Description.?Description) ?
                                  )
                              &   ( a
                                  .     (id.!ToolID)
                                        (name.!ToolID)
                                        (tabindex.0)
                                    , (h3.,!Title)
                                  )
                                  (p.,!Description)
                            | 
                        )
                      . !tools
                      )
                )
              )
      )
      "
/**
 * importTables
 *
 * Import earlier exported tables, from the same or from another instance of Text Tonsorium.
 * The tabel tooladm, which contains fields with values to the instance, is extended, but not
 * the values for contact email and for the tool's URL are not overwritten.
 *
 * Called from importMetadata.java
 */"
      ( importTables
      =   prod missingToolprop prodtoolprop productionTables tdata tid saveAllTables
        .     ( saveAllTables
              =   tab saved folder
                .   !arg:
                  & :?saved
                  & (   !where
                      :   ?
                          ( ?Tables
                          .   ?folder
                            &   whl
                              ' ( !Tables
                                :   ( %?tab
                                    & saveTable$(!folder.!tab)
                                    & !saved !tab:?saved
                                    )
                                    ?Tables
                                )
                            & ~
                          )
                          ?
                    | Saved !saved
                    )
              )
            & !arg:(?prod.?arg)
            & @(!arg:alltables ?)
            & ( (   !prod:
                  &   map$((=.!arg.readTable$!arg).!prodtables)
                    : ?productionTables
                  & get$(path$!arg)
                  & saveAllTables$
                  & readTable$tooladm
                  & readTable$toolprop
                  & :?missingToolprop
                  &   map
                    $ ( ( 
                        =     name productioncontent
                            , anotool ToolID prodtool mergedtooladm
                          .   !arg:(?name.?productioncontent)
                            & (   !name:tooladm
                                & "Use the imported non-production tooladm, but inject ContactEmail ServiceURL from current production tooladm"
                                & 0:?mergedtooladm
                                &   whl
                                  ' (   !tooladm
                                      :   ( ? (ToolID.?ToolID) ?
                                          : ?anotool
                                          )
                                        + ?tooladm
                                    & (     !productioncontent
                                          :   ?
                                            + ( ? (ToolID.!ToolID) ?
                                              : ?prodtool
                                              )
                                            + ?
                                        &   map
                                          $ ( ( 
                                              =   a z anoval prodval
                                                .     !anotool
                                                    : ?a (!arg.?anoval) ?z
                                                  &   !prodtool
                                                    : ? (!arg.?prodval) ?
                                                  & ( !anoval:!prodval
                                                    |     !a
                                                          (!arg.!prodval)
                                                          !z
                                                      : ?anotool
                                                    )
                                              )
                                            . ContactEmail ServiceURL
                                            )
                                      | 
                                      )
                                    & !mergedtooladm+!anotool:?mergedtooladm
                                    )
                                & log$OUTLIERS
                                &   whl
                                  ' (   !productioncontent
                                      :   ( ? (ToolID.?ToolID) ?
                                          : ?prodtool
                                          )
                                        + ?productioncontent
                                    & (   !mergedtooladm
                                        : ?+(? (ToolID.!ToolID) ?)+?
                                      |   !prodtool+!mergedtooladm:?mergedtooladm
                                        &   !ToolID !missingToolprop
                                          : ?missingToolprop
                                      )
                                    )
                                & !mergedtooladm:?productioncontent
                              | 
                              )
                            & ( !name:toolprop
                              |   !productioncontent:?!name
                                & saveTable$!name
                              )
                        )
                      . !productionTables
                      )
                  & ( !missingToolprop:&log$NOTHINGMISSING
                    |   !productionTables:? (toolprop.?prodtoolprop) ?
                      & log$HAVETOINSERT
                      & readTable$toolprop
                      &   whl
                        ' (   !prodtoolprop
                            :   ?
                              + (   ?tid
                                  & !missingToolprop:? !tid ?
                                . ?tdata
                                )
                              + ?prodtoolprop
                          & (!tid.!tdata)+!toolprop:?toolprop
                          )
                      & saveTable$toolprop
                    )
                  & "Imported file, but kept local production data."
                |   get$(path$!arg)
                  & saveAllTables$
                  & "Initialized all tables from imported file."
                )
              | str$("Cannot read " !arg)&~
              )
          | str$"Usage: importTables$\"<file name>\" .  <file name> must start with 'alltables'."
      )
      "
/**
 * isTEIoutput
 *
 * Takes the identification of a result (consisting of job nr and job ID) and determines the format of the result.
 * Returns the format as a string if the format is txtann, txtbasis or teip5 and an empty string otherwise.
 *
 * Called from util.java
 */"
      ( isTEIoutput
      =   format JobNr jobID
        .   readTable$jobs
          & !arg:(@(?:? #?JobNr).?jobID)
          & (@(!jobID:?jobID " " ?)|)
          & (     !jobs
                :   ?
                    ( !JobNr
                    .   ?
                        ( !jobID ?
                        . ?
                        . ?
                        .   ?
                          + ( O
                            .   ?
                              + ( format
                                .   ( txtann
                                    | txtbasis
                                    | teip5
                                    )
                                  : ?format
                                . ?
                                )
                              + ?
                            )
                          + ?
                        . ?
                        )
                        ?
                    )
                    ?
              & !format
            | 
            )
      )
      "
/**
 * keep
 *
 * Check whether a file in the staging area can be deleted.
 *
 * Files that are still needed in other tasks must be kept.
 * The function looks for outstanding jobs that take the argument as input.
 * Argument: file name, may be preceded by a slash
 *      /19231210291
 *
 * Called from cleanup.java
 */"
      ( keep
      =     jobNr jobID jobstatus files toolURL parms file
          , find jobNrParm stagingName stem
        .   ( find
            =   x T L R
              .   !arg:(?x.?T)
                & ( !x:!T
                  |   !T:?L_?R
                    & (find$(!x.!L)|find$(!x.!R))
                  )
            )
          & log$(keep !arg)
          & !arg:(?stagingName.?jobNrParm)
          & (@(!stagingName:? "/" ?stagingName)|)
          & (   ( @(!stagingName:?stem ".withmetadata.xml")
                & str$(!stem ".xml")
                )
              : ?stagingName
            | 
            )
          & (   @(!stagingName:!jobNrParm ("-all"|"-final") ".zip")
              & "Zip-files must die after some days."
              & no
            |   !jobNrParm:
              & (     !jobs
                    :   ?
                        ( ?jobNr
                        .   ?
                            ( (%?jobID ?jobstatus.?files.?toolURL.?parms.?file)
                            & ( !files:? !stagingName ?
                              | !file:!stagingName
                              |   !parms:?+(I.?parms)+?
                                & find$(!stagingName.!parms)
                              )
                            &   !jobstatus
                              : (|waiting|starting)
                            )
                            ?
                        )
                        ?
                  & "Some job is still using this file. Keep it."
                  & log$(!stagingName yes)
                  & yes
                |   "There are no unfinished jobs using this file. Time to let the file go."
                  & log$(!stagingName no)
                  & no
                )
            |     !jobs
                :   ?
                    ( ~!jobNrParm
                    .   ?
                        ( (?.?files.?.?parms.?file)
                        & ( !files:? !stagingName ?
                          | !file:!stagingName
                          |   !parms:?+(I.?parms)+?
                            & find$(!stagingName.!parms)
                          )
                        )
                        ?
                    )
                    ?
              & "The user wants to delete everything from this job, but another job is still using the file. So, no. Keep it."
              & log$(!stagingName !jobNrParm yes)
              & yes
            |   "The user's wish can be fulfilled."
              & log$(!stagingName !jobNrParm no)
              & no
            )
      )
      "
/**
 * letter
 *
 * Input: <Job number>.<'y' or 'n'>
 * Output: a semicolon separated list of filenames, followed by an HTML page that explains what each file is.
 *
 * Called from zipresults.java
 */"
      ( letter
      =     workflow steps resources files inps Steps
          , html metadata explain type shortletter jobMetaData
        .   log$(letter !arg)
          & ( inps
            =   a
              .     !arg:%?a ?arg
                  & (a.(href.!a),!a) (br.,) inps$!arg
                | 
            )
          & ( explain
            =   explanation
              .     !fileFormats:? (?.!arg.?explanation) ?
                  & !explanation:~
                  & " (" localized$!explanation ") "
                | 
            )
          & ( Steps
            =     body JobNr JobId filename tool
                , items I O format id title fil
                , Href2 Href2nometa
                , stage steps shortletter type
              .   !arg:(?steps.?shortletter.?type)
                &     map
                    $ ( ( 
                        =   
                          .     !arg
                              : ( step
                                .   
                                  ,   (JobNr.,?JobNr)
                                      (JobId.,?JobId)
                                      (name.,?filename)
                                      (tool.,?tool)
                                      (items.,?items)
                                      (input.,?I)
                                      (output.,?O)
                                      (format.,?format)
                                      (stage.,?stage)
                                )
                            &   whl
                              ' (   !items
                                  :   ( item
                                      .   
                                        ,   ? (id.,?id) ?
                                          : ? (title.,?title) ?
                                      )
                                      ?items
                                & ( !resources:? !title ?
                                  |   !resources !title:?resources
                                    & (     !Uploads
                                          : ? (?.!title.?fil.?) ?
                                        & ( !shortletter:y
                                          |   !files "file:" !fil "*" !title ";"
                                            : ?files
                                          )
                                      | 
                                      )
                                  )
                                )
                            & (   @(!filename:fejl ?)
                                &   ( h2
                                    .   
                                      ,   localized
                                        $ ("The following step(s) failed:" "F√∏lgende trin fejlede:")
                                    )
                                    ( dl
                                    .   
                                      ,   ( dt
                                          .   
                                            , ( strong
                                              .   
                                                ,   str
                                                  $ (localized$("Step " "Trin ") !JobId)
                                              )
                                          )
                                          (dd.,!tool)
                                    )
                              |   @(!filename:skipped ?)
                                & ( dl
                                  .   
                                    ,   ( dt
                                        .   
                                          , ( strong
                                            .   
                                              , ( s
                                                .   
                                                  ,   str
                                                    $ (localized$("Step " "Trin ") !JobId)
                                                )
                                            )
                                        )
                                        (dd.,(s.,!tool))
                                  )
                              |   ( !shortletter:~y
                                  | !stage:LAST
                                  )
                                &   ( !type:TEI&
                                    |   
                                      &   !format
                                        : ( txtbasis
                                          | teip5
                                          | txtann
                                          )
                                      & Filename$!filename
                                    | 
                                    )
                                  : ?Href2
                                & FilenameNoMetadata$!filename:?Href2nometa
                                &   ( dt
                                    .   
                                      , ( strong
                                        .   
                                          ,   str
                                            $ ( localized$("Step " "Trin ")
                                                !JobId
                                                (   !shortletter:y
                                                  & 
                                                |   !stage:LAST
                                                  & localized$(" (last)" " (sidste)")
                                                | 
                                                )
                                              )
                                        )
                                    )
                                    ( dd
                                    .   
                                      ,   (   ( @(!O:? TEI ?)
                                              | !Href2:~
                                              )
                                            & (     !format
                                                  : (txtbasis|teip5)
                                                & !type:TEI
                                                &   !files "file:" !Href2nometa ";"
                                                  : ?files
                                                &   str$(!tool ": ")
                                                    ( a
                                                    .     (href.!Href2nometa)
                                                          (tabindex.0)
                                                      ,   localized
                                                        $ ( "with original metadata"
                                                            "med oprindelig metadata"
                                                          )
                                                    )
                                              |     !format
                                                  : ( txtann
                                                    | txtbasis
                                                    | teip5
                                                    )
                                                &     !files
                                                      "file:"
                                                      ( !Href2:
                                                      | !Href2 ";file:"
                                                      )
                                                      !Href2nometa
                                                      ";"
                                                  : ?files
                                                &   str$(!tool ": ")
                                                    ( !Href2:
                                                    |   ( a
                                                        .     (href.!Href2)
                                                              (tabindex.0)
                                                          ,   localized
                                                            $ ( "including metadata"
                                                                "inklusiv metadata"
                                                              )
                                                        )
                                                        ","
                                                    )
                                                    ( a
                                                    .     (href.!Href2nometa)
                                                          (tabindex.0)
                                                      ,   localized
                                                        $ ("without metadata" "uden metadata")
                                                    )
                                              | !Href2:
                                              |       !files
                                                      "file:"
                                                      !Href2
                                                      "*"
                                                      !filename
                                                      ";"
                                                  : ?files
                                                &   str$(!tool ": ")
                                                    ( a
                                                    .     (href.!filename)
                                                          (tabindex.0)
                                                      , basistekst
                                                    )
                                                    explain$!format
                                              )
                                          |       !files
                                                  "file:"
                                                  !Href2nometa
                                                  "*"
                                                  !filename
                                                  ";"
                                              : ?files
                                            &   str$(!tool ": ")
                                                (a.(href.!filename),data)
                                                explain$!format
                                          )
                                          ( !I:!O:
                                          | ( dl
                                            .   
                                              ,   ( !I:
                                                  |   (dt.,Input)
                                                      (dd.,!I)
                                                  )
                                                  ( !O:
                                                  |   (dt.,Output)
                                                      (dd.,!O)
                                                  )
                                            )
                                          )
                                    )
                              | 
                              )
                        )
                      . !steps
                      )
                  : ?body
                & (dl.,!body)
            )
          & ( jobMetaData
            =     userProvidedMetadata Metadata Heading Fields
                , listOfFields Val XPath workflow
                , ID TextInUI Required Control Place
                , Notes HelpText Pattern URL type
              .     readTable$jobAbout
                  & (     !jobAbout
                        :   ?
                            ( !arg
                            .   ? (human.?workflow) ?
                              : ? (userProvidedMetadata.?userProvidedMetadata) ?
                            )
                            ?
                      & readTable$TEImetadata:?Metadata
                      &   ( !userProvidedMetadata:&TEI
                          | UserProvided
                          )
                        : ?type
                      & ( XPath
                        =   el at
                          .     !arg:%?el ?arg
                              & (   !el:(?el.?at)
                                  & "/" !el "/@" !at
                                | "/" !el XPath$!arg
                                )
                            | 
                        )
                      & ( listOfFields
                        =   
                          .   map
                            $ ( ( 
                                =   
                                  .     !arg
                                      : ( ?ID
                                        . ?TextInUI
                                        . ?Required
                                        . ?Control
                                        . ?Place
                                        . ?Notes
                                        . ?HelpText
                                        . ?Pattern
                                        . ?URL
                                        )
                                    & (     !userProvidedMetadata
                                          : ? (!ID.?Val) ?
                                        &   (dt.,addurl$(localized$!TextInUI.!URL))
                                            (dd.,"XPath: " XPath$!Place)
                                            ( dd
                                            .   
                                              ,   localized$(Value V√¶rdi)
                                                  ": "
                                                  ( strong
                                                  .   
                                                    ,   !Val:~
                                                      | " "
                                                  )
                                            )
                                      | 
                                      )
                                )
                              . !arg
                              )
                        )
                      & (   map
                          $ ( ( 
                              =   Heading Fields L
                                .     !arg:(?Heading,?Fields)
                                    & listOfFields$!Fields:~:?L
                                    & (h2.,localized$!Heading) (dl.,!L)
                                  | 
                              )
                            . !Metadata
                            )
                        . !type
                        )
                    | (.)
                    )
                | (.)
            )
          & !arg:(?arg.?shortletter)
          & "shortletter: y or n or c (code 20230110)"
          & ( !shortletter:c
            |   ( 
                =   zippedresults zipfile
                  .   (readTable$zippedresults|:?zippedresults)
                    &     str
                        $ ( !arg
                            ( !shortletter:y&"-final"
                            | "-all"
                            )
                            ".zip"
                          )
                      : ?zipfile
                    & ( !zippedresults:? !zipfile ?
                      | !zipfile !zippedresults:?zippedresults
                      )
                    & saveTable$zippedresults
                )
              $ !arg
            )
          & jobMetaData$!arg:(?metadata.?type)
          & "type == () | TEI | UserProvided"
          & readTable$fileFormats
          & readTable$Uploads
          & letterData$!arg:(workflow.,?workflow) (steps.,?steps)
          & :?resources:?files
          &     toML
              $ ( html
                .   
                  ,   ( head
                      .   
                        ,   (meta.charset.UTF-8)
                            ( title
                            . ,localized$("Results from CLARIN-DK tools" "Resultater fra Tools")
                            )
                            !Style
                      )
                      ( body
                      .   (class.bodycanvas)
                        , ( div
                          .   (class.canvasdiv)
                            ,   (h1.,localized$(Results Resultater))
                                (h2.,Workflow)
                                (p.,!workflow)
                                (h2.,localized$(Steps Trin))
                                (dl.,Steps$(!steps.!shortletter.!type))
                                (   !shortletter:(c|y)
                                  & 
                                |   ( h2
                                    .   
                                      , localized$("Input to the workflow:" "Workflowets input:")
                                    )
                                    (p.,inps$!resources)
                                )
                                !metadata
                          )
                      )
                )
            : ?html
          & str$(!files !html)
      )
      "
/**
 * parseStatusCode
 *
 * Find the number greater than 100 immediately following the string
 * 'HTTP-status-code'
 *
 * Called from upload.java
 */"
      ( parseStatusCode
      = .@(!arg:HTTP-status-code (#>100:?arg) ?)&!arg
      )
      "
/**
 * parsemessage
 *
 * Find the text following the number greater than 100 immediately following the string
 * 'HTTP-status-code'
 *
 * Called from upload.java
 */"
      ( parsemessage
      = .@(!arg:HTTP-status-code #>100 ?arg)&!arg
      )
      "
/**
 * percentEncodeURL
 *
 * Transforms each 8-bit byte to a percent encoded character, unless the byte represents an ASCII (7-bits) character.
 *
 * Called from compute.java, workflow.java
 */"
      ( percentEncodeURL
      =   pEU
        .   ( pEU
            =   A h
              .   @(!arg:?A (%@:>"~":?h) ?arg)
                & d2x$(asc$!h):?h
                & !A "%" upp$!h pEU$!arg
            )
          & str$(pEU$!arg)
      )
      "
/**
 * poll
 *
 * Checks every 5 seconds whether the results of a workflow are all available.
 * When all results are available, the returned web page contains links to the
 * zipped output, and the page is no more auto-reloaded.
 *
 * Called from poll.java
 */"
      ( poll
      =     n step secs steplinks links DOWNLOADPSEUDOCODE
          , serviceurl title DOWNLOAD steptexts mode
          , runningParagraphs JobNr hours minutes myjobs
        .   ( steplinks
            =     links locJobs file step outp ServiceURL JobNr
                , seenInputs Title myjobs
              .   !arg:(?JobNr.?locJobs)
                & !locJobs:? (!JobNr.?myjobs) ?
                & !( 
                   ' ( $myjobs
                     :   ?
                         ( (step1 ?.?file.?.?.?outp) ?
                         : ?locJobs
                         )
                     )
                   )
                & :?seenInputs
                &       map
                      $ ( ( 
                          =   files status
                            .     !arg:(?status.?files.?.?.?)
                                &   map
                                  $ ( ( 
                                      =   
                                        .     !( 
                                               ' ( $Uploads
                                                 : ? (?.?.$arg.?) ?
                                                 )
                                               )
                                            & (   !seenInputs:? !arg ?
                                                & 
                                              |   !arg !seenInputs:?seenInputs
                                                &   paragraph
                                                  $ ( "input:"
                                                      ( a
                                                      .     ( href
                                                            .   str
                                                              $ ( !wwwServer
                                                                  "/texton/data/"
                                                                  !arg
                                                                )
                                                            )
                                                            (tabindex.0)
                                                        , !arg
                                                      )
                                                    )
                                              )
                                          |   !arg:(?,?)
                                            & 
                                          |     !arg
                                              : @
                                              : @(!arg:step ?)
                                            & 
                                          | 
                                      )
                                    . !files
                                    )
                              | 
                          )
                        . !locJobs
                        )
                        map
                      $ ( ( 
                          =   
                            .       !arg
                                  : (?step done.?.?ServiceURL.?.?file)
                                &   !tooladm
                                  :   ?
                                    + ( ? (ServiceURL.!ServiceURL) ?
                                      : ? (Title.?Title) ?
                                      )
                                    + ?
                                &   paragraph
                                  $ ( str$(!step ":")
                                      ( a
                                      .     (href.str$(!wwwServer "/texton/data/" !file))
                                            (tabindex.0)
                                        , !file
                                      )
                                      " ("
                                      !Title
                                      ")"
                                    )
                              | 
                          )
                        . !locJobs
                        )
                  : ?links
                & ( !links:% %
                  | !locJobs:? (!JobNr.?) ?
                  |     !links
                          paragraph
                        $ ( "output:"
                            (a.(href.str$(!wwwServer "/texton/data/" !file)),!outp)
                          )
                    : ?links
                  )
                & !links
            )
          & " ( I
              .   (ambig.una.0)
                + (app.nrm.0)
                + ( facet
                  .   (seg.F.\"text-1-905-step5.xml\")
                    + (tok.(F.\"text-1-905-step4.xml\")+(PT.0))
                  )
                + (format.txtann.0)
                + (lang.en.0)
                + (period.c21.0)
                + (pres.nml.0)
              )
            + ( O
              .   (ambig.una.0)
                + (app.nrm.0)
                + (facet.pos.PT)
                + (format.txtann.0)
                + (lang.en.0)
                + (period.c21.0)
                + (pres.nml.0)
              )
            + (base.\"http://localhost/texton/data/\")
            + (job.905-step6)
            + (mode.dry)
            + (post2.\"http://localhost/texton/upload\")"
          & ( steptexts
            =     links locJobs file step outp ServiceURL JobNr Title feat inputs
                , rapport vals
              .   !arg:(?JobNr.?locJobs)
                & !( 
                   ' ( $locJobs
                     :   ?
                         ( ($JobNr.step1 ?.?file.?.?.?outp) ?
                         : ?locJobs
                         )
                     )
                   )
                &     map
                    $ ( ( 
                        =   src I
                          .       !arg
                                : ( !JobNr
                                  . ?step done
                                  . ?src
                                  . ?ServiceURL
                                  . ?+(I.?I)+?
                                  . ?file
                                  )
                              &   !tooladm
                                :   ?
                                  + ( ? (ServiceURL.!ServiceURL) ?
                                    : ? (Title.?Title) ?
                                    )
                                  + ?
                              &   ( get$(str$(data/ !file),STR)
                                  | str$("Received " !file)
                                  )
                                : ?rapport
                              &   paragraph$(str$(!step ":") " " !Title)
                                    paragraph
                                  $ ( str
                                    $ ( "source:"
                                        (   !src:% %
                                          &   !I
                                            : ?+(?feat.%+%:?vals)+?
                                          & 0:?inputs
                                          &   map
                                            $ ( ( 
                                                =   
                                                  .       !vals
                                                        :   ?
                                                          + ( ?val
                                                            .   ?
                                                              + ( F
                                                                . @( ?
                                                                   : ? !arg ?
                                                                   )
                                                                )
                                                              + ?
                                                            )
                                                          + ?
                                                      &     (str$(!feat !val).!arg)
                                                          + !inputs
                                                        : ?inputs
                                                    | 
                                                )
                                              . !src
                                              )
                                          &   mop
                                            $ ( ( 
                                                =   
                                                  .   !arg:(?fv.?stp)
                                                    & " " !stp "($I" !fv "F)"
                                                )
                                              . !inputs
                                              . '$inputs
                                              )
                                        | " " !src
                                        )
                                      )
                                    )
                                  (pre.,!rapport)
                                  (br.,)
                            | 
                        )
                      . !locJobs
                      )
                  : ?links
                & ( !links:% %
                  | !locJobs:? (!JobNr.?) ?
                  | 
                  )
                & !links
            )
          & ( !arg:(?JobNr.?secs)
            | @(!arg:? #?JobNr)&5:?secs
            )
          & ( !wwwServer:~
            |   readTable$properties
              & !properties:? (wwwServer.?wwwServer.?) ?
              & log$(wwwServer !wwwServer)
            )
          & ( ~
            |   readTable$jobs
              & "Without reading jobs from file the shown list is sometimes incomplete. But why?"
            | readTable$tooladm&readTable$Uploads
            )
          & div$(!deleteAfterMillisec*86400000^-1*24*60.1):?minutes
          & (   !jobs
              : ? (!JobNr.? (?.?.?.?+(mode.?mode)+?.?) ?) ?
            | niks:?mode
            )
          &   ( !mode:dry&steptexts$(!JobNr.!jobs)
              | steplinks$(!JobNr.!jobs)
              )
            : ?links
          & !jobs:? (!JobNr.? [?n:?myjobs) ?
          &     map
              $ ( ( 
                  =   serviceurl title step
                    .       !arg
                          : (   %@?step
                                (|starting|waiting)
                            . ~(? (?,pending) ?)
                            . ?serviceurl
                            . ?
                            . ?
                            )
                        &   !tooladm
                          :   ?
                            + ( ? (ServiceURL.!serviceurl) ?
                              : ? (Title.?title) ?
                              )
                            + ?
                        &   paragraph
                          $ ( localized$("Currently running " "I √∏jeblikket k√∏rer ")
                              !step
                              " "
                              localized$(of af)
                              " "
                              !n
                              " ("
                              !title
                              ")"
                            )
                      | 
                  )
                . !myjobs
                )
            : ?runningParagraphs
          & ( DOWNLOAD
            =   
              .   ( a
                  .     (href.!wwwServer "/texton/zipresults?shortletter=n&amp;JobNr=" !arg)
                        (tabindex.0)
                    , localized$("Download input and all results" "Download input og alle resultater")
                  )
                  localized$(" OR " " ELLER ")
                  ( a
                  .     (href.!wwwServer "/texton/zipresults?shortletter=y&amp;JobNr=" !arg)
                        (tabindex.0)
                    , localized$("Download final results" "Download slutresultater")
                  )
            )
          & ( DOWNLOADPSEUDOCODE
            =   
              . a
              .     (href.!wwwServer "/texton/zipresults?shortletter=c&amp;JobNr=" !arg)
                    (tabindex.0)
                , localized$("Download workflow as (pseudo-)code" "Download arbejdsgangen som (pseudo-)kode")
            )
          &   toML
            $ ( (   !runningParagraphs:
                  &   !HTMLbodyContainer
                    $ ( div
                      .   (class.canvasdiv)
                        ,   ( h1
                            . (class.smallmargin),localized$("Done! " "F√¶rdig! ")
                            )
                            (   !mode:dry
                              & log$(Done! !arg str$!links)
                              & paragraph$(DOWNLOADPSEUDOCODE$!JobNr)
                            |   paragraph$(DOWNLOAD$!JobNr)
                                !links
                                  paragraph
                                $ ( (br.,)
                                      localized
                                    $ ( "To download the results, see the links at the top of this page."
                                        "Se links √∏verst p√• denne side hvis du vil downloade resultaterne."
                                      )
                                  )
                            )
                              paragraph
                            $ (   localized
                                $ ( "Click the following link to immediately DELETE your input and the results from the workflow from the server. "
                                    "Tryk p√• n√¶ste link for at fjerne dit input og arbejdsgangens resultater fra serveren. "
                                  )
                                ( a
                                .     (href.!wwwServer "/texton/cleanup?JobNr=" !JobNr)
                                      (tabindex.0)
                                  ,   localized
                                    $ ( "DELETE input and results from server"
                                        "FJERN input og resultaterne fra serveren"
                                      )
                                )
                              )
                              paragraph
                            $ ( a
                              .   (href.!wwwServer "/texton/") (tabindex.0)
                                , localized$(Home Forside)
                              )
                              paragraph
                            $ ( a
                              .   (href.!wwwServer "/texton/") (tabindex.0)
                                , ( img
                                  . (src."texton.png") (alt.start),
                                  )
                              )
                            feedbackform$
                      )
                |   refreshingXHTMLbodyContainer
                  $ ( !secs str$(!wwwServer "/texton/mypoll?job=" !JobNr)
                    . div
                    .   (class.canvasdiv)
                      ,   ( h1
                          . (class.smallmargin),localized$("Running... " "K√∏rer... ")
                          )
                            paragraph
                          $ ( str
                            $ (   localized
                                $ ( "Reload this page to track the status of your job. Or wait. This page auto-reloads after "
                                    "Genindl√¶s denne side hvis du vil f√∏lge status p√• arbejdsgangen. Eller vent. Siden genindl√¶ses automatisk efter "
                                  )
                                !secs
                                localized$(" seconds." " sekunder.")
                              )
                            )
                          !links
                          !runningParagraphs
                    )
                )
              |   !HTMLbodyContainer
                $ (     ( 
                        =   zippedresults zipfile
                          .   readTable$zippedresults
                            &   str$(!arg ("-all"|"-final") ".zip")
                              : ?zipfile
                            & !zippedresults:? !zipfile ?
                        )
                      $ !JobNr
                    &   paragraph
                      $ ( DOWNLOAD$!JobNr
                            localized
                          $ (   str
                              $ (" The zipped results are kept for no more than " !minutes " minutes! ")
                                str
                              $ ( " De zippede resultater bliver bevaret is h√∏jst "
                                  !minutes
                                  " minutter!"
                                )
                            )
                        )
                  |   paragraph
                    $ ( localized
                      $ ( str$("The results have been deleted after " !hours " hours. ")
                          str$("Resultaterne er blevet slettet efter " !hours " timer. ")
                        )
                      )
                  )
              )
      )
      "
/**
 * readJobTables
 *
 * Read job related tables from files.
 *
 * Called from cleanup.java
 */"
      ( readJobTables
      =   
        .   ( readTable$jobs
            | :?jobs&saveTable$jobs
            )
          & ( readTable$Uploads
            | :?Uploads&saveTable$Uploads
            )
          & ( readTable$CTBs
            | :?CTBs&saveTable$CTBs
            )
          & ( readTable$jobAbout
            | :?jobAbout&saveTable$jobAbout
            )
          & ( readTable$ItemGroupsCache
            | :?ItemGroupsCache&saveTable$ItemGroupsCache
            )
      )
      "
/**
  * register
  *
  * Register a tool - integrated or not.
  * Produces an initially empty html form that dynamically adapts to user's
  * need to register multiple values for the same feature.
  * The form consists of two parts: a part for general information, most of
  * which can be deposited in the repository in a later phase, and a part that
  * is mainly used for integrated tools. The second part collects very precise
  * and formalised information that enables the Tools module to compute
  * workflows with tools and resources that fit together.
  *
  * Affected tables:
  *         tooladm.table   (general part),
  *         toolprop.table  (for integrated tools)
  * Input: a list of HTTP-parameters converted to the form
  *     (<parameter>.<value>) (<parameter>.<value>) (<parameter>.<value>) ...
  *
  * Output: a XHTML-form
  *
  * Input and output form a closed circuit: the form is generated by the
  * register function and the input from the filled-out form is sent to the
  * register function.
  *
  * Called from register.java
  */"
      ( register
      =     Metadata featureListing staticFields
          , ToolName ToolVersion FullToolName PassWord password
          , ToolURL ToolPublisher ContentProvider passwordAsHandle
          , ToolCreator InfoAbout ToolDescription mail2
          , ToolExternalURI ToolMultiInp aFeature askOptional
          , ToolPostData ToolInactive askOnE checkParmsSimple
          , additionalFormFields additionalMetadata
          , formFields storeTool handle saveToolTable
          , unfoldInputAndOutput foldInputAndOutput createFeatureFieldset
          , nth AA ZZ feats windfw ContactEmail contactEmail
          , featjursPreexisting featjursURL aboutFeature error Submit
          , createBoilerPlate force askFieldSet validationComments
          , storeToolButton replaceToolButton
          , deleteToolButton UpdateButton PHPbutton
        .   clean$
          & ( checkParmsSimple
            =   parms parm aBbr tmp
              .   !arg:(?parms.?parm)
                & !parms:? (!parm.%?aBbr) ?
                & (!parm.!aBbr):?tmp
                & ( hiddenData:? !tmp ?
                  | !hiddenData !tmp:?hiddenData
                  )
                & !aBbr
            )
          & "createBoilerPlate fails if user is  granted access."
          & ( createBoilerPlate
            =     ToolName ToolVersion FullToolName
                , URL Publisher ContentProvider
                , Creator InfoAbout Description
                , ExternalURI MultiInp url-password
                , PostData Inactive pval toggles
                , liste a z urlparm var val like
                , PassWord url-ToolName
                , ContactEmail url-contactEmail
              .     ~(!arg:? (name.?) ?)
                  &   !arg
                    : ? (contactEmail.~:?url-contactEmail) ?
                  & "User hasn't specified a name yet, but email is known. This
                     generates a form independent of already registered tools."
                  & (..!url-contactEmail.!arg (ml2.!url-contactEmail) (nctv.on))
                |   "Either the name http parameter is similar to an existing
                     tool's name, or it is the name of a new tool."
                  & ( like
                    = .sim$(trim$!sjt,trim$!arg):1&?
                    )
                  & "TODO RESET ALL OF urlparm IF TOOL NOT FOUND"
                  & !arg:?urlparm
                  &   !urlparm
                    : ? (name.?url-ToolName) ?
                    : ( ? (password.~:?url-password) ?
                      | ?&:?url-password
                      )
                    : ? (contactEmail.~:?url-contactEmail) ?
                  & :?ContactEmail
                  & (     !tooladm
                        :   ?
                          + (   ?
                                ( ToolID
                                .   like$!url-ToolName
                                  : ?ToolName
                                  : ?url-ToolName
                                )
                                ?
                            : (? (PassWord.?PassWord) ?|?)
                            : ( ? (ContactEmail.?ContactEmail) ?
                              | ?
                              )
                            : ? (Version.?ToolVersion) ?
                            : ? (Title.?FullToolName) ?
                            : ? (ServiceURL.?URL) ?
                            : ? (Publisher.?Publisher) ?
                            : ? (ContentProvider.?ContentProvider) ?
                            : ? (Creator.?Creator) ?
                            : ? (InfoAbout.?InfoAbout) ?
                            : ? (Description.?Description) ?
                            : ? (ExternalURI.?ExternalURI) ?
                            : ? (MultiInp.?MultiInp) ?
                            : ? (PostData.?PostData) ?
                            : ? (Inactive.?Inactive) ?
                            )
                          + ?
                      & !urlparm:?a (name.?) ?z
                      & !a (name.!url-ToolName) !z:?urlparm
                      & "The name http parameter was similar to an existing tool's name.
                         Use the existing tool's name instead and fetch all that is known
                         about this tool."
                    |   "The name http parameter is not seen before, so
                         we create an empty form for an inactive tool."
                      & !url-ToolName:?ToolName
                      & !url-contactEmail:?ContactEmail
                      &   
                        : ?PassWord
                        : ?url-password
                        : ?ToolVersion
                        : ?FullToolName
                        : ?URL
                        : ?Publisher
                        : ?ContentProvider
                        : ?Creator
                        : ?InfoAbout
                        : ?Description
                        : ?ExternalURI
                        : ?MultiInp
                        : ?PostData
                      & on:?Inactive
                    )
                  & ( !url-contactEmail:!ContactEmail
                    |   ( !url-password:!PassWord:~
                        | !PassWord:!ContactEmail:
                        )
                      & !url-contactEmail:?ContactEmail
                    )
                  & "You only are allowed to edit a tool that
                        1) is yours (email)
                     or 2) you know the password for
                     or 3) has empty password AND email fields (orphan tool)

                     The password is reset and the tool becomes yours."
                  &     (psswrd.)
                        (ml2.!ContactEmail)
                        (vrsion.!ToolVersion)
                        (fllNm.!FullToolName)
                        (pblshr.!Publisher)
                        (cntPrvdr.!ContentProvider)
                        (crtr.!Creator)
                        (docuri.!InfoAbout)
                        (url.!URL)
                        (dscrptn.!Description)
                        (xuri.!ExternalURI)
                    : ?liste
                  &     (multiinp.!MultiInp)
                        (pstdt.!PostData)
                        (|(nctv.!Inactive))
                    : ?toggles
                  &   (     !urlparm
                          : ? (handle.?handle) ?
                          : ? (nth.?) ?
                        & "When the user enters the form, the list of http
                           parameters is still short:
                                 handle,contactEmail,name,password,bsubmit
                           A good indication that the user hasn't toggled
                           anything is the absence of the 'nth' parameter.
                           User's input value of Inactive overrules
                           registered input."
                        & ( !urlparm:? (nctv.?) ?
                          | (nctv.) !urlparm
                          )
                      |   "Registered value of Inactive overrules user's input."
                        &   !urlparm
                          : ( ?a (nctv.?) ?z
                            | ?z&:?a
                            )
                        & (nctv.!Inactive) !a !z
                      )
                    : ?urlparm
                  & ( !urlparm:? (url.?) ?
                    |   whl
                      ' ( !toggles:(?var.?val) ?toggles
                        & ( !urlparm:? (!var.?) ?
                          | !urlparm (!var.trim$!val):?urlparm
                          )
                        )
                    )
                  &   whl
                    ' ( !liste:(?var.?val) ?liste
                      & trim$!val:?val
                      & (   !urlparm
                          :   ?a
                              (   (!var.) ?z
                                & "Replace empty value by non-empty value."
                                & !a (!var.!val) !z:?urlparm
                              |   (!var.?pval) ?z
                                & !a (!var.trim$!pval) !z:?urlparm
                              )
                        | !urlparm (!var.!val):?urlparm
                        )
                      )
                  & (!ToolName.!PassWord.!ContactEmail.!urlparm)
            )
          & ( staticFields
            =   staticField
              .   ( staticField
                  =   urlvars prompt urlvar,internalvar fieldType attrs
                    .     !arg
                        : (?urlvars.?prompt.?urlvar.?internalvar.?fieldType.?attrs)
                      &   (checkParmsSimple$(!urlvars.!urlvar)|)
                        : ?!internalvar
                      & !fieldType$(!prompt.!urlvar.(val.!!internalvar) !attrs)
                  )
                &     fieldset
                    $ ( localized$(Boilerplate "Generelle oplysninger for alle v√¶rkt√∏jer")
                      .     paragraph
                          $ (   staticField
                              $ ( !arg
                                . "ToolID:"
                                . name
                                . ToolName
                                . makeTextFormField
                                .   (desc.localized$("short unique name" "kort unikt navn"))
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "Title:"
                                . fllNm
                                . FullToolName
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ("full name of the tool" "V√¶rkt√∏jets fulde navn")
                                    )
                                    (size.40)
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "Version:"
                                . vrsion
                                . ToolVersion
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "may only contain ascii letters dots  and digits"
                                          "m√• kun indeholde ascii-bogstaver, punktum og cifre"
                                        )
                                    )
                                    (required."*")
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Publisher:"
                                . pblshr
                                . ToolPublisher
                                . makeTextFormField
                                . required
                                . "*"
                                )
                                staticField
                              $ ( !arg
                                . "Content provider:"
                                . cntPrvdr
                                . ContentProvider
                                . makeTextFormField
                                . required
                                . "*"
                                )
                                staticField
                              $ ( !arg
                                . "Creator:"
                                . crtr
                                . ToolCreator
                                . makeTextFormField
                                . (size.25) (required."*")
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Email:"
                                . ml2
                                . ContactEmail
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "protection against unauthorized update"
                                          "Beskyttelse mod uautoriseret redigering af oplysninger. Email adressen bliver ikke offentliggjort eller lagret i repositoriet ved deponering af v√¶rkt√∏jets oplysninger og kan √¶ndres ved at overdrage redigeringsrettigheden til en anden person. (Se forklaring p√• Password-feltet.)"
                                        )
                                    )
                                    (readonly.yes)
                                )
                                staticField
                              $ ( !arg
                                . "Password:"
                                . psswrd
                                . PassWord
                                . makeTextFormField
                                . desc
                                .   localized
                                  $ ( "If you want to transfer the edit right of the tool to somebody else, enter a one-time password that you share with the other person. The other person must be logged in via WAYF and enter the password to gain access and the edit right."
                                      "Hvis du vil overdrage redigeringsrettigheden til en anden person, skriv en engangsadgangskode og giv den til den anden person. For at modtage redigeringsrettigheden, skal den anden person logge sig p√• via WAYF og indtaste adgangskoden. N√•r hun eller han erstatter v√¶rkt√∏jets oplysninger, bliver hans eller hendes email adresse noteret i Email-feltet og er hun eller han blevet den prim√¶re kontaktperson hvis der er sp√∏rgsm√•l eller problemer ang. v√¶rkt√∏jet."
                                    )
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "InfoAbout:"
                                . docuri
                                . InfoAbout
                                . makeTextFormField
                                .   ( desc
                                    . localized$("URI of documentation" "Dokumentationens URI")
                                    )
                                    (size.40)
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "External Service URL:"
                                . xuri
                                . ToolExternalURI
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "fill out if the tool (also) functions as a web service"
                                          "udfyld hvis v√¶rkt√∏jet (ogs√•) fungerer som webservice"
                                        )
                                    )
                                    (size.40)
                                )
                            )
                            paragraph
                          $ ( staticField
                            $ ( !arg
                              . "Description:"
                              . dscrptn
                              . ToolDescription
                              . makeTextAreaFormField
                              . required
                              . "*"
                              )
                            )
                      )
                      fieldset
                    $ ( localized$("Webservice metadata" Webserviceoplysninger)
                      .     paragraph
                          $ ( staticField
                            $ ( !arg
                              . "Service URL of the tool:"
                              . url
                              . ToolURL
                              . makeTextFormField
                              .   ( desc
                                  .   localized
                                    $ ( "Something like \"https://abc.foo/wordreverser\". Only needed for integrated tools. To wipe URL: replace with one or more blank characters."
                                        "Noget i stil med \"https://abc.foo/wordreverser\". Kun kr√¶vet for integrerede v√¶rkt√∏jer. For at udviske URL: erstat med blanktegn."
                                      )
                                  )
                                  (size.40)
                              )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Requires HTTP POST method:"
                                . pstdt
                                . ToolPostData
                                . makeCheckboxFormField
                                . 
                                )
                                staticField
                              $ ( !arg
                                . "Takes multiple inputs:"
                                . multiinp
                                . ToolMultiInp
                                . makeCheckboxFormField
                                . desc
                                .   localized
                                  $ ( "Check if tool takes more than one input of the same type"
                                      "Marker hvis v√¶rkt√∏jet tager to eller flere filer af samme type"
                                    )
                                )
                                staticField
                              $ ( !arg
                                . "Inactive:"
                                . nctv
                                . ToolInactive
                                . makeCheckboxFormField
                                .   ( desc
                                    .   localized
                                      $ ( "Check if the tool is not integrated. Also check this box if an integrated tool temporarily cannot be used. (You need to be logged in to toggle this swicth.)"
                                          "Marker hvis v√¶rkt√∏jet er midlertidigt ude af drift eller slet ikke integreret. (Du skal v√¶re logget p√• f√∏r du kan √¶ndre dette felt.)"
                                        )
                                    )
                                    (   !handle:
                                      & (disabled.disabled)
                                    | 
                                    )
                                )
                            )
                      )
            )
          & ( featureListing
            =   listing featname inouts in outp K listIO
              .   ( listIO
                  =     in io I S L M s
                      , opt addFeature listing Is OnE
                    .   ( addFeature
                        =     moreToCome K L featname io
                            , I S listing M s optional OnE
                          .     !arg
                              : ( ?moreToCome
                                . ?K
                                . ?L
                                . ?featname
                                . ?io
                                . ?I
                                . ?S
                                . ?listing
                                . ?optional
                                . ?OnE
                                )
                            &     (str$(!featname !K "." !L !io).!I)
                                  ( !optional:
                                  | (str$(!featname !K "." !L !io !optional).on)
                                  )
                                  ( !OnE:
                                  | (str$(!featname !K "." !L !io !OnE).on)
                                  )
                                  (   !moreToCome:(1|)
                                    & 
                                  | (str$(!featname !K "." !L !io More).on)
                                  )
                                  !listing
                              : ?listing
                            & 0:?M
                            & ( !S:1
                              |   whl
                                ' ( !S:%?s+?S
                                  & 1+!M:?M
                                  &     (str$(!featname !K "." !L "." !M !io Spc).!s)
                                        ( !S:0&
                                        | (   str
                                            $ ( !featname
                                                !K
                                                "."
                                                !L
                                                "."
                                                !M
                                                !io
                                                Spc
                                                More
                                              )
                                          . on
                                          )
                                        )
                                        !listing
                                    : ?listing
                                  )
                              )
                            & !listing
                        )
                      & 0:?L
                      & !arg:(?in.?io.?listing)
                      & !in:(%?in ?opt|?opt)
                      &   whl
                        ' ( !in:%?I^?S*?in
                          & (   !I:(?Is.OnE)
                              & :?OnE
                              &   whl
                                ' ( !Is:%@?I^?S*?Is
                                  & 1+!L:?L
                                  &     addFeature
                                      $ ( !Is*!in
                                        . !K
                                        . !L
                                        . !featname
                                        . !io
                                        . !I
                                        . !S
                                        . !listing
                                        . 
                                        . !OnE
                                        )
                                    : ?listing
                                  & OnE:?OnE
                                  )
                            |   1+!L:?L
                              &     addFeature
                                  $ (!in.!K.!L.!featname.!io.!I.!S.!listing..)
                                : ?listing
                            )
                          )
                      & ( !opt:
                        |     (str$(!featname !K "." !L !io More).on) !listing
                            : ?listing
                          &   whl
                            ' ( !opt:%?I^?S ?opt
                              & 1+!L:?L
                              &     addFeature
                                  $ ( !opt
                                    . !K
                                    . !L
                                    . !featname
                                    . !io
                                    . !I
                                    . !S
                                    . !listing
                                    . Optional
                                    . 
                                    )
                                : ?listing
                              )
                        )
                      & !listing
                  )
                & :?listing
                &   whl
                  ' ( !arg:(?featname,?inouts) ?arg
                    & 0:?K
                    &   whl
                      ' ( !inouts:#*(?in.?outp)+?inouts
                        & 1+!K:?K
                        & listIO$(!in.Input.!listing):?listing
                        & listIO$(!outp.Output.!listing):?listing
                        & ( !inouts:0
                          |   (str$(!featname !K More).on) !listing
                            : ?listing
                          )
                        )
                    )
                & !listing
            )
          & ( windfw
            =   nth Nth toolprop ZZ ToolName featjursPreexisting
              .   !arg:(?toolprop.?ToolName.?nth:?Nth)
                & !toolprop:?+(!ToolName.?featjursPreexisting)+?ZZ
                &   whl
                  ' ( !Nth:>0
                    & !ZZ:(!ToolName.?featjursPreexisting)+?ZZ
                    & !Nth+-1:?Nth
                    )
                & (!featjursPreexisting.!ZZ.!nth+-1*!Nth)
            )
          & ( unfoldInputAndOutput
            =   feat apair a z II OO zpair
              .   map
                $ ( ( 
                    =   
                      .   !arg:(?feat,?arg)
                        &   whl
                          ' ( !arg:?apair+#*(%?a+%?z.?OO)+?zpair
                            & !apair+(!a.!OO)+(!z.!OO)+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(?II.%?a+%?z)+?zpair
                            & !apair+(!II.!a)+(!II.!z)+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(^?.^?)+?zpair
                            & !apair+!zpair:?arg
                            )
                        & (!feat,!arg)
                    )
                  . !arg
                  )
            )
          & ( foldInputAndOutput
            =   feat apair a b II OO zpair,mpair aval zval
              .   map
                $ ( ( 
                    =   
                      .   !arg:(?feat,?arg)
                        &   whl
                          ' ( !arg:?apair+#%*(?II.?OO)+?zpair
                            & !apair+(!II.!OO)+!zpair:?arg
                            )
                        &   whl
                          ' (   !arg
                              : ?apair+#*(?a.?OO)+?mpair+#*(?b.!OO)+?zpair
                            &   !apair+(denumerizeSum$(!a+!b).!OO)+!mpair+!zpair
                              : ?arg
                            )
                        &   whl
                          ' (   !arg
                              : ?apair+#*(?II.?a)+?mpair+#*(!II.?b)+?zpair
                            &   !apair+(!II.denumerizeSum$(!a+!b))+!mpair+!zpair
                              : ?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(^?.^?)+?zpair
                            & !apair+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(?aval*^?*?zval.?OO)+?zpair
                            & !apair+(denumerizeSum$(!aval*!zval).!OO)+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(?II.?aval*^?*?zval)+?zpair
                            & !apair+(!II.denumerizeSum$(!aval*!zval))+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(1.?OO)+?zpair
                            & !apair+(.!OO)+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(?II.1)+?zpair
                            & !apair+(!II.)+!zpair:?arg
                            )
                        & ( !arg:0&:?arg
                          | 
                          )
                        & (!feat,!arg)
                    )
                  . !arg
                  )
            )
          & ( askOptional
            =   urlparms featinoutOptional
              .   !arg:(?urlparms.?featinoutOptional)
                &   (checkParmsSimple$(!urlparms.!featinoutOptional)|)
                  : ?!featinoutOptional
                & makeCheckboxFormField$(optional.!featinoutOptional.val.!!featinoutOptional)
            )
          & ( askOnE
            =   urlparms featinoutOnE featinout inout values
              .   !arg:(?urlparms.?featinoutOnE.?featinout.?values.?inout)
                & (   !inout:Input
                    & (   !values:% ?
                        &   (checkParmsSimple$(!urlparms.!featinoutOnE)|)
                          : ?!featinoutOnE
                        &   makeCheckboxFormField
                          $ (     !!featinoutOnE:
                                & (!!featinout:|üóé)
                              | ‚Æ≠
                            . !featinoutOnE
                            . val
                            . !!featinoutOnE
                            )
                      | !!featinout:
                      | üóé
                      )
                  | 
                  )
            )
          & ( aFeature
            =     NrRequiredAndOptional NrInOutAlternative
                , NrSpecification shortfeatname requireds
                , inout featinout featinoutMore featinoutOnE
                , featinoutOptional urlparms FieldSet
                , feattable featdescription row aboutFeature
                , specifications specificationTables
                , sameFeatureOnceMore optionals
                , sameSpecificationOnceMore full
                , additionalFieldSet additionalOptionals
                , specificationTable aSpecification
                , featinoutSpec featinoutOptMore
              .   ( sameFeatureOnceMore
                  = .!arg:(?arg.?)&(.!arg.)
                  )
                & ( aSpecification
                  =   :?sameSpecificationOnceMore
                    & 1+!NrSpecification:?NrSpecification
                    &     str
                        $ ( !shortfeatname
                            !NrInOutAlternative
                            "."
                            !NrRequiredAndOptional
                            "."
                            !NrSpecification
                            !inout
                            Spc
                          )
                      : ?featinoutSpec
                    & str$(!featinoutSpec More):?featinoutOptMore
                    & (       checkParms
                            $ ( !urlparms
                              . !featinoutSpec
                              .   !!specificationTable
                                |   readTable$!specificationTable
                                  & !!specificationTable
                              )
                          : ?!featinoutSpec
                        &     (!!featinoutSpec:~:~1|0)
                            + !specifications
                          : ?specifications
                      | :?!featinoutSpec
                      )
                    &     !row
                            makeSelectFormField
                          $ (   str
                              $ ( (     !!feattable
                                      : ? (?full.!!featinout.?) ?
                                    & localized$!full
                                  |   "featinout:"
                                      !featinout
                                      "=="
                                      !!featinout
                                      " and feattable "
                                      !feattable
                                      " looks like this:"
                                      !!feattable
                                  )
                                  " style"
                                )
                            . !featinoutSpec
                            . options
                            . makeOptionList$(!!specificationTable.!!featinoutSpec)
                            )
                          (     checkParmsSimple$(!urlparms.!featinoutOptMore)
                              : ?!featinoutOptMore
                            & (   !!featinoutOptMore:on
                                &   '$aSpecification
                                  : (=?sameSpecificationOnceMore)
                                & makeHiddenFields$(!featinoutOptMore.on)
                              | 
                              )
                          | makeCheckboxFormField$(localized$(more mere).!featinoutOptMore.)
                          )
                      : ?row
                    & !sameSpecificationOnceMore
                  )
                &   !arg
                  : ( ?requireds
                    . (?NrRequiredAndOptional.?inout.?NrInOutAlternative.?aboutFeature)
                    . ?urlparms
                    )
                &   !aboutFeature
                  : ? (short.?shortfeatname) ?
                  : ? (description.?featdescription) ?
                  : ? (table.?feattable) ?
                  : ( ? (specificationTable.?specificationTables) ?
                    | ?&:?specificationTables
                    )
                & 1+!NrRequiredAndOptional:?NrRequiredAndOptional
                &   str$(!shortfeatname !NrInOutAlternative "." !NrRequiredAndOptional !inout)
                  : ?featinout
                & "e.g. facet3.2InputMore
                   shown after second input of third inputs/output(s) combination"
                & str$(!featinout More):?featinoutMore
                & str$(!featinout Optional):?featinoutOptional
                & :?!featinoutOptional
                & str$(!featinout OnE):?featinoutOnE
                & :?!featinoutOnE
                &   (checkParms$(!urlparms.!featinout.!!feattable)|)
                  : ?!featinout
                &       makeSelectFormField
                      $ ( !inout
                        . !featinout
                        .   (options.makeOptionList$(!!feattable.!!featinout))
                            (desc.localized$!featdescription)
                        )
                      askOnE$(!urlparms.!featinoutOnE.!featinout.!requireds.!inout)
                      optionalFeature$(!urlparms.!featinoutOptional)
                      (   checkParmsSimple$(!urlparms.!featinoutMore):on
                        & '$aFeature:(=?sameFeatureOnceMore)
                        & makeHiddenFields$(!featinoutMore.on)
                      | makeCheckboxFormField$(localized$(more mere).!featinoutMore.)
                      )
                  : ?row
                & 0:?specifications
                & (   !specificationTables
                    :   ?
                        ( ? (%@:!!featinout) ?
                        .   ?specificationTable
                          & 0:?NrSpecification
                          & !aSpecification
                        )
                        ?
                  | 
                  )
                &     !!featinout
                    ^ (!specifications:~0:~|1)
                  : ?!featinout
                &   (   !!featinoutOptional:
                      &     ( !!featinoutOnE:&!!featinout
                            | (OnE.!!featinout)
                            )
                            !requireds
                        : ?requireds
                      & 
                    | !!featinout
                    )
                  : ?optionals
                & paragraph$!row:?FieldSet
                & '$shouldIAskOptionalFeature:(=?optionalFeature)
                &     sameFeatureOnceMore
                    $ ( !requireds
                      . (!NrRequiredAndOptional.!inout.!NrInOutAlternative.!aboutFeature)
                      . !urlparms
                      )
                  : (?additionalFieldSet.?requireds.?additionalOptionals)
                & tbl$(!featinoutMore,0)
                & tbl$(!featinoutOptMore,0)
                & tbl$(!featinoutOptional,0)
                & tbl$(!featinoutOnE,0)
                & tbl$(!featinout,0)
                & tbl$(!featinoutSpec,0)
                & ( !FieldSet !additionalFieldSet
                  . !requireds
                  .   !optionals
                        map
                      $ ( ( 
                          =   
                            .   !optionals:? !arg ?&
                              | !arg
                          )
                        . !additionalOptionals
                        )
                  )
            )
          & ( askFieldSet
            =     NrInOutAlternative additionalInoutpairs
                , shortfeatname inout featurePair inoutpairs
                , featurePairMore FieldSet optionalFeature ret
                , NrRequiredAndOptional optionals requireds
                , shouldIAskOptionalFeature
                , urlparms feattable featdescription formstuff
                , Input Output
              .   "askFieldSet: recursive function that returns a list of
                       fieldset elements, one for each input/output pair of the
                       current feature. After the last fieldset element follows
                       a checkbox input element inviting to create an extra
                       fieldset element if the user checks the box and reloads
                       the page. The list contains minimally one input/output
                       element.
                       askFieldSet is called recursively when the URL
                       parameter list has a <featurename><cardinal #>More
                       element, e.g. facet2More=on
                      "
                & !arg:((?NrInOutAlternative.?aboutFeature).?urlparms)
                &   !aboutFeature
                  : ? (short.?shortfeatname) ?
                  : ? (description.?featdescription) ?
                  : ? (table.?feattable) ?
                & 1+!NrInOutAlternative:?NrInOutAlternative
                & str$(!shortfeatname !NrInOutAlternative):?featurePair
                & :?FieldSet
                & (optionalFeature=.)
                & '$askOptional:(=?shouldIAskOptionalFeature)
                & :?FieldSet
                & (     map
                      $ ( ( 
                          =   Lrequireds OnErequired additionalFieldSet required
                            .   !arg:%@?inout
                              & :?requireds
                              & 0:?NrRequiredAndOptional
                              &     aFeature
                                  $ ( !requireds
                                    . ( !NrRequiredAndOptional
                                      . !inout
                                      . !NrInOutAlternative
                                      . !aboutFeature
                                      )
                                    . !urlparms
                                    )
                                : (?additionalFieldSet.?Lrequireds.?optionals)
                              & 1:?requireds:?OnErequired
                              &   whl
                                ' ( !Lrequireds:%?required ?Lrequireds
                                  & (   !required:(OnE.?required)
                                      & !required*!OnErequired:?OnErequired
                                    |   !required*!OnErequired:?OnErequired
                                      &   (   !OnErequired:%*%
                                            & (!OnErequired.OnE)
                                          | !OnErequired
                                          )
                                        : ?required
                                      & ( !requireds:?*!required*?
                                        | !required*!requireds:?requireds
                                        )
                                      & 1:?OnErequired
                                    )
                                  )
                              & !FieldSet !additionalFieldSet:?FieldSet
                              & !requireds:~:~1
                              & (   !inout:Input
                                  & !requireds !optionals:?Input
                                | !requireds !optionals:?Output
                                )
                              & (shouldIAskOptionalFeature=.)
                              & (optionalFeature=.)
                          )
                        . Input Output
                        )
                    & !Input:~0
                    & !Output:~0
                    & (!Input.!Output):?inoutpairs
                  | 
                  )
                &     fieldset$(.!FieldSet)
                      ( str$(!featurePair More):?featurePairMore
                      & (   checkParmsSimple$(!urlparms.!featurePairMore)
                          &     askFieldSet
                              $ ((!NrInOutAlternative.!aboutFeature).!urlparms)
                            : (?formstuff.?additionalInoutpairs)
                          & !inoutpairs+!additionalInoutpairs:?inoutpairs
                          & "If user has checked 'more' for opening creating
                                 another input/output pair, then 'askFieldSet'
                                 is called.
                                "
                          & makeHiddenFields$(!featurePairMore.on) !formstuff
                        |   "The last input/output combination is always
                                 followed by an invitation to add another one.
                                "
                          &   makeCheckboxFormField
                            $ (   localized
                                $ ( "Add an input/output combination"
                                    "Tilf√∏j en input/output-kombination"
                                  )
                              . !featurePairMore
                              . 
                              )
                        )
                      )
                  : ?ret
                & (!ret.!inoutpairs)
            )
          & ( createFeatureFieldset
            =     inoutpairs aboutFeature urlparms formstuff
                , featname shortfeatname
                , featdescription feattable specificationTables
              .   !arg:(?aboutFeature.?urlparms)
                & "
                   urlparms: the URL parameters in Bracmat structures. When
                   starting the edit, there is not much in them. After pressing
                   'store' or 'replace', urlparms contains all the data that is
                   in the form, including the changes the user has just made.

                   aboutFeature: the general information about a feature. This
                   is constant, system-wide info.
                  "
                &   !aboutFeature
                  : ? (name.?featname) ?
                  : ? (short.?shortfeatname) ?
                  : ? (description.?featdescription) ?
                  : ? (table.?feattable) ?
                  : ( ? (specificationTable.?specificationTables) ?
                    | ?
                    )
                & 0:?inoutpairs
                & readTable$!feattable
                &   askFieldSet$((0.!aboutFeature).!urlparms)
                  : (?formstuff.?inoutpairs)
                & ( fieldset$(localized$!featname.!formstuff)
                  .   !inoutpairs:0&
                    | (!shortfeatname,!inoutpairs)
                  )
            )
          & ( validationComments
            =     Submit otherName
                , ToolName ToolVersion FullToolName PassWord
                , ToolURL ToolPublisher ContentProvider
                , ToolCreator InfoAbout ToolDescription
                , ToolExternalURI ToolMultiInp mayNotBeEmpty
                , ToolPostData ToolInactive Nazn dNazn
              .     !arg
                  : ( ?ToolName
                    . ?PassWord
                    . ?ToolVersion
                    . ?FullToolName
                    . ?ToolURL
                    . ?ToolPublisher
                    . ?ContentProvider
                    . ?ToolCreator
                    . ?InfoAbout
                    . ?ToolDescription
                    . ?ToolExternalURI
                    . ?ToolMultiInp
                    . ?ToolPostData
                    . ?ToolInactive
                    . ?Submit
                    )
                & ( mayNotBeEmpty
                  =   
                    .   "'"
                        !arg
                        "' "
                        localized$("may not be empty" "m√• ikke v√¶re tom")
                        (br.,)
                  )
                & ( ( !ToolName:&mayNotBeEmpty$ToolID
                    |   @(!ToolName:allowedChar$('$NCNameStartChar) !NCName)
                      & `~
                    |   str
                      $ ( "ToolID '"
                          !ToolName
                            localized
                          $ ( "' contains invalid characters. (Must be an xml:id)"
                              "' indeholder ugyldige karakterer. (Skal v√¶re et xml:id)"
                            )
                        )
                    )
                  | !ToolName:&mayNotBeEmpty$ToolID
                  | !FullToolName:&mayNotBeEmpty$Title
                  |   !ToolURL:
                    & !ToolInactive:
                    &     localized
                        $ ( "'Service URL' may not be empty if the tool is integrated and active. If the tool must be integrated in the infrastructure, but not just now, you must check the field 'Inactive'."
                            "'Service URL' m√• ikke v√¶re tom hvis v√¶rkt√∏jet er et aktivt integreret v√¶rkt√∏j. Hvis v√¶rkt√∏jet ikke skal v√¶re integreret i infrastrukturen, skal du markere feltet 'Inactive'."
                          )
                        (br.,)
                  |     !tooladm
                      :   ?
                        + ( ? (ToolID.!ToolName) ?
                          : ? (Inactive.) ?
                          : ? (ServiceURL.<>!ToolURL) ?
                          )
                        + ?
                    & !Submit:!storeToolButton
                    &     str
                        $ (   localized
                            $ ( "There is already an integrated tool with the name '"
                                "Der findes et integreret v√¶rkt√∏j med navn '"
                              )
                            !ToolName
                              localized
                            $ ( "' with another Service URL. If you are sure it is the same tool, you can change the Service URL by temporarily deactivating the tool. (Check the 'Inactive'-field, save, change the Service URL, uncheck 'Inactive', and save.)"
                                "' med en anden Service URL end den indtastede. Hvis du er sikker p√• at det er samme v√¶rkt√∏j, kan du √¶ndre Service URL ved f√∏rst midlertigt at deaktivere v√¶rkt√∏jet. (Klik 'Inactive'-feltet, gem, √¶ndr Service URL og klik 'Inactive'-feltet igen, gem.)"
                              )
                          )
                        (br.,)
                  |   !ToolURL:~
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!ToolURL) ?
                          : ? (ToolID.?otherName:<>!ToolName) ?
                          )
                        + ?
                    &     str
                        $ ( localized$("Cannot save '" "Kan ikke gemme '")
                            !ToolName
                            localized$("' on Service URL \"" "' p√• Service URL \"")
                            !ToolURL
                              localized
                            $ ("\" (already taken by the tool '" "\" (allerede i brug af v√¶rkt√∏jet '")
                            !otherName
                            "')."
                          )
                        (br.,)
                  |   ( Nazn
                      =   #
                          ( 
                          | ? (%@:~<a:~>z)
                          | `
                          )
                          (|#)
                      )
                    & '("." ()$Nazn):(=?dNazn)
                    & (   @( !ToolVersion
                           :   !Nazn
                               ( 
                               |   !dNazn
                                   ( 
                                   | !dNazn (|!dNazn)
                                   )
                               )
                           )
                        & `~
                      |   localized
                        $ ( "'Version' must match the regular expression [d]+[a-z]*[d]*(.[d]+[a-z]*[d]*){0,3}"
                            "'Version' skal matche det regul√¶re udtryk [d]+[a-z]*[d]*(.[d]+[a-z]*[d]*){0,3}"
                          )
                      )
                  | !ToolPublisher:&mayNotBeEmpty$Publisher
                  |   !ContentProvider:
                    & mayNotBeEmpty$"Content provider"
                  | !ToolCreator:&mayNotBeEmpty$Creator
                  |   !InfoAbout:
                    &     localized
                        $ ( "'InfoAbout' (tool documentation): URL may not be empty"
                            "'InfoAbout' (v√¶rkt√∏jets dokumentation): URL m√• ikke v√¶re tom"
                          )
                        (br.,)
                  | !ToolDescription:&mayNotBeEmpty$Description
                  )
            )
          & ( saveToolTable
            =   
              .   saveTable$!arg
                & :?recentTasks
                & saveTable$recentTasks
            )
          & ( storeTool
            =     A M Z Metadata admdata
                , ToolName ToolVersion FullToolName PassWord
                , ToolURL ToolPublisher ContentProvider
                , ToolCreator InfoAbout ToolDescription
                , ToolExternalURI ToolMultiInp removeEmptyValues
                , ToolPostData ToolInactive sortFacets
                , ContactEmail otherToolprop thisToolProp
                , Combine IOFeatComb IOcomb IOcombine Ocomb
                , subset unfact unfactorize force
              .     !arg
                  : ( ?Metadata
                    . ?ToolName
                    . ?PassWord
                    . ?ContactEmail
                    . ?ToolVersion
                    . ?FullToolName
                    . ?ToolURL
                    . ?ToolPublisher
                    . ?ContentProvider
                    . ?ToolCreator
                    . ?InfoAbout
                    . ?ToolDescription
                    . ?ToolExternalURI
                    . ?ToolMultiInp
                    . ?ToolPostData
                    . ?ToolInactive
                    . ?ZZ
                    . ?force
                    )
                & (   (!ToolInactive:on|!handle:~)
                    &   (   !ZZ:<0
                          & (   !toolprop:?A+!Metadata+?Z
                              & ( !force:no&!toolprop
                                | !A+!Metadata+!Z
                                )
                            | !Metadata+!toolprop
                            )
                        |   !toolprop:?AA+(?.?)+!ZZ
                          & ( !AA+!ZZ:?A+!Metadata+?Z
                            | !AA+!Metadata+!ZZ
                            )
                        )
                      : ?toolprop
                    &   whl
                      ' ( !toolprop:?A+(?.)+?Z
                        & !A+!Z:?toolprop
                        )
                    & removeNumFactors$!toolprop:?toolprop
                    & ( removeEmptyValues
                      =   a b nw
                        .     !arg:?a_?b
                            & (removeEmptyValues$!a)_(removeEmptyValues$!b):?nw
                            & !(glf$('($arg.$nw))):?arg
                            & ( !arg:*?arg&!arg
                              | !arg:+?arg&!arg
                              | !arg:?a^&!a
                              | !arg:^?&
                              )
                          | !arg
                      )
                    & removeEmptyValues$!toolprop:?toolprop
                    & ( sortFacets
                      =   toolpropFacetsSorted Name facets
                        .   0:?toolpropFacetsSorted
                          &   whl
                            ' ( !arg:#*(?Name.?facets)+?arg
                              &   (!Name.sort$!facets)+!toolpropFacetsSorted
                                : ?toolpropFacetsSorted
                              )
                          & !toolpropFacetsSorted
                      )
                    & sortFacets$!toolprop:?toolprop
                    & removeNumFactors$!toolprop:?toolprop
                    & ( unfact
                      =   ToolName F A Z a z f,O x m T y
                        .   !arg:(?ToolName.?F)
                          & (   !F:?A (?f,%?a+%?z) ?Z
                              &   unfact$(!ToolName.!A (!f,!a) !Z)
                                + unfact$(!ToolName.!A (!f,!z) !Z)
                            |   !F:?A (?f,(%?a+%?z.?O)) ?Z
                              &   unfact$(!ToolName.!A (!f,(!a.!O)) !Z)
                                + unfact$(!ToolName.!A (!f,(!z.!O)) !Z)
                            |   !F:?A (?f,(?O.%?a+%?z)) ?Z
                              &   unfact$(!ToolName.!A (!f,(!O.!a)) !Z)
                                + unfact$(!ToolName.!A (!f,(!O.!z)) !Z)
                            |     !F
                                : ?A (?f,(?O.?x*?m^(%?a+%?z)*?y ?T)) ?Z
                              &     unfact
                                  $ (!ToolName.!A (!f,(!O.!x*!m^!a*!y !T)) !Z)
                                +   unfact
                                  $ (!ToolName.!A (!f,(!O.!x*!m^!z*!y !T)) !Z)
                            |     !F
                                :   ?A
                                    (?f,(?x*?m^(%?a+%?z)*?y ?T.?O))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x*!m^!a*!y !T.!O))
                                        !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x*!m^!z*!y !T.!O))
                                        !Z
                                    )
                            |     !F
                                : ?A (?f,(%?x ?m^(%?a+%?z) ?T.?O)) ?Z
                              &     unfact
                                  $ ( !ToolName
                                    . !A (!f,(!x !m^!a !T.!O)) !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    . !A (!f,(!x !m^!z !T.!O)) !Z
                                    )
                            |   !F:?A (?f,(?O.%?x ?m^(%?a+%?z) ?T)) ?Z
                              &     unfact
                                  $ (!ToolName.!A (!f,(!O.!x !m^!a !T)) !Z)
                                +   unfact
                                  $ (!ToolName.!A (!f,(!O.!x !m^!z !T)) !Z)
                            | !arg
                            )
                      )
                    & ( subset
                      =   toolprop ToolName Fe A fe subs
                        .   !arg:(?toolprop.?ToolName)
                          & (   !toolprop:?A+(!ToolName.?Fe)+?toolprop
                              & 0:?subs
                              &   whl
                                ' ( !toolprop:(!ToolName.?fe)+?toolprop
                                  & !subs+(!ToolName.!fe):?subs
                                  )
                              & ((!ToolName.!Fe)+!subs.!A+!toolprop)
                            | (0.!toolprop)
                            )
                      )
                    & subset$(!toolprop.!ToolName):(?thisToolProp.?otherToolprop)
                    & ( unfactorize
                      =   A
                        .     !arg:%?A+?arg
                            & unfact$!A+unfactorize$!arg
                          | 0
                      )
                    & unfactorize$!thisToolProp:?thisToolProp
                    & removeNumFactors$!thisToolProp:?thisToolProp
                    & ( Combine
                      =     A M Z AA ZZ Name Facet val1
                          , Vals1 Vals2 done
                        .     whl
                            ' ( 0:?done
                              &   whl
                                ' (   !arg
                                    :   ?A
                                      + (?Name.?val1)
                                      + ?M
                                      + ( ?
                                        .   ?AA
                                            ( (?Facet,?Vals2) ?ZZ
                                            &   !val1
                                              : !AA (!Facet,?Vals1) !ZZ
                                            )
                                        )
                                      + ?Z
                                  & !done+!A:?done
                                  &     (!Name.!AA (!Facet,!Vals1+!Vals2) !ZZ)
                                      + !M
                                      + !Z
                                    : ?arg
                                  )
                              & !done+!arg:?arg
                              & !done:~0
                              )
                          & !arg
                      )
                    & Combine$!thisToolProp:?thisToolProp
                    & ( Ocomb
                      =   a i1 i2 o m z
                        .     !arg:?a+(?i1.?o)+?m+(?i2.!o)+?z
                            & Ocomb$(!a+(!i1+!i2.!o)+!m+!z)
                          | !arg
                      )
                    & ( IOcomb
                      =   a i o1 o2 m z
                        .     !arg:?a+(?i.?o1)+?m+(!i.?o2)+?z
                            & IOcomb$(!a+(!i.!o1+!o2)+!m+!z)
                          | Ocomb$!arg
                      )
                    & ( IOFeatComb
                      =   F vs
                        .     !arg:(?F,?vs) ?arg
                            & (!F,IOcomb$!vs) IOFeatComb$!arg
                          | 
                      )
                    & ( IOcombine
                      =   Name facets
                        .     !arg:(?Name.?facets)+?arg
                            & (!Name.IOFeatComb$!facets)+IOcombine$!arg
                          | 0
                      )
                    & IOcombine$!thisToolProp:?thisToolProp
                    & ( !thisToolProp:0
                      |   !thisToolProp+!otherToolprop:?toolprop
                        & saveToolTable$toolprop
                      )
                    & (   !tooladm:?A+(? (ToolID.!ToolName) ?)+?Z
                        & !A+!Z:?tooladm
                      | 
                      )
                    &     !tooladm
                        + (   (ToolID.!ToolName)
                              (PassWord.!PassWord)
                              (ContactEmail.!ContactEmail)
                              (Version.!ToolVersion)
                              (Title.!FullToolName)
                              (ServiceURL.!ToolURL)
                              (Publisher.!ToolPublisher)
                              (ContentProvider.!ContentProvider)
                              (Creator.!ToolCreator)
                              (InfoAbout.!InfoAbout)
                              (Description.!ToolDescription)
                              (ExternalURI.!ToolExternalURI)
                              (MultiInp.!ToolMultiInp)
                              (PostData.!ToolPostData)
                              (Inactive.!ToolInactive)
                          : ?admdata
                          )
                      : ?tooladm
                    & saveToolTable$tooladm
                    & "O.k."
                  |   str
                    $ "You need to provide valid password to save or replace an active tool. Otherwise you can only look at the metadata."
                  )
            )
          & "Body of Register starts here"
          & log$NEW
          & log$REGISTER
          & log$
          & lst$(arg,path$"log.txt",RAW APP WYD)
          &   
            : ?servicedSources
            : ?servicedGoals
            : ?servicedSuperGoals
            : ?goalPicklists
          & localized$("Save metadata" "Gem oplysninger"):?storeToolButton
          & localized$("Replace metadata" "Erstat oplysninger"):?replaceToolButton
          & localized$("Delete metadata" "Slet oplysninger"):?deleteToolButton
          & localized$("Show more entry fields" "Vis flere inputfelter"):?UpdateButton
          & localized$("PHP wrapper" PHP-kode):?PHPbutton
          & 0:?tabind
          & :?hiddenData:?formFields:?Metadata
          & readTable$facets
          & readTable$toolprop
          & readTable$tooladm
          & readTable$features
          & ( !arg:? (handle.?handle) ?
            | :?handle
            )
          & ( !arg:? (passwordAsHandle.?passwordAsHandle) ?
            | (.):?passwordAsHandle
            )
          & ( !arg:? (mail2.?mail2) ?
            | :?mail2
            )
          & (   createBoilerPlate$!arg:(?ToolName.?password.?contactEmail.?arg)
              & staticFields$!arg:?formFields
              &     ( h1
                    .   
                      ,     !ToolName:
                          & localized$("Register a new tool" "Registrer et nyt v√¶rkt√∏j")
                        | localized$("Update tool metadata" "Opdater v√¶rkt√∏jsoplysninger")
                    )
                    !formFields
                : ?formFields
              & "
                Decide in how far the features as received in the request
                string (the arg variable) or the features as defined in
                toolprop.table should be used in the ensuing process (storage
                as needed and creation of the form to be returned to the
                caller): One of the submit buttons pressed or tool not defined
                in toolprop.table (i.e. tool is not integrated): use info from
                request string.
                Otherwise: use metadata from toolprop.table.
                "
              &   (     !arg
                      :   ?
                          (bsubmit.@(?:(prev|next) #?nth))
                          ?
                    & "
                      If user wants to navigate to the next or previous
                      incarnation wind to the requested incarnation of tool and
                      read tools' properties from toolprop.table. ZZ is the
                      part of the toolprop table coming after this incarnation
                      of this tool. This variable is later used to decide
                      whether a 'next' button is needed and also to locate the
                      old version of the incarnation if the user wants to
                      remove or replace it.
                      "
                    &   windfw$(!toolprop.!ToolName.!nth)
                      : (?featjursPreexisting.?ZZ.?nth)
                    & featureListing$(unfoldInputAndOutput$!featjursPreexisting)
                  |   !arg:? (nth.?nth) ?
                    & "
                      The cardinal number of the incarnation is known.
                      "
                    &   windfw$(!toolprop.!ToolName.!nth)
                      : (?featjursPreexisting.?ZZ.?nth)
                    & (   !arg:? (bsubmit.?) ?
                        & "
                          User presses one of the 'submit' buttons
                          (!storeToolButton, !replaceToolButton,
                           !deleteToolButton, !UpdateButton, !PHPbutton).
                          The features as shown in the form should overrule the
                          properties as recorded in the toolprop table for this
                          incarnation of the tool, so ignore the preexisting
                          properties.
                          "
                        & !arg
                      | featureListing$(unfoldInputAndOutput$!featjursPreexisting)
                      )
                  |   "We are just entering the form for the selected tool.
                       The cardinal number of the incarnation is not known.
                       Navigate to the first incarnation of the tool.
                      "
                    & windfw$(!toolprop.!ToolName.0):(?featjursPreexisting.?ZZ.?nth)
                    & "featjursPreexisting e.g. for a tool with features
                       'facet' and 'lang':

                              ( facet
                              , ( ner*(seg*tok^PT.OnE)*(tok^simple*txt.OnE)
                                . pos^PT*seg*tok
                                )
                              )
                              (lang,(da.da))

                       Or, another tool:

                              (ambig,(una.una))
                              (facet,(lem+pos+tok+txt+(seg*tok.OnE).rep))
                              (format,(flat.html^ROTM))
                              (pres,(nml.frq))

                       ZZ are other incarnations of the same tool and other
                       tools altogether, all coming AFTER the tool incarnation
                       currently being shown.

                       nth is the incarnation number.

                       Unfolding makes sure that (input.output) pairs with sums
                       in the input and/or output are converted to sum of
                       pairs.

                              ( facet
                              , ( ner*(seg*tok^PT.OnE)*(tok^simple*txt.OnE)
                                . pos^PT*seg*tok
                                )
                              )
                              (lang,(da.da))

                      Or
                              (ambig,(una.una))
                              ( facet
                              ,   (lem.rep)
                                + (pos.rep)
                                + (tok.rep)
                                + (txt.rep)
                                + ((seg*tok.OnE).rep)
                              )
                              (format,(flat.html^ROTM))
                              (pres,(nml.frq))

                      "
                    & featureListing$(unfoldInputAndOutput$!featjursPreexisting)
                  |   -1:?nth
                    & "
                      The tool hasn't any features (yet).
                      "
                    & !arg
                  )
                : ?featjursURL
              & "
                Add 'previous' and 'next' buttons as needed.
                "
              & ( !nth:<0
                |   (   !nth:>0
                      & !formFields submit$(str$(prev !nth+-1)):?formFields
                    | 
                    )
                  & (   !ZZ:(!ToolName.?)+?
                      & !formFields submit$(str$(next !nth+1)):?formFields
                    | 
                    )
                )
              & !formFields helplink$:?formFields
              & !features:?feats
              & "
                Step through the (short) list of features (facet, format,
                language). For each feature, create an input field and collect
                in the formFields variable. The Metadata variable collects the
                same data in a format similar to the format in the toolprop
                table. A feature can look like:

                          + ( (inDex.B)
                              (name.Language Sprog)
                              (short.lang)
                              ( description
                              .   \"Language of the text\"
                                  \"Sproget i teksten.\"
                              )
                              (table.linguae)
                              ( sourcehelp
                              .   \"You can leave this as it is.\"
                                  \"Du m√• gerne angive inputtets sprog\"
                              )
                              ( goalhelp
                              .   \"You should fill out this field.\"
                                  \"Du b√∏r specificere outputtets sprog\"
                              )
                            )
                "
              &     !formFields
                      mop
                    $ ( ( 
                        =   
                          .     createFeatureFieldset$(!arg.!featjursURL)
                              : (?additionalFormFields.?additionalMetadata)
                            & !Metadata !additionalMetadata:?Metadata
                            & !additionalFormFields
                        )
                      . !feats
                      . (=+)
                      )
                : ?formFields
              & " formFields is basically a list of HTML fieldset elements.
                 The first two are for boilerplate info. Each of the remaining
                 fieldsets is dedicated to one feature (facet, language, ...).
                 These latter fieldsets are created by createFeatureFieldset.

                 Each fieldset element consists (among other fields) of a list
                 of fieldset elements, on for each input/output combination.

                 Each input/output combination has paragraph (p) elements for
                 input lines followed by output lines.

                 A line consists of a label, a select element and one or more
                 checkbox input elements.

                 Metadata: space separated list of (!shortfeatname,!inoutpairs)
                "
              & "Before editing the tool metadata, the metadata were unfolded.
                 Now, before storing them, they are refolded to save space and
                 to make computation of workflows a little bit faster. (Is that
                 also true: computations becoming faster?)
                "
              & foldInputAndOutput$!Metadata:?Metadata
              & no:?force
              & (!ToolName.!Metadata):?Metadata
              & (   ( !arg:? (bsubmit.?Submit) ?
                    | :?Submit
                    )
                  & (   !Submit:!PHPbutton
                      & wrapper$(PHP.!ToolName)
                    |     (     !Submit
                              : (!storeToolButton|!replaceToolButton)
                            & (   validationComments
                                $ ( !ToolName
                                  . !PassWord
                                  . !ToolVersion
                                  . !FullToolName
                                  . !ToolURL
                                  . !ToolPublisher
                                  . !ContentProvider
                                  . !ToolCreator
                                  . !InfoAbout
                                  . !ToolDescription
                                  . !ToolExternalURI
                                  . !ToolMultiInp
                                  . !ToolPostData
                                  . !ToolInactive
                                  . !Submit
                                  )
                              |   0:?nth
                                &   storeTool
                                  $ ( !Metadata
                                    . !ToolName
                                    . !PassWord:?password
                                    . !ContactEmail:?contactEmail
                                    . !ToolVersion
                                    . !FullToolName
                                    . !ToolURL
                                    . !ToolPublisher
                                    . !ContentProvider
                                    . !ToolCreator
                                    . !InfoAbout
                                    . !ToolDescription
                                    . !ToolExternalURI
                                    . !ToolMultiInp
                                    . !ToolPostData
                                    . !ToolInactive
                                    .     !Submit:!storeToolButton
                                        & -1
                                      | !ZZ
                                    . !force
                                    )
                              )
                          |   !Submit:!deleteToolButton
                            & (   !toolprop:?AA+(!ToolName.?)+!ZZ
                                & !AA+!ZZ:?toolprop
                                & saveToolTable$toolprop
                                &   (!nth+-1:~<0|0)
                                  : ?nth
                                & str$("Deleted current incarnation of tool " !ToolName)
                              |   -1:?nth
                                &   !tooladm
                                  : ?AA+(? (ToolID.!ToolName) ?)+?ZZ
                                & !AA+!ZZ:?tooladm
                                & saveToolTable$tooladm
                                & str$("Deleted administrative metadata of tool " !ToolName)
                              )
                          | "Up to date"
                          )
                        : ?error
                      & log$(error !error nth !nth)
                      & (   (|!nth:<0)
                          & !error:~"Up to date"
                          &   update
                            $ ( (msg.!error)
                                ( !passwordAsHandle:(.)&
                                | (passwordAsHandle.!passwordAsHandle)
                                )
                                ( !contactEmail:
                                | (contactEmail.!contactEmail)
                                )
                                (!handle:|(handle.!handle))
                              )
                        |   toML
                          $ ( !HTMLbodyContainer
                            $ ( ( !formFields:
                                |   form
                                  $ ( register
                                    .   ( !handle:
                                        | makeHiddenFields$(handle.!handle)
                                        )
                                        !formFields
                                        submit$!storeToolButton
                                        ( !nth:<0&
                                        |   submit$!replaceToolButton
                                            makeHiddenFields$(nth.!nth)
                                        )
                                          makeHiddenFields
                                        $ ( (password.!password)
                                            (   !passwordAsHandle:(.)
                                              & 
                                            | (passwordAsHandle.!passwordAsHandle)
                                            )
                                            ( !mail2:
                                            | (mail2.!mail2)
                                            )
                                            (contactEmail.!contactEmail)
                                          )
                                        submit$!deleteToolButton
                                        submit$!UpdateButton
                                        submit$!PHPbutton
                                        helplink$(usedonly.n)
                                    . POST
                                    )
                                )
                                (p.,!error (br.,))
                                (hr.,)
                              )
                            )
                        )
                    )
                | str$("unknown button: " !Submit)
                )
            |   !arg:? (name.?ToolName) ?
              &   update
                $ ( (msg."Forkert adgangskode!")
                    (selected.!ToolName)
                    (password.!password)
                    (contactEmail.!contactEmail)
                    (handle.!handle)
                  )
            |   toML
              $ ( !HTMLbodyContainer
                $ ( paragraph
                  $ ( str
                    $ ( localized$("Email address missing." "Der mangler en email-adresse.")
                        " ('mail2' HTTP parameter)"
                      )
                    )
                  )
                )
            )
      )
      "
/**
 * saveJobTables
 *
 * Save job related tables to files.
 *
 * Called from cleanup.java
 */"
      ( saveJobTables
      =   
        .   saveTable$jobs
          & saveTable$Uploads
          & saveTable$CTBs
          & saveTable$jobAbout
          & saveTable$ItemGroupsCache
      )
      "
/**
 * setLanguage
 *
 * Set the language in the user interface.
 * The Text Tonsorium can handle two languages. Currently, these languages are English and Danish.
 * Whenever text is copied to HTML pages, the correct language version is chosen by calling
 * localized, e.g. localized$(Text"
      in
      the
      default
      "language Tekst"
      p√•
      "dansk)
 *
 * Called from setLanguage.java
 */"
      ( setLanguage
      =   A Z
        .     !arg:? (UIlanguage.?arg) ?
            & (   readTable$UIlanguage
                & (   !UIlanguage:?A !arg ?Z
                    & !arg !A !Z:?UIlanguage
                    & saveTable$UIlanguage
                    & setLang$!arg:?arg
                    & toML$(!HTMLbodyContainer$(paragraph$(str$("Sprog er nu sat til " !arg))))
                  | toML$(!HTMLbodyContainer$(paragraph$(str$("Det forstod jeg ikke:" !arg))))
                  )
              |   toML
                $ ( !HTMLbodyContainer
                  $ ( paragraph
                    $ "Table UIlanguage listing ISO codes of supported UI languages could not be read."
                    )
                  )
              )
          | toML$(!HTMLbodyContainer$(paragraph$"Expected parameter 'UIlanguage'"))
      )
      "
/**
 * showworkflows
 *
 * Computes or retrieves available workflows given the user's I/O whishes.
 * Either produces a list of these workflows that the user can choose from, or
 * produces a new set of output specification form fields with option lists
 * that are restricted to the values that are represented in the found
 * workflows. Using these select fields, the user can close in on his/her
 * goal, making the list of candidate workflows shorter and closer to the
 * user's whishes.
 *
 * Called from showworkflows.java
 */"
      ( showworkflows
      =     Tool parms Items NothingToDo Submit Pfeats
          , presels errors BodyContainer topologicalOrderedTools
          , PIPE A Z TooManyWorkflows updateUploads 2or3things
          , ShowAllPipes rstr reorderedworkflowlist orgarg pipe
          , val allpipes batch returnCode reqtool sources
          , ShowAllPipesIfNotTooExpensive add makeValRows
          , B M Y f fixed formFields fvs nfvs nvs output extractPfeaturesFromHTTParg
          , ZoomInOrShowWorkflows fintool SVG
          , pipes pps rwl superset updatedArg userInput vs
        .   ( ShowAllPipes
            =   hiddenData reorderedworkflowlist,"visualizedWorkFlow(s)" struct
              .   !arg:(?hiddenData.?reorderedworkflowlist.?topologicalOrderedTools)
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ (   !reorderedworkflowlist:%+%
                            &     makeWorkflowRadioButtons
                                $ (!reorderedworkflowlist.!topologicalOrderedTools)
                              : ?"visualizedWorkFlow(s)"
                            &   (h3.,localized$(Workflows Arbejdsgange))
                                ( p
                                .   
                                  ,   ( a
                                      .   (href."#below") (tabindex.0)
                                        , localized$(Below Forneden)
                                      )
                                        localized
                                      $ ( " are the workflows that fulfil the goal set by you."
                                          " er arbejdsgangene som l√∏ser din opgave."
                                        )
                                      (br.,)
                                        localized
                                      $ ( "You can use the table if you first want to learn which tools can be combined."
                                          "Du kan bruge tabellen hvis du f√∏rst vil unders√∏ge hvilke v√¶rkt√∏jer lader sig kombinere."
                                        )
                                      (br.,)
                                      ( small
                                      .   
                                        , ( i
                                          .   
                                            ,     localized
                                                $ ( "Workflows have the structure of directed acyclic graphs. Therefore, tools are in general only "
                                                    "Arbejdsgangene har strukturen af rettede acykliske grafer. Derfor er v√¶rkt√∏jerne generelt kun "
                                                  )
                                                ( strong
                                                .   
                                                  ,   localized
                                                    $ ("partially ordered" "partielt ordnet")
                                                )
                                                "."
                                          )
                                      )
                                      (br.,)
                                      ( small
                                      .   
                                        , ( i
                                          .   
                                            ,   localized
                                              $ ( "Near the top of the table are the tools closest to the input, near the bottom those that are closest to your goal."
                                                  "I toppen af tabellen finder du v√¶rkt√∏jer som er t√¶t p√• inputtet og i bunden v√¶rkt√∏jer som er t√¶t p√• dit m√•l."
                                                )
                                          )
                                      )
                                )
                                  form
                                $ ( chosenworkflow
                                  .   (br.,)
                                      makeHiddenFields$!hiddenData
                                      !"visualizedWorkFlow(s)"
                                  )
                          |   !reorderedworkflowlist:(?,(?.?struct))
                            &   makeWorkflowVisualisation$!struct
                              : (?"visualizedWorkFlow(s)".?SVG)
                            &   workflowAsTextAndGraph
                              $ (   ( 
                                    |   (h3.,Workflow)
                                        ( p
                                        .   
                                          ,   localized
                                            $ ( "This is the workflow that fulfils the goal set by you."
                                                "Dette er arbejdsgangen som l√∏ser din opgave."
                                              )
                                        )
                                    )
                                      form
                                    $ ( chosenworkflow
                                      .   submit$Submit
                                          submit$(localized$!Dryrun)
                                          BookMark$(.)
                                          (|helplink$)
                                          makeHiddenFields$!hiddenData
                                      . 
                                      )
                                . !"visualizedWorkFlow(s)"
                                . !SVG
                                )
                          )
                        )
                    )
            )
          & ( NothingToDo
            =   hiddenData rstr lstr
              .   !arg:?hiddenData
                & ( !hiddenData:? (reqtool.?rstr) ?
                  | :?rstr
                  )
                & ( !hiddenData:? (reqtool.?lstr) ?
                  | :?lstr
                  )
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ ( (h3.,localized$("Nothing to do" "Der er intet at lave"))
                            ( p
                            .   
                              ,     !rstr:
                                  &   localized
                                    $ ( "The goal is trivially fulfilled by the input. Go to the previous screen and specify your goal (or even the input) in more detail."
                                        "Inputtet opfylder allerede m√•let. G√• tilbage til forrige sk√¶rm og specificer dit m√•l (og eventuelt ogs√• inputtet) n√¶rmere."
                                      )
                                |     localized
                                    $ ( "The goal is trivially fulfilled by the input. Go to the previous screen and either specify your goal in more detail, or do not specify a goal at all. If you choose the second option, an implicit goal will be derived from the tool that you specified."
                                        "Inputtet opfylder allerede m√•let. G√• tilbage til forrige sk√¶rm og specificer dit m√•l n√¶rmere, eller lad v√¶re med at specificere et m√•l. Hvis du v√¶lger det sidste, bliver m√•let implicit bestemt af det v√¶rkt√∏j du har valgt."
                                      )
                                    " ("
                                    ToolTitle$!rstr
                                    ")"
                            )
                          )
                        )
                    )
            )
          & ( TooManyWorkflows
            =   
              .   str
                $ ( 404~~~
                      toML
                    $ ( !BodyContainer
                      $ ( paragraph
                        $ ( localized
                          $ ( "The computation is taking too long. Try to specify more details for your goal."
                              "Beregningen tager for lang tid. Pr√∏v at specificere dit m√•l n√¶rmere."
                            )
                          )
                        )
                      )
                  )
            )
          & ( add
            =   fvs calls
              .   !arg:(?arg.?fvs.?calls)
                &   map
                  $ ( ( 
                      =   f v
                        .   !arg:(?f,?v)
                          & (!v:(?v.OnE)|)
                          & !f^!v*!fvs:?fvs
                      )
                    . !arg
                    )
                & (!fvs.1+!calls)
            )
          & ( ShowAllPipesIfNotTooExpensive
            =     returnCode reorderedworkflowlist
                , userInput topologicalOrderedTools
                , hiddenData superset
              .       !arg
                    : ( ?returnCode
                      . ?hiddenData
                      . ?userInput:(?.?.?.?superset)
                      . ?reorderedworkflowlist
                      . ?topologicalOrderedTools
                      )
                  & !returnCode:allRight
                  & saveTask$(!userInput.!reorderedworkflowlist.!topologicalOrderedTools)
                  & "TODO update hiddenData"
                  & updateOargFromParg$!orgarg:?updatedArg
                  & makeArgsForHiddenFields$(!updatedArg.!superset):?hiddenData
                  & !hiddenData
                  & ShowAllPipes$(!hiddenData.!reorderedworkflowlist.!topologicalOrderedTools)
                | !returnCode:tooComplex&TooExpensive$
            )
          & ( ZoomInOrShowWorkflows
            =     returnCode pipes Pfeats
                , reorderedworkflowlist topologicalOrderedTools userInput ZoomIn
              .   ( ZoomIn
                  =     returnCode pipes
                      , reorderedworkflowlist topologicalOrderedTools userInput
                      , A B M Y f fixed addCalls ShowZoomedInForm
                      , fvs nfvs nvs output pipe pps rwl tool vs
                    .   ( ShowZoomedInForm
                        =   nfvs userInput fixed orgarg SUP SMP
                          .   ( makeValRows
                              =     name short description table
                                  , hide preselvalsrows nfvs
                                .   !arg:?nfvs
                                  & readTable$features
                                  &     mop
                                      $ ( ( 
                                          =   
                                            .     !arg
                                                : ? (name.?name) ?
                                                : ? (short.?short) ?
                                                :   ?
                                                    (description.?description)
                                                    ?
                                                : ? (table.?table) ?
                                              & (   !arg
                                                  : ? (hide.?hide) ?
                                                | :?hide
                                                )
                                              & (   !nfvs:?*!short^?vs*?
                                                  & !hide:
                                                  & readTable$!table
                                                  & ( ?
                                                    . !short
                                                    . localized$!name
                                                    .   map
                                                      $ ( ( 
                                                          =   
                                                            .     !arg
                                                                : ( ?
                                                                  . [%( !vs
                                                                      :   ?
                                                                        +   ?
                                                                          * !sjt
                                                                          * ?
                                                                        + ?
                                                                      )
                                                                  . ?
                                                                  )
                                                              | 
                                                          )
                                                        . !!table
                                                        )
                                                    . 
                                                    )
                                                | 
                                                )
                                          )
                                        . !features
                                        . (=+)
                                        )
                                    : ?preselvalsrows
                                  & !preselvalsrows
                              )
                            & !arg:(?nfvs.?userInput.?fixed.?orgarg)
                            &     createGoalPickLists
                                $ ( makeValRows$!nfvs
                                  .   makeExpandedSelectLists
                                    $ ( makeSuperGoals$!nfvs:(?SUP.?SMP)
                                      & !SUP !SMP
                                      )
                                  . 
                                  )
                              : ?formFields
                            & "postpone pruning, which is costly. Instead, show input fields again, but with restricted option lists."
                            &   str
                              $ ( 200~~~
                                    toML
                                  $ ( !BodyContainer
                                    $ ( ( h1
                                        .   
                                          ,   localized
                                            $ ( "Refinement of your goal"
                                                "N√¶rmere bestemmelse af dit m√•l"
                                              )
                                        )
                                        ( form
                                        .     (action.showworkflows)
                                              (class.formRounded)
                                              (accept-charset.UTF-8)
                                          ,   ( p
                                              .   
                                                ,     localized
                                                    $ ( "There are workflow candidates with different output specifications. "
                                                        "Vi fandt arbejdsgange med forskellige outputspecifikationer. "
                                                      )
                                                    (   !nfvs:?*[>1
                                                      &   localized
                                                        $ ( "Here you can supply more specifiations for the output."
                                                            "P√• denne side kan du v√¶lge flere specifikationer."
                                                          )
                                                    |   localized
                                                      $ ( "Here you can supply the missing specification and thereby reduce the number of proposed workflow candidates."
                                                          "P√• denne side kan du give den manglende specifikation og p√• den m√•de reducere antallet af foresl√•ede arbejdsgange."
                                                        )
                                                    )
                                              )
                                              (   !nfvs:?*[>1
                                                & ( p
                                                  .   
                                                    ,   localized
                                                      $ ( "It is advisable to choose just one value at a time. In that way, you do not run the risk of selecting a combination of values for which no workflow exists."
                                                          "Det er bedst at v√¶lge pr√¶cis √©n v√¶rdi ad gangen. P√• den m√•de undg√•r du at du kommer til at selektere en kombination af v√¶rdier som ikke resulterer i nogen arbejdsgangkandidater."
                                                        )
                                                  )
                                              | 
                                              )
                                              (   !userInput
                                                : (?.?.?.?superset)
                                              &   updateOargFromParg$!orgarg
                                                : ?updatedArg
                                              &     ( 
                                                    =     updatedArg
                                                        , fixed ft v
                                                        , A Z
                                                      .     !arg
                                                          : (?updatedArg.?fixed)
                                                        &   whl
                                                          ' (   !fixed
                                                              : %?ft^(#*%@?v)*?fixed
                                                            &     (str$(O !ft).!v)
                                                                  (     !updatedArg
                                                                      :   ?A
                                                                          ( @( ?
                                                                             :   O
                                                                                 !ft
                                                                             )
                                                                          . ?
                                                                          )
                                                                          ?Z
                                                                    & !A !Z
                                                                  | !updatedArg
                                                                  )
                                                              : ?updatedArg
                                                            )
                                                        & !updatedArg
                                                    )
                                                  $ (!updatedArg.!fixed)
                                                : ?updatedArg
                                              &   makeHiddenFields
                                                $ ( makeArgsForHiddenFields
                                                  $ (!updatedArg.!superset)
                                                  )
                                              )
                                              ( div
                                              .   (class.topmargin)
                                                , (table.,!formFields)
                                              )
                                              ( div
                                              .   (class.topmargin)
                                                ,     !nfvs:?*[>1
                                                    &     submit
                                                        $ (localized$!helpmespecifymygoal)
                                                        ( 
                                                        |   submitNR
                                                          $ (localized$!"skip zoom")
                                                        )
                                                  | submit$(localized$!"show workflows")
                                              )
                                              (paragraph.,helplink$)
                                        )
                                      )
                                    )
                                )
                        )
                      &   !arg
                        : ( ?returnCode
                          . ?pipes
                          . ?reorderedworkflowlist
                          . ?topologicalOrderedTools
                          . ?userInput
                          )
                      & 1:?fvs
                      & 0:?addCalls
                      & (   !returnCode:workflowsFound
                          & !pipes:?pps
                          &   whl
                            ' ( !pps:%?pipe+?pps
                              &   ( 
                                  =   wfs tool output
                                    .   !arg:(?.?wfs)
                                      &   whl
                                        ' ( !wfs:(?tool,(?output.?))+?wfs
                                          &   add$(!output.!fvs.!addCalls)
                                            : (?fvs.?addCalls)
                                          )
                                  )
                                $ !pipe
                              )
                        |   !reorderedworkflowlist:?rwl
                          &   whl
                            ' ( !rwl:(?,(?.? (?tool.?.?.?output)))+?rwl
                              & add$(!output.!fvs.!addCalls):(?fvs.?addCalls)
                              )
                        )
                      & "fvs is the union of feature values. Important to keep these,
                         as they make it possible to create a form for zooming in."
                      & "It is not unimportant how fvs is obtained.
                         Reorderedworkflowlist outputs can have features
                         that are not (yet) in the output of pipes."
                      & "Zooming in is useful if
                         (>=1)  a feature can have one of several values
                         (0|1) a feature can, but need not be specified
                         (>=0)  a combination of the above"
                      & 1:?fixed:?nfvs
                      &   mop
                        $ ( ( 
                            =   count n
                              .   !arg:%?f^%?vs
                                & 0:?nvs
                                &   whl
                                  ' ( !vs:%?A+?vs
                                    &   whl
                                      ' ( !A:?B*%?M^%*?Y
                                        & !B*!M*!Y:?A
                                        )
                                    & !nvs+!A:?nvs
                                    )
                                & 0:?count
                                &   whl
                                  ' ( !nvs:%?A+?nvs
                                    &     !count
                                        + ( !A:#%?n*?A&!n
                                          | 1
                                          )
                                      : ?count
                                    & !vs+!A:?vs
                                    )
                                & (   !count:!addCalls
                                    & (   !vs:%+%
                                        & "All workflows specify this feature, but in different ways."
                                        & (   ( 
                                              |     !userInput
                                                  : (?.?.?.? !f ?)
                                                & "And the user has specified that combinations are OK."
                                              )
                                            & !nfvs*!f^!vs:?nfvs
                                          | 
                                          )
                                      |   "All workflows specify this feature with the same value."
                                        & !fixed*!f^!vs:?fixed
                                      )
                                  |   !count:<!addCalls
                                    & (   !vs:%+%
                                        & "Some workflows did not specify this feature. User can choose blank value."
                                        & !nfvs*!f^!vs:?nfvs
                                      | "If there is only one non-blank value, then choosing between that value
                                         and blank is hard to understand for a user, since blank means:
                                         Any value goes, even the non-blank value that is the other choice."
                                      )
                                  | 
                                  )
                            )
                          . !fvs
                          . (=*)
                          )
                      & (   !nfvs:(1|sml^?)
                          &   NoNeedForMoreZoomingIn
                            $ ( !returnCode
                              . !pipes
                              . !reorderedworkflowlist
                              . !topologicalOrderedTools
                              . !userInput
                              )
                        | ShowZoomedInForm$(!nfvs.!userInput.!fixed.!orgarg)
                        )
                  )
                &   !arg
                  : ( ?returnCode
                    . ?pipes
                    . ?reorderedworkflowlist
                    . ?topologicalOrderedTools
                    . ?userInput
                    . ?Pfeats
                    )
                & log$(Submit !Submit)
                & log$(zubmit localized$!helpmespecifymygoal)
                & (   ( localized$!"show workflows":!Submit
                      | localized$!"skip zoom":!Submit
                      | !Pfeats:~:~(? (?.~) ?)
                      )
                    &   NoNeedForMoreZoomingIn
                      $ ( !returnCode
                        . !pipes
                        . !reorderedworkflowlist
                        . !topologicalOrderedTools
                        . !userInput
                        )
                  |   localized$!helpmespecifymygoal:!Submit
                    &   ZoomIn
                      $ ( !returnCode
                        . !pipes
                        . !reorderedworkflowlist
                        . !topologicalOrderedTools
                        . !userInput
                        )
                  )
            )
          & ( extractPfeaturesFromHTTParg
            =   short p v parms
              .   "Collects features having prefix 'P' in the HTTP parameter list."
                & !arg:?parms
                & readTable$features
                &   mop
                  $ ( ( 
                      =   
                        .   !arg:? (short.?short) ?
                          & str$(P !short):?p
                          &   map
                            $ ( ( 
                                = .!arg:(!p.?v)|
                                )
                              . !parms
                              )
                      )
                    . !features
                    . (=+)
                    )
            )
          & log$showworkflows-WORKFLOWLISTLOGJE
          & !arg:?orgarg
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & :?PIPE
          &   initialiseSpecifyGoalShowWorkflowsChosenWorkflow$!arg
            : (?errors.?hiddenData.?Items.?Tool.?parms.?BodyContainer)
          & "(B) First build a list of items."
          & getSingleItemOrNothing$!parms:?Items
          & analyzeInput$(!Items.!errors):(?Items.?presels.?errors)
          & ( !errors:~
            |     supplementParmsAndHiddenData$(!parms.!hiddenData)
                : (?parms.?Submit.?hiddenData.?batch)
              & "Add any info about the input that the user has provided, e.g. language of the resource."
              & ( updateUploads
                =   A nr Item stagingName meta feats Z parms
                  .   !arg:?parms
                    & readTable$Uploads:?Uploads
                    & readTable$features:?features
                    &   map
                      $ ( ( 
                          =   
                            .     !arg:(Item.?Item)
                                &   !Uploads
                                  : ?A (?nr.!Item.?stagingName.?meta.?feats) ?Z
                                &     !A
                                      ( !nr
                                      . !Item
                                      . !stagingName
                                      . !meta
                                      .   map
                                        $ ( ( 
                                            =   key val
                                              .       !arg
                                                    : ( @(?:I ?key)
                                                      . ~:?val
                                                      )
                                                  &   !features
                                                    :   ?
                                                      + (? (short.!key) ?)
                                                      + ?
                                                  & (!key.!val)
                                                | 
                                            )
                                          . !parms
                                          )
                                      )
                                      !Z
                                  : ?Uploads
                              | 
                          )
                        . !parms
                        )
                    & saveTable$Uploads
                )
              & (     (eye|localized$!updateAvailableWorkflows)
                    : !Submit
                  & specifyGoal$!parms
                |   updateUploads$!parms
                  & 0:?allpipes
                  & localized$("No workflows found." "Ingen arbejdsgange fundet."):?returnCode
                  & :?reqtool:?fintool
                  & log$CALL-Pipelines
                  & :?msg
                  & (     Pipelines$(!parms.)
                        : ((?sources.?):?userInput.?2or3things.?returnCode.?msg)
                      & (   !returnCode:allRight
                          & "returnCode:allRight"
                          & !2or3things:(?reorderedworkflowlist.?topologicalOrderedTools)
                        | !2or3things:(?pipes.?parms)
                        )
                      & log$("back from Pipelines" !returnCode)
                      & "allRight
                         onlyWithoutRestriction
                         triviallyFulfilled
                         tooComplex
                         workflowsFound
                         tooMany"
                      & (   !returnCode:(workflowsFound|allRight)
                          & extractPfeaturesFromHTTParg$!parms:?Pfeats
                          & (   ZoomInOrShowWorkflows
                              $ ( !returnCode
                                . !pipes
                                . !reorderedworkflowlist
                                . !topologicalOrderedTools
                                . !userInput
                                . !Pfeats
                                )
                            | 
                            )
                        |   !returnCode:onlyWithoutRestriction
                          & !parms:? (reqtool.?reqtool) ?
                          & FulfillableWithoutRestriction$!reqtool
                        |   !returnCode:triviallyFulfilled
                          & NothingToDo$!hiddenData
                        |   !returnCode:(tooMany|tooComplex)
                          & TooManyWorkflows$
                        |   !returnCode:notFulfillable
                          &   NotFulfillable
                            $ (!msg:~|!returnCode.!userInput)
                        )
                    | NotFulfillable$(!msg:~|!returnCode.)
                    )
                )
            )
      )
      "
/**
 * specifyGoal
 *
 * Prepare a workflow.
 * Functions as a wizard, taking input from various stages.
 * The function creates a resource by choice of goal
 * Arguments:
 *      - http parameters
 * http parameters:
 *      mail2=<address>
 *      action=batch | batch=on | batch=off
 *      bsubmit=next step|Submit|View details
 *      (item=<itemid>)+
 *      (Item=<itemid>)+
 *      I<feature>=<featurevalue>
 *      O<feature>=<featurevalue>
 * features are (currently): facet, format and lang
 * feature values are complex strings consisting of a feature value and,
 * optionally, a specialisation of the feature values, separated from the
 * former by a caret.
 *
 * Called from specifyGoal.java
 */"
      ( specifyGoal
      =     Tool item parms Items items presels convertISO639-3to-1-IfPossible
          , errors batch desiredTools sourcesAndGoals BodyContainer
          , A itms orgarg buildItemListFromForeignData updatePreselsWithUserAmendments
          , "We are at the start. Show an input form." preSelectedOutputSpec
        .   ( buildItemListFromForeignData
            =     A Z N name Items nofonts ContentType feats preSelectedOutputSpec
                , DestinationDir LocalFileName language date analyseContentType
              .   ( analyseContentType
                  =     R spec nofonts ct DestinationDir LocalFileName anateip5
                      , asDiplom input getInput asTabSeparated asConll txt asText
                    .   !arg:(?arg.?nofonts.?DestinationDir.?LocalFileName)
                      & @( !arg
                         : ((%? "/" %?:?ct) ";" ?|?ct)
                         )
                      & ( getInput
                        = .get$(str$(!DestinationDir !LocalFileName),STR,TXT)
                        )
                      & ( asText
                        =     TOT DOT WHT COM CIF SEM
                            , VTB FFE BEL CTL SYM txt
                            , BM1 BM2 UT8 TTO
                          .   str$(chr$255 chr$254):?BM1
                            & str$(chr$254 chr$255):?BM2
                            &     str
                                $ (chr$(x2d$ef) chr$(x2d$bb) chr$(x2d$bf))
                              : ?UT8
                            & !arg:?txt
                            & ( 
                              | !( 
                                 ' @( !txt
                                    : ~($BM1 ?|$BM2 ?)
                                    )
                                 )
                              )
                            & log$notUTF16
                            & (   !('@(!txt:$UT8 ?txt))
                                & log$HASBOM
                              | log$NOBOM
                              )
                            &   0
                              : ?TOT
                              : ?DOT
                              : ?WHT
                              : ?COM
                              : ?CIF
                              : ?SEM
                              : ?VTB
                              : ?FFE
                              : ?BEL
                              : ?CTL
                              : ?SYM
                            &   vap
                              $ ( ( 
                                  =   
                                    .   1+!TOT:?TOT
                                      &   !arg
                                        : (   "."
                                            & 1+!DOT:?DOT
                                          |   ( " "
                                              | \t
                                              | \n
                                              )
                                            & 1+!WHT:?WHT
                                          |   ","
                                            & 1+!COM:?COM
                                          |   ~<0:~>9
                                            & 1+!CIF:?CIF
                                          |   ";"
                                            & 1+!SEM:?SEM
                                          |   \v
                                            & 1+!VTB:?VTB
                                          |   \f
                                            & 1+!FFE:?FFE
                                          |   \a
                                            & 1+!BEL:?BEL
                                          |   <" "
                                            & 1+!CTL:?CTL
                                          |   ( "<"
                                              | ">"
                                              | "\\"
                                              | "/"
                                              | "$"
                                              | "["
                                              | "]"
                                              | "{"
                                              | "}"
                                              | "="
                                              | "|"
                                              | "*"
                                              | "#"
                                              | "%"
                                              | "&"
                                              | "_"
                                              | "+"
                                              )
                                            & 1+!SYM:?SYM
                                          )
                                  )
                                . !txt
                                )
                            & ( !TOT:~>100
                              |   !TOT^-1:?TTO
                                & !DOT*!TTO:<1/5
                                & !WHT*!TTO:>1/10:<3/5
                                & !COM*!TTO:<1/25
                                & !CIF*!TTO:<1/2
                                & !SEM*!TTO:<170
                                & !VTB*!TTO:<1/70000
                                & !FFE*!TTO:<1/1000
                                & !BEL*!TTO:<1/20000
                                & !CTL*!TTO:<1/3800
                                & !SYM*!TTO:<1/10
                              )
                        )
                      & ( asDiplom
                        =   N lang input
                          .   0:?lang
                            & !arg:?input
                            &     vap
                                $ ( ( 
                                    =   N la
                                      .   ( @(!arg:?arg \r)
                                          | 
                                          )
                                        &   vap$((=.!arg).!arg."|")
                                          : ? [?N
                                          : (   ( %@
                                                : @( ?
                                                   :   ?
                                                       (L|l)
                                                       anguage
                                                       ?
                                                   )
                                                )
                                                ( %@
                                                : @( ?
                                                   :   ?
                                                       ( (   (   ( D
                                                                 | d
                                                                 )
                                                                 an
                                                             |   ( L
                                                                 | l
                                                                 )
                                                                 at
                                                             | mlg
                                                             | swe
                                                             )
                                                           : ?la
                                                         |   Svensk
                                                           & swe:?la
                                                         )
                                                       &   low$!la+!lang
                                                         : ?lang
                                                       )
                                                       ?
                                                   )
                                                )
                                            | ?
                                            )
                                        & !N
                                    )
                                  . !input
                                  . \n
                                  )
                              : ? (~<17:?N) !N !N ?
                            &   (app.unn)
                                (facet.tok)
                                (format.dipl)
                                (   !lang:#*%@?lang
                                  & ( lang
                                    .   !lang:lat&la
                                      | !lang:dan&da
                                      | !lang:mlg&gml
                                      | !lang:swe&sv
                                    )
                                | 
                                )
                                (period.c13)
                                (pres.nml)
                        )
                      & ( asConll
                        =     TL L spc facet pat est
                            , ID FORM LEMMA HEAD DEPREL
                            , PLEMMA POS PPOS FEAT PFEAT PHEAD
                            , PDEPREL FILLPRED PRED APREDs
                            , UPOSTAG XPOSTAG FEATS DEPS MISC
                          .   @( !arg
                               : ( "#" ?
                                 | \n ?
                                 | # \t ?
                                 | # "-" # \t ?
                                 )
                               )
                            &   vap
                              $ ( ( 
                                  =   
                                    .     @( !arg
                                           : ( \r
                                             | 
                                             | "#" ?
                                             | # \t ?
                                             | # "-" # \t ?
                                             )
                                           )
                                        & 
                                      | !arg
                                  )
                                . !arg
                                . \n
                                )
                            &   
                              : ?FORM
                              : ?LEMMA
                              : ?HEAD
                              : ?DEPREL
                              : ?PLEMMA
                              : ?POS
                              : ?PPOS
                              : ?FEAT
                              : ?PFEAT
                              : ?PHEAD
                              : ?PDEPREL
                              : ?FILLPRED
                              : ?PRED
                              : ?APREDs
                              : ?UPOSTAG
                              : ?XPOSTAG
                              : ?FEATS
                              : ?DEPS
                              : ?MISC
                            & ( @(!arg:? \n (# \t ?:?TL))
                              & @(!TL:?TL (\r|\n) ?)
                              & vap$((=.!arg).!TL.\t):?TL
                              & !TL:? [?L
                              &   (   !L:10
                                    & ( clU
                                      . ( 
                                        =   %?ID
                                            %?FORM
                                            %?LEMMA
                                            %?UPOSTAG
                                            %?XPOSTAG
                                            %?FEATS
                                            %?HEAD
                                            %?DEPREL
                                            %?DEPS
                                            %?MISC
                                        )
                                      )
                                  |   !L:~<14
                                    & ( cnl2009
                                      . ( 
                                        =   %?ID
                                            %?FORM
                                            %?LEMMA
                                            %?PLEMMA
                                            %?POS
                                            %?PPOS
                                            %?FEAT
                                            %?PFEAT
                                            %?HEAD
                                            %?PHEAD
                                            %?DEPREL
                                            %?PDEPREL
                                            %?FILLPRED
                                            %?PRED
                                            ( %?APREDs
                                            |   
                                              & :?APREDs
                                            )
                                        )
                                      )
                                  )
                                : (?spc.(=?pat))
                              )
                            & !TL:!pat
                            & ( est
                              =   
                                .   str
                                  $ ( vap
                                    $ ( (=.!arg)
                                      .   str
                                        $ (vap$((=.!arg).str$!arg."_"))
                                      . "-"
                                      )
                                    )
                              )
                            &     seg
                                * ( est$!FORM:&1
                                  | tok
                                  )
                                * (   est$(!LEMMA !PLEMMA):
                                    & 1
                                  | lem
                                  )
                                * (   est$(!UPOSTAG !XPOSTAG !POS !PPOS):
                                    & 1
                                  | pos
                                  )
                                * (   est$(!FEATS !FEAT !PFEAT):
                                    & 1
                                  | mrf
                                  )
                                * (   est$(!HEAD !PHEAD !DEPREL !PDEPREL):
                                    & 1
                                  | stx
                                  )
                              : ?facet
                            & "https://ufal.mff.cuni.cz/conll2009-st/task-description.html
                        ID FORM LEMMA PLEMMA POS PPOS FEAT PFEAT HEAD PHEAD DEPREL PDEPREL FILLPRED PRED APREDs

                         https://github.com/UniversalDependencies/docs/issues/229
                        Change naming in CoNLL-U: CPOSTAG --> UPOSTAG #229

                         https://universaldependencies.org/docs/format.html

                        CoNLL-U Format

                        ID: Word index, integer starting at 1 for each new sentence; may be a range for tokens with multiple words.
                        FORM: Word form or punctuation symbol.
                        LEMMA: Lemma or stem of word form.
                        UPOSTAG: Universal part-of-speech tag drawn from our revised version of the Google universal POS tags.
                        XPOSTAG: Language-specific part-of-speech tag; underscore if not available.
                        FEATS: List of morphological features from the universal feature inventory or from a defined language-specific extension; underscore if not available.
                        HEAD: Head of the current token, which is either a value of ID or zero (0).
                        DEPREL: Universal Stanford dependency relation to the HEAD (root iff HEAD = 0) or a defined language-specific subtype of one.
                        DEPS: List of secondary dependencies (head-deprel pairs).
                        MISC: Any other annotation.
                        "
                            &   ( !facet:1&
                                | (facet.!facet)
                                )
                                (format.conll^!spc)
                        )
                      & ( asTabSeparated
                        =   L H e empty
                          .   :?e
                            & (   @(!arg:? \t ? \n ? \t ? \n ?)
                                & -1:?L:?H
                                &   vap
                                  $ ( ( 
                                      =   K
                                        .     vap$((=..).!arg.\t)
                                            : ? [?K
                                          & (   !K:1
                                              & trim$!arg:
                                              & e:?e
                                            |   !e:?empty
                                              & (   !L:-1
                                                  & !K:?L
                                                | !K:<!L:?L
                                                | 
                                                )
                                              & (   !H:-1
                                                  & !K:?H
                                                | !K:>!H:?H
                                                | 
                                                )
                                            )
                                      )
                                    . !arg
                                    . \n
                                    )
                                & !L:!H
                                & (4:<!L:?L|)
                                & (format.str$(!L col !empty))
                              |     vap$((=.trim$!arg).!arg.\n)
                                  : ~(? @(?:? " " ?) ?)
                                  : ?L
                                & ( !L:% %&(format.1col)
                                  |   @(!L:"https://alf.hum.ku.dk/korp" ?)
                                    & (facet.kwic) (format.url)
                                  )
                              )
                        )
                      & ( anateip5
                        =   xml att msd
                          .       get$(str$(!DestinationDir !LocalFileName),X ML)
                                : ?xml
                              & "Some inputs contain sporadic <w> tags. Such texts are not to be considered tokenised."
                              &     (   !xml:? (s.?) ?xml
                                      & seg
                                    | 1
                                    )
                                  * (   !xml:? (w.?att) ?xml
                                      & tok
                                    | 1
                                    )
                                  * (   !att:? (lemma.?) ?
                                      & lem
                                    | 1
                                    )
                                  * (   !att:? (msd.?msd) ?
                                      &   mrf
                                        * (   @(!msd:UPosTag ?)
                                            & pos
                                          | 1
                                          )
                                    | 1
                                    )
                                  * (   !xml:? (name.?) ?xml
                                      & ner
                                    | 1
                                    )
                                  * (     !xml
                                        :   ?
                                            (linkGrp.? (type.UD-SYN) ?)
                                            ?
                                      & stx
                                    | 1
                                    )
                                : ~1
                                : ~ner
                                : ~tok
                            | txt
                        )
                      &   !ct
                        : (   application/pdf
                            &     (   !nofonts:true
                                    & (app.rom)
                                  | (app.nrm)
                                  )
                                  (facet.txt)
                                  ( format
                                  .     !nofonts:true
                                      & img^pdf
                                    | pdf
                                  )
                              : ?R
                          |   "application/vnd.ms-powerpoint"
                            &     (app.nrm)
                                  (facet.txt)
                                  (format.ppt)
                              : ?R
                          |   "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                            &     (app.nrm)
                                  (facet.txt)
                                  (format.pptx)
                              : ?R
                          |   "application/vnd.oasis.opendocument.presentation"
                            &     (app.nrm)
                                  (facet.txt)
                                  (format.odp)
                              : ?R
                          |   "application/vnd.ms-excel"
                            &     (app.nrm)
                                  (facet.txt)
                                  (format.xls)
                              : ?R
                          |   "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                            &     (app.nrm)
                                  (facet.txt)
                                  (format.xlsx)
                              : ?R
                          |   "application/vnd.oasis.opendocument.spreadsheet"
                            &     (app.nrm)
                                  (facet.txt)
                                  (format.ods)
                              : ?R
                          |   (application/x-download|application/octet-stream)
                            & log$!ct
                            & (   getInput$:?input
                                & log$GotInput
                                & (   @( !input
                                       : ("%PDF" ?|"%pdf" ?)
                                       )
                                    &     (   !nofonts:t
                                            & (app.rom)
                                          | (app.nrm)
                                          )
                                          (facet.txt)
                                          ( format
                                          .     !nofonts:true
                                              & img^pdf
                                            | pdf
                                          )
                                      : ?R
                                    & log$pdf
                                  |   asDiplom$!input:?R
                                    & log$diplom
                                  |   asConll$!input:?R
                                    & log$conll
                                  |   asTabSeparated$!input:?R
                                    & log$tabs
                                  |   asText$!input
                                    & log$OKtext
                                    &     (app.nrm)
                                          (facet.txt)
                                          (format.flat)
                                      : ?R
                                  | :?R
                                  )
                              | log$HASzeros&:?R
                              )
                          |   application/msword
                            & @( get$(str$(!DestinationDir !LocalFileName),STR)
                               : (   ? rtf [<10 ?
                                   &     (app.nrm)
                                         (facet.txt)
                                         (format.rtf)
                                     : ?R
                                 |   ? xml [<10 ?
                                   &     (app.nrm)
                                         (facet.txt)
                                         (format.xml)
                                     : ?R
                                 |   PK ?
                                   &     (app.nrm)
                                         (facet.txt)
                                         (format.docx)
                                     : ?R
                                 |   ? [<9
                                   &     (app.nrm)
                                         (facet.txt)
                                         (format.doc)
                                     : ?R
                                 |   ?
                                   & (app.nrm) (facet.txt):?R
                                 )
                               )
                          |   "application/vnd.oasis.opendocument.text"
                            & @( get$(str$(!DestinationDir !LocalFileName),STR)
                               : (   PK ?
                                   &     (app.nrm)
                                         (facet.txt)
                                         (format.odt)
                                     : ?R
                                 |   ?
                                   & (app.nrm) (facet.txt):?R
                                 )
                               )
                          |   application/octet-stream
                            & log$(!LocalFileName application/octet-stream)
                            & ( @( get$(str$(!DestinationDir !LocalFileName),STR,TXT)
                                 : (   ? rtf [<10 ?
                                     &     (app.nrm)
                                           (facet.txt)
                                           (format.rtf)
                                       : ?R
                                   |   ? xml [<10 ?
                                     &     (app.nrm)
                                           (facet.txt)
                                           (format.xml)
                                       : ?R
                                   |   ?txt
                                     & (   asText$!txt
                                         &     (app.nrm)
                                               (facet.txt)
                                               (format.flat)
                                           : ?R
                                       | :?R
                                       )
                                   )
                                 )
                              |   log$(!LocalFileName "File contains zeros.")
                                & :?R
                              )
                          |   "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                            &     (app.nrm)
                                  (facet.txt)
                                  (format.docx)
                              : ?R
                          |   application/json
                            & (format.json) (app.drty):?R
                          |   (text/html|"application/xhtml+xml")
                            &     (app.nrm)
                                  (facet.txt)
                                  (format.html)
                              : ?R
                          |   (text/rtf|application/rtf)
                            &     (app.nrm)
                                  (facet.txt)
                                  (format.rtf)
                              : ?R
                          |   text/plain
                            & (   getInput$:?input
                                &   ( asDiplom$!input
                                    | asConll$!input
                                    | asTabSeparated$!input
                                    |   (app.nrm)
                                        (facet.txt)
                                        (format.flat)
                                    )
                                  : ?R
                              | log$HASzeros&:?R
                              )
                          |   (application/conllu|text/x-conll)
                            & log$!ct
                            & (   getInput$:?input
                                &   (asConll$!input|(format.flat))
                                  : ?R
                              | log$HASzeros&:?R
                              )
                          |   @( ?
                               :   image/
                                   (   ( gif
                                       | jpeg
                                       | pjpeg
                                       | png
                                       | tiff
                                       | "vnd.microsoft.icon"
                                       )
                                     : ?spec
                                   | "svg+xml"&svg:?spec
                                   )
                               )
                            &     (app.rom)
                                  (facet.txt)
                                  (format.img^!spec)
                              : ?R
                          |   @( ?
                               :   audio/
                                   ( ( basic
                                     | L24
                                     | mp4
                                     | mpeg
                                     | ogg
                                     | vorbis
                                     | "vnd.rn-realaudio"
                                     | "vnd.wave"
                                     | webm
                                     )
                                   : ?spec
                                   )
                               )
                            & (format.snd^!spec):?R
                          |   @( ?
                               :   video/
                                   ( ( mpeg
                                     | mp4
                                     | ogg
                                     | quicktime
                                     | webm
                                     | x-matroska
                                     | x-ms-wmv
                                     | x-flv
                                     )
                                   : ?spec
                                   )
                               )
                            & (format.vid^!spec):?R
                          |   text/xml
                            & (       get
                                    $ ( str$(!DestinationDir !LocalFileName)
                                      , X ML
                                      , TRM
                                      )
                                  : ? (TEI.?) ?
                                &     (app.nrm)
                                      (facet.anateip5$)
                                      (format.teip5)
                                  : ?R
                              | (format.xm):?R
                              )
                          |   "application/tei+xml"
                            &     (app.nrm)
                                  (facet.anateip5$)
                                  (format.teip5)
                              : ?R
                          | :?R
                          )
                      & (   !R
                          : ? (format.json|dipl) ?
                        | !R:~&!R (ambig.una):?R
                        )
                      & !R
                  )
                &   (   !arg:? (language.?language) ?
                      & readTable$linguae
                      & !linguae:? (?.!language.?) ?
                      & (lang.!language)
                    | 
                    )
                  : ?language
                & ( !arg:? (DATE.?date) ?
                  | :?date
                  )
                &     map
                    $ ( ( 
                        =     FieldName Name ContentType nofonts Size
                            , DestinationDir LocalFileName feats A N name Z
                          .       !arg
                                : ( ( FieldName,?FieldName
                                    . Name,?Name
                                    . ContentType,%?ContentType ?nofonts
                                    . Size,?Size
                                    . DestinationDir,?DestinationDir
                                    . LocalFileName,?LocalFileName
                                    )
                                  | ( FieldName
                                    . @( ?
                                       :   ?ContentType
                                           ";"
                                           ?nofonts
                                           ";"
                                           ?DestinationDir
                                           ";"
                                           ?LocalFileName
                                       )
                                    )
                                  )
                              & log$(analyseContentType !LocalFileName)
                              &     analyseContentType
                                  $ (!ContentType.!nofonts.!DestinationDir.!LocalFileName)
                                : ?feats
                              &   !Uploads
                                : ?A (?N.?name.!LocalFileName.?.?) ?Z
                              &     !A
                                    ( !N
                                    . !name
                                    . !LocalFileName
                                    . (TITLE.!name) (DATE.!date)
                                    . !language !feats
                                    )
                                    !Z
                                : ?Uploads
                              & (Item.str$(removePercentEncodings$!name))
                            | 
                        )
                      . !arg
                      )
                  : ?Items
                & saveTable$Uploads
                & !Items
            )
          & ( desiredTools
            =   ToolID Title S
              .   readTable$tooladm
                & 0:?S
                & (   !tooladm
                    :   ?
                      + (   ~(? (Inactive.on) ?)
                          : ? (ToolID.?ToolID) ?
                          : ? (Title.?Title) ?
                        & !S+(low$!Title.!Title.!ToolID):?S
                        & ~
                        )
                      + ?
                  | 
                  )
                &   ( tr
                    .   
                      ,   ( td
                          .   
                            ,   localized
                              $ ( "Workflow must utilize the tool:"
                                  "Arbejdsgang skal inkludere v√¶rkt√∏jet:"
                                )
                          )
                          ( td
                          .   
                            ,   makeSelectFormField
                              $ ( 
                                . reqtool
                                . options
                                .   makeOptionList
                                  $ (   mop
                                      $ ( ( 
                                          =   
                                            .     !arg:(?.?Title.?ToolID)
                                                & (!Title.!ToolID)
                                              | 
                                          )
                                        . !S
                                        . (=+)
                                        )
                                    . 
                                    )
                                )
                          )
                    )
                    ( tr
                    .   
                      ,   ( td
                          . ,localized$("The last tool must be:" "Arbejdsgangen skal afslutte med:")
                          )
                          ( td
                          .   
                            ,   makeSelectFormField
                              $ ( 
                                . fintool
                                . options
                                .   makeOptionList
                                  $ (   mop
                                      $ ( ( 
                                          =   
                                            .     !arg:(?.?Title.?ToolID)
                                                & (!Title.!ToolID)
                                              | 
                                          )
                                        . !S
                                        . (=+)
                                        )
                                    . 
                                    )
                                )
                          )
                    )
            )
          & ( sourcesAndGoals
            =     f name short Ofields activeTools
                , servicedGoalsTable cmptblWrkflws
                , servicedSourcesTable
                , description itms Types linkedWorkflows
                , table presel L retrieveServicedOutputFeaturesAndTheirValues
                , preselvalsrows items item spec
                , preselvals presels
                , G sourcePicklists preSelectedOutputSpec
                , B C D E R hide n nt p prod x
                , mentionBookmarkedWorkflows linksAndLinked
                , features links addOutputWishesFrom3rdParty
              .   ( cmptblWrkflws
                  =   itemGroups presels Ofields
                    .   !arg:(?itemGroups.?presels.?Ofields)
                      &   log
                        $ ( cmptblWrkflws
                            itemGroups
                            !itemGroups
                            presels
                            !presels
                            Ofields
                            !Ofields
                          )
                      & (!wrkflws|readTable$wrkflws)
                      &   map
                        $ ( ( 
                            =   n itm knownInputFeatures fitm
                              .   !arg:(?n.?itm:%?fitm ?)
                                & ( !n
                                  . !itm
                                  .       map
                                        $ ( ( 
                                            =   f v
                                              .     !arg:(?f.?v.!fitm)
                                                  & (!f.!v)
                                                | 
                                            )
                                          . !presels
                                          )
                                      : ?knownInputFeatures
                                    &   map
                                      $ ( ( 
                                          =   name i o wf
                                            .     !arg
                                                : (?name.(?i.?o).?wf)
                                              & (       map
                                                      $ ( ( 
                                                          =   a b
                                                            .       !arg
                                                                  : (?a.?b)
                                                                &   !i
                                                                  : (   ?
                                                                        (!a,!b)
                                                                        ?
                                                                    | ~( ?
                                                                         (!a,?)
                                                                         ?
                                                                       )
                                                                    )
                                                                & !arg
                                                              | 
                                                          )
                                                        . !knownInputFeatures
                                                        )
                                                    : !knownInputFeatures
                                                  &     map
                                                      $ ( ( 
                                                          =   a b
                                                            .       !arg
                                                                  : (?a.?b)
                                                                & ( !b:
                                                                  |   !o
                                                                    : (   ?
                                                                          (!a,!b)
                                                                          ?
                                                                      | ~( ?
                                                                           (!a,?)
                                                                           ?
                                                                         )
                                                                      )
                                                                  )
                                                                & !arg
                                                              | 
                                                          )
                                                        . !Ofields
                                                        )
                                                    : !Ofields
                                                  & !name
                                                | 
                                                )
                                          )
                                        . !wrkflws
                                        )
                                  )
                            )
                          . !itemGroups
                          )
                  )
                & ( linksAndLinked
                  =   stable exr L itmgrp id Ofields
                    .   !arg:(?stable.?exr.?Ofields)
                      & !exr:?itmgrp
                      & (!itmgrp:";" ?itmgrp|)
                      & (   !stable:%? [?L
                          & (   "item_group_" !itmgrp:?id
                              &   ( a
                                  .     (href.str$("#" !id))
                                        (tabindex.0)
                                        ( title
                                        .   str
                                          $ ( localized
                                            $ ( "You can ignore all form fields below if you choose a bookmarked workflow."
                                                "Du kan ignorere alle formularfelter hernede hvis du v√¶lger en markeret workflow."
                                              )
                                            )
                                        )
                                    , ( p
                                      .   (style."text-align: center; font-size: large;")
                                        ,   str
                                          $ ( !L
                                              " "
                                              (   !L:1
                                                & localized$(bookmarked markeret)
                                              | localized$(bookmarked markerede)
                                              )
                                              " "
                                              localized$(workflow arbejdsgang)
                                              ( !L:1&
                                              | localized$(s e)
                                              )
                                            )
                                      )
                                  )
                                  ( p
                                  .   (style."text-align: center;")
                                    ,     localized
                                        $ ("for this type of input" "til denne type input")
                                        (   !Ofields:? (?.~) ?
                                          & localized$(" and output" " og output")
                                        | 
                                        )
                                  )
                            .   ( p
                                .   (id.str$!id)
                                  ,   !itmgrp:&
                                    |   str
                                      $ (   localized
                                          $ ( "Workflows compatible with input in column"
                                              "Arbejdsgange der passer til input i kolonne"
                                            )
                                          " "
                                          !itmgrp
                                        )
                                )
                                  map
                                $ ( ( 
                                    =   low full idval o
                                      .   !arg:(?low.?full.?idval)
                                        &   \r\n
                                            ( input
                                            .     (type.submit)
                                                  (name.str$(bview- !full))
                                                  (value.üëÅ)
                                              , 
                                            )
                                            \r\n
                                            ( input
                                            .     (type.submit)
                                                  (name.str$(bsubmit- !full))
                                                  (value.‚ñ∫)
                                              , 
                                            )
                                            \r\n
                                            !full
                                            ( div
                                            .     (class.tooltip)
                                                  (tabindex.0)
                                                  ( title
                                                  .     !wrkflws
                                                      :   ?
                                                          (!full.(?.?o).?)
                                                          ?
                                                    & str$(inoutdesc$(!o.", "))
                                                  )
                                              , ‚à¥
                                            )
                                            (br.,)
                                            (br.,)
                                    )
                                  . !stable
                                  )
                            )
                        | (.)
                        )
                  )
                & ( mentionBookmarkedWorkflows
                  =   items Ofields preSelectedOutputSpec
                    .   !arg:(?items.?Ofields.?preSelectedOutputSpec)
                      & (   ( !preSelectedOutputSpec:
                            | !items:? (?.?.~) ?
                            )
                          & "Show row mentioning bookmarked workflows if the request does not come from 3rd party or if there are any bookmarked workflows to be mentioned.
                               (This is to diminish the mental load on Switchboard users. Don't confront them with too many buttons.)"
                          & ( tr
                            .   (class.specialrow)
                              ,     cell
                                  $ ( submit2
                                    $ ( eye
                                      .   localized$!updateAvailableWorkflows
                                            localized
                                          $ ( "If you have redacted the input fields, use this button to search for relevant bookmarked workflows."
                                              "Hvis du har √¶ndret noget i inputfelterne, brug knappen for at s√∏ge efter passende markerede arbejdsgange."
                                            )
                                      )
                                    )
                                    map
                                  $ ( ( 
                                      =     nt wrkfls exr stable
                                          , links linked
                                        .   !arg:(?nt.?arg.?wrkfls)
                                          & (   !items:% %
                                              & (exr=";" !nt)
                                            | :?exr
                                            )
                                          &   cell
                                            $ (   !wrkfls:
                                                & ( span
                                                  .   (class.smallfont)
                                                    ,       !Ofields
                                                          : ? (?.~) ?
                                                        &     localized
                                                            $ ( "(No workflows have already been defined for this"
                                                                "(Der ikke endnu nogen arbejdsgange der passer til "
                                                              )
                                                            (br.,)
                                                              localized
                                                            $ ( "combination of input and output specs. Specify "
                                                                "denne kombination af input- og outputspecificationer. "
                                                              )
                                                            (br.,)
                                                              localized
                                                            $ ( "your goal the best you can and press the button"
                                                                "Specificer dit m√•l s√• godt du kan og tryk knappen "
                                                              )
                                                            (br.,)
                                                              localized
                                                            $ ( "near the bottom of this page.)"
                                                                "nederst p√• siden.)"
                                                              )
                                                      |     localized
                                                          $ ( "(Be the first to bookmark a workflow for this kind of"
                                                              "(Bliv den f√∏rste til at markere en arbejdsgang til den her"
                                                            )
                                                          (br.,)
                                                            localized
                                                          $ ( "input. But for now, "
                                                              "slags input. Men for nu: "
                                                            )
                                                          ( strong
                                                          .   
                                                            ,   localized
                                                              $ ( "specify your goal"
                                                                  "specificer dit m√•l"
                                                                )
                                                          )
                                                            localized
                                                          $ ( " and press the"
                                                              " og tryk knappen"
                                                            )
                                                          (br.,)
                                                            localized
                                                          $ ( "button near the bottom of this page.)"
                                                              "nederst p√• siden.)"
                                                            )
                                                  )
                                              |     listToThreeColumnTable$!wrkfls
                                                  : ?stable
                                                & (       linksAndLinked
                                                        $ (!stable.!exr.!Ofields)
                                                      : (?links.?linked)
                                                    &   !linkedWorkflows (!nt.!linked)
                                                      : ?linkedWorkflows
                                                    & !links
                                                  | ( select
                                                    .     ( tabindex
                                                          .     1+!tabind
                                                              : ?tabind
                                                            & 0
                                                          )
                                                          (name.str$(workflow !exr))
                                                      ,   makeOptionListSimple
                                                        $ (!stable.bookmarked-)
                                                    )
                                                  )
                                              )
                                      )
                                    . !items
                                    )
                            )
                        | 
                        )
                  )
                & ( addOutputWishesFrom3rdParty
                  =   R Ofields
                    .   !arg:(?Ofields.? (!LaNg.?R) ?)
                      &   map
                        $ ( ( 
                            =     f v v1 v2 v4 v5
                                , v6 v7 v8 v9 v10 v11
                                , v7a v6-8 v6a v7m v7z
                              .     !arg:(?f.?v)
                                  & str$!v:?v
                                  &   !R
                                    :   ?v1
                                        ( tr
                                        .   
                                          ,   (td.,?v2)
                                              ( td
                                              .   
                                                ,   ?v4
                                                    ( select
                                                    .       ?
                                                            ( name
                                                            . @(?:O !f)
                                                            )
                                                            ?
                                                        : ?v5
                                                      ,       ?v6
                                                              ( option
                                                              .       ?
                                                                      (value.!v)
                                                                      ?
                                                                  : ?v7a
                                                                , ?v7
                                                              )
                                                              ?v8
                                                          &     !v6
                                                                ( option
                                                                .     !v7a
                                                                      ( selected
                                                                      . selected
                                                                      )
                                                                  , !v7
                                                                )
                                                                !v8
                                                            : ?v6-8
                                                        |     ?v6
                                                              ( optgroup
                                                              .   ?v6a
                                                                ,   ?v7a
                                                                    ( option
                                                                    .       ?
                                                                            ( value
                                                                            . !v
                                                                            )
                                                                            ?
                                                                        : ?v7m
                                                                      , ?v7
                                                                    )
                                                                    ?v7z
                                                              )
                                                              ?v8
                                                          &     !v6
                                                                ( optgroup
                                                                .   !v6a
                                                                  ,   !v7a
                                                                      ( option
                                                                      .     !v7m
                                                                            ( selected
                                                                            . selected
                                                                            )
                                                                        , !v7
                                                                      )
                                                                      !v7z
                                                                )
                                                                !v8
                                                            : ?v6-8
                                                    )
                                                    ?v9
                                              )
                                              ?v10
                                        )
                                        ?v11
                                  &     !v1
                                        ( tr
                                        .   
                                          ,   (td.,!v2)
                                              ( td
                                              .   
                                                ,   !v4
                                                    (select.!v5,!v6-8)
                                                    !v9
                                              )
                                              !v10
                                        )
                                        !v11
                                    : ?R
                                | log$(str$("Cannot find " !arg " in output fields"))
                            )
                          . !Ofields
                          )
                      & !R
                  )
                & ( retrieveServicedOutputFeaturesAndTheirValues
                  =   Feats activeTools collector SuperSets
                    .   !arg:?activeTools
                      & 1:?collector
                      &   whl
                        ' ( !activeTools:(?.?Feats)+?activeTools
                          &   map
                            $ ( ( 
                                =   ios o os Os a e m name z
                                  .   !arg:(?name,?ios)
                                    & 0:?Os
                                    &   whl
                                      ' ( !ios:(?.?os)+?ios
                                        &   whl
                                          ' ( !os:%?o+?os
                                            &   whl
                                              ' ( !o:?a*%@?m^%?e*?z
                                                & !a*!m*!z:?o
                                                )
                                            & !Os+!o:?Os
                                            )
                                        )
                                    & !name^!Os*!collector:?collector
                                )
                              . !Feats
                              )
                          )
                      & !collector
                  )
                & !arg:(?presels.?Ofields.?preSelectedOutputSpec)
                & :?linkedWorkflows:?items
                & readTable$features
                & log$featuresRead
                & 1:?prod
                & :?preselvalsrows
                &     mop
                    $ ( ( 
                        =   
                          .     !arg
                              : ? (name.?name) ?
                              : ? (short.?short) ?
                              : ? (description.?description) ?
                              : ? (table.?table) ?
                            & ( !arg:? (hide.?hide) ?
                              | :?hide
                              )
                            & readTable$!table
                            &     map
                                $ ( ( 
                                    =   
                                      .     !arg:(!short.?presel.?item)
                                          & ( !items:? !item ?
                                            | !items !item:?items
                                            )
                                          & !item^!presel*!prod:?prod
                                          & (!presel.!item)
                                        | 
                                    )
                                  . !presels
                                  )
                              : ?preselvals
                            & (!preselvals.!short.!name.!!table.!hide)
                        )
                      . !features
                      . (=+)
                      )
                  : ?preselvalsrows
                & "'preselvalsrows' is a list of all features and their possible values.
                     The first field is filled with pairs of {feature value,item name}, if available.
                     e.g.  (txt.pictureA)
                           (txt.pictureB)
                           (txt.myPlainText)

                     and   (img^png.pictureA)
                           (img^png.pictureB)
                           (flat.myPlainText)
                     Otherwise this field is empty."
                & "'prod' is a product of input item names, each with an exponent that is the sum of features guessed by the system.
                     E.g.
                          myPlainText^(flat+nrm+txt+una)
                        * pictureA^(rom+txt+una+img^png)
                        * pictureB^(rom+txt+una+img^png)
                    "
                &   whl
                  ' ( !prod:?A*%?B^%?x*?C*%?D^!x*?E
                    & !A*(!B !D)^!x*!C*!E:?prod
                    )
                & "'prod' now lists item names together if they have the same feature values.
                     E.g.
                          myPlainText^(flat+nrm+txt+una)
                        * (pictureA pictureB)^(rom+txt+una+img^png)
                    "
                & :?items
                & !prod:?p
                & 0:?R
                &   whl
                  ' ( !p:(? [?n:%?itms)^%?*?p
                    & (!n.!itms)+!R:?R
                    )
                & "R is a sum of lists of item names. The most numerous group last."
                & :?items
                &   whl
                  ' ( !R:(?.?itms)+?R
                    & (.!itms) !items:?items
                    )
                & "items is a list of lists of item names, most numerous list first. E.g.
                     (.pictureA pictureB) (.myPlainText)
                    "
                & 0:?nt
                &     map
                    $ ( ( 
                        =   
                          .     !arg:(.?arg)
                              & (!nt+1:?nt.!arg)
                            | 
                        )
                      . !items
                      )
                  : ?items
                & "'items' now has ordinal numbers."
                &     map
                    $ ( ( 
                        =   seen a b c d e
                          .   !arg:(?a.?b.?c.?d.?e)
                            & 0:?seen
                            & (   map
                                $ ( ( 
                                    =   presel item comb
                                      .     !arg:(?presel.?item)
                                          &   !prod
                                            : ?*(? !item ?:?comb)^?*?
                                          & (   !seen:?+!comb+?
                                              & 
                                            |   !comb+!seen:?seen
                                              & (!presel.!comb)
                                            )
                                        | !arg
                                    )
                                  . !a
                                  )
                              . !b
                              . !c
                              . !d
                              . !e
                              )
                        )
                      . !preselvalsrows
                      )
                  : ?preselvalsrows
                & "The first field in 'preselvalsrows' now groups items that are similar in all features.
                     e.g.  (txt.pictureA pictureB)
                                     (txt.myPlainText)

                     and   (img^png.pictureA pictureB)
                                     (flat.myPlainText)
                     Otherwise this field is empty."
                & "Notice: this function does not have local variable 'abbr' !"
                & log$CreateSourcePicklists
                & readTable$toolprop
                & readTable$tooladm
                & readTable$features
                &     map
                    $ ( ( 
                        =   exr help
                          .     !arg:(?preselvals.?short.?name.?table.)
                              & (   !servicedSources
                                  : ? (!short.?servicedSourcesTable) ?
                                |   log$CreateGlobalServicedSources
                                  &     selectServicedValues
                                      $ ( !short
                                        . !table
                                        . ( 
                                          =   
                                            ' ( ?
                                              + (     ?
                                                    +   ?
                                                      * ( $abbr^?
                                                        | (?*$abbr^?*?.OnE)
                                                        )
                                                      * ?
                                                    + ?
                                                    ?
                                                . ?
                                                )
                                              + ?
                                              )
                                          )
                                        )
                                    : ?servicedSourcesTable
                                  &   (!short.!servicedSourcesTable) !servicedSources
                                    : ?servicedSources
                                )
                              & (   !items:% %
                                  & (exr=";" !nt)
                                | :?exr
                                )
                              & (     !features
                                    :   ?
                                      + ( ? (short.!short) ?
                                        : ? (sourcehelp.?help) ?
                                        )
                                      + ?
                                  & (desc.localized$!help):?help
                                | :?help
                                )
                              &   row
                                $ ( namecell$(!features.!short.localized$!name)
                                    featurehelpcell$(!features.!short.sourcehelp)
                                      map
                                    $ ( ( 
                                        =   
                                          .   !arg:(?nt.?arg)
                                            &   cell
                                              $ (     !preselvals
                                                    :   ?
                                                        (%?presel^?spec.!arg)
                                                        ?
                                                  & (   !spec:1
                                                      & "List all values, without subspecifications."
                                                      &   makeSelectFormField
                                                        $ ( 
                                                          . str$(I !short !exr)
                                                          .   !help
                                                              ( options
                                                              .   makeOptionList
                                                                $ ( !servicedSourcesTable
                                                                  . !presel
                                                                  )
                                                              )
                                                          )
                                                    |   "List all subspecifications, no possibility to choose other feature value."
                                                      &   !features
                                                        :   ?
                                                          + (   ?
                                                                (short.!short)
                                                                ?
                                                            :   ?
                                                                ( specificationTable
                                                                .   ?
                                                                    (   ?
                                                                        ( %@
                                                                        : !presel
                                                                        )
                                                                        ?
                                                                    . ?Types
                                                                    )
                                                                    ?
                                                                )
                                                                ?
                                                            )
                                                          + ?
                                                      & readTable$!Types
                                                      &   makeSelectFormField
                                                        $ ( 
                                                          . str$(I !short !exr)
                                                          .   !help
                                                              ( options
                                                              .   makeOptionList
                                                                $ ( !!Types
                                                                  . !spec
                                                                  .   str
                                                                    $ (!presel "^")
                                                                  )
                                                              )
                                                          )
                                                    )
                                                |   makeSelectFormField
                                                  $ ( 
                                                    . str$(I !short !exr)
                                                    .   !help
                                                        ( options
                                                        .   makeOptionList
                                                          $ (!servicedSourcesTable.)
                                                        )
                                                    )
                                                )
                                        )
                                      . !items
                                      )
                                  )
                            | 
                        )
                      . !preselvalsrows
                      )
                  : ?sourcePicklists
                & log$SourcePicklistsCreated
                & getActiveTools$:?activeTools
                & (   !servicedSuperGoals:
                    &   makeSuperGoals$(retrieveServicedOutputFeaturesAndTheirValues$!activeTools)
                      : (?servicedSuperGoals.?)
                  | 
                  )
                & readTable$features
                & (   !goalPicklists:
                    & !LaNg:?G
                    &     map
                        $ ( ( 
                            =   expandedSelectLists
                              .   setLang$!arg
                                &   makeExpandedSelectLists$!servicedSuperGoals
                                  : ?expandedSelectLists
                                & ( !arg
                                  .   createGoalPickLists
                                    $ (!preselvalsrows.!expandedSelectLists.including)
                                  )
                            )
                          . !lANgs
                          )
                      : ?goalPicklists
                    & setLang$!G
                  | 
                  )
                & cmptblWrkflws$(!items.!presels.!Ofields):?items
                & log$(HIDDENDATA !hiddenData)
                &     map
                    $ ( ( 
                        =   
                          .     !arg
                              : ~(   reqtool
                                   | fintool
                                   | SuperSet-facet
                                 . ?
                                 )
                            | 
                        )
                      . !hiddenData
                      )
                  : ?hiddenData
                & ( !items
                  .     fieldset
                      $ ( ( div
                          .   (class.overflowing)
                            ,   ( div
                                .     (class.leftfloating)
                                      (style."width: 70%; height: auto;")
                                  ,   ( strong
                                      .   
                                        ,   localized
                                          $ ("This is your input" "Det her er dit input")
                                      )
                                      (" ‚∏∫ "|(br.,))
                                      (   !items:% %
                                        &   localized
                                          $ ( "Correct only if you see something wrong. Not every field needs to be filled out. Choose one of the columns of inputs."
                                              "Korriger kun hvis du ser noget forkert. Nogle felter m√• godt v√¶re blanke. V√¶lg en af kolonnerne."
                                            )
                                      |   localized
                                        $ ( "Correct only if you see something wrong. Not every field needs to be filled out."
                                            "Korriger kun hvis du ser noget forkert. Nogle felter m√• godt v√¶re blanke."
                                          )
                                      )
                                )
                                ( div
                                .     (class.rightfloating)
                                      (style."width: 30%; height: auto;")
                                  , (p.,fixedMenuItems$(specifyGoal.!orgarg))
                                )
                          )
                        .   Table
                          $ ( id,inputs
                            .   row
                              $ ( cell$()
                                    map
                                  $ ( ( 
                                      =   nt wrkfls
                                        .   !arg:(?nt.?arg.?wrkfls)
                                          &     map
                                              $ ( (=.!arg (br.,))
                                                . !arg
                                                )
                                            : ?arg (br.,)
                                          & cell$!arg
                                      )
                                    . !items
                                    )
                                )
                            .   (   !items:% %
                                  & 0:?nt
                                  &   row
                                    $ (   cell
                                        $ ( strong
                                          .   
                                            ,   localized
                                              $ ( "Inputs are dissimilar. Select a column."
                                                  "Inputs tilh√∏rer uens kategorier. V√¶lg en kolonne."
                                                )
                                          )
                                          map
                                        $ ( ( 
                                            =   nt wrkfls
                                              .   !arg:(?nt.?arg.?wrkfls)
                                                &   cell
                                                  $ ( input
                                                    .     (type.radio)
                                                          (name.itms)
                                                          (value.!nt)
                                                          (   !nt:1
                                                            & (checked.checked)
                                                          | 
                                                          )
                                                      , 
                                                    )
                                            )
                                          . !items
                                          )
                                      )
                                | 
                                )
                                !sourcePicklists
                                  mentionBookmarkedWorkflows
                                $ (!items.!Ofields.!preSelectedOutputSpec)
                            )
                        )
                        fieldset
                      $ (   ( span
                            .   (style."font-size: large")
                              ,   (span.(style."font-size: x-large"),"‚òû ")
                                  (strong.,localized$("Your goal" "Dit m√•l"))
                            )
                            (" ‚∏∫ "|(br.,))
                              localized
                            $ ( "Fill out the fields that sketch out the desired result and leave the other fields "
                                "Udfyld de felter som skitserer det √∏nskede resultat og lad de √∏vrige felter v√¶re "
                              )
                            (strong.,localized$(blank blanke))
                              localized
                            $ ( ". In the next steps, Text Tonsorium will help you specify the smaller details and zoom in on a suitable workflow."
                                ". I de n√¶ste trin hj√¶lper Text Tonsorium dig med at pr√¶cisere dit m√•l og med at v√¶lge en egnet arbejdsgang."
                              )
                        .   Table
                          $ ( id,goal
                            . row$(cell$() cell$() cell$)
                            .   addOutputWishesFrom3rdParty$(!Ofields.!goalPicklists)
                                ( tr
                                .   
                                  ,   ( td
                                      .   
                                        , ( strong
                                          .   
                                            ,     localized
                                                $ ( "For experienced users "
                                                    "For erfarne brugere "
                                                  )
                                                ‚Ü≥
                                          )
                                      )
                                      ( td
                                      .   
                                        ,   localized
                                          $ ( "The two fields below are optional! Use them if you have a preference for one or two specific tools."
                                              "De to rubrikker hernede er optionelle! Brug dem kun hvis du har en preference for en eller to bestemte v√¶rkt√∏jer."
                                            )
                                      )
                                )
                                desiredTools$
                            )
                        )
                  . !linkedWorkflows
                  )
            )
          & ( "We are at the start. Show an input form."
            =     formFields presels nt CLOCK sourceAndGoal
                , itemGroupsExt linkedWorkflows
                , hiddenData Items A Z Ofields preSelectedOutputSpec
              .   !arg:(?presels.?hiddenData.?Items.?preSelectedOutputSpec)
                & log$"We are at the start. Show an input form."
                & (   !Items:
                    &   str
                      $ ( 200~~~
                            toML
                          $ ( !BodyContainer
                            $ ( paragraph
                              $ ( localized
                                $ ( "No input is specified, or the input is not accessible."
                                    "Inputtet er ikke specificeret, eller inputtet er ikke tilg√¶ngeligt."
                                  )
                                )
                              )
                            )
                        )
                  |       map
                        $ ( ( 
                            =   f v
                              .       !arg
                                    : (~Item:@(?:O ?f).?v)
                                  & (!f.!v)
                                | 
                            )
                          . !hiddenData
                          )
                      : ?Ofields
                    &   sourcesAndGoals$(!presels.!Ofields.!preSelectedOutputSpec)
                      : (?itemGroupsExt.?sourceAndGoal.?linkedWorkflows)
                    & "The next line decides whether hiddendata will contain a single Item parameter or a CLOCK parameter.
                       The pattern (@.@.?) succeeds if there is only one file in itemGroupsExt. In that case, we'll have an Item parameter.
                       If the second part of itemGroupsExt contains two or more file names, the second @ fails. Then we'l have a CLOCK
                       parameter, and no Item parameter."
                    &   (   !itemGroupsExt:(@.@.?)
                          & !Items !hiddenData
                        |   readTable$ItemGroupsCache
                          & (   !ItemGroupsCache
                              : ? (?CLOCK.!itemGroupsExt) ?
                            |       (clk$:?CLOCK.!itemGroupsExt)
                                    !ItemGroupsCache
                                : ?ItemGroupsCache
                              & saveTable$ItemGroupsCache
                            )
                          & (   !hiddenData:?A (CLOCK.?) ?Z
                              & !A (CLOCK.!CLOCK) !Z
                            | (CLOCK.!CLOCK) !hiddenData
                            )
                        )
                      : ?hiddenData
                    &     map
                        $ ( ( 
                            =   
                              .       !arg
                                    : (@(?:(I|O) ~tem).?)
                                  & 
                                | !arg
                            )
                          . !hiddenData
                          )
                      : ?hiddenData
                    & !sourceAndGoal:?formFields
                    &   str
                      $ ( 200~~~
                            toML
                          $ ( !BodyContainer
                            $ ( !formFields:
                              |     form
                                  $ ( showworkflows
                                    .   makeHiddenFields$!hiddenData
                                        !formFields
                                        submit$(localized$!helpmespecifymygoal)
                                        (br.,)
                                        ( small
                                        .   
                                          , ( i
                                            .   
                                              ,   localized
                                                $ ( "You may experience some waiting time and even time-out. In the latter case, try again some minutes later. In general, the computations terminate normally and the results are memoized!"
                                                    "Du kan opleve at du skal vente, eller at siden indikerer time-out. N√•r det sidste sker, kan du pr√∏ve igen efter nogle minutter. Normalt k√∏rer beregningerne bare videre, og resultaterne bliver husket!"
                                                  )
                                            )
                                        )
                                    )
                                  (br.,)
                                  ( !linkedWorkflows:
                                  |   ( h1
                                      .   
                                        ,   localized
                                          $ ("Bookmarked workflows" "Markerede arbejdsgange")
                                      )
                                      ( p
                                      .   
                                        ,   localized
                                          $ ( "Text Tonsorium can enact a bookmarked workflow or compute and enact a workflow that fulfils your goal as specified above."
                                              "Text Tonsorium kan afvikle en markeret arbejdsgang eller beregne og udf√∏re en arbejdsgang som opfylder dit m√•l som beskrevet ovenover."
                                            )
                                      )
                                      (br.,)
                                      (br.,)
                                        map
                                      $ ( ( 
                                          =   nt linkedWorkflows
                                            .   !arg:(?nt.?linkedWorkflows)
                                              &   form
                                                $ ( chosenworkflow
                                                  .     makeHiddenFields
                                                      $ ( !hiddenData
                                                          (     !hiddenData
                                                              :   ?
                                                                  (itms.?itms)
                                                                  ?
                                                            & 
                                                          | (itms.!nt)
                                                          )
                                                        )
                                                      !linkedWorkflows
                                                  )
                                          )
                                        . !linkedWorkflows
                                        )
                                  )
                              )
                            )
                        )
                  )
            )
          & ( updatePreselsWithUserAmendments
            =   presels inputs Ifields Items,computedInputFeatures
              .   !arg:(?presels.?arg.?Items)
                &     map
                    $ ( ( 
                        =   f v
                          .     !arg:(~Item:@(?:I ?f).?v)
                              & (!f.!v)
                            | 
                        )
                      . !arg
                      )
                  : ?Ifields
                & ( "No input amendments from user."&!Ifields:
                  |   0:?inputs
                    & 0:?computedInputFeatures
                    &   map
                      $ ( ( 
                          =   f v
                            .     !arg:(?f.?v.?arg)
                                & !inputs+!arg:?inputs
                                &   (!f.!v)+!computedInputFeatures
                                  : ?computedInputFeatures
                              | 
                          )
                        . !presels
                        )
                    & (   !inputs:0
                        & !arg:? (Item.?inputs) ?
                        & ( !Items:? (Item.!inputs) ?
                          | (Item.!inputs) !Items:?Items
                          )
                      |     mop
                          $ ( ( 
                              = .!arg:#*%@?arg&!arg
                              )
                            . !inputs
                            . (=+)
                            )
                        : ?inputs
                      )
                    &       map
                          $ ( ( 
                              =   f v A Z
                                .   !arg:(?f.?v)
                                  & (   !computedInputFeatures:?A+#*(!f.?)+?Z
                                      & !A+!Z:?computedInputFeatures
                                    | 
                                    )
                                  & ( !v:
                                    | map$((=.!f.!v.!arg).!inputs)
                                    )
                              )
                            . !Ifields
                            )
                            mop
                          $ ( ( 
                              =   f v
                                .   !arg:(?f.?v)
                                  & ( !v:
                                    | map$((=.!f.!v.!arg).!inputs)
                                    )
                              )
                            . !computedInputFeatures
                            . (=+)
                            )
                      : ?presels
                  )
                & (!presels.!Items)
            )
          & ( convertISO639-3to-1-IfPossible
            =   A lan la
              .   readTable$linguae
                &   map
                  $ ( ( 
                      =   
                        .     !arg:(@(?A:? lang).?lan)
                            & !('($linguae:? (?.?la.$lan) ?))
                            & (!A.!la)
                          | !arg
                      )
                    . !arg
                    )
            )
          & log$NEW
          & log$specifyGoal-CREATELOGJE
          & log$(arg !arg)
          & (     !arg
                : ~(? (action.?) ?)
                : ~(? (fintool.?) ?)
                :   ?
                    (@(?:O ?).?)
                    ?
                    (@(?:O ?).?)
                    ?
                    (@(?:O ?preSelectedOutputSpec).?)
                    ?
              & "Heuristic way of finding out that request comes from 'outside', e.g. Clarin Language Switchboard.
                 In that case, do not show row for previously created workflows if there are no workflows to show.
                 If fewer than 3 output specs are given, the user is regarded as 'advanced' and the bookmark line is shown."
            | :?preSelectedOutputSpec
            )
          & convertISO639-3to-1-IfPossible$!arg:?arg
          & !arg:?orgarg
          &   initialiseSpecifyGoalShowWorkflowsChosenWorkflow$!arg
            : (?errors.?hiddenData.?Items.?Tool.?parms.?BodyContainer)
          & "First build a list of items."
          & (   !Items:
              & buildItemListFromForeignData$!parms:?Items
            | 
            )
          & analyzeInput$(!Items.!errors):(?Items.?presels.?errors)
          & ( !errors:~
            |     getBatchHandleDesiredtoolSuperset$(!parms.!hiddenData)
                : (?parms.?hiddenData.?batch)
              & updatePreselsWithUserAmendments$(!presels.!arg.!Items):(?presels.?Items)
              & readTable$tooladm
              & log$(presels !presels hiddenData !hiddenData Items !Items)
              &   "We are at the start. Show an input form."
                $ (!presels.!hiddenData.!Items.!preSelectedOutputSpec)
            )
      )
      "
/**
 * storeUpload
 *
 * Administrate the storage of a copy of a file from repositorium in a place
 * where a webservice can fetch it - the staging area of the Tools service.
 *
 * Adds an entry to a five-column table Uploads.table.
 * The first column is unique number generated by adding 1 to the highest
 * currently occupied number, second is the resource identifier of a
 * resource that has been copied to a local place, where a webservice can GET
 * it. The third field
 * contains the name of the resource as the webservice perceives it. It is a
 * concatenation of 'Uploaded' and the number in the first field.)
 * E.g.
 *      ( 9
 *      . dkclarin:59004
 *      . 19325730679
 *      .
 *      .
 *      )
 * The resource identifier is going to be used in the new resource's metadata.
 * The missing fifth and sixth fields are later filled out.
 * If the user provides a file by file upload, the second and third column are the same.
 *
 * Input:
 *      item id (like dkclarin:59004/components/component/dkclarin:59003/content)
 *      date
 *      fk (optional)
 *
 * Affected tables:
 *      Uploads.table
 *
 * Output:
 *      The local file name of the resource (= fourth field)
 *
 * Called from compute.java
 */"
      ( storeUpload
      =   nr item fname visibility date enam txe ext
        .   1:?nr
          &   !arg
            : ( ?item
              .   (?date.?visibility)
                | ?date&:?visibility
              )
          & str$(removePercentEncodings$!item):?item
          & (   @(rev$!item:?txe "." ?enam)
              & (   @( !txe
                     :   ?
                         ( "/"
                         | "\\"
                         | ":"
                         | " "
                         | "?"
                         | "*"
                         | "["
                         | "]"
                         | ";"
                         | "|"
                         | "="
                         | ","
                         )
                         ?
                     )
                  & :?ext
                |   rev$!enam:?item
                  & str$("." rev$!txe):?ext
                )
            | :?ext
            )
          & (readTable$Uploads|:?Uploads)
          & (   !Uploads:(?nr.?) ?
              & !nr+1:?nr
            | :?Uploads
            )
          & str$(!item "-" !nr):?fname
          &     str
              $ ( vap
                $ ( ( 
                    =   
                      .       !arg
                            : ( "/"
                              | "\\"
                              | ":"
                              | " "
                              | "?"
                              | "*"
                              | "["
                              | "]"
                              | ";"
                              | "|"
                              | "="
                              | ","
                              | "%"
                              | "&"
                              )
                          & "_"
                        | !arg
                    )
                  . !fname
                  )
                )
            : ?fname
          & str$(!fname !ext):?fname
          &     ( !nr
                .     !item:text
                    & !ext:
                    & !fname
                  | str$(!item !ext)
                . !fname
                . 
                . 
                )
                !Uploads
            : ?Uploads
          & saveTable$Uploads
          & !fname
      )
      "
/**
 * stresstest
 *
 * Do a computation that occupies Bracmat for several seconds.
 * Usage: activate the stresstest from several browsers at
 * about the same time, so they have to queue up and wait for
 * the previous to finish.
 *
 * Purpose: check that the transition from Java's multiple threads
 * to the Bracmat JNI's single thread and back goes smooth.
 *
 * Input: a HTTP-parameter 'stress' with a numerical value > 0.
 *
 * The function computes the first 'stress' terms in the decimal
 * approximation of œÄ.
 *
 * Called from stresstest.java
 */"
      ( stresstest
      =   PI err pi
        .     ( pi
              =   s1,s2,isgn,isgn1,err1,err2,i,j
                .   0:?s1
                  & 1:?isgn
                  & 1:?i
                  &   whl
                    ' ( !i:~>!arg
                      & 2*!i+-1:?j
                      & !s1+!isgn*(!j*5^!j)^-1:?s1
                      & -1*!isgn:?isgn
                      & 1+!i:?i
                      )
                  & 16*((2*!arg+1)*5^(2*!arg+1))^-1:?err1
                  & !isgn:?isgn1
                  & 16*!s1:?s1
                  & 0:?s2
                  & 1:?isgn
                  & 1:?i
                  &   whl
                    ' ( 2*!i+-1:?j
                      & (!j*239^!j)^-1:?err2
                      & 4*!err2:>!err1
                      & !s2+!isgn*!err2:?s2
                      & -1*!isgn:?isgn
                      & 1+!i:?i
                      )
                  & flt$(!isgn1*(!err1+4*!err2),2):?err
                  & !s1+-4*!s2
              )
            & !arg:? (stress.~/#?arg:>0:<1001) ?
            & (readTable$pies|:?pies)
            & pi$!arg:?PI
            & !pies (!arg.!PI !err):?pies
            & saveTable$pies
            &   toML
              $ ( !HTMLbodyContainer
                $ ( paragraph
                  $ ( str
                    $ ( "Your number:"
                        !arg
                        " Your approximation of pi:"
                        flt$(!PI,!arg)
                        " error "
                        !err
                      )
                    )
                  )
                )
          | toML$(!HTMLbodyContainer$(paragraph$(str$("Not understood:" !arg))))
      )
      "
/**
 * toolsdata
 *
 * Return the full file system path to Tool's staging area.
 * The input can be a file name: this name is appended to the returned value.
 *
 * Called from util.java, workflow.java
 */"
      (toolsdata=.str$(!documentRoot (|!stagingArea) !arg))
      "
/**
 * unstore
 *
 * If something went wrong, e.g. an URL that could not be fetched, call unstore.
 *
 * Called from compute.java
 */"
      ( unstore
      =   A Z
        .   readTable$Uploads
          & !Uploads:?A (?.?.!arg..) ?Z
          & !A !Z:?Uploads
          & saveTable$Uploads
      )
      "
/**
 * update
 *
 * Create an HTML form that allows a user to choose a tool from a pick list.
 * The user must also fill out a password.
 *
 * The input can either be an empty string or two fields: a message to be
 * displayed above the form and the name of a tool, which will then be
 * selected when the browser shows the pick list.
 *
 * Called from update.java
 */"
      ( update
      =     L ToolID Title msg selected
          , contactEmail handle
          , passwordAsHandle
        .     0:?tabind
            & readTable$tooladm
            & :?msg:?selected:?contactEmail:?handle
            & (!arg:? (msg.?msg) ?|)
            & (!arg:? (selected.?selected) ?|)
            & ( !arg:? (passwordAsHandle.?passwordAsHandle) ?
              | (.):?passwordAsHandle
              )
            & ( !arg:? (contactEmail.?contactEmail) ?
              | 
              )
            & (!arg:? (handle.?handle) ?|)
            & :?L
            &   !tooladm
              :   ?
                + (   ? (ToolID.?ToolID) ?
                    : ? (Title.?Title) ?
                  & !L (!Title.!ToolID):?L
                  )
                + 0
            &   toML
              $ ( !HTMLbodyContainer
                $ ( (!msg:|paragraph$!msg)
                      form
                    $ ( register
                      .     paragraph
                          $ ( makeSelectFormField
                            $ ( localized$("Choose a tool" "V√¶lg et v√¶rkt√∏j")
                              . name
                              .   (options.makeOptionList$(!L.!selected))
                                  (required."*")
                              )
                            )
                            paragraph
                          $ ( makePasswordFormField
                            $ (   localized
                                $ ( "Password (If you are not owner)"
                                    "Adgangskode (Hvis du ikke er \"ejer\")"
                                  )
                              . password
                              . desc
                              .   localized
                                $ ( "Use this field if you don't own the tool and the owner has given you the password. When you update the tool metadata, you become the new owner of the tool."
                                    "Brug feltet hvis du ikke er ejer af v√¶rkt√∏jet og du har f√•et adgangskoden fra ejeren. N√•r du opdaterer v√¶rkt√∏jsoplysningerne bliver du automatisk den nye ejer af v√¶rkt√∏jet."
                                  )
                              )
                            )
                          submit$next
                          helplink$(usedonly.n)
                            makeHiddenFields
                          $ ( ( !passwordAsHandle:(.)&
                              | (passwordAsHandle.!passwordAsHandle)
                              )
                              ( !contactEmail:
                              | (contactEmail.!contactEmail)
                              )
                              (!handle:|(handle.!handle))
                            )
                      . POST
                      )
                  )
                )
          | 
      )
      "
/**
 * upload
 *
 * Make a waiting job non-waiting upon receipt of a result from an
 * asynchronous tool.
 *
 * Analyze the job parameter. It tells to which job the sent file belongs.
 * The jobs table knows the file name and location for the uploaded file.
 *              (Last field)
 * Input:
 *      List of HTTP request parameters.
 *      One of the parameters must be (job.<jobNr>-<jobID>)
 *
 * Output:
 *      The file name that must be given to the received file when saved in
 *      the staging area.
 *
 * Status codes:
 *      200     ok
 *      400     'job' parameter does not contain hyphen '-' or
 *              'job' parameter missing altogether.
 *      404     Job is not expecting a result (job is not waiting)
 *              Job is unknown
 *      500     Job list could not be read
 *
 * Affected tables:
 *      jobs.table
 *
 * Called from upload.java
 */"
      ( upload
      =   jobNr jobID jobstatus JOB,A B Y Z files toolURL parms file
        .     !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
            & (   readTable$jobs
                & (     !jobs
                      :   ?A
                          ( !jobNr
                          .   ?B
                              (!jobID ?jobstatus.?files.?toolURL.?parms.?file)
                              ?Y
                          )
                          ?Z
                    & (   !jobstatus:(waiting|starting)
                        &     !A
                              ( !jobNr
                              .   !B
                                  (!jobID done.!files.!toolURL.!parms.!file)
                                  !Y
                              )
                              !Z
                          : ?jobs
                        & saveTable$jobs
                        & !file
                      |   str
                        $ ( "HTTP-status-code404upload$("
                            !arg
                            ") failed. Job "
                            !jobNr
                            "-"
                            !jobID
                            " is not expecting a result. Its current status is '"
                            !jobstatus
                            "'."
                          )
                      )
                  |   str
                    $ ( "HTTP-status-code404upload$("
                        !arg
                        ") failed. Job "
                        !jobNr
                        "-"
                        !jobID
                        " not found in joblist."
                      )
                  )
              | str$("HTTP-status-code500upload$(" !arg ") failed. Joblist could not be read")
              )
          |   str
            $ ( "HTTP-status-code400upload$("
                !arg
                ") failed. "
                (   !arg:? (job.?JOB) ?
                  & ( @(!JOB:% "-" %)
                    | "'job' parameter value must contain a hyphen '-'. "
                    )
                | "'job' parameter missing. "
                )
              )
      )
      "
/**
 * uploadJobID
 *
 * Analyze the job parameter. It tells to which job the sent file belongs.
 *
 * Called from upload.java
 */"
      ( uploadJobID
      =   jobID jobNr
        .   !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
          & !jobID
      )
      "
/**
 * uploadJobNr
 *
 * Return the string preceding the hyphen in the input.
 *
 * Input: <jobNr>-<jobID>
 *
 * Called from upload.java
 */"
      ( uploadJobNr
      =   jobID jobNr
        .   "analyze the job parameter. It tells to which job the sent file belongs."
          & !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
          & !jobNr
      )
      "
/**
 * waitingJob
 *
 * Make a job 'waiting'.
 *
 * Input: JobNr and jobID
 *
 * Affected tables:
 *     jobs.table
 *
 * Called from workflow.java
 */"
      ( waitingJob
      =   A B Y Z JobNr jobID ZZ jobstatus
        .     readTable$jobs
            & log$("waitingJob " !arg)
            & !arg:(@(?:? #?JobNr).?jobID)
            &   whl
              ' (   !jobs
                  :   ?A
                      (!JobNr.?B (!jobID ?jobstatus.?ZZ) ?Y)
                      ?Z
                & !jobstatus:(|starting)
                &   !A (!JobNr.!B (!jobID waiting.!ZZ) !Y) !Z
                  : ?jobs
                )
            & saveTable$jobs
            & 
          | "Expecting (? #JobNr.jobID)"
      )
  : ?Globals
& (setLang$da|);

r=
  get'"toolsProg.bra"
& rmv$"toolsProg.bak"
& ren$("toolsProg.bra"."toolsProg.bak")
&   put
  $ ( "{toolsProg.bra


    Copyright 2014, Bart Jongejan
    This file is part of the DK-ClarinTools.

    DK-ClarinTools is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    DK-ClarinTools is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with DK-ClarinTools.  If not, see <http://www.gnu.org/licenses/>.





Source code for DK-Clarin tools webservice

To neatly re-format this source code, load the file in a running instance of
Bracmat:

    get$\"toolsprog.bra\"

Now, after you have made changes to the source code in a text editor, reload
the source code in Bracmat using the command:

    !r

This command re-reads the file, renames the previous version from toolsprog.bra
to toolsprog.bak and then saves the source code. Some editors will notice that
the text has changed on disk and offer you to reload the source code.

To change the comment near the start of this file, you need to go to the bottom
of the file and find the text there. A change made to that text takes effect
after saving once and pressing !r two times. Remember to escape quotes \" with
a backslash \\. Comments elsewhere (i.e. text enclosed by braces { and } is NOT
saved. Use string expressions if you want a comment somewhere.

The following commands can be issued by sending an 'expression' HTTP parameter
to the 'bracmatevaluator' servlet.

To get started from a file containing all tables called 'alltablesxxx' (replace
xxx with actual characters in the file name), e.g., alltables.GPL:

importTables$\"alltables.GPL\"

This reads the named file and stores each table in a separate file in a folder
structure
work/
    job/
    meta/
        feature/
        style/

(This folder structure must already exist.) Finally, the same file is
rewritten, so all lay-out is normalized (Bracmat style).
This command reads all single file tables from the folder structure and saves
them to 'alltablesxxx'. The command knows the actual name of the file to write
to because that name is stored in the variable AAA, which is itself stored
alongside all tables, and is therefore known after the last time
importTables$alltablesxxx was called. It is possible to change context by
reading an 'alltablesyyy' that is different from 'alltablesxxx'.

If <prod> is the empty string \"\", then the table tooladm is anonymized by
changing all domains in service URLs \"http:\\localhost\" and by changing all
contact emails to \"x@x.xxx\".

To export all tables to a different file, do

exportTables$(<prod>.\"alltableszzz\")

where alltableszzz must be a valid file name that starts with 'alltables'.



To do a clean up, removing almost all that is not defined in this file from
Bracmat's memory, call the clean function

    clean$

Changes made to table files take immediately effect. It is advised to use the
admin page to register new tools. Some changes cannot be made using the admin
page, such as adding a new feature or feature value.

Server:
Add following line to /etc/httpd/conf.d/proxy_ajp.conf:
    ProxyPass /toolsdata !
(Restart Apache sudo /etc/init.d/httpd restart)

Make sure bracmat is in JBoss's or Tomcat PATH:
    /usr/lib/libbracmat.so -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1 -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1.0

The conf/properties.xml file has an entry \"toolsHome\". The value of this entry
is the location of this file, toolsprog.bra.
}

"
    , "toolsProg.bra"
    , NEW BIN
    )
& lst'(toolsProg,"toolsProg.bra",APP BIN WYD)
& put'(\n,"toolsProg.bra",APP BIN)
& lst'(r,"toolsProg.bra",APP BIN WYD);
