{toolsProg.bra


    Copyright 2014, Bart Jongejan
    This file is part of the DK-ClarinTools.

    DK-ClarinTools is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    DK-ClarinTools is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with DK-ClarinTools.  If not, see <http://www.gnu.org/licenses/>.





Source code for DK-Clarin tools webservice 

To neatly re-format this source code, load the file in a running instance of
Bracmat:

    get$"toolsprog.bra"
    
Now, after you have made changes to the source code in a text editor, reload
the source code in Bracmat using the command:

    !r

This command re-reads the file, renames the previous version from toolsprog.bra
to toolsprog.bak and then saves the source code. Some editors will notice that
the text has changed on disk and offer you to reload the source code.

To change the comment near the start of this file, you need to go to the bottom
of the file and find the text there. A change made to that text takes effect
after saving once and pressing !r two times. Remember to escape quotes " with
a backslash \. Comments elsewhere (i.e. text enclosed by braces { and } is NOT
saved. Use string expressions if you want a comment somewhere.

The following commands can be issued by sending an 'expression' HTTP parameter
to the 'bracmatevaluator' servlet.

To get started from a file containing all tables called 'alltablesxxx' (replace
xxx with actual characters in the file name), e.g., alltables.GPL:

importTables$"alltables.GPL"

This reads the named file and stores each table in a separate file in a folder
structure
work/
    job/
    meta/
        feature/
        style/

(This folder structure must already exist.) Finally, the same file is
rewritten, so all lay-out is normalized (Bracmat style).
This command reads all single file tables from the folder structure and saves
them to 'alltablesxxx'. The command knows the actual name of the file to write
to because that name is stored in the variable AAA, which is itself stored
alongside all tables, and is therefore known after the last time 
importTables$alltablesxxx was called. It is possible to change context by
reading an 'alltablesyyy' that is different from 'alltablesxxx'.

If <prod> is the empty string "", then the table tooladm is anonymized by 
changing all domains in service URLs "http:\localhost" and by changing all
contact emails to "x@x.xxx".

To export all tables to a different file, do

exportTables$(<prod>."alltableszzz")

where alltableszzz must be a valid file name that starts with 'alltables'.



To do a clean up, removing almost all that is not defined in this file from 
Bracmat's memory, call the clean function

    clean$
    
Changes made to table files take immediately effect. It is advised to use the
admin page to register new tools. Some changes cannot be made using the admin
page, such as adding a new feature or feature value.
    
Server:
Add following line to /etc/httpd/conf.d/proxy_ajp.conf:
    ProxyPass /toolsdata !
(Restart Apache sudo /etc/init.d/httpd restart)
    
Make sure bracmat is in JBoss's or Tomcat PATH:
    /usr/lib/libbracmat.so -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1 -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1.0

The conf/properties.xml file has an entry "toolsHome". The value of this entry
is the location of this file, toolsprog.bra.
}

toolsProg=
      " Replaced:

        pmls-------  lem*mrf*pos*stx
        spo--------  cls*pos*seg
        stp--------  pos*seg*tok
        stpd-------  pos*seg*stx*tok
        stlp-------  lem*pos*seg*tok
        stopl------  cls*lem*pos*seg*tok
        stpld------  lem*pos*seg*stx*tok
        stpmld-----  lem*mrf*pos*seg*stx*tok
        stpmldn----  lem*mrf*ner*pos*seg*stx*tok
        tlp--------  lem*pos*tok
        tlpm-------  lem*mrf*pos*tok
        tlpmn------  lem*mrf*ner*pos*tok
        stl--------  lem*seg*tok
        sl---------  lem*seg
        tl---------  lem*tok
        stn--------  ner*seg*tok
        seto-------  seg*tok
            
        Still used with some formats:
        tp
        tlp
        seto"
      (indent=0)
      (logno=0)
      (tabind=0)
      (memoizedTrees=)
      (globval=)
      (runningThreads=0)
      (maxRunningThreads=0)
      ( headerTitle
      = "Text Tonsorium - Natural Language Processing workflows automatically composed, scheduled and enacted"
      )
      (hiddenData=)
      ( "Set from boot"
        (toolshome=)
        (documentRoot=)
        (wwwServer=)
        (deleteAfterMillisec=)
        86400000
        (stagingArea=)
        (baseUrlTools=)
        (path=)
      )
      (servicedSources=)
      (servicedGoals=)
      (goalPicklists=)
      (servicedSuperGoals=)
      ( helpmespecifymygoal
      =   "No wait! ... I want to specify my goal in more detail."
          "Nej vent! ... Jeg vil specificere outputtet yderligere."
      )
      ("next step"="Show available workflows." "Vis mulige arbejdsgange.")
      (StartClk=)
      (startclock=.-1*clk$:?StartClk)
      ( clock
      =   
        .   ( !StartClk:&startclock$
            | 
            )
          & str$("[" jsn$(clk$+!StartClk) "]")
      )
      (path=.str$(!toolshome !arg))
      ( log
      =   c spc i logfile
        .   path$"log.txt":?logfile
          & (   !arg:NEW
              & put$(,!logfile,NEW)
              & startclock$
              & 0:?logno
            |   (!logno|0:?logno)
              &     ( :?spc
                    & 1+!logno:?logno
                    & !indent:?i
                    &   whl
                      ' ( !i+-1:>0:?i
                        & " " !spc:?spc
                        )
                    & str$("[" !indent "] " !logno !spc)
                    )
                    !arg
                : ?arg
              & put$(clock$,!logfile,APP)
              &   whl
                ' ( !arg:%?c ?arg
                  & put$(!c " ",!logfile,APP)
                  )
              & put$(\n,!logfile,APP)
            )
      )
      ( readTable
      =   folder
        .     !arg:%@
            & (   !arg:(AAA|where)
                & (get$(path$!arg):?!arg|`~)
              |   ( !where:(?.?) ?
                  | readTable$where
                  )
                & !where:? (? !arg ?.?folder) ?
                & get$(path$(!folder !arg)):?!arg
              )
          | log$("Cannot read " !arg)&~
      )
      ( saveTable
      =   tab saved folder
        .     !arg:
            & :?saved
            & (   !where
                :   ?
                    ( ?Tables
                    .   ?folder
                      &   whl
                        ' ( !Tables
                          :   ( %?tab
                              & saveTable$(!folder.!tab)
                              & !saved !tab:?saved
                              )
                              ?Tables
                          )
                      & ~
                    )
                    ?
              | Saved !saved
              )
          |   !arg:(?folder.?tab)
            & lst$(!tab,path$(!folder !tab),NEW,RAW)
          |     whl
              ' ( !arg:%?tab ?arg
                & (   !where:? (? !tab ?.?folder) ?
                    & lst$(!tab,path$(!folder !tab),NEW,RAW)
                  | 
                  )
                )
            & 
      )
      ( saveTable
      =   tab saved folder
        .     !arg:
            & :?saved
            & (   !where
                :   ?
                    ( ?Tables
                    .   ?folder
                      &   whl
                        ' ( !Tables
                          :   ( %?tab
                              & saveTable$(!folder.!tab)
                              & !saved !tab:?saved
                              )
                              ?Tables
                          )
                      & ~
                    )
                    ?
              | Saved !saved
              )
          |   !arg:(?folder.?tab)
            & lst$(!tab,path$(!folder !tab),NEW,RAW)
          |     whl
              ' ( !arg:%?tab ?arg
                & (   !where:? (? !tab ?.?folder) ?
                    & lst$(!tab,path$(!folder !tab),NEW,RAW)
                  | 
                  )
                )
            & 
      )
      ( localized
      =   
        .   ( !lANgs:% !LaNg&!arg:% %?arg
            | !arg:%?arg ?
            )
          & !arg
      )
      ( dezilacol
      =   A B G R
        .   !lANgs:?G:%?A ?B
          & !B !A:?lANgs
          & localized$!arg:?R
          & !G:?lANgs
          & !R
      )
      ( UILangNames
      =   G R
        .   readTable$linguae
          & !LaNg:?G
          &     map
              $ ( ( 
                  =   L
                    .     setLang$!arg
                        & !linguae:? (?L.!arg.?) ?
                        & localized$!L
                      | 
                  )
                . !arg
                )
            : ?R
          & setLang$!G
          & !R
      )
      "Reusable patterns in errorInMetadata function"
      ( ISO639
      = [%( readTable$linguae
          & !( 
             ' ( $linguae
               : ( ? (?.$sjt.?) ?
                 | ? (? ()$sjt ?.?.?) ?
                 )
               )
             )
          )
      )
      ( DATE
      =   (   #%@?y1 #%@?y2 #%@?y3 #%@?y4 "-" #%@?m1 #%@?m2 "-" #%@?d1 #%@?d2
            & 10*!m1+!m2:~<1:~>12
            & 10*!d1+!d2:~<1:~>31
          | #%@?y1 #%@?y2 #%@?y3 #%@?y4
          )
        & 1000*!y1+100*!y2+10*!y3+!y4:<2100
      )
      ( MEDIATYPE
      =   ( application
          | audio
          | example
          | image
          | message
          | model
          | multipart
          | text
          | video
          | chemical
          )
          "/"
            ( 
            =   sub parms suf name
              .   @(!sjt:(?sub ";" ?parms|?sub))
                & whl'@(!sub:?sub " ")
                & @( !sub
                   : ( (vnd|prs|x) "." ?name
                     | ?name
                     )
                   )
                & (   @(!name:? "+" ?suf)
                    & (   !suf
                        : ( xml
                          | json
                          | ber
                          | der
                          | fastinfoset
                          | wbxml
                          | zip
                          | cbor
                          | binary
                          | vrml
                          )
                      | `~
                      )
                  | 
                  )
                & ?
            )
          $ 
      )
      "
/**
 * toolsdata
 *
 * Return the full file system path to Tool's staging area.
 * The input can be a file name: this name is appended to the returned value.
 *
 * Called from workflow.java
 */"
      ( toolsdata
      = .str$(!documentRoot (|!stagingArea) !arg)
      )
      "
/**
 * toolsdataURL
 *
 * Return the full URL to Tool's staging area.
 * The input can be a file name: this name is appended to the returned value.
 *
 * Called from workflow.java
 */"
      (toolsdataURL=.str$(!baseUrlTools !stagingArea !arg))
      (toolsUploadURL=.str$(!baseUrlTools "/texton/upload" !arg))
      ( read
      = .get$(path$((!arg:~|all) ".bra"))
      )
      ( prodtables
      =   CTBs
          jobAbout
          jobNr
          jobs
          (|NORELATIONSFILES|relations)
          Uploads
          zippedresults
          tooladm
          jobNr
          toolprop
          ItemGroupsCache
          footer
          recentTasks
          wrkflws
      )
      ( saveAllTables
      =   tab saved folder
        .   !arg:
          & :?saved
          & (   !where
              :   ?
                  ( ?Tables
                  .   ?folder
                    &   whl
                      ' ( !Tables
                        :   ( %?tab
                            & saveTable$(!folder.!tab)
                            & !saved !tab:?saved
                            )
                            ?Tables
                        )
                    & ~
                  )
                  ?
            | Saved !saved
            )
      )
      ( importTables
      =     prod missingToolprop prodtoolprop productionTables tdata
          , tid
        .     !arg:(?prod.?arg)
            & @(!arg:alltables ?)
            & ( (   !prod:
                  &     map
                      $ ((=.!arg.readTable$!arg).!prodtables)
                    : ?productionTables
                  & get$(path$!arg)
                  & saveAllTables$
                  & readTable$tooladm
                  & readTable$toolprop
                  & :?missingToolprop
                  &   map
                    $ ( ( 
                        =     name productioncontent
                            , anotool ToolID prodtool mergedtooladm
                          .   !arg:(?name.?productioncontent)
                            & (   !name:tooladm
                                & "Use the imported non-production tooladm, but inject ContactEmail ServiceURL from current production tooladm"
                                & 0:?mergedtooladm
                                &   whl
                                  ' (   !tooladm
                                      :   ( ? (ToolID.?ToolID) ?
                                          : ?anotool
                                          )
                                        + ?tooladm
                                    & (     !productioncontent
                                          :   ?
                                            + ( ? (ToolID.!ToolID) ?
                                              : ?prodtool
                                              )
                                            + ?
                                        &   map
                                          $ ( ( 
                                              =   a z anoval prodval
                                                .     !anotool
                                                    :   ?a
                                                        (!arg.?anoval)
                                                        ?z
                                                  &   !prodtool
                                                    :   ?
                                                        (!arg.?prodval)
                                                        ?
                                                  & ( !anoval:!prodval
                                                    |     !a
                                                          (!arg.!prodval)
                                                          !z
                                                      : ?anotool
                                                    )
                                              )
                                            . ContactEmail ServiceURL
                                            )
                                      | 
                                      )
                                    &   !mergedtooladm+!anotool
                                      : ?mergedtooladm
                                    )
                                & log$OUTLIERS
                                &   whl
                                  ' (   !productioncontent
                                      :   ( ? (ToolID.?ToolID) ?
                                          : ?prodtool
                                          )
                                        + ?productioncontent
                                    & (   !mergedtooladm
                                        :   ?
                                          + (? (ToolID.!ToolID) ?)
                                          + ?
                                      |     !prodtool+!mergedtooladm
                                          : ?mergedtooladm
                                        &   !ToolID !missingToolprop
                                          : ?missingToolprop
                                      )
                                    )
                                & !mergedtooladm:?productioncontent
                              | 
                              )
                            & ( !name:toolprop
                              |     !productioncontent
                                  : ?(&!name)
                                & saveTable$!name
                              )
                        )
                      . !productionTables
                      )
                  & (   !missingToolprop:
                      & log$NOTHINGMISSING
                    |     !productionTables
                        : ? (toolprop.?prodtoolprop) ?
                      & log$HAVETOINSERT
                      & readTable$toolprop
                      &   whl
                        ' (   !prodtoolprop
                            :   ?
                              + (   ?tid
                                  & !missingToolprop:? !tid ?
                                  & log$(tid !tid is missing)
                                . ?tdata
                                )
                              + ?prodtoolprop
                          & (!tid.!tdata)+!toolprop:?toolprop
                          )
                      & saveTable$toolprop
                    )
                  & "Imported file, but kept local production data."
                |   get$(path$!arg)
                  & saveAllTables$
                  & "Initialized all tables from imported file."
                )
              | str$("Cannot read " !arg)&~
              )
          |   str
            $ "Usage: importTables$\"<file name>\" .  <file name> must start with 'alltables'."
      )
      ( readTableFromFolder
      =   folder file
        .     !arg:(?folder.?file)
            & get$(path$(!folder !file)):?!file
          | str$("Cannot read " !arg)&~
      )
      ( exportTables
      =   tabs tab Tables folder error prod mssg
        .     ( !where:(?.?) ?
              | readTable$where
              )
            & !arg:(?prod.?arg)
            & (   @(!arg:(|alltables ?))
                & 0:?tabs
                & :?error
                & (   !where
                    :   ?
                        ( ?Tables
                        .   ?folder
                          &   whl
                            ' ( !Tables
                              :   ( %@?tab
                                  & (   readTableFromFolder$(!folder.!tab)
                                      & !tab+!tabs:?tabs
                                    |   log
                                      $ ( str
                                        $ ( " Cannot read ["
                                            !tab
                                            "] in ["
                                            !folder
                                            "]."
                                          )
                                        )
                                    )
                                  )
                                  ?Tables
                              )
                          & ~
                        )
                        ?
                  |   ( !tabs:?+where+?
                      | where+!tabs:?tabs
                      )
                    & (   @(!arg:alltables ?)
                        & !arg:?AAA
                      | 
                      )
                    & (   !prod:
                        &   map
                          $ ( (=.:?(&!arg))
                            . !prodtables
                            )
                        & 0:?jobNr
                        & readTable$toolprop
                        & readTable$tooladm
                        &     ( 
                              =     anotooladm A Z a z
                                  , ContactEmail ServiceURL
                                .   0:?anotooladm
                                  &   whl
                                    ' (   !arg
                                        :   ( ?A
                                              (ContactEmail.?ContactEmail)
                                              ?Z
                                            )
                                          + ?arg
                                      &     !A
                                            (ContactEmail."x@x.xxx")
                                            !Z
                                        :   ?A
                                            (ServiceURL.?ServiceURL)
                                            ?Z
                                      & (   @( !ServiceURL
                                             : ? "://" ? "/" ?z
                                             )
                                          &   str$("http://localhost/" !z)
                                            : ?ServiceURL
                                        | 
                                        )
                                      &     !anotooladm
                                          + ( !A
                                              (ServiceURL.!ServiceURL)
                                              !Z
                                            )
                                        : ?anotooladm
                                      )
                                  & !anotooladm
                              )
                            $ !tooladm
                          : ?tooladm
                      | 
                      )
                    &   (   lst$(!tabs,path$!AAA,NEW)
                          &   str
                            $ ("Saved all tables in '" path$!AAA "'. " !error)
                        |   str
                          $ ( "Cannot write to ["
                              path$!AAA
                              "]. Check file access rights for JBoss/Tomcat."
                            )
                        )
                      : ?mssg
                    & (   !prod:
                        & map$((=.readTable$!arg).!prodtables)
                        & readTable$jobNr
                        & readTable$tooladm
                      | 
                      )
                    & !mssg
                  )
              |   str
                $ "'exportTables$' must be called without argument or with the name of a file that must start with 'alltables'."
              )
          | str$"Cannot read table 'where'"&~
      )
      ( saveToolTable
      =   
        .   saveTable$!arg
          & :?recentTasks
          & saveTable$recentTasks
      )
      ( setLang
      =   full A Z
        .     low$!arg:?arg
            & ( !lANgs:? !arg ?
              |   @(!arg:d (a|k) ?)
                & !lANgs:% ?arg
                & !arg:~
              | !lANgs:%?arg ?
              )
            & !arg:?LaNg
            & readTable$linguae
            & !linguae:? (?full.!LaNg.?) ?
            & localized$!full
            & (   !hiddenData:?A (UIlanguage.?) ?Z
                & !A !Z:?hiddenData
              | 
              )
            & (UIlanguage.!LaNg) !hiddenData:?hiddenData
          | log$("failed to set language to " !arg)&~
      )
      ( setTypeFace
      =   A Z
        .   !arg:?TyPeFaCe
          & (   !hiddenData:?A (TyPeFaCe.?) ?Z
              & !A !Z:?hiddenData
            | 
            )
          & (TyPeFaCe.!TyPeFaCe) !hiddenData:?hiddenData
      )
      "
/**
 * clean
 * 
 * Free all variables that shouldn't exist.
 * Such variables are normally undeclared 'local' variables.
 * (In proper coding, all such variables should be declared).
 *
 * Called from reloadScript.java
 */"
      ( clean
      =   
        .   map
          $ ( ( 
              =   
                .         MLencoding
                          abs
                          arg
                          c
                          cat
                          cos
                          fct
                          flt
                          jsn
                          nestML
                          out
                          sgn
                          sin
                          sub
                          tay
                          toML
                          v
                          w
                          Globals
                          !Globals
                      : ? !arg ?
                    & 
                  | tbl$(!arg,0)&!arg
              )
            . cat$
            )
      )
      ( trim
      =   a z
        .     whl
            ' ( @(!arg:?a \r ?z)
              & str$(!a !z):?arg
              )
          &   whl
            ' @(!arg:(" "|\n|\t) ?arg)
          &   whl
            ' @(!arg:?arg (" "|\n|\t))
          & !arg
      )
      ( hasTree
      =   2a 3a 1a 5a
        .     !arg:(?2a.?5a:(=?3a))
            & !2a:!3a
          |   !2a
            : ? (?.?,?1a&hasTree$(!1a.!5a)) ?
      )
      ( NCNameStartChar
      =   ~<A:~>Z
        | "_"
        | ~<a:~>z
        | ~<√Ä:~>√ñ
        | ~<√ò:~>√∂
        | ~<√∏:~>Àø
        | ~<Õ∞:~>ÕΩ
        | ~<Õø:~>·øø
        | ~<‚Äå:~>‚Äç
        | ~<‚Å∞:~>‚Üè
        | ~<‚∞Ä:~>‚øØ
        | ~<„ÄÅ:~>Ìüø
        | ~<Ô§Ä:~>Ô∑è
        | ~<Ô∑∞:~>ÔøΩ
        | ~<êÄÄ:~>ÛØøø
      )
      ( NCNameChar
      =   !NCNameStartChar
        | "-"
        | "."
        | ~<0:~>9
        | ¬∑
        | ~<ÃÄ:~>ÕØ
        | ~<‚Äø:~>‚ÅÄ
      )
      (allowedChar=.utf$!sjt&!sjt:!(arg.))
      ( NCName
      = |allowedChar$('$NCNameChar) !NCName
      )
      ( checkParms
      =   parms parm table val abBr abbrs spec
        .   !arg:(?parms.?parm.?table)
          & :?abbrs
          &   whl
            ' ( !parms:? (!parm.?val) ?parms
              & !hiddenData (!parm.!val):?hiddenData
              &   whl
                ' ( !val:%?abBr^?spec+?val
                  & !table:? (?.!abBr.?) ?
                  & !abbrs !abBr:?abbrs
                  )
              )
          & !abbrs
      )
      ( checkParmsSimple
      =   parms parm aBbr
        .   !arg:(?parms.?parm)
          & !parms:? (!parm.%?aBbr) ?
          & !hiddenData (!parm.!aBbr):?hiddenData
          & !aBbr
      )
      ( heading
      =   n
        .   !arg:(?n.?arg)
          & (str$(h !n).,!arg) \r\n
      )
      (paragraph=.(p.,!arg) \r\n)
      ( fieldset
      =   legend content
        .   !arg:(?legend.?content)
          &   ( fieldset
              .   (class.noborder)
                ,   ( !legend:
                    | (legend.(class.secondpage),!legend)
                    )
                    !content
              )
              \r\n
      )
      ( form
      =   action method
        .   !arg:(?action.?arg)
          & (   !arg
              : ( ?arg
                .   ( post
                    | POST
                    | get
                    | GET
                    )
                  : ?method
                )
            | GET:?method
            )
          & ( form
            .     (   !method:(POST|post)
                    & (enctype.multipart/form-data)
                  | "20121024 GET no enctype?"&
                  | (enctype.application/x-www-form-urlencoded)
                  )
                  (accept-charset.UTF-8)
                  (method.low$!method)
                  (action.!action)
                  (class.formRounded)
              , (div.,!arg)
            )
      )
      ( makeCheckboxFormField
      =   text parm desc state disabled
        .     !arg
            : ( ?text
              . ?parm
              .   ( ? (val.?state) ?
                  | ?&:?state
                  )
                : ( ? (disabled.?disabled) ?
                  | ?&:?disabled
                  )
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
              )
          &   (span.,!text)
              \r\n
              ( input
              .     (type.checkbox)
                    (tabindex.1+!tabind:?tabind)
                    (name.!parm)
                    ( !state:
                    | ( checked
                      .   !state:on&checked
                        | 
                      )
                    )
                    (!disabled:|(disabled.!disabled))
                    (!desc:|(title.!desc))
                , 
              )
              \r\n
      )
      ( makeStaticTextFormField
      =   text val
        .   !arg:(?text.?val)
          & (label.,!text) \r\n !val \r\n
      )
      ( makeTextFormField
      =   text parm val desc readonly size required
        .     !arg
            : ( ?text
              . ?parm
              .   ? (val.?val) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (readonly.?readonly) ?
                  | ?&:?readonly
                  )
                : ( ? (size.?size) ?
                  | ?&:?size
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( label
              .   
                ,   !text
                    ( !required:
                    | " " (span.(class.requiblue),!required)
                    )
              )
              \r\n
              ( input
              .     (tabindex.1+!tabind:?tabind)
                    (type.text)
                    (name.!parm)
                    (!val:|(value.trim$!val))
                    (!desc:|(title.!desc))
                    ( !readonly:(|no)
                    | (disabled.disabled)
                    )
                    (!size:|(size.!size))
                , 
              )
              \r\n
      )
      ( makeTextAreaFormField
      =   text parm val required desc
        .     !arg
            : ( ?text
              . ?parm
              .   ? (val.?val) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( label
              .   
                ,   !text
                    ( !required:
                    | " " (span.(class.requiblue),!required)
                    )
              )
              \r\n
              ( textarea
              .     (tabindex.1+!tabind:?tabind)
                    (name.!parm)
                    (rows.2)
                    (cols.60)
                    (!desc:|(title.!desc))
                , trim$!val
              )
              \r\n
      )
      ( ToolTitle
      =   
        .     readTable$tooladm
            & (     !tooladm
                  :   ?
                    + ( ? (ToolID.!arg) ?
                      : ? (Title.?arg) ?
                      )
                    + ?
                & !arg
              | str$("ToolTitle:" !arg " does not exist.")
              )
          | str$("ToolTitle:" !arg " tooladm cannot be read.")
      )
      ( toolID2title
      =   
        .   readTable$tooladm
          &   map
            $ ( ( 
                =   tit
                  .   (   !tooladm
                        :   ?
                          + ( ? (ToolID.!arg) ?
                            : ? (Title.?tit) ?
                            )
                          + ?
                      | 
                      )
                    & (!arg.!tit)
                )
              . !arg
              )
      )
      ( enumerateTools
      =   tool o i inp I,a b
        .     !arg:(?tool,(?o.?i.?inp))
            & ToolTitle$!tool:?tool
            &   (enumerateTools$!inp:?I)
                (!I:|" ‚Üí ")
                !tool
          |   !arg:%?a*%?b
            & "(" enumerateTools$!a ‚à™ enumerateTools$!b ")"
          |   !arg:%?a+%?b
            & "(" enumerateTools$!a "|" enumerateTools$!b ")"
          | !arg:(?o.?inp)&enumerateTools$!inp
          | 
      )
      ( disam
      =     nextvar ding nextn nextvars wfs wflw N toolPlumbing
          , demul demultiply inmul inmultiply c2m cm
        .     0:?nextn
            & :?nextvars
            & ( nextvar
              =   bang quest var squest
                .   !nextn+1:?nextn
                  &   !nextvars (str$(a !nextn):?var)
                    : ?nextvars
                  & glf$('(`%?.$var)):?quest
                  & glf$('(!.$var)):?bang
                  & glf$('(?.$var)):?squest
                  & (!quest.!bang.!squest)
              )
            & ( ding
              =     bang bangA bangZ bangT featval o
                  , quest questA questZ questT bangIO questIO
                  , questionpattern-tio questiontemplate
                  , questiontemplate-lhs question
                  , questiontemplate-rhs
                  , replacement replacementtemplate
                  , replacementtemplate-lhs replacementtemplate-rhs
                  , rynaps synaps wf1
                  , i w ws wf1 tmp REPLACE IO
                .     !arg
                    : ( ?wf1
                      . (=?questiontemplate)
                      . (=?replacementtemplate)
                      )
                  & "questiontemplate is macro '(...$synaps...)"
                  & (     (=?t.(?i.?o).?IO)
                        : (=?synaps)
                      &   !questiontemplate
                        : (=?questionpattern-tio)
                      & !wf1:!questionpattern-tio
                      &   nextvar$
                        : ((=?questT).(=?bangT).?)
                      &   nextvar$
                        : (?.(=?bangA).(=?questA))
                      &   nextvar$
                        : (?.(=?bangZ).(=?questZ))
                      &   nextvar$
                        : (?.(=?bang).(=?quest))
                      &   nextvar$
                        : (?.(=?bangIO).(=?questIO))
                      & "If a feature is shared by all workflows, remove it."
                      & ( REPLACE
                        =   !questiontemplate:(=?question)
                          & ( (,!toolPlumbing):!question
                            |   !wfs:?ws
                              &   whl
                                ' ( !ws:%?w ?tmp
                                  & !w:!question
                                  & !tmp:?ws
                                  )
                              & (   !ws:
                                  & !wfs:?ws
                                  & :?wfs
                                  &   whl
                                    ' ( !ws:%?w ?ws
                                      & !w:!question
                                      & !wfs !replacement:?wfs
                                      )
                                | 
                                )
                            )
                        )
                      &     
                          ' ( $bangT
                            . ($bangA ()$bangZ.$bang)
                            . $bangIO
                            )
                        : (=?rynaps)
                      & !replacementtemplate:(=?replacement)
                      &   whl
                        ' ( !i:%?featval ?i
                          &     
                              ' ( $questT
                                . ( $questA ()$featval ()$questZ
                                  . $quest
                                  )
                                . $questIO
                                )
                            : (=?synaps)
                          & !REPLACE
                          )
                      &     
                          ' ( $bangT
                            . ($bang.$bangA ()$bangZ)
                            . $bangIO
                            )
                        : (=?rynaps)
                      & !replacementtemplate:(=?replacement)
                      &   whl
                        ' ( !o:%?featval ?o
                          &     
                              ' ( $questT
                                . ( $quest
                                  . $questA ()$featval ()$questZ
                                  )
                                . $questIO
                                )
                            : (=?synaps)
                          & !REPLACE
                          )
                    |   (=%?_%?):(=?synaps)
                      & !questiontemplate:(=?question)
                      & !wf1:!question
                      &   nextvar$
                        : ((=?quest).(=?bang).?)
                      &   '$(%?:$($synaps))_($quest)
                        : (=?synaps)
                      &   !questiontemplate
                        : (=?questiontemplate-lhs)
                      &   '$($($rynaps))_($bang)
                        : (=?rynaps)
                      &   !replacementtemplate
                        : (=?replacementtemplate-lhs)
                      &   '$($quest)_(%?:$($synaps))
                        : (=?synaps)
                      &   !questiontemplate
                        : (=?questiontemplate-rhs)
                      &   '$($bang)_($($rynaps))
                        : (=?rynaps)
                      &   !replacementtemplate
                        : (=?replacementtemplate-rhs)
                      &   ding
                        $ ( !wf1
                          . '('$questiontemplate-lhs)
                          . '('$replacementtemplate-lhs)
                          )
                      &   ding
                        $ ( !wf1
                          . '('$questiontemplate-rhs)
                          . '('$replacementtemplate-rhs)
                          )
                    )
              )
            & "de/inmul(tiply) are used to replace (commutative) * operators
               with (noncommutative) , operators. And back again. Reason:
               During simplification factors can swap place, leading to
               mismatch with the tool plumbing pattern."
            & ( demul
              =   a b
                .     !arg:%?a*%?b
                    & demul$!a:?a
                    & demul$!b:?b
                    & !(glf$('($arg.$a,$b)))
                  | !arg:(?a.OnE)&(demul$!a.OnE)
                  |   !arg:?a_?b
                    & (demul$!a)_(demul$!b)
                  | !arg
              )
            & ( demultiply
              =   wf n
                .   map
                  $ ( ( 
                      =   
                        .   !arg:(?n,?wf)
                          & (!n,demul$!wf)
                      )
                    . !arg
                    )
              )
            & ( cm
              =   x
                .   !arg:(?x,?arg)&!x*cm$!arg
                  | !arg
              )
            & ( c2m
              =   x
                .     !arg:(?x,?arg)
                    & c2m$!x*c2m$!arg
                  | !arg:(?x.OnE)&(cm$!x.OnE)
                  | !arg
              )
            & ( inmul
              =   a b
                .     !arg:(@?a,?b)
                    & (!a,c2m$!b:?a)
                  | !arg:(?a.OnE)&(cm$!a.OnE)
                  |   !arg:?a_?b
                    & (inmul$!a)_(inmul$!b)
                  | !arg
              )
            & ( inmultiply
              =   wf n
                .   map
                  $ ( ( 
                      =   
                        .   !arg:(?n,?wf)
                          & (!n,inmul$!wf)
                      )
                    . !arg
                    )
              )
            & !arg:((=?toolPlumbing).?wfs)
            & demul$!toolPlumbing:?toolPlumbing
            & demultiply$!wfs:?wfs
            & !wfs:%?wflw ?
            & :?nextvars
            & 0:?nextn
            & "ding changes wfs !!"
            &   ding
              $ ( !wflw
                . (='(?N,$synaps))
                . (='(!N,$rynaps))
                )
            & tbl$(!nextvars,0)
            & inmultiply$!wfs:?wfs
            & !wfs
          | 
      )
      ( describefeature
      =     featvals table specificationTables featdesc
          , featval spec full stbl sps sp
          , featvalspec featvalspecs addFeatvalSpec
        .   ( addFeatvalSpec
            =     !featdesc
                  (!featdesc:|" & ")
                  (   !!table:? (?full.!featval.?) ?
                    & localized$!full
                  | !featval
                  )
                  ( !spec:1&
                  |   "["
                      (   !specificationTables
                        :   ?
                            (? (%@:!featval) ?.?stbl)
                            ?
                      & :?sps
                      & (!!stbl|readTable$!stbl)
                      &   whl
                        ' ( !spec:%?sp+?spec
                          &     !sps
                                (!sps:|"|")
                                (   !!stbl:? (?full.!sp.?) ?
                                  & localized$!full
                                | !sp
                                )
                            : ?sps
                          )
                      & !sps
                      )
                      "]"
                  )
              : ?featdesc
            )
          & !arg:(?featvals.?table.?specificationTables)
          & :?featdesc
          &   whl
            ' ( !featvals:%?featvalspec*?featvals
              &   !featvalspec
                : (   (?featvalspecs.OnE)
                    &   whl
                      ' ( !featvalspecs:%?featval^?spec*?featvalspecs
                        & !addFeatvalSpec
                        )
                  | %?featval^?spec&!addFeatvalSpec
                  )
              )
          & !featdesc
      )
      ( inoutdesc
      =   description
        .         map
                $ ( ( 
                    =     featname featvals table
                        , specificationTables
                      .     !arg:(?featname,?featvals)
                          &   !features
                            :   ?
                              + ( ? (short.!featname) ?
                                : ? (table.?table) ?
                                : (   ?
                                      (specificationTable.?specificationTables)
                                      ?
                                  |   ?
                                    & :?specificationTables
                                  )
                                )
                              + ?
                          &   ", "
                                describefeature
                              $ (!featvals.!table.!specificationTables)
                        | 
                    )
                  . !arg
                  )
              : ", " ?description
            & !description
          | 
      )
      ( fullinoutdesc
      =   description
        .         map
                $ ( ( 
                    =     featname featvals table
                        , specificationTables name
                      .     !arg:(?featname,?featvals)
                          &   !features
                            :   ?
                              + ( ? (short.!featname) ?
                                : ? (table.?table) ?
                                : ? (name.?name) ?
                                : (   ?
                                      (specificationTable.?specificationTables)
                                      ?
                                  |   ?
                                    & :?specificationTables
                                  )
                                )
                              + ?
                          &   ", "
                              localized$!name
                              ":"
                                describefeature
                              $ (!featvals.!table.!specificationTables)
                        | 
                    )
                  . !arg
                  )
              : ", " ?description
            & !description
          | 
      )
      ( fullinoutdescTable
      =   
        .   !arg:
          | ( table
            .   
              ,   map
                $ ( ( 
                    =     featname featvals table
                        , specificationTables name
                      .   !arg:(?featname,?featvals)
                        &   !features
                          :   ?
                            + ( ? (short.!featname) ?
                              : ? (table.?table) ?
                              : ? (name.?name) ?
                              : (   ?
                                    (specificationTable.?specificationTables)
                                    ?
                                |   ?
                                  & :?specificationTables
                                )
                              )
                            + ?
                        & ( tr
                          .   
                            ,   ( td
                                .   (class.smallfont)
                                  , localized$!name
                                )
                                ( td
                                .   (class.smallfont)
                                  ,   describefeature
                                    $ (!featvals.!table.!specificationTables)
                                )
                          )
                    )
                  . !arg
                  )
            )
      )
      ( sort
      =   S L e f
        .   :?L
          &   whl
            ' ( !arg:%?e ?arg
              & (!e.) !L:?L
              )
          &   whl
            ' ( :?S
              &   whl
                ' (!L:%?e %?f ?L&!e+!f !S:?S)
              & !L !S:?S
              & !S:% %:?L
              )
          & :?L
          & whl'(!S:#*(?e.)+?S&!e !L:?L)
          & :?S
          & whl'(!L:%?e ?L&!e !S:?S)
          & !S
      )
      ( reorder
      =     reorderedworkflowlist nr groupIfSameTools
          , workflow weighted presentable
        .   ( presentable
            =     mul2com accumulateAbbreviations findUnvisitedWF
                , replace insertNameInFirst
                , removeWorkflowsPrecedingRefs isReferenced
                , deleteReference renameReference
                , abbrevs name newseqno newseqnos nrefs ref
                , refs seq seqno struct wf
              .   ( mul2com
                  =   a b n I O i o
                    .     !arg:%?a*%?b
                        & (mul2com$!a,mul2com$!b)
                      |   !arg:(?n.(?i.?o).?I.?O)
                        & (!n.!I.!O)^(!i.!o)*!abbrevs:?abbrevs
                        & (!n..!I.!O)
                      |   !arg:?a_?b
                        & (mul2com$!a)_(mul2com$!b)
                      | !arg
                  )
                & ( accumulateAbbreviations
                  =   A I O i o exp N list sum
                    .   1:?N
                      & ( sum
                        =   S t
                          .   0:?S
                            &   whl
                              ' ( !arg:%?t ?arg
                                & !S+!t:?S
                                )
                            & !S
                        )
                      & ( list
                        =   S t
                          .   :?S
                            &   whl
                              ' ( !arg:#*((?,?):%?t)+?arg
                                & !S !t:?S
                                )
                            & !S
                        )
                      &   whl
                        ' ( !arg:%?A^%?exp*?arg
                          & 0:?I:?O
                          &   whl
                            ' ( !exp:?*(?i.?o)+?exp
                              & !I+sum$!i:?I
                              & !O+sum$!o:?O
                              )
                          & !A^(list$!I.list$!O)*!N:?N
                          )
                      & !N
                  )
                & ( findUnvisitedWF
                  =   a b
                    .     !arg:(%?a,%?b)
                        & ( findUnvisitedWF$!a
                          | findUnvisitedWF$!b
                          )
                      |   !arg:?a (?..?)
                        & findUnvisitedWF$!a
                      |   !arg:(? (?..?):?arg) ?
                        & !arg
                  )
                & ( replace
                  =   a b struct wf seqno n m
                    .   !arg:(?struct.?wf.?seqno)
                      & (   !struct:(%?a,%?b)
                          & ( replace$(!a.!wf.!seqno)
                            , replace$(!b.!wf.!seqno)
                            )
                        |   !struct:(!wf:?a (?n..?m)) ?b
                          & !a (.!seqno.!m) !b
                        |   !struct:?a (?n..?m)
                          & replace$(!a.!wf.!seqno) (!n..!m)
                        | !struct
                        )
                  )
                & ( insertNameInFirst
                  =   struct name seqno a b
                    .   !arg:(?struct.?name.?seqno)
                      & (   !struct:(%?a,%?b)
                          & (   insertNameInFirst$(!a.!name.!seqno)
                              : ?a
                            |   insertNameInFirst$(!b.!name.!seqno)
                              : ?b
                            )
                          & (!a,!b)
                        |   !struct:?a ((?.?.?):?b)
                          & insertNameInFirst$(!a.!name.!seqno):?a
                          & !a !b
                        |   !struct:?a (.!seqno.?b)
                          & !a (!name.!seqno.!b)
                        )
                  )
                & ( removeWorkflowsPrecedingRefs
                  =   a b
                    .     !arg:(%?a,%?b)
                        & ( removeWorkflowsPrecedingRefs$!a
                          , removeWorkflowsPrecedingRefs$!b
                          )
                      |   !arg:? ((.?.?):?b)
                        & !b
                      |   !arg:?a ((?.?.?):?b)
                        & removeWorkflowsPrecedingRefs$!a !b
                      | !arg
                  )
                & ( isReferenced
                  =   a b seqno struct
                    .     !arg:(?seqno.?struct)
                        & !struct:(%?a,%?b)
                        & ( isReferenced$(!seqno.!a)
                          | isReferenced$(!seqno.!b)
                          )
                      | !struct:? (.!seqno.?) ?
                      |   !struct:%?a %?b
                        & ( isReferenced$(!seqno.!a)
                          | isReferenced$(!seqno.!b)
                          )
                  )
                & ( deleteReference
                  =   a b struct seqno n m
                    .   !arg:(?seqno.?struct)
                      & (   !struct:(%?a,%?b)
                          & ( deleteReference$(!seqno.!a):?a
                            | deleteReference$(!seqno.!b):?b
                            )
                          & (!a,!b)
                        |   !struct:?a (?n.!seqno.?m) ?b
                          & !a (!n..!m) !b
                        |   !struct:%?a %?b
                          & ( deleteReference$(!seqno.!a):?a
                            | deleteReference$(!seqno.!b):?b
                            )
                          & !a !b
                        )
                  )
                & ( renameReference
                  =   a b struct seq n m seqno nseqno
                    .   !arg:(?seq.?struct)
                      & (   !struct:(%?a,%?b)
                          & ( renameReference$(!seq.!a)
                            , renameReference$(!seq.!b)
                            )
                        |   !struct:%?a %?b
                          &   renameReference$(!seq.!a)
                              renameReference$(!seq.!b)
                        |   !seq:(?seqno.?nseqno)
                          & !struct:(?n.!seqno.?m)
                          & (!n.!nseqno.!m)
                        | !struct
                        )
                  )
                & 1:?abbrevs
                & "Replace * by , and collect abbrevs (side effect)"
                & mul2com$!arg:?struct
                & accumulateAbbreviations$!abbrevs:?abbrevs
                & 0:?seqno
                & :?refs
                &   whl
                  ' ( findUnvisitedWF$!struct:?wf
                    & 1+!seqno:?seqno
                    & !wf:? (?name.?)
                    & (!name.!seqno) !refs:?refs
                    & replace$(!struct.!wf.!seqno):?struct
                    )
                & :?nrefs
                &   whl
                  ' ( !refs:%?ref ?refs
                    & !ref !nrefs:?nrefs
                    & insertNameInFirst$(!struct.!ref):?struct
                    )
                & removeWorkflowsPrecedingRefs$!struct:?struct
                & :?newseqnos
                & (48|9311):?newseqno
                &   whl
                  ' ( !nrefs:(?.?seqno) ?nrefs
                    & 1+!newseqno:?newseqno
                    & (   isReferenced$(!seqno.!struct)
                        &   (!seqno.!newseqno) !newseqnos
                          : ?newseqnos
                      | deleteReference$(!seqno.!struct):?struct
                      )
                    )
                &   whl
                  ' ( !newseqnos:%?seq ?newseqnos
                    & renameReference$(!seq.!struct):?struct
                    )
                & (!struct.!abbrevs)
            )
          & ( weighted
            =     name Ntools Nsteps n nr countTools
                , A B T C usedTools struct abbrevs
                , toolInventory toolsUsed plumbing
              .   ( plumbing
                  =   a b
                    .     !arg:%?a %?b
                        & plumbing$!a plumbing$!b
                      |   !arg:(%?a,%?b)
                        & (plumbing$!a,plumbing$!b)
                      | !arg:(?a.?b.?)&(!a.!b)
                  )
                & !arg:(?nr,(?struct.?abbrevs))
                & 0:?Ntools:?Nsteps:?toolInventory
                & ( countTools
                  =   A B
                    .     !arg:((?A,?B)|%?A %?B)
                        & countTools$!A+countTools$!B
                      | !arg:(~:?A.?.?.?)&!A
                      | 0
                  )
                & countTools$!struct:?toolInventory
                & ( usedTools
                  =   A B
                    .     !arg:((?A,?B)|%?A %?B)
                        & usedTools$!A usedTools$!B
                      | !arg:(?A.?.?.?)&!A
                      | 
                  )
                & usedTools$!struct:?toolsUsed
                &   whl
                  ' ( !toolsUsed:?A %@?T ?B %@!T ?C
                    & !A !T !B !C:?toolsUsed
                    )
                &   whl
                  ' ( !toolInventory:?n*%@?name+?toolInventory
                    & !n+!Nsteps:?Nsteps
                    & 1+!Ntools:?Ntools
                    )
                & ( (!Ntools.!toolsUsed.!Nsteps.plumbing$!struct.!nr)
                  , (!abbrevs.!struct)
                  )
            )
          & ( groupIfSameTools
            =   L seen a b c B sb
              .   0:?L
                & :?seen
                &   whl
                  ' ( !arg:((?a.?b.?c),?B)+?arg
                    & sort$!b:?sb
                    & ( !seen:? (!sb.?b) ?
                      | (!sb.!b) !seen:?seen
                      )
                    & !L+((!a.!b.!c),!B):?L
                    )
                & !L
            )
          & 0:?reorderedworkflowlist
          &   map
            $ ( ( 
                =   nr workflow
                  .   whl
                    ' ( !arg:(?nr,?workflow) ?arg
                      &     weighted$(!nr,presentable$!workflow)
                          + !reorderedworkflowlist
                        : ?reorderedworkflowlist
                      )
                )
              . !arg
              )
          &   groupIfSameTools$!reorderedworkflowlist
            : ?reorderedworkflowlist
          &   ( 
              =   L p n a b c d e B
                .   :?L
                  & :?p
                  & 0:?n
                  &   whl
                    ' ( !arg:((?a.?b.?c.?d.?e),?B)+?arg
                      & (   !d:~!p:?p
                          & 1+!n:?n
                        | 
                        )
                      & ((!a.!b.!c.!n.!e),!B) !L:?L
                      )
                  & 0:?arg
                  &   whl
                    ' (!L:%?a ?L&!a+!arg:?arg)
                  & !arg
              )
            $ !reorderedworkflowlist
      )
      ( topologicalOrder
      =     edges workflow A Z ABC XYZ
          , 2p Kahn edg pr shorting
          , pairs shrtlst nshrtlst kahn
        .   log$topologicalOrder
          & ( edg
            =   a b
              .   !arg:%?a %?b&edg$!b edg$!a
                | !arg:(?a,?b)&edg$!a+edg$!b
                | !arg:(?a.?b)&!a
            )
          & ( pr
            =   nxt a b c dpt S
              .   !arg:(?dpt.?nxt.?arg)
                & (!nxt:#%*?nxt|)
                & (   !arg:%+%
                    & 0:?S
                    &   whl
                      ' ( !arg:%?a+?arg
                        & pr$(1+!dpt.!nxt.!a)+!S:?S
                        )
                    & !S
                  |   !arg:#%*%?a
                    & pr$(1+!dpt.!nxt.!a)
                  |   !arg:%?a %?b
                    &   ( !nxt:&0
                        | (!a.!nxt)
                        )
                      + (   !b:%@?b ?c
                          & (!b.!a)+pr$(1+!dpt.!b.!c)
                        | pr$(1+!dpt.!a.!b)
                        )
                  |   !arg:%@?a ?
                    & ( !nxt:&0
                      | (!a.!nxt)
                      )
                  | 0
                  )
            )
          & 0:?edges
          &   map
            $ ( ( 
                =   
                  .   whl
                    ' ( !arg:(?,?workflow) ?arg
                      & edg$!workflow+!edges:?edges
                      )
                )
              . !arg
              )
          & (   !edges:@
              & log$"There is only one step."
              & !edges
            |   log$callPR
              & pr$(0..!edges):?pairs
              & log$callPRdone
              & ( 2p
                =   a b
                  .     !arg:%@?a %@?b ?arg
                      & (!a.!b)+2p$(!b !arg)
                    | 0
                )
              & ( Kahn
                =   pairs A Z i S L m n
                  .   "create topological ordering"
                    & !arg:?pairs
                    & :?S:?L
                    & (   !pairs
                        :   ?
                          +   #
                            * (   ?i
                                & ~(!pairs:?+#*(?.!i)+?)
                                & ~(!S:? !i ?)
                                & !i !S:?S
                                & ~
                              . ?
                              )
                          + ?
                      | 
                      )
                    &   whl
                      ' ( !S:%?n ?S
                        & !L !n:?L
                        &   whl
                          ' ( !pairs:?A+#*(!n.?m)+?Z
                            & !A+!Z:?pairs
                            & ( !pairs:?+#*(?.!m)+?
                              | !m !S:?S
                              )
                            )
                        )
                    & ( !pairs:0&!L
                      | "graph has at least one cycle"&
                      )
                )
              & ( shorting
                =   A Z L p S x y shrtlst
                  .   !arg:(?p,?arg:?L)
                    & 0:?S
                    & log$shorting
                    & :?shrtlst
                    &   whl
                      ' ( !L:#*(?x.?y)+?L
                        & !x+!y+!S:?S
                        )
                    & "Edges with node(s) occurring in that edge only are not
                       eligible for deletion.
                       Such nodes have no explicit numerical factor in S."
                    & (   !arg:%+%
                        & (   !arg
                            :   ?A
                              + (     #
                                    * (   ?x
                                        & ~(!S:?+!x+?)
                                      .   ?y
                                        & ~(!S:?+!y+?)
                                      )
                                  + ?Z
                                &   (!p+!A,!Z) !shrtlst
                                  : ?shrtlst
                                & ~
                                )
                          | !shrtlst
                          )
                      | (!p,0)
                      )
                )
              & log$sofarsogood
              & (0,!pairs):?shrtlst:?nshrtlst
              & :?kahn
              &   whl
                ' ( !shrtlst:~(0,0)
                  &   whl
                    ' ( !shrtlst:(?ABC,?XYZ) ?shrtlst
                      & Kahn$(!ABC+!XYZ):?kahn:
                      )
                  & !kahn:
                  & !nshrtlst:~
                  & log$("cycle [" !nshrtlst "]")
                  & "Cycle(s) found. Remove one edge, try again. The ABC edges
                     must not be touched. Remove edge from XYZ."
                  &   whl
                    ' ( !nshrtlst:(?ABC,?XYZ) ?nshrtlst
                      & shorting$(!ABC,!XYZ) !shrtlst:?shrtlst
                      )
                  )
              & !kahn
            )
      )
      ( set
      =   S L e
        .   0:?S
          &   whl
            ' ( !arg:%?e ?arg
              & (!S:?+!e+?|!e+!S:?S)
              )
          & :?L
          & whl'(!S:%?e+?S&!L !e:?L)
          & !L
      )
      ( makeWorkflowsSequential
      =     i nr enumerateToolsDetail
          , disambiguatedworkflowlist groupedworkflowlist n
          , o pat pipe pipes sameToolDifferentRoles
          , toolPlumbing "*" simplify
          , wf wfs workflow workflowlist saveio toolPattern
        .   ( enumerateToolsDetail
            =   tool o i predecessors myfold,a b
              .       !arg
                    : ( ?tool
                      , ( ?o
                        . ?
                        .   (?i.?predecessors)
                          | ?i&:?predecessors
                        )
                      )
                  & ( myfold
                    =   a b A B F R v1 v2
                      .     !arg:%?a*%?b
                          & myfold$!b:?b
                          & (     !a
                                :   ?
                                    ( ?F
                                    ,   ?v1
                                      &   !b
                                        : ?A (!F,~!v1:?v2) ?B
                                      &   !A (!F,!v1*!v2) !B
                                        : ?R
                                    )
                                    ?
                              & !R
                            | 
                            )
                        | !arg
                    )
                  &   ( !predecessors:
                      | enumerateToolsDetail$!predecessors
                      )
                      (!tool.myfold$!i.!o)
                |   !arg:%?a*%?b
                  & enumerateToolsDetail$!a*enumerateToolsDetail$!b
                |   !arg:%?a+%?b
                  & enumerateToolsDetail$!a+enumerateToolsDetail$!b
                |   !arg:(?o.?i)
                  & enumerateToolsDetail$!i
                | 1
            )
          & ( simplify
            =     WF S dun sortout n f i I
                , o feat val A Z O IO replace
              .   ( sortout
                  =   L R
                    .   !arg:(?.?)&!arg !S:?S
                      |   !arg:%?L_%?R
                        & sortout$!L
                        & sortout$!R
                  )
                & :?S
                & sortout$!arg
                & :?dun
                & ( replace
                  =   n r p L R WF
                    .   !arg:(?WF.?n.(=?p).(=?r))
                      & (   !WF:(=?.?)
                          & (   !WF:(=!n.!p)
                              & !r:?r
                              & '($n.$r)
                            | !WF
                            )
                        |   !WF:(=%?L_%?R)
                          &   
                            '   
                              $   ( 
                                  $ ( replace
                                    $ ('$L.!n.'$p.'$r)
                                    )
                                  )
                                _ ( 
                                  $ ( replace
                                    $ ('$R.!n.'$p.'$r)
                                    )
                                  )
                        )
                  )
                & '$arg:?WF
                &   whl
                  ' ( !S:(?n.?f) ?S
                    & ( !dun:? !n ?
                      |   !n !dun:?dun
                        & (   !S:? (!n.~!f) ?
                            & !f:((?i.?o).?IO)
                            &   whl
                              ' ( !i:(?feat,?val) ?i
                                & (   !S
                                    :   ?
                                        ( !n
                                        . (? (!feat,~!val) ?.?)
                                        . ?
                                        )
                                        ?
                                  |     replace
                                      $ ( !WF
                                        . !n
                                        .   
                                          ' ( (   ?A
                                                  ($feat,$val)
                                                  ?Z
                                              . ?O
                                              )
                                            . ?IO
                                            )
                                        . ( 
                                          = (!A ? !Z.!O).!IO
                                          )
                                        )
                                    : ?WF
                                  )
                                )
                            &   whl
                              ' ( !o:(?feat,?val) ?o
                                & (   !S
                                    :   ?
                                        ( !n
                                        . (?.? (!feat,~!val) ?)
                                        . ?
                                        )
                                  |     replace
                                      $ ( !WF
                                        . !n
                                        .   
                                          ' ( ( ?I
                                              .   ?A
                                                  ($feat,$val)
                                                  ?Z
                                              )
                                            . ?IO
                                            )
                                        . (=(!I.!A ? !Z).!IO)
                                        )
                                    : ?WF
                                  )
                                )
                          |   replace$(!WF.!n.(=?).(=?))
                            : ?WF
                          )
                      )
                    )
                & !WF
            )
          & ( toolPattern
            =   pat tool lhs rhs lpat rpat Wf feats
              .   :?pat
                & !arg:(=?Wf)
                &   whl
                  ' ( (   '$Wf:(=?Wf (?tool.?feats))
                        & (   '$feats:(=?feats.?)
                            & '($feats.?):(=?feats)
                          | 
                          )
                        & (   :!pat
                            & '($tool.$feats)
                          | '(($tool.$feats) ()$pat)
                          )
                      |   '$Wf:(=?Wf %?lhs*%?rhs)
                        & "*"$('$lhs):(=?lpat)
                        & "*"$('$rhs):(=?rpat)
                        & (   :!pat
                            & '($lpat*$rpat)
                          | '($lpat*$rpat ()$pat)
                          )
                      )
                    : (=?pat)
                    )
                & '$pat
            )
          & "Same code, but a bit faster because of short names. (intensively used code!)"
          & ( "*"
            =   "#" "%" "[" "]" "(" ")" "-" "="
              .   :?"#"
                & !arg:(=?"-")
                &   whl
                  ' ( (   '$"-":(=?"-" (?"%".?"="))
                        & (   '$"=":(=?"=".?)
                            & '($"=".?):(=?"=")
                          | 
                          )
                        & ( :!"#"&'($"%".$"=")
                          | '(($"%".?) ()$"#")
                          )
                      |   '$"-":(=?"-" %?"["*%?"]")
                        & "*"$('$"["):(=?"(")
                        & "*"$('$"]"):(=?")")
                        & ( :!"#"&'($"("*$")")
                          | '($"("*$")" ()$"#")
                          )
                      )
                    : (=?"#")
                    )
                & '$"#"
            )
          & ( sameToolDifferentRoles
            =     delta Delta replac I O
                , simple tool tree
                , details flatlist updat
                , fx fy reps sx sy
              .   ( delta
                  =   this other L f v
                    .   !arg:(?this.?other)
                      & :?L
                      & (   !this
                          :   ?
                              ( (?f,?v)
                              & ( !other:? (!f,!v) ?
                                | (!f,!v) !L:?L
                                )
                              & ~
                              )
                              ?
                        | !L
                        )
                  )
                & ( Delta
                  =   AI AO BI BO
                    .   !arg:((?AI.?AO),(?BI.?BO))
                      & (delta$(!AI.!BI).delta$(!AO.!BO))
                  )
                & ( replac
                  =   t s r a b
                    .   !arg:(?t.?s,?r)
                      & ( !t:!s&!r
                        |   !t:%?a %?b
                          & replac$(!a.!s,!r) replac$(!b.!s,!r)
                        |   !t:(%?a,%?b)
                          & (replac$(!a.!s,!r),replac$(!b.!s,!r))
                        | !t
                        )
                  )
                & ( flatlist
                  =   p q
                    .     !arg
                        : ( @
                          . (?.?)
                          . (?,?) ?
                          . (?,?) ?
                          )
                      |   !arg:((?p,?q)|%?p %?q)
                        & flatlist$!p+flatlist$!q
                  )
                & ( updat
                  =     reps tool i o id
                      , od I O details A Z
                    .     !arg
                        : ( ?reps
                          . ?tool
                          . (?i.?o),(?id.?od)
                          . ?details
                          )
                      & (     !reps
                            : ?A (!tool.(?I.?O).!details) ?Z
                          &   !A
                              ( !tool
                              . (set$(!I !i !id).set$(!O !o !od))
                              . !details
                              )
                              !Z
                        |   ( !tool
                            . (set$(!i !id).set$(!o !od))
                            . !details
                            )
                            !reps
                        )
                  )
                &   map
                  $ ( ( 
                      =   
                        .   !arg:(?n,?tree)
                          & :?reps
                          & (   flatlist$!tree
                              :   ?
                                + ?*(?tool.?sx.?fx)
                                + ?
                                + ?*(!tool.?sy.?fy)
                                + ( ?
                                  &     updat
                                      $ ( !reps
                                        . !tool
                                        . !sx,Delta$(!fx,!fy)
                                        . !fx
                                        )
                                    : ?reps
                                  &     updat
                                      $ ( !reps
                                        . !tool
                                        . !sy,Delta$(!fy,!fx)
                                        . !fy
                                        )
                                    : ?reps
                                  & ~
                                  )
                            |     whl
                                ' (   !reps
                                    : (?tool.?simple.?details) ?reps
                                  &     replac
                                      $ ( !tree
                                        .   (!tool.?.!details)
                                          , (!tool.!simple.!details)
                                        )
                                    : ?tree
                                  )
                              & (!n,!tree)
                            )
                      )
                    . !arg
                    )
            )
          & ( saveio
            =   n i o x y
              .     !arg:(?n.?i.~(?.?):?o)
                  & (!n.(!i.!o).!i.!o)
                | !arg:%?x*%?y&saveio$!x*saveio$!y
                | !arg:(?x.OnE)&!arg
                |   !arg:?x_?y
                  & (saveio$!x)_(saveio$!y)
                | !arg
            )
          & !arg:?pipes
          & "pipes is an unnumbered list sorted on directly on full workflow tree."
          & :?workflowlist
          & 0:?n
          & log$"Create workflowlist from pipes"
          &   whl
            ' ( 1+!n:?n:<1000000
              & !pipes:%?pipe+?pipes
              &   saveio$(!n.enumerateToolsDetail$!pipe) !workflowlist
                : ?workflowlist
              )
          & ( !n:<1000000
            | "while enumerateToolsDetail: MAX NUMBER OF WORKFLOW OPERATIONS REACHED (1000000)"
            )
          & "workflowlist is numbered list of workflows, with equal branches not merged yet, and with I/O duplicated."
          & :?groupedworkflowlist
          & :?toolPlumbing
          & :?disambiguatedworkflowlist
          &   whl
            ' ( 1+!n:?n:<1000000
              & !workflowlist:(#?nr.?workflow) ?workflowlist
              &   toolPattern$(simplify$!workflow)
                : (=?toolPlumbing)
              & (!nr,!workflow):?wfs
              &     map
                  $ ( ( 
                      =   
                        .     !arg:(#?nr.!toolPlumbing:?wf)
                            & 1+!n:?n:<1000000
                            & (!nr,!wf) !wfs:?wfs
                            & 
                          | !arg
                      )
                    . !workflowlist
                    )
                : ?workflowlist
              & '$toolPlumbing:?toolPlumbing
              & "The function disam spots the differences between workflows 
                 that have the same tools in the same structure: the 'smaller'
                 differences. For example, in the example below, (.app,nrm)
                 indicates that the workflow differs from another workflow as
                 to the appearance of the output, which is 'normalized', while
                 another workflow has e.g. 'unnormalized' output. The field
                 left of the dot is empty, which tells us that there is no
                 difference in the input.
                      ( JSON to ORG-mode converter
                      . (.app,nrm)
                      .   (ambig,pru)
                          (app,drty)
                          (facet,stlp^Menotas)
                          (format,json^xid)
                          (lang,da)
                          (period,c21)
                          (pres,nml)
                      .   (ambig,pru)
                          (app,nrm)
                          (facet,tlp^Menotas)
                          (format,dipl)
                          (lang,da)
                          (period,c21)
                          (pres,nml)
                      )"
              & "'sameToolDifferentRoles' does something similar to 'disam'.
                 Whereas 'disam' looks at different uses of the same tool in
                 different workflows, 'sameToolDifferentRoles' looks at
                 different uses of the same tool in the same workflow."
              &     sameToolDifferentRoles$(disam$(!toolPlumbing.!wfs))
                    !disambiguatedworkflowlist
                : ?disambiguatedworkflowlist
              )
          & log$disambiguatedworkflowlistCREATED
          & ( !n:<1000000
            | "while groupedworkflowlist: MAX NUMBER OF WORKFLOW OPERATIONS REACHED (1000000)"
            )
          & ( reorder$!disambiguatedworkflowlist
            . topologicalOrder$!disambiguatedworkflowlist
            )
      )
      ( Circle
      =   
        .   !arg:~#&!arg
          | ( strong
            .   
              ,     !arg:<128
                  & ( !arg:~<48&!arg+-48
                    | chr$!arg
                    )
                | chu$!arg
            )
      )
      ( SpotInput
      =   spotInput subt diff
        .   ( subt
            =   plus A f v a x y z
              .   !arg:(?plus.?A)
                &   whl
                  ' ( !A:(?f,?v) ?A
                    & !plus:?a (!f,?x*!v*?y) ?z
                    & ( !x*!y:1
                      | !a (!f,!x*!y) !z:?plus
                      )
                    )
                & !plus
            )
          & ( diff
            =   plus minus A refs
              .   !arg:(?plus.?refs.?minus)
                & ( !minus:
                  |     whl
                      ' ( !minus:(? (?.?.?.?A),?minus)
                        & subt$(!plus.!A):?plus
                        )
                    & !minus:? (?.?.?.?A)
                    & subt$(!plus.!A):?plus
                  )
                & ( !refs:
                  |     whl
                      ' ( !refs:(? (?.?.?.?A),?refs)
                        & subt$(!plus.!A):?plus
                        )
                    & !refs:? (?.?.?.?A)
                    & subt$(!plus.!A):?plus
                  )
                & !plus
            )
          & ( spotInput
            =     max nrefs N A B spotting
                , refs inputs name P a N DATA
              .   !arg:?spotting
                & (     !arg
                      :   ?A
                          ((?name.?refs [?nrefs.?inputs.?):?B)
                    &   ( !name:&spotInput$!A
                        |   0:?nrefs
                          & 1:?max
                          & (   !inputs
                              :   ?
                                  ( ?
                                  ,   ?
                                    * ( [?P
                                      & !P:>!max:?max
                                      )
                                  )
                                  (?&~)
                            | 
                            )
                          & !A:?a
                          & 0:?N
                          & ( !a:
                            |   -1:?N
                              &   whl
                                ' ( !a:(?,?a)
                                  & !N+-1:?N
                                  )
                            )
                          & (   !max+!N+!nrefs:0
                              & spotInput$!A
                            |   diff$(!inputs..!A):?DATA
                              & (   !A:
                                  & (.‚àµ..!DATA)
                                | (spotInput$!A,(.‚àµ..!DATA))
                                )
                            )
                        )
                        !B
                  |   !arg:(?A,?B)
                    & (spotInput$!A,spotInput$!B)
                  | !arg
                  )
            )
          & spotInput$!arg
      )
      ( sum2list
      =   L E
        .   :?L
          &   whl
            ' ( !arg:%?E+?arg
              & (.!E) !L:?L
              )
          & :?arg
          & whl'(!L:%?E ?L&!E !arg:?arg)
          & !arg
      )
      ( makeWorkflowRadioButtons
      =     i Nsteps Ntools n o
          , toolPlumbing translateManyToHumanLanguage
          , abbR reorderedworkflowlist struct
          , toolsUsed topologicalOrderedTools candidateList
        .   ( translateManyToHumanLanguage
            =     description seqno struct abbrevs o
                , describeShort
              .   ( describeShort
                  =   describe circle nice arrow
                    .   ( circle
                        =   
                          .   !arg:~#&!arg
                            | ( strong
                              .   
                                ,     !arg:<128
                                    &   ":"
                                        (   !arg:~<48
                                          & !arg+-48
                                        | chr$!arg
                                        )
                                  | chu$!arg
                              )
                        )
                      & ( nice
                        =   i o
                          .   !arg:(?i.?o)
                            & inoutdesc$!i:?i
                            & inoutdesc$!o:?o
                            & ( :!i:!o
                              |   "("
                                  !i
                                  ( !i:
                                  | !o:
                                  | " ; "
                                  )
                                  !o
                                  ")"
                              )
                        )
                      & ( arrow
                        =   b i
                          .   !arg:(?arg.?b)
                            & !b:(?.?.?i.?) ?
                            & ( div
                              .   (class.tooltip)
                                ,   ( !arg:1&" ‚Üí "
                                    | !arg:2&" ‚áí "
                                    | !arg:3&" ‚áõ "
                                    | " ‚≠Ü "
                                    )
                                    ( span
                                    .   (class.tooltiptext)
                                      , fullinoutdesc$!i
                                    )
                              )
                        )
                      & ( describe
                        =   a b c m n an bn cn h L tit
                          .   !arg:(?h.?arg)
                            & (   !arg:(?a,?b)
                                & describe$(.!a):(?L.?an)
                                &   whl
                                  ' ( !b:(?c,?b)
                                    &     !L
                                          "+"
                                          (   describe$(h.!c)
                                            : (?c.?cn)
                                          & !c
                                          )
                                      : ?L
                                    & !an+!cn:?an
                                    )
                                &     !L
                                      "+"
                                      ( describe$(h.!b):(?b.?bn)
                                      & !b
                                      )
                                  : ?L
                                & !an+!bn:?an
                                & (!L.!an)
                              |   !arg:%?a %?b
                                & describe$(.!a):(?a.?an)
                                & (       !a
                                          (   !a:(div.?,‚àµ ?)
                                            & 
                                          | arrow$(!an.!b)
                                          )
                                          (   describe$(.!b)
                                            : (?b.?bn)
                                          & !b
                                          )
                                      : ?c
                                    & ( !h:&!c
                                      | "[" !c "]"
                                      )
                                  . !bn
                                  )
                              |   !arg:(?m.?seqno.?n)
                                & ( !m::?tit
                                  |   !tooladm
                                    :   ?
                                      + ( ? (ToolID.!m) ?
                                        : ? (Title.?tit) ?
                                        )
                                      + ?
                                  )
                                & (   (   !tit:
                                        & (   !seqno:‚àµ
                                            & 
                                          | Circle$!seqno
                                          )
                                      | !tit circle$!seqno
                                      )
                                      (   !tit:
                                        & (   !seqno:‚àµ
                                            & !n:(?.?c)
                                            & ( !c:
                                              | ( div
                                                .   (class.tooltip)
                                                  ,   ‚àµ
                                                      ( span
                                                      .   (class.tooltiptext)
                                                        , fullinoutdesc$!c
                                                      )
                                                )
                                              )
                                          | 
                                          )
                                      |   !abbrevs:?*(!m.!n)^?n*?
                                        & nice$!n
                                      )
                                  . 1
                                  )
                              )
                        )
                      & describe$(.!arg):(?arg.?)
                      & !arg
                  )
                & !arg:(?abbrevs.?struct)
                & SpotInput$!struct:?struct
                & describeShort$!struct:?description
                & (   !description:~
                    & !struct:? (?.?.?.?o)
                    &   !description
                        ( div
                        .   (class.tooltip)
                          ,   ‚à¥
                              ( span
                              . (class.tooltiptextL),inoutdesc$!o
                              )
                        )
                  |   log$"It seems that the input already matches your goal"
                    & log$(description !description)
                    & log$(struct !struct)
                    &   localized
                      $ ( "It seems that the input already matches your goal. Or we haven't enough information about the input. Use the back button to change your choice."
                          "Det ser ud til at inputtet allerede opfylder dit m√•l. Eller vi har ikke fundet de n√∏dvendige oplysninger om inputtet. Brug knappen \"Forrige\" for at √¶ndre dine valg."
                        )
                  )
            )
          & ( candidateList
            =     reorderedworkflowlist nsteps ntools
                , theUsedTools infoAboutTool toolRows transpose
                , currNsteps currNtools currToolPlumbing currToolsUsed2
                , hyperlinks nth thead toolSetID buttons
                , toolTable toolUsageList topologicalOrderedTools
              .   ( nsteps
                  =   
                    . p
                    .   
                      ,   "("
                          !arg
                          " "
                            localized
                          $ ( ( !arg:1&step
                              | steps
                              )
                              trin
                            )
                          ")"
                  )
                & ( ntools
                  =   below
                    .   !arg:(?arg.?below)
                      & ( p
                        .   !below:|(id.below)
                          , ( strong
                            .   
                              ,   (üó±|üíà)
                                  " "
                                  !arg
                                  " "
                                    localized
                                  $ (   !arg:1
                                      & tool v√¶rkt√∏j
                                    | tools v√¶rkt√∏jer
                                    )
                            )
                        )
                  )
                & ( theUsedTools
                  =   ID
                    .       !toolUsageList
                            (   str$(T (1+!toolSetID:?toolSetID))
                              : ?ID
                            . !arg
                            )
                        : ?toolUsageList
                      & (     map
                            $ ( ( 
                                =   
                                  .   !arg:(?.?arg)
                                    & ", " !arg
                                )
                              . !arg
                              )
                          : ", " ?arg
                        | 
                        )
                      & (p.(id.!ID),(strong.,!arg))
                  )
                & ( infoAboutTool
                  =   Description Title
                    .   !arg:(?arg.?Title)
                      &   !tooladm
                        :   ?
                          + ( ? (ToolID.!arg) ?
                            : ? (Description.?Description) ?
                            )
                          + ?
                      & ( div
                        .   (class.tooltip)
                          ,   !Title
                              ( span
                              . (class.tooltiptext),!Description
                              )
                        )
                  )
                & ( toolRows
                  =   tool tools row rows
                    .       !arg
                          : (%?tool ?tools.(?.?row) ?rows)
                        &   ( tr
                            .   
                              ,   (td.,infoAboutTool$!tool)
                                  map$((=.td.,!arg).!row)
                            )
                            toolRows$(!tools.!rows)
                      | 
                  )
                & ( transpose
                  =   L ID a
                    .   !arg:(?.) ?&
                      |       map
                            $ ( ( 
                                =   ID a
                                  .   !arg:(?ID.%?a ?arg)
                                    & (!a.!ID.!arg)
                                )
                              . !arg
                              )
                          : ?L
                        &   ( 
                            .   map
                              $ ( ( 
                                  =   
                                    .   !arg:(?arg.?)
                                      & !arg
                                  )
                                . !L
                                )
                            )
                              transpose
                            $ ( map
                              $ ( ( 
                                  =   
                                    .   !arg:(?.?arg)
                                      & !arg
                                  )
                                . !L
                                )
                              )
                  )
                &   !arg
                  : (?reorderedworkflowlist.?topologicalOrderedTools)
                & 0:?nth
                & (   !reorderedworkflowlist
                    : ((?currNsteps.?),?)+?
                  | 1:?currNsteps
                  )
                & :?currToolPlumbing:?currToolsUsed2
                & 0:?currNtools
                & :?toolUsageList
                & 0:?toolSetID
                &   sum2list$!reorderedworkflowlist
                  : ?reorderedworkflowlist
                &       map
                      $ ( ( 
                          =     Nsteps Ntools abbR nr
                              , struct toolPlumbing toolsUsed toolsUsed2
                            .     !arg
                                : ( 
                                  .   ( ?Ntools
                                      . ?toolsUsed
                                      . ?Nsteps
                                      . ?toolPlumbing
                                      . ?nr
                                      )
                                    , (?abbR.?struct)
                                  )
                              & toolID2title$!toolsUsed:?toolsUsed2
                              & 1+!nth:?nth
                              &   (   !nth:1
                                    & !Ntools:?currNtools
                                    & !toolsUsed2:?currToolsUsed2
                                    & !Nsteps:?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    &   (hr.,)
                                        (hr.,)
                                        ntools$(!Ntools.below)
                                        theUsedTools$!toolsUsed2
                                        nsteps$!Nsteps
                                  |     !Ntools
                                      : ~!currNtools
                                      : ?currNtools
                                    & !toolsUsed2:?currToolsUsed2
                                    & !Nsteps:?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    &   (hr.,)
                                        (hr.,)
                                        ntools$(!Ntools.)
                                        theUsedTools$!toolsUsed2
                                        nsteps$!Nsteps
                                  |     !toolsUsed2
                                      : ~!currToolsUsed2
                                      : ?currToolsUsed2
                                    & !Nsteps:?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    &   (hr.,)
                                        theUsedTools$!toolsUsed2
                                        nsteps$!Nsteps
                                  |     !Nsteps
                                      : ~!currNsteps
                                      : ?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    & nsteps$!Nsteps
                                  |     !toolPlumbing
                                      : ~!currToolPlumbing
                                      : ?currToolPlumbing
                                    & 
                                  | 
                                  )
                                  !nth
                                  \r\n
                                  ( input
                                  .     (type.submit)
                                        (name.str$(bview- !nth))
                                        (value.üîç)
                                    , 
                                  )
                                  \r\n
                                  ( input
                                  .     (type.submit)
                                        (name.str$(bsubmit- !nth))
                                        (value.‚ñ∫)
                                    , 
                                  )
                                  \r\n
                                    translateManyToHumanLanguage
                                  $ (!abbR.!struct)
                                  (br.,)
                                  (br.,)
                          )
                        . !reorderedworkflowlist
                        )
                      (br.,)
                  : ?buttons
                &   (       map
                          $ ( ( 
                              =   ID cur
                                .   !arg:(?ID.?cur)
                                  & ( !ID
                                    .   map
                                      $ ( ( 
                                          =   
                                            .     !cur:? !arg ?
                                                & (‚óº|‚ñ†)
                                              | " "
                                          )
                                        . !topologicalOrderedTools
                                        )
                                    )
                              )
                            . !toolUsageList
                            )
                        : ?toolTable
                      & (   !toolUsageList:? [>1
                          &   ( thead
                              .   
                                , ( tr
                                  .   
                                    ,   ( th
                                        .   
                                          ,     localized
                                              $ (tools v√¶rkt√∏jer)
                                              ü†ì
                                              ( 
                                              |   " ‚ßπ "
                                                  localized$hyperlinks
                                                  ü†í
                                              )
                                        )
                                        (     map
                                            $ ( ( 
                                                =   ID
                                                  .   !arg:(?ID.?)
                                                    & ( th
                                                      .   
                                                        , ( a
                                                          .   ( href
                                                              . str$("#" !ID)
                                                              )
                                                            , ‚¨á
                                                          )
                                                      )
                                                )
                                              . !toolTable
                                              )
                                          : ?hyperlinks
                                        & 
                                        )
                                  )
                              )
                            : ?thead
                        | 
                        )
                      & transpose$!toolTable:?toolTable
                      &   ( table
                          .   (id.t01)
                            ,   (   !toolUsageList:? [>1
                                  & !thead
                                | 
                                )
                                ( tbody
                                .   
                                  ,   toolRows
                                    $ (!topologicalOrderedTools.!toolTable)
                                )
                                (   !toolUsageList:? [>1
                                  & ( thead
                                    .   
                                      , ( tr
                                        .   
                                          ,   ( th
                                              .   
                                                ,   ( 
                                                    |     localized
                                                        $ (tools v√¶rkt√∏jer)
                                                        ü†ë
                                                        " ‚ß∏ "
                                                    )
                                                    localized$hyperlinks
                                                    ü†í
                                              )
                                              !hyperlinks
                                        )
                                    )
                                | 
                                )
                          )
                          ( p
                          .   
                            ,   (br.,)
                                  localized
                                $ ( "Move the mouse pointer over the tool names for a short explanation of what the tool does."
                                    "Du f√•r en kort forklaring for hvert v√¶rkt√∏j ved at flytte musepilen over v√¶rkt√∏jets navn."
                                  )
                                (br.,)
                                  localized
                                $ ( "Click on the hyperlink for the preferred tools, and find all workflows that can be generated by the tools."
                                    "Klik p√• hyperlinket for de v√¶rkt√∏jer som du foretr√¶kker, og se alle arbejdgange med disse v√¶rkt√∏jer."
                                  )
                                (br.,)
                                  localized
                                $ ( "Select a workflow by pressing a üîç (View details) or ‚ñ∫ (Submit) button."
                                    "V√¶lg en arbejdsgang ved at trykke p√• üîç (Se detaljer) eller ‚ñ∫ (Submit)."
                                  )
                          )
                    | 
                    )
                    !buttons
            )
          & !arg:(?reorderedworkflowlist.?topologicalOrderedTools)
          &   toolID2title$!topologicalOrderedTools
            : ?topologicalOrderedTools
          & candidateList$(!reorderedworkflowlist.!topologicalOrderedTools)
      )
      ( makeWorkflowVisualisation
      =   n o struct translateOneToHumanLanguage
        .   ( translateOneToHumanLanguage
            =   description seqno struct o describeLong
              .   ( describeLong
                  =   describe simplearrow
                    .   ( simplearrow
                        =   b i
                          .   !arg:(?arg.?b)
                            & !b:(?.?.?i.?) ?
                            & ( !arg:1&" ‚Üí "
                              | !arg:2&" ‚áí "
                              | !arg:3&" ‚áõ "
                              | " ‚≠Ü "
                              )
                        )
                      & ( describe
                        =   a b c m n an bn cn h L tit
                          .   !arg:(?h.?arg)
                            & (   !arg:(?a,?b)
                                & describe$(.!a):(?L.?an)
                                &   whl
                                  ' ( !b:(?c,?b)
                                    &     !L
                                          (dt.,"+")
                                          (   describe$(h.!c)
                                            : (?c.?cn)
                                          & !c
                                          )
                                      : ?L
                                    & !an+!cn:?an
                                    )
                                &     !L
                                      (dt.,"+")
                                      ( describe$(h.!b):(?b.?bn)
                                      & !b
                                      )
                                  : ?L
                                & !an+!bn:?an
                                & (!L.!an)
                              |   !arg:%?a %?b
                                & describe$(.!a):(?a.?an)
                                & (       (dd.,(dl.,!a))
                                          (dt.,simplearrow$(!an.!b))
                                          (   describe$(.!b)
                                            : (?b.?bn)
                                          & !b
                                          )
                                      : ?c
                                    & ( !h:&!c
                                      | (dt.,"[") !c (dt.,"]")
                                      )
                                  . !bn
                                  )
                              |   !arg:(?m.?seqno.?n)
                                & ( !m::?tit
                                  |   !tooladm
                                    :   ?
                                      + ( ? (ToolID.!m) ?
                                        : ? (Title.?tit) ?
                                        )
                                      + ?
                                  )
                                & (   ( dt
                                      .   
                                        ,   (   Circle$!seqno
                                              : ?c
                                              : 
                                            |   !c
                                                ( !tit:
                                                | "-"
                                                )
                                            )
                                            !tit
                                      )
                                      (   !seqno:~‚àµ
                                        & !tit:
                                      |   !n:(?.?c)
                                        & ( !c:
                                          | (dd.,fullinoutdescTable$!c)
                                          )
                                      )
                                  . 1
                                  )
                              )
                        )
                      & describe$(.!arg):(?arg.?)
                      & (dl.,!arg)
                  )
                & !arg:?struct
                & SpotInput$!struct:?struct
                & describeLong$!struct:?description
                & (   !description:~
                    &   !struct
                      : ( ? (?.?.?.?o)
                        | (? (?.?.?.?o),?)
                        )
                    & !description
                  |   localized
                    $ ( "It seems that the input already matches your goal. Or we haven't enough information about the input. Use the back button to change your choice."
                        "Det ser ud til at inputtet allerede opfylder dit m√•l. Eller vi har ikke fundet de n√∏dvendige oplysninger om inputtet. Brug knappen \"Forrige\" for at √¶ndre dine valg."
                      )
                  )
            )
          & translateOneToHumanLanguage$!arg (br.,)
      )
      ( makePasswordFormField
      =   text parm desc size required
        .     !arg
            : ( ?text
              . ?parm
              .   ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (size.?size) ?
                  | ?&:?size
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( !required:
              | (span.(class.requiblue),!required)
              )
              (span.,!text)
              \r\n
              ( input
              .     (tabindex.1+!tabind:?tabind)
                    (type.password)
                    (name.!parm)
                    (value.)
                    (!desc:|(title.!desc))
                    (!size:|(size.!size))
                , 
              )
              \r\n
      )
      ( makeSelectFormField
      =   text parm options desc required
        .     !arg
            : ( ?text
              . ?parm
              .   ? (options.?options) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( label
              .   
                ,   !text
                    ( !required:
                    | " " (span.(class.requiblue),!required)
                    )
              )
              \r\n
              ( select
              .     (tabindex.1+!tabind:?tabind)
                    (name.!parm)
                    (!desc:|(title.!desc))
                , \r\n !options
              )
              \r\n
      )
      ( submit
      =   button
        .   !arg:?button
          &   ( input
              .     (type.submit)
                    (tabindex.1+!tabind:?tabind)
                    (name.bsubmit)
                    (value.!button)
                , 
              )
              \r\n
      )
      ( Style
      =   ( style
          .   
            ,   \r\n
                ( ".bodycanvas {background: linear-gradient(179deg, rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204));background-repeat: no-repeat;}"
                | ".bodycanvas {background: linear-gradient(rgb(254,254,254), rgba(0,210,255,0.2));background-repeat: no-repeat;}"
                )
                \r\n
                "a:link, a:visited {color: #000;}"
                \r\n
                "a, dd, dt, label, h1, h2, h3, span, p, td, input, legend, textarea, li {font-family:"
                (   !TyPeFaCe:sans-serif
                  & "Calibri,WorkSans,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,sans-serif,Comic Sans MS"
                | "Comic Sans MS,Calibri,WorkSans,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,sans-serif"
                )
                ";text-rendering: optimizeLegibility;line-height: 1.4;}"
                \r\n
                "div.canvasdiv {margin:0px auto;width:55em;text-align:left;}"
                \r\n
                "input { font-size: 12pt; }"
                \r\n
                "textarea {font-size: 10pt;}"
                \r\n
                "ol li {font-size: 10pt;}"
                \r\n
                "legend.firstpage {font-weight: bold;}"
                \r\n
                "legend.secondpage {border:none;color:black;background-color:rgba(154,186,206,0.6);text-align:left;display:block;margin:0;padding:10px;float:left;width:100%;position:relative;font-size:15px;}"
                \r\n
                ".required {color:red; font-size:90%;width: auto; line-height: normal;}"
                \r\n
                ".requiblue {color:blue; font-size:90%;width: auto; line-height: normal;}"
                \r\n
                "p {margin: 0}"
                \r\n
                "p.indent {text-indent: 20px}"
                \r\n
                "#t01 tr:nth-child(2n+0) { background-color: #eee; }"
                \r\n
                "*:target {background: yellow;}"
                \r\n
                "body { font-size: 100%; }"
                \r\n
                ".formRounded input[type='submit'] {color:#FFFFFF; background-color:#5d9cec; border-color:#68A9fb; text-align:center; vertical-align:middle; cursor:pointer; border:1px solid black; padding:6px 6px; font-size:14px; border-radius:4px; }"
                \r\n
                "fieldset {padding: 10px;border-style: solid;border-radius: 5px;}"
                \r\n
                "fieldset.noborder {padding: 10px; border-style: none;}"
                \r\n
                "tr.specialrow {background-color: #ddd;}"
                \r\n
                "td.textareawide {width:70%}"
                \r\n
                ".smallmargin {margin-top:0.5em; margin-bottom:0.5em;}"
                \r\n
                ".fileupload {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                ".typein {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                ".URLs {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                "label.firstpage {font-weight: bold; display: block; width: 250px; float: left; padding-left: 9px;}"
                \r\n
                "div.topmargin label.firstpage  {font-weight: bold; display: block; width: 250px; float: left; padding-left: 19px;}"
                \r\n
                "label.firstpage:after { content: ' ' }"
                \r\n
                ".alt {padding: 10px;}"
                \r\n
                "/* Tooltip container */"
                \r\n
                ".tooltip { position: relative; display: inline-block; border-bottom: 1px dotted black; /* If you want dots under the hoverable text */ }"
                \r\n
                "/* Tooltip text */"
                \r\n
                ".tooltip .tooltiptext  { visibility: hidden; width: 330px; background-color: #555; color: #fff; text-align: left; padding: 5px 10px; border-radius: 6px; /* Position the tooltip text */ position: absolute; z-index: 1; bottom: 125%; left:  0%; margin-left: 0px; /* Fade in tooltip */ opacity: 0; transition: opacity 0.3s; }"
                \r\n
                ".tooltip .tooltiptextL { visibility: hidden; width: 220px; background-color: #555; color: #fff; text-align: left; padding: 5px 10px; border-radius: 6px; /* Position the tooltip text */ position: absolute; z-index: 1; bottom: 125%; right: 0%; margin-left: 0px; /* Fade in tooltip */ opacity: 0; transition: opacity 0.3s; }"
                \r\n
                "/* Tooltip arrow */"
                \r\n
                ".tooltip .tooltiptext::after, .tooltip .tooltiptextL::after { position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #555 transparent transparent transparent; }"
                \r\n
                "/* Show the tooltip text when you mouse over the tooltip container */"
                \r\n
                ".tooltip:hover .tooltiptext,.tooltip:hover .tooltiptextL { visibility: visible; opacity: 1; }"
                \r\n
                "div.row{display:table-row;} .row * {vertical-align: middle;} .row label{display: table-cell; text-align: right; padding: 5px;} span.autogen{font-style:italic; width:auto; display: table-cell; text-align: left; padding: 5px;} .row input{display: table-cell;} .row textarea{display: table-cell;} span.required{width: 20px;}"
                \r\n
                ".italics {font-style:italic; width:auto;}"
                \r\n
                ".overflowing {overflow:auto;}"
                \r\n
                ".rightfloating {float:right;}"
                \r\n
                ".leftfloating {float:left;}"
                \r\n
                ".topmargin {margin-top:10px;}"
                \r\n
                ".smallfont {font-size:small}"
                \r\n
                "#wrapper {width: 100%; overflow: hidden;}"
                \r\n
                "#left {width: 500px; float: left;}"
                \r\n
                "#content {margin-left: 620px;}"
                \r\n
                "}"
          )
          \r\n
      )
      ( StyleFront
      =   ( style
          .   
            ,   \r\n
                ( ".bodycanvas {background: linear-gradient(181deg, rgb(0,91,188),rgb(0,91,188),rgb(0,91,188),rgb(0,91,188),rgb(0,91,188),rgb(0,91,188), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0), rgba(255,214,0));background-repeat: no-repeat;}"
                | ".bodycanvas {background: linear-gradient(179deg, rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255),rgb(204,228,255), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204), rgba(255,246,204));background-repeat: no-repeat;}"
                | ".bodycanvas {background: linear-gradient(rgb(254,254,254), rgba(0,210,255,0.2));background-repeat: no-repeat;}"
                )
                \r\n
                "a:link, a:visited {color: #000;}"
                \r\n
                "a, dd, dt, label, h1, h2, h3, span, p, td, input, legend, textarea, li {font-family:"
                (   !TyPeFaCe:sans-serif
                  & "Calibri,WorkSans,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,sans-serif,Comic Sans MS"
                | "Comic Sans MS,Calibri,WorkSans,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Helvetica,Arial,sans-serif"
                )
                ";text-rendering: optimizeLegibility;line-height: 1.4;}"
                \r\n
                "div.canvasdiv {margin:0px auto;width:55em;text-align:left;}"
                \r\n
                "input { font-size: 12pt; }"
                \r\n
                "textarea {font-size: 10pt;}"
                \r\n
                "ol li {font-size: 10pt;}"
                \r\n
                "legend.firstpage {font-weight: bold;}"
                \r\n
                "legend.secondpage {border:none;color:black;background-color:rgba(154,186,206,0.6);text-align:left;display:block;margin:0;padding:10px;float:left;width:100%;position:relative;font-size:15px;}"
                \r\n
                ".required {color:red; font-size:90%;width: auto; line-height: normal;}"
                \r\n
                ".requiblue {color:blue; font-size:90%;width: auto; line-height: normal;}"
                \r\n
                "p {margin: 0}"
                \r\n
                "p.indent {text-indent: 20px}"
                \r\n
                "#t01 tr:nth-child(2n+0) { background-color: #eee; }"
                \r\n
                "*:target {background: yellow;}"
                \r\n
                "body { font-size: 100%; }"
                \r\n
                ".formRounded input[type='submit'] {color:#FFFFFF; background-color:#5d9cec; border-color:#68A9fb; text-align:center; vertical-align:middle; cursor:pointer; border:1px solid black; padding:6px 6px; font-size:14px; border-radius:4px; }"
                \r\n
                "fieldset {padding: 10px;border-style: solid;border-radius: 5px;}"
                \r\n
                "fieldset.noborder {padding: 10px; border-style: none;}"
                \r\n
                "tr.specialrow {background-color: #ddd;}"
                \r\n
                "td.textareawide {width:70%}"
                \r\n
                ".smallmargin {margin-top:0.5em; margin-bottom:0.5em;}"
                \r\n
                ".fileupload {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                ".typein {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                ".URLs {background-color:rgba(154,186,206,0.6);padding: 10px;}"
                \r\n
                "label.firstpage {font-weight: bold; display: block; width: 250px; float: left; padding-left: 9px;}"
                \r\n
                "div.topmargin label.firstpage  {font-weight: bold; display: block; width: 250px; float: left; padding-left: 19px;}"
                \r\n
                "label.firstpage:after { content: ' ' }"
                \r\n
                ".alt {padding: 10px;}"
                \r\n
                "/* Tooltip container */"
                \r\n
                ".tooltip { position: relative; display: inline-block; border-bottom: 1px dotted black; /* If you want dots under the hoverable text */ }"
                \r\n
                "/* Tooltip text */"
                \r\n
                ".tooltip .tooltiptext  { visibility: hidden; width: 330px; background-color: #555; color: #fff; text-align: left; padding: 5px 10px; border-radius: 6px; /* Position the tooltip text */ position: absolute; z-index: 1; bottom: 125%; left:  0%; margin-left: 0px; /* Fade in tooltip */ opacity: 0; transition: opacity 0.3s; }"
                \r\n
                ".tooltip .tooltiptextL { visibility: hidden; width: 220px; background-color: #555; color: #fff; text-align: left; padding: 5px 10px; border-radius: 6px; /* Position the tooltip text */ position: absolute; z-index: 1; bottom: 125%; right: 0%; margin-left: 0px; /* Fade in tooltip */ opacity: 0; transition: opacity 0.3s; }"
                \r\n
                "/* Tooltip arrow */"
                \r\n
                ".tooltip .tooltiptext::after, .tooltip .tooltiptextL::after { position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #555 transparent transparent transparent; }"
                \r\n
                "/* Show the tooltip text when you mouse over the tooltip container */"
                \r\n
                ".tooltip:hover .tooltiptext,.tooltip:hover .tooltiptextL { visibility: visible; opacity: 1; }"
                \r\n
                "div.row{display:table-row;} .row * {vertical-align: middle;} .row label{display: table-cell; text-align: right; padding: 5px;} span.autogen{font-style:italic; width:auto; display: table-cell; text-align: left; padding: 5px;} .row input{display: table-cell;} .row textarea{display: table-cell;} span.required{width: 20px;}"
                \r\n
                ".italics {font-style:italic; width:auto;}"
                \r\n
                ".overflowing {overflow:auto;}"
                \r\n
                ".rightfloating {float:right;}"
                \r\n
                ".leftfloating {float:left;}"
                \r\n
                ".topmargin {margin-top:10px;}"
                \r\n
                ".smallfont {font-size:small}"
                \r\n
                "#wrapper {width: 100%; overflow: hidden;}"
                \r\n
                "#left {width: 500px; float: left;}"
                \r\n
                "#content {margin-left: 620px;}"
                \r\n
                "}"
          )
          \r\n
      )
      (HTMLbodyContainer=XHTMLbodyContainer)
      ( XHTMLbodyContainer
      =   
        .   "iso-8859-1 and not utf-8, because of problematic handling of UTF-8 by JNI
             (Or rather Java, which uses UTF-16 and converts surrogate pairs to 6 bytes of UTF-8 !)"
          &   ("?"."xml version='1.0' encoding='iso-8859-1'")
              \r\n
              ( "!DOCTYPE"
              . " html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'"
              )
              \r\n
              ( html
              .     (xmlns."http://www.w3.org/1999/xhtml")
                    ("xml:lang".!LaNg)
                    (lang.!LaNg)
                ,   \r\n
                    ( head
                    . ,\r\n (title.,!headerTitle) \r\n !Style
                    )
                    \r\n
                    (body.(class.bodycanvas),!arg)
              )
              \r\n
      )
      ( XHTML-SVG-bodyContainer
      =   
        .   "iso-8859-1 and not utf-8, because of problematic handling of UTF-8 by JNI
             (Or rather Java, which uses UTF-16 and converts surrogate pairs to 6 bytes of UTF-8 !)"
          &   ("?"."xml version='1.0' encoding='UTF-8'")
              \r\n
              ( "!DOCTYPE"
              . " html PUBLIC '-//W3C//DTD XHTML 1.1 plus MathML 2.0 plus SVG 1.1//EN' 'http://www.w3.org/2002/04/xhtml-math-svg/xhtml-math-svg.dtd'"
              )
              \r\n
              ( html
              .     (xmlns."http://www.w3.org/1999/xhtml")
                    ("xmlns:svg"."http://www.w3.org/2000/svg")
                    ("xml:lang".!LaNg)
                    (lang.!LaNg)
                ,   \r\n
                    ( head
                    .   
                      ,   \r\n
                          (title.,!headerTitle)
                          \r\n
                          ( meta
                          .     (http-equiv.content-type)
                                (content."text/html; charset=UTF-8")
                            , 
                          )
                          \r\n
                          !Style
                    )
                    \r\n
                    (body.(class.bodycanvas),!arg)
              )
              \r\n
      )
      ( HTML-SVG-bodyContainer
      =   tit bod
        .     !arg:(?tit.?bod)
            &   ("!DOCTYPE"." html")
                ( html
                .   
                  ,   ( head
                      .   
                        ,   (title.,!tit)
                            ( meta
                            .     (http-equiv.content-type)
                                  (content."text/html; charset=UTF-8")
                              , 
                            )
                            \r\n
                            !Style
                            ( style
                            .   (type.text/css)
                              , ".demo div {float: left; clear: none;} .illustration {border: none;text-align: right;margin-left: 0;margin-right: auto;border-spacing: 0pt;font-size: 80%;font-family: Verdana, sans-serif;} .illustration td {margin-left: 0%;margin-right: 0%;border: 0px;padding: 0em;width: 3em;text-align: center;} caption {font-style: italic;} "
                            )
                      )
                      (body.,!bod)
                )
          | AAP
      )
      ( refreshingXHTMLbodyContainer
      =   seconds body URL
        .   !arg:(%?seconds ?URL.?body)
          &   ("?"."xml version='1.0' encoding='iso-8859-1'")
              \r\n
              ( "!DOCTYPE"
              . " html PUBLIC '-//W3C//DTD XHTML 1.0 Strict//EN' 'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd'"
              )
              \r\n
              ( html
              .     (xmlns."http://www.w3.org/1999/xhtml")
                    ("xml:lang".!LaNg)
                    (lang.!LaNg)
                ,   \r\n
                    ( head
                    .   
                      ,   \r\n
                          (title.,!headerTitle)
                          \r\n
                          ( meta
                          .     (http-equiv.refresh)
                                ( content
                                .   str
                                  $ ( !seconds
                                      (!URL:|"; " !URL)
                                    )
                                )
                            , 
                          )
                          \r\n
                          !Style
                    )
                    \r\n
                    (body.(class.bodycanvas),!body)
              )
              \r\n
      )
      ( atts
      =   name value
        .     !arg:(?name,?value) ?arg
            & (!name.!value) atts$!arg
          | 
      )
      ( Table
      =   attributes heading content
        .   !arg:(?attributes.?heading.?content)
          &   ( table
              .   atts$!attributes
                , (thead.,!heading) \r\n (tbody.,!content)
              )
              \r\n
      )
      (row=.(tr.,!arg) \r\n)
      (cell=.td.,!arg)
      ( xml-id
      =   car cdr
        .   str
          $ ( ( @(!arg:%@?car ?cdr)
              &   str
                $ ( (!car:!NCNameStartChar|A !car)
                      vap
                    $ ( (=.!arg:!NCName|"_")
                      . !cdr
                      )
                  )
              )
              !tabind
            )
      )
      ( makeOptionList
      =   table aBbR full selected prefix stable
        .     !arg
            : ( ?table
              .   (?selected.?prefix)
                | ?selected&:?prefix
              )
          &     map
              $ ( ( 
                  =   f a
                    .   !arg:(?f.(?a.?)|?a)
                      & (low$(localized$!f:?f).!f.!a)
                  )
                . !table
                )
            : ?stable
          & ( !stable:? [<5
            | sort$!stable:?stable
            )
          &   ( option
              .   (id.str$(b !tabind)) (value.)
                , chu$8239
              )
              \r\n
                map
              $ ( ( 
                  =   
                    .   !arg:(?.?full.?aBbR)
                      &   ( option
                          .     (id.xml-id$!aBbR)
                                (value.str$(!prefix !aBbR))
                                (   !selected:!aBbR
                                  & (selected.selected)
                                | 
                                )
                            , !full
                          )
                          \r\n
                  )
                . !stable
                )
      )
      ( makeOptgroupList
      =     featTbl aBbR full selected prefix stable
          , valueExpandedListPairs hum
        .     !arg
            : ( ?valueExpandedListPairs,?featTbl
              .   (?selected.?prefix)
                | ?selected&:?prefix
              )
          & ( hum
            =   L a e H
              .   :?L
                &   whl
                  ' ( !arg:%?a*?arg
                    & !a:%@?a^?e
                    & !featTbl:? (?H.!a.?) ?
                    & (!e:1|)
                    & !L ", " localized$!H:?L
                    )
                & !L:", " ?L
                & !L
            )
          &     ( option
                .   (id.str$(b !tabind)) (value.)
                  , chu$8239
                )
                \r\n
                  map
                $ ( ( 
                    =   f a F exp
                      .   !arg:(?F.?exp)
                        & !featTbl:? (?f.!F.?) ?
                        & ( optgroup
                          .   (label.low$(localized$!f))
                            ,   map
                              $ ( ( 
                                  =   
                                    .   ( option
                                        .     (id.xml-id$!arg)
                                              (value.str$(!prefix !arg))
                                              (   !selected:!arg
                                                & (selected.selected)
                                              | 
                                              )
                                          , str$(hum$!arg)
                                        )
                                        \r\n
                                  )
                                . !exp
                                )
                          )
                    )
                  . !valueExpandedListPairs
                  )
            : ?stable
          & !stable
      )
      ( listToThreeColumnTable
      = .map$((=.low$!arg.!arg.xml-id$!arg).!arg)
      )
      ( makeOptionListSimple
      =   idval full stable prefix
        .   !arg:(?stable.?prefix)
          & ( !stable:? [<5
            | sort$!stable:?stable
            )
          &   ( option
              .   (id.str$(b !tabind)) (value.)
                , chu$8239
              )
              \r\n
                map
              $ ( ( 
                  =   
                    .   !arg:(?.?full.?idval)
                      &   ( option
                          . (id.!idval) (value.!full),!full
                          )
                          \r\n
                  )
                . !stable
                )
      )
      "
/**
 * uploadJobNr
 * 
 * Return the string preceding the hyphen in the input.
 *
 * Input: <jobNr>-<jobID>
 *
 * Called from upload.java
 */"
      ( uploadJobNr
      =   jobID jobNr
        .   "analyze the job parameter. It tells to which job the sent file belongs."
          & !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
          & !jobNr
      )
      ( uploadJobID
      =   jobID jobNr
        .   "analyze the job parameter. It tells to which job the sent file belongs."
          & !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
          & !jobID
      )
      "
/**
 * upload
 *
 * Make a waiting job non-waiting upon receipt of a result from an 
 * asynchronous tool.
 *
 * Analyze the job parameter. It tells to which job the sent file belongs.
 * The jobs table knows the file name and location for the uploaded file.
 *              (Last field)
 * Input:
 *      List of HTTP request parameters.
 *      One of the parameters must be (job.<jobNr>-<jobID>)
 *
 * Output:
 *      The file name that must be given to the received file when saved in
 *      the staging area.
 *
 * Status codes:
 *      200     ok
 *      400     'job' parameter does not contain hyphen '-' or
 *              'job' parameter missing altogether.
 *      404     Job is not expecting a result (job is not waiting)
 *              Job is unknown
 *      500     Job list could not be read
 *
 * Affected tables:
 *      jobs.table
 *
 * Called from upload.java
 */"
      ( upload
      =     jobNr jobID jobstatus JOB
          , A Z files toolURL parms file
        .     !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
            & (   readTable$jobs
                & (     !jobs
                      :   ?A
                          ( !jobNr
                          . !jobID ?jobstatus
                          . ?files
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                          ?Z
                    & (     !jobstatus
                          : (waiting|starting)
                        &     !A
                              ( !jobNr
                              . !jobID done
                              . !files
                              . !toolURL
                              . !parms
                              . !file
                              )
                              !Z
                          : ?jobs
                        & saveTable$jobs
                        & !file
                      |   str
                        $ ( "HTTP-status-code404upload$("
                            !arg
                            ") failed. Job "
                            !jobNr
                            "-"
                            !jobID
                            " is not expecting a result. Its current status is '"
                            !jobstatus
                            "'."
                          )
                      )
                  |   str
                    $ ( "HTTP-status-code404upload$("
                        !arg
                        ") failed. Job "
                        !jobNr
                        "-"
                        !jobID
                        " not found in joblist."
                      )
                  )
              |   str
                $ ( "HTTP-status-code500upload$("
                    !arg
                    ") failed. Joblist could not be read"
                  )
              )
          |   str
            $ ( "HTTP-status-code400upload$("
                !arg
                ") failed. "
                (   !arg:? (job.?JOB) ?
                  & ( @(!JOB:% "-" %)
                    | "'job' parameter value must contain a hyphen '-'. "
                    )
                | "'job' parameter missing. "
                )
              )
      )
      "
/**
 * parseStatusCode
 *
 * Find the number greater than 100 immediately following the string 
 * 'HTTP-status-code'
 *
 * Called from upload.java
 */"
      ( parseStatusCode
      =   
        .   @(!arg:HTTP-status-code (#>100:?arg) ?)
          & !arg
      )
      "
/**
 * parsemessage
 *
 * Find the text following the number greater than 100 immediately following the string 
 * 'HTTP-status-code'
 *
 * Called from upload.java
 */"
      ( parsemessage
      = .@(!arg:HTTP-status-code #>100 ?arg)&!arg
      )
      ( getShort
      =   feat full ABBR table
        .   !arg:(?feat.?full)
          & (     !features
                :   ?
                  + ( ? (short.!feat) ?
                    : ? (table.?table) ?
                    )
                  + ?
              & readTable$!table
              & !!table:? (? !full ?.?ABBR.?) ?
              & !ABBR
            | !full
            )
      )
      ( itemFeats
      =   feats
        .   !Uploads:? (?.!arg.?.?.?feats) ?
          & !feats
      )
      ( makeHiddenFields
      =   ret par val
        .   :?ret
          &   whl
            ' ( !arg:(?par.?globval) ?arg
              & @(lst$(globval,MEM,LIN):"globval=" ?val ";\n")
              &     !ret
                    ( input
                    .     (type.hidden)
                          (name.!par)
                          (value.!val)
                      , 
                    )
                : ?ret
              )
          & !ret
      )
      ( makeHiddenFields
      =   ret par val
        .   :?ret
          &   whl
            ' ( !arg:(?par.?val) ?arg
              &     !ret
                    ( input
                    .     (type.hidden)
                          (name.!par)
                          (value.str$!val)
                      , 
                    )
                : ?ret
              )
          & !ret
      )
      ( percentEncode
      =   c
        .     @(!arg:%@?c ?arg)
            & "%" d2x$(asc$!c) percentEncode$!arg
          | 
      )
      ( queryEncode
      =   
        .   str
          $ ( vap
            $ ( ( 
                =   
                  .   !arg:" "&"+"
                    |   !arg
                      : ( ~<a:~>z
                        | ~<A:~>Z
                        | ~<0:~>9
                        | "-"
                        | "_"
                        | "."
                        | "~"
                        )
                    | str$(percentEncode$!arg)
                )
              . !arg
              )
            )
      )
      ( changeloglink
      =   usedonly linktext offset title
        .   ( !arg:? (linktext.?linktext) ?
            | changelog √¶ndringer:?linktext
            )
          & ( !arg:? (offset.?offset) ?
            | :?offset
            )
          & ( !arg:? (title.?title) ?
            | :?title
            )
          & ( a
            .     ( href
                  .   str
                    $ ( "changelog?UIlanguage="
                        !LaNg
                        "&TyPeFaCe="
                          queryEncode
                        $ (!TyPeFaCe|"Comic Sans MS")
                        (!offset:|"#" !offset)
                      )
                  )
                  (!title:|(title.!title))
              , localized$!linktext
            )
      )
      ( helplink
      =   usedonly linktext offset title
        .   ( !arg:? (usedonly.?usedonly) ?
            | y:?usedonly
            )
          & ( !arg:? (linktext.?linktext) ?
            | help hj√¶lp:?linktext
            )
          & ( !arg:? (offset.?offset) ?
            | :?offset
            )
          & ( !arg:? (title.?title) ?
            | :?title
            )
          & ( a
            .     ( href
                  .   str
                    $ ( "help?UIlanguage="
                        !LaNg
                        "&usedonly="
                        !usedonly
                        "&TyPeFaCe="
                          queryEncode
                        $ (!TyPeFaCe|"Comic Sans MS")
                        (!offset:|"#" !offset)
                      )
                  )
                  (!title:|(title.!title))
              , localized$!linktext
            )
      )
      "
/**
 * update
 *
 * Create an HTML form that allows a user to choose a tool from a pick list.
 * The user must also fill out a password.
 *
 * The input can either be an empty string or two fields: a message to be 
 * displayed above the form and the name of a tool, which will then be 
 * selected when the browser shows the pick list.
 *
 * Called from update.java
 */"
      ( update
      =     L ToolID Title msg selected
          , contactEmail handle
          , passwordAsHandle
        .     0:?tabind
            & readTable$tooladm
            &   
              : ?msg
              : ?selected
              : ?contactEmail
              : ?handle
            & (!arg:? (msg.?msg) ?|)
            & ( !arg:? (selected.?selected) ?
              | 
              )
            & 
            & (   !arg
                : ? (passwordAsHandle.?passwordAsHandle) ?
              | (.):?passwordAsHandle
              )
            & ( !arg:? (contactEmail.?contactEmail) ?
              | 
              )
            & (!arg:? (handle.?handle) ?|)
            & :?L
            &   !tooladm
              :   ?
                + (   ? (ToolID.?ToolID) ?
                    : ? (Title.?Title) ?
                  & !L (!Title.!ToolID):?L
                  )
                + 0
            &   toML
              $ ( !HTMLbodyContainer
                $ ( (!msg:|paragraph$!msg)
                      form
                    $ ( register
                      .     paragraph
                          $ ( makeSelectFormField
                            $ (   localized
                                $ ("Choose a tool" "V√¶lg et v√¶rkt√∏j")
                              . name
                              .   (options.makeOptionList$(!L.!selected))
                                  (required."*")
                              )
                            )
                            paragraph
                          $ ( makePasswordFormField
                            $ (   localized
                                $ ( "Password (If you are not owner)"
                                    "Adgangskode (Hvis du ikke er \"ejer\")"
                                  )
                              . password
                              . desc
                              .   localized
                                $ ( "Use this field if you don't own the tool and the owner has given you the password. When you update the tool metadata, you become the new owner of the tool."
                                    "Brug feltet hvis du ikke er ejer af v√¶rkt√∏jet og du har f√•et adgangskoden fra ejeren. N√•r du opdaterer v√¶rkt√∏jsoplysningerne bliver du automatisk den nye ejer af v√¶rkt√∏jet."
                                  )
                              )
                            )
                          submit$next
                          helplink$(usedonly.n)
                            makeHiddenFields
                          $ ( (   !passwordAsHandle:(.)
                                & 
                              | (passwordAsHandle.!passwordAsHandle)
                              )
                              ( !contactEmail:
                              | (contactEmail.!contactEmail)
                              )
                              ( !handle:
                              | (handle.!handle)
                              )
                            )
                      . POST
                      )
                  )
                )
          | 
      )
      ( denumerizeSum
      =   A M Z
        .     whl
            ' ( !arg:(?A+#%*?M+?Z|?A+?M^#%+?Z)
              & !A+!M+!Z:?arg
              )
          & !arg
      )
      ( removeNumFactors
      =   A M Z
        .     whl
            ' ( !arg:?A+#%*?M+?Z
              & !A+!M+!Z:?arg
              )
          & !arg
      )
      "
/*
 * wrapper
 *
 * Generate a web service wrapper from tool metadata.
 * Usage: wrapper$(PHP.<toolID>)
 * (Other languages may be supported in the future.)
 */"
      ( wrapper
      =     combineToolIncarnations getBoilerPlate
          , getFeatName getFeatSpecTable getFeatTable listAlts
          , makeName DATA DATATEXT FEATURES FEATURETEXT Features
          , IO STYLES STYLETEXT basejobpost2 boilerPlate
          , boolfunc boolvar data declarations ech featname fname
          , fname1 fname2 fval helperFunctions httpparm iolist
          , lastWord mainfunc name o sptable stringfunc stringvar
          , toolParmTests toolprop value values var logInvalid
          , voidfunc i tooladm features svalues edata
          , getFeatValues toolid output TUPTUO reverselist
          , facets fileFormats linguae presentations combineFeats
        .   !arg:(?arg.?toolid)
          & :?TUPTUO
          & (output=.str$!arg !TUPTUO:?TUPTUO)
          & ( reverselist
            =   L E
              .   :?L
                &   whl
                  ' (!arg:%?E ?arg&!E !L:?L)
                & str$!L
            )
          & (   !arg:PHP
              &   "function "
                : ?stringfunc
                : ?boolfunc
                : ?voidfunc
              & "$":?stringvar:?boolvar:?var
              &     "<?php
header('Content-type:text/plain; charset=UTF-8');
/*
 * This "
                    !arg
                    " script is generated by CLARIN-DK's tool registration form 
 * (http://localhost/texton/register). It should, with no or few adaptations
 * work out of the box as a dummy for your web service. The output returned
 * to the CLARIN-DK workflow manager is just a listing of the HTTP parameters
 * received by this web service from the CLARIN-DK workflow manager, and not
 * the output proper. For that you have to add your code to this script and
 * deactivate the dummy functionality. (The comments near the end of this
 * script explain how that is done.)
 *
 * Places in this script that require your attention are marked 'TODO'.
 */
"
                : ?boilerPlate
              &   "    }
catch (SystemExit $e) 
    { 
    header('HTTP/1.0 404 An error occurred: ' . $ERROR);
    logit('An error occurred' . $ERROR);
    echo $ERROR;
    }
?>
"
                : ?lastWord
            |   !arg:java
              & "public String ":?stringfunc
              & "public bool ":?boolfunc
              & "public void ":?voidfunc
              & "String ":?stringvar
              & "bool ":?boolvar
              & :?var
              & :?boilerPlate:?lastWord
            )
          & ( listAlts
            =     alt featF opts rsr rsrc stl Stl alts
                , term DATA FEATURES STYLES rsrcs stls valstr
              .     !arg
                  : (?alts.?IO.?featname.?DATA.?FEATURES.?STYLES)
                &   whl
                  ' ( !alts:(%(%?alt ?opts):?term)+?alts
                    & (   (!alt:%*%|!opts:% ?)
                        & ( featF
                          =   IO featname rsr DATA
                            .   !arg:(?DATA.?IO.?featname.?rsr)
                              & (!IO.!featname.!rsr.F)+!DATA
                          )
                      | ( featF
                        = DATA.!arg:(?DATA.?)&!DATA
                        )
                      )
                    &   whl
                      ' ( !alt:%?rsrc*?alt
                        & 1:?stls
                        & ( !rsrc:@?rsr
                          |   (   !rsrc:(?rsrcs.OnE)
                                & :?valstr
                                &   whl
                                  ' ( !rsrcs:%?rsr*?rsrcs
                                    & !rsr:%@?rsr^?Stl
                                    & !valstr "_" !rsr:?valstr
                                    &   whl
                                      ' ( !Stl:%?stl+?Stl
                                        & ( !stl:1
                                          |     str$("__" !rsr "_" !stl)
                                              * !stls
                                            : ?stls
                                          )
                                        )
                                    )
                                & str$!valstr:?rsr
                              |   !rsrc:?rsr^%?Stl
                                &   whl
                                  ' ( !Stl:%?stl+?Stl
                                    & !stls*!stl:?stls
                                    )
                              )
                            &   (!IO.!featname.!rsr)\L!stls+!STYLES
                              : ?STYLES
                          )
                        & (!IO.!featname)\L!rsr+!FEATURES:?FEATURES
                        & featF$(!DATA.!IO.!featname.!rsr):?DATA
                        )
                    &   whl
                      ' ( !opts:%?rsrc ?opts
                        & (   !rsrc:?rsr^%?Stl
                            &   whl
                              ' ( !Stl:%?stl+?Stl
                                &   (!IO.!featname.!rsr)\L!stl+!STYLES
                                  : ?STYLES
                                )
                          | !rsrc:?rsr
                          )
                        & (!IO.!featname)\L!rsr+!FEATURES:?FEATURES
                        & (!IO.!featname.!rsr.F)+!DATA:?DATA
                        )
                    )
                & (!DATA.!FEATURES.!STYLES)
            )
          & ( makeName
            =   name camel c
              .   :?name
                & (camel=.!arg)
                &   whl
                  ' ( @(!arg:%?c ?arg)
                    &     (     !c
                              : ( ~<0:~>9
                                | "_"
                                | ~<a:~>z
                                | ~<A:~>Z
                                )
                            & camel$!c:?c
                            & (camel=.!arg)
                            & !c
                          | (camel=.upp$!arg)&
                          )
                          !name
                      : ?name
                    )
                & rev$(str$!name)
            )
          & readTable$toolprop
          & readTable$tooladm
          & readTable$fileFormats
          & readTable$facets
          & readTable$presentations
          & readTable$linguae
          & readTable$features
          & readTable$periods
          & ( getBoilerPlate
            =   id field val
              .   !arg:(?id.?field)
                &   !tooladm
                  :   ?
                    + ( ? (ToolID.!id) ?
                      : ? (!field.?val) ?
                      )
                    + ?
                & !val
            )
          & ( getFeatName
            =   fname
              .     !features
                  :   ?
                    + ( ? (short.!arg) ?
                      : ? (name.?fname) ?
                      )
                    + ?
                & localized$!fname
            )
          & ( getFeatTable
            =   table
              .     !features
                  :   ?
                    + ( ? (short.!arg) ?
                      : ? (table.?table) ?
                      )
                    + ?
                & !table
            )
          & ( getFeatValues
            =   featname value fval fvalAlt featTable
              .   !arg:(?featname.?value)
                & !(getFeatTable$!featname):?featTable
                &   (     !featTable
                        : ? (%?fval ? @?fvalAlt.!value.?) ?
                      &   !fval
                          (!fvalAlt:|" (" !fvalAlt ")")
                    |       vap
                          $ ( ( 
                              =   fval fvalAlt
                                .   !arg:
                                  |     !featTable
                                      :   ?
                                          (%?fval ? @?fvalAlt.!arg.?)
                                          ?
                                    &   " and "
                                        !fval
                                        ( !fvalAlt:
                                        | " (" !fvalAlt ")"
                                        )
                              )
                            . !value
                            . "_"
                            )
                        : (" and " ?value|?value)
                      & !value
                    )
                  : ?value
                & !value
            )
          & ( getFeatSpecTable
            =   table val
              .   !arg:(?arg.?val)
                &   !features
                  :   ?
                    + ( ? (short.!arg) ?
                      :   ?
                          ( specificationTable
                          . ? (? !val ?.?table) ?
                          )
                          ?
                      )
                    + ?
                & !table
            )
          & ( logInvalid
            =   fname1 fname2 toolid feats
              .   !arg:(?toolid.?feats)
                & (     !feats
                      :   ?
                          (?fname1,? (?+(%?*%? ?)+?.?) ?)
                          ?
                          (?fname2,? (?+(%?*%? ?)+?.?) ?)
                          ?
                    &   log
                      $ ( str
                        $ ( "Tool "
                            !toolid
                            ": inputs differ on two features: "
                            !fname1
                            " and "
                            !fname2
                            " in the same tool incarnation. This is currently not supported."
                          )
                        )
                  |     !feats
                      :   ?
                          (?fname1,? (?.?+(%*% ?)+?) ?)
                          ?
                          (?fname2,? (?.?+(%*% ?)+?) ?)
                          ?
                    &   log
                      $ ( str
                        $ ( "Tool "
                            !toolid
                            ": outputs differ on two features: "
                            !fname1
                            " and "
                            !fname2
                            " in the same tool incarnation. This is currently not supported."
                          )
                        )
                  | 
                  )
            )
          & ( combineFeats
            =   A B M Z b c
              .     whl
                  ' ( !arg:?A (?B,?b) ?M (!B,?c) ?Z
                    & !A (!B,!b+!c) !M !Z:?arg
                    )
                & !arg
            )
          & ( combineToolIncarnations
            =   featK toolprop toolid Feats featPair
              .   !arg:(?toolprop.?toolid)
                & :?Feats
                &   whl
                  ' ( !toolprop:?+(!toolid.?featK)+?toolprop
                    & logInvalid$(!toolid.!featK)
                    &   whl
                      ' ( !featK:%?featPair+?featK
                        & !featPair !Feats:?Feats
                        )
                    )
                & combineFeats$!Feats
            )
          & combineToolIncarnations$(!toolprop.!toolid):?Features
          & 0:?DATA
          & 0:?FEATURES
          & 0:?STYLES
          & (     !Features
                :   ?
                    ( facet
                    ,   ?+#*(?+(%*%|% %)+?.?)+?
                      : ?fval
                    )
                    ?
              & (     !fval
                    : ?+#*(?+(%@^?|(?.OnE))+?.?)+?
                  & "IF in some cases, IfeatvalF in other cases"
                  & (I...F)+!DATA:?DATA
                | "Never IF, always IfeatvalF"
                )
            |   "Always IF, never IfeatvalF"
              & (I...F)+!DATA:?DATA
            )
          & "Always OF, never OfeatvalF"
          & (O...F)+!DATA:?DATA
          &   whl
            ' ( !Features:(?fname,?iolist) ?Features
              &   whl
                ' ( !iolist:#*(?i.?o)+?iolist
                  &   listAlts$(!i.I.!fname.!DATA.!FEATURES.!STYLES)
                    : (?DATA.?FEATURES.?STYLES)
                  &   listAlts$(!o.O.!fname.!DATA.!FEATURES.!STYLES)
                    : (?DATA.?FEATURES.?STYLES)
                  )
              )
          &     "/*
ToolID         : "
                !toolid
                "
PassWord       : "
                getBoilerPlate$(!toolid.PassWord)
                "
Version        : "
                getBoilerPlate$(!toolid.Version)
                "
Title          : "
                getBoilerPlate$(!toolid.Title)
                "
Path in URL    : "
                  ( 
                  =   path
                    .   @( str$(getBoilerPlate$(!arg.ServiceURL))
                         : ? "://" ? "/" ?path
                         )
                      & !path
                  )
                $ !toolid
                \t
                "*** TODO make sure your web service listens on this path and that this script is readable for the webserver. ***
Publisher      : "
                getBoilerPlate$(!toolid.Publisher)
                "
ContentProvider: "
                getBoilerPlate$(!toolid.ContentProvider)
                "
Creator        : "
                getBoilerPlate$(!toolid.Creator)
                "
InfoAbout      : "
                getBoilerPlate$(!toolid.InfoAbout)
                "
Description    : "
                getBoilerPlate$(!toolid.Description)
                "
ExternalURI    : "
                getBoilerPlate$(!toolid.ExternalURI)
                "
XMLparms       : "
                getBoilerPlate$(!toolid.XMLparms)
                "
PostData       : "
                getBoilerPlate$(!toolid.PostData)
                "
Inactive       : "
                getBoilerPlate$(!toolid.Inactive)
                "
*/

/*******************
* helper functions *
*******************/
$toollog = '../log/"
                makeName$!toolid
                ".log'; /* Used by the logit() function. TODO make sure the folder exists and is writable. Adapt if needed */
                
/*  TODO Set $dodelete to false if temporary files in /tmp should not be deleted before returning. */
$dodelete = true;
$tobedeleted = array();


function loginit()  /* Wipes the contents of the log file! TODO Change this behaviour if needed. */
    {
    global $toollog,$ftemp;
    $ftemp = fopen($toollog,'w');
    if($ftemp)
        {
        fwrite($ftemp,$toollog . \"\\n\");
        fclose($ftemp);
        }
    }
    
function logit($str) /* TODO You can use this function to write strings to the log file. */
    {
    global $toollog,$ftemp;
    $ftemp = fopen($toollog,'a');
    if($ftemp)
        {
        fwrite($ftemp,$str . \"\\n\");
        fclose($ftemp);
        }
    }
    
class SystemExit extends Exception {}
try {
    "
                !boolfunc
                "hasArgument ("
                !stringvar
                "parameterName)
        {
        return isset($_REQUEST[\""
                !stringvar
                "parameterName\"]);
        }

    "
                !stringfunc
                "getArgument ("
                !stringvar
                "parameterName)
        {
        return isset($_REQUEST[\""
                !stringvar
                "parameterName\"]) ? $_REQUEST[\""
                !stringvar
                "parameterName\"] : \"\";
        }

    "
                !boolfunc
                "existsArgumentWithValue ("
                !stringvar
                "parameterName, "
                !stringvar
                "parameterValue)
        {
        /* Check whether there is an argument <parameterName> that has value 
           <parameterValue>. 
           There may be any number of arguments with name <parameterName> !
        */
        $query  = explode('&', $_SERVER['QUERY_STRING']);

        foreach( $query as $param )
            {
            list($name, $value) = explode('=', $param);
            if("
                !stringvar
                "parameterName == urldecode($name) && "
                !stringvar
                "parameterValue == urldecode($value))
                return true;
            }
        return false;
        }

    function tempFileName($suff) /* TODO Use this to create temporary files, if needed. */
        {
        global $dodelete;
        global $tobedeleted;
        $tmpno = tempnam('/tmp', $suff);
        if($dodelete)
            $tobedeleted[$tmpno] = true;
        return $tmpno;
        }
        
    function requestFile($requestParm) // e.g. \"IfacettokF\"
        {
        logit(\"requestFile({$requestParm})\");

        if(isset($_REQUEST[$requestParm]))
            {
            $urlbase = isset($_REQUEST[\"base\"]) ? $_REQUEST[\"base\"] : \"http://localhost/toolsdata/\";

            $item = $_REQUEST[$requestParm];
            $url = $urlbase . urlencode($item);
            logit(\"requestParm:$requestParm\");
            logit(\"urlbase:$urlbase\");
            logit(\"item:$item\");
            logit(\"url[$url]\");

            $handle = fopen($url, \"r\");
            if($handle == false)
                {
                logit(\"Cannot open url[$url]\");
                return \"\";
                }
            else
                {
                $tempfilename = tempFileName(\""
                makeName$!toolid
                "_{$requestParm}_\");
                $temp_fh = fopen($tempfilename, 'w');
                if($temp_fh == false)
                    {
                    fclose($handle);
                    logit(\"handle closed. Cannot open $tempfilename\");
                    return \"\";
                    }
                else
                    {
                    while (!feof($handle)) 
                        {
                        $read = fread($handle, 8192);
                        fwrite($temp_fh, $read);    
                        }
                    fclose($temp_fh);
                    fclose($handle);
                    return $tempfilename;
                    }
                }
            }
        logit(\"empty\");
        return \"\";
        }    
"
            : ?helperFunctions
          &     "
/***************
* declarations *
***************/

/*
 * TODO Use the variables defined below to configure your tool for the right 
 * input files and the right settings.
 * The input files are local files that your tool can open and close like any
 * other file.
 * If your tool needs to create temporary files, use the tempFileName() 
 * function. It can mark the temporary files for deletion when the webservice
 * is done. (See the global dodelete variable.)
 */
        "
                !stringvar
                "base = \"\";"
                \t
                "/* URL from where this web service downloads input. The generated script takes care of that, so you can ignore this variable. */
        "
                !stringvar
                "job = \"\";"
                \t
                "/* Only used if this web service returns 201 and POSTs result later. In that case the uploaded file must have the name of the job. */
        "
                !stringvar
                "post2 = \"\";"
                \t
                "/* Only used if this web service returns 201 and POSTs result later. In that case the uploaded file must be posted to this URL. */
        "
                !stringvar
                "echos = \"\";"
                \t
                "/* List arguments and their actual values. For sanity check of this generated script. All references to this variable can be removed once your web service is working as intended. */
"
            : ?declarations
          & :?toolParmTests
          &     "
        if( hasArgument(\"base\") )
            {
            "
                !var
                "base = getArgument(\"base\");
            }
        if( hasArgument(\"job\") )
            {
            "
                !var
                "job = getArgument(\"job\");
            }
        if( hasArgument(\"post2\") )
            {
            "
                !var
                "post2 = getArgument(\"post2\");
            }
        "
                !var
                "echos = \"base=$base job=$job post2=$post2 \";
"
            : ?basejobpost2
          & "
/*********
* input  *
*********/
":?DATATEXT
          &   whl
            ' ( !DATA:#*(?IO.?featname.?value.F)+?DATA
              & "Restriction: There is exactly one output file."
              &     (!featname:|I)
                    !featname
                    !value
                    F
                : ?httpparm
              & (   !IO:I
                  &     !declarations
                        "        "
                        !stringvar
                        !httpparm
                        " = \"\";"
                        \t
                        "/* "
                        ( Input
                          (   !featname:
                            & " (ONLY used if there is exactly ONE input to this workflow step)"
                          |   " with "
                              low$(getFeatName$!featname)
                              " "
                              getFeatValues$(!featname.!value)
                          )
                        )
                        " */\n"
                    : ?declarations
                  &     !DATATEXT
                        "        if( hasArgument(\""
                        !httpparm
                        "\") )
            {        
            "
                        !var
                        !httpparm
                        " = requestFile(\""
                        !httpparm
                        "\");
            if("
                        !var
                        !httpparm
                        " == '')
                {
                header(\"HTTP/1.0 404 Input "
                        ( !featname:
                        |   "with "
                            low$(getFeatName$!featname)
                            " '"
                            getFeatValues$(!featname.!value)
                            "' "
                        )
                        "not found ("
                        !httpparm
                        " parameter). \");
                return;
                }
            "
                        !var
                        "echos = "
                        !var
                        "echos . \""
                        !httpparm
                        "="
                        !var
                        !httpparm
                        " \";
            }
"
                    : ?DATATEXT
                | 
                )
              )
          &   "
/************************
* input/output features *
************************/
"
            : ?FEATURETEXT
          &   whl
            ' ( !FEATURES:#*(?IO.?data)\L?svalues+?FEATURES
              & ( 
                |   !declarations "    " !stringvar !IO !data " = \"\";\n"
                  : ?declarations
                )
              &     !FEATURETEXT
                    "        if( hasArgument(\""
                    !IO
                    !data
                    "\") )
            {
"
                : ?FEATURETEXT
              & :?ech
              &   whl
                ' ( !svalues:%?values+?svalues
                  &   whl
                    ' ( !values:%@?value^?*?values
                      &     !declarations
                            "        "
                            !stringvar
                            !IO
                            !data
                            !value
                            " = false;"
                            \t
                            "/* "
                            ( getFeatName$!data
                              " in "
                              ( !IO:I&input
                              | output
                              )
                              " is "
                              getFeatValues$(!data.!value)
                            )
                            " if true */
"
                        : ?declarations
                      &     !ech
                            " . \""
                            !IO
                            !data
                            !value
                            "="
                            !var
                            !IO
                            !data
                            !value
                            " \""
                        : ?ech
                      &     !FEATURETEXT
                            "            "
                            !var
                            !IO
                            !data
                            !value
                            " = existsArgumentWithValue(\""
                            !IO
                            !data
                            "\", \""
                            !value
                            "\");\n"
                        : ?FEATURETEXT
                      )
                  )
              &     !FEATURETEXT
                    "            "
                    !var
                    "echos = "
                    !var
                    echos
                    !ech
                    ";
            }
"
                : ?FEATURETEXT
              )
          &   "
/*******************************
* input/output features styles *
*******************************/
"
            : ?STYLETEXT
          &   whl
            ' ( !STYLES:#*(?IO.?featname.?data)\L?svalues+?STYLES
              &     !STYLETEXT
                    "        if( hasArgument(\""
                    !IO
                    !featname
                    !data
                    "\") )
            {
"
                : ?STYLETEXT
              & :?ech
              &   whl
                ' ( !svalues:%?values+?svalues
                  &   whl
                    ' ( !values:%@?value^?*?values
                      &     !ech
                            " . \""
                            !IO
                            !featname
                            !data
                            !value
                            "="
                            !var
                            !IO
                            !featname
                            !data
                            !value
                            " \""
                        : ?ech
                      &     !STYLETEXT
                            "            "
                            !stringvar
                            !IO
                            !featname
                            !data
                            !value
                            " = existsArgumentWithValue(\""
                            !IO
                            !featname
                            !data
                            "\", \""
                            !value
                            "\");\n"
                        : ?STYLETEXT
                      &     !declarations
                            "        "
                            !stringvar
                            !IO
                            !featname
                            !data
                            !value
                            " = false;"
                            \t
                            "/* Style of "
                            low$(getFeatName$!featname)
                            " "
                            getFeatValues$(!featname.!data)
                            " in "
                            ( !IO:I&input
                            | output
                            )
                            " is "
                            (     getFeatSpecTable$(!featname.!data)
                                : ?sptable
                              &   ( !!sptable
                                  |   readTable$!sptable
                                    & !!sptable
                                  )
                                : ?specTable
                              & (     !specTable
                                    : ? (?fval.!value.?) ?
                                  & !fval
                                | 
                                )
                            |   @(!value:"__" ?edata "_" ?value)
                              &   getFeatSpecTable$(!featname.!edata)
                                : ?sptable
                              &   ( !!sptable
                                  |   readTable$!sptable
                                    & !!sptable
                                  )
                                : ?specTable
                              &   (     !specTable
                                      : ? (?fval.!value.?) ?
                                    & !fval
                                  | 
                                  )
                                  " for the "
                                  getFeatValues$(!featname.!edata)
                                  " component"
                            )
                            " if true */
"
                        : ?declarations
                      )
                  )
              &     !STYLETEXT
                    "            "
                    !var
                    "echos = "
                    !var
                    echos
                    !ech
                    ";
            }
"
                : ?STYLETEXT
              )
          &   output
            $ ( !boilerPlate
                !helperFunctions
                "\n    "
                !voidfunc
                (str$("do_" makeName$!toolid):?mainfunc)
                "()
        {
        global $dodelete;
        global $tobedeleted;"
                !declarations
                !basejobpost2
                !DATATEXT
                !FEATURETEXT
                !STYLETEXT
                \n
                "//* DUMMY CODE TO SANITY CHECK GENERATED SCRIPT (TODO Remove one of the two solidi from the beginning of this line to activate your own code)"
                "\n        "
                !stringvar
                makeName$!toolid
                "file = tempFileName(\""
                makeName$!toolid
                "-results\");
        $command = \"echo $echos >> "
                !stringvar
                makeName$!toolid
                "file\";
        logit($command);

        if(($cmd = popen($command, \"r\")) == NULL)
            {
            throw new SystemExit(); // instead of exit()
            }

        while($read = fgets($cmd))
            {
            }

        pclose($cmd);
/*/
// YOUR CODE STARTS HERE.
//        TODO your code!
// YOUR CODE ENDS HERE. OUTPUT EXPECTED IN "
                !var
                makeName$!toolid
                "file
//*/
        $tmpf = fopen("
                !var
                makeName$!toolid
                "file,'r');

        if($tmpf)
            {
            //logit('output from "
                makeName$!toolid
                ":');
            while($line = fgets($tmpf))
                {
                //logit($line);
                print $line;
                }
            fclose($tmpf);
            }

        if($dodelete)
            {
            foreach ($tobedeleted as $filename => $dot) 
                {
                if($dot)
                    unlink($filename);
                }
            unset($tobedeleted);
            }
        }
    loginit();
    "
                !mainfunc
                "();\n"
                !lastWord
              )
          & reverselist$!TUPTUO
      )
      "
/**
  * register
  *
  * Register a tool - integrated or not.
  * Produces an initially empty html form that dynamically adapts to user's
  * need to register multiple values for the same feature.
  * The form consists of two parts: a part for general information, most of
  * which can be deposited in the repository in a later phase, and a part that
  * is mainly used for integrated tools. The second part collects very precise
  * and formalised information that enables the Tools module to compute
  * workflows with tools and resources that fit together. 
  *
  * Affected tables: 
  *         tooladm.table   (general part), 
  *         toolprop.table  (for integrated tools)
  * Input: a list of HTTP-parameters converted to the form 
  *     (<parameter>.<value>) (<parameter>.<value>) (<parameter>.<value>) ...
  *
  * Output: a XHTML-form
  *
  * Input and output form a closed circuit: the form is generated by the 
  * register function and the input from the filled-out form is sent to the
  * register function.
  *
  * Called from register.java
  */"
      ( register
      =     Metadata featureListing staticFields
          , ToolName ToolVersion FullToolName PassWord password
          , ToolURL ToolPublisher ContentProvider passwordAsHandle
          , ToolCreator InfoAbout ToolDescription mail2
          , ToolExternalURI ToolXMLparms aFeature askOptional
          , ToolPostData ToolInactive askOnE
          , additionalFormFields additionalMetadata
          , formFields storeTool handle
          , unfoldInputAndOutput foldInputAndOutput createFeatureFieldset
          , nth AA ZZ feats windfw ContactEmail contactEmail
          , featjursPreexisting featjursURL aboutFeature error Submit
          , createBoilerPlate force askFieldSet validationComments
          , storeToolButton replaceToolButton
          , deleteToolButton UpdateButton PHPbutton
        .   clean$
          & "createBoilerPlate fails if user is  granted access."
          & ( createBoilerPlate
            =     ToolName ToolVersion FullToolName
                , URL Publisher ContentProvider
                , Creator InfoAbout Description
                , ExternalURI XMLparms url-password
                , PostData Inactive pval toggles
                , liste a z urlparm var val like
                , PassWord url-ToolName
                , ContactEmail url-contactEmail
              .     ~(!arg:? (name.?) ?)
                  &   !arg
                    : ? (contactEmail.~:?url-contactEmail) ?
                  & "User hasn't specified a name yet, but email is known. This
                     generates a form independent of already registered tools."
                  & ( 
                    . 
                    . !url-contactEmail
                    . !arg (ml2.!url-contactEmail) (nctv.on)
                    )
                |   "Either the name http parameter is similar to an existing 
                     tool's name, or it is the name of a new tool."
                  & ( like
                    =   
                      .   sim$(trim$!sjt,trim$!arg):1
                        & ?
                    )
                  & "TODO RESET ALL OF urlparm IF TOOL NOT FOUND"
                  & !arg:?urlparm
                  &   !urlparm
                    : ? (name.?url-ToolName) ?
                    : ( ? (password.~:?url-password) ?
                      | ?&:?url-password
                      )
                    : ? (contactEmail.~:?url-contactEmail) ?
                  & :?ContactEmail
                  & (     !tooladm
                        :   ?
                          + (   ?
                                ( ToolID
                                .   like$!url-ToolName
                                  : ?ToolName
                                  : ?url-ToolName
                                )
                                ?
                            : ( ? (PassWord.?PassWord) ?
                              | ?
                              )
                            : ( ? (ContactEmail.?ContactEmail) ?
                              | ?
                              )
                            : ? (Version.?ToolVersion) ?
                            : ? (Title.?FullToolName) ?
                            : ? (ServiceURL.?URL) ?
                            : ? (Publisher.?Publisher) ?
                            : ? (ContentProvider.?ContentProvider) ?
                            : ? (Creator.?Creator) ?
                            : ? (InfoAbout.?InfoAbout) ?
                            : ? (Description.?Description) ?
                            : ? (ExternalURI.?ExternalURI) ?
                            : ? (XMLparms.?XMLparms) ?
                            : ? (PostData.?PostData) ?
                            : ? (Inactive.?Inactive) ?
                            )
                          + ?
                      & !urlparm:?a (name.?) ?z
                      & !a (name.!url-ToolName) !z:?urlparm
                      & "The name http parameter was similar to an existing tool's name.
                         Use the existing tool's name instead and fetch all that is known
                         about this tool."
                    |   "The name http parameter is not seen before, so 
                         we create an empty form for an inactive tool."
                      & !url-ToolName:?ToolName
                      & !url-contactEmail:?ContactEmail
                      &   
                        : ?PassWord
                        : ?url-password
                        : ?ToolVersion
                        : ?FullToolName
                        : ?URL
                        : ?Publisher
                        : ?ContentProvider
                        : ?Creator
                        : ?InfoAbout
                        : ?Description
                        : ?ExternalURI
                        : ?XMLparms
                        : ?PostData
                      & on:?Inactive
                    )
                  & ( !url-contactEmail:!ContactEmail
                    |   ( !url-password:!PassWord:~
                        | !PassWord:!ContactEmail:
                        )
                      & !url-contactEmail:?ContactEmail
                    )
                  & "You only are allowed to edit a tool that
                        1) is yours (email) 
                     or 2) you know the password for
                     or 3) has empty password AND email fields (orphan tool)
                     
                     The password is reset and the tool becomes yours."
                  &     (psswrd.)
                        (ml2.!ContactEmail)
                        (vrsion.!ToolVersion)
                        (fllNm.!FullToolName)
                        (pblshr.!Publisher)
                        (cntPrvdr.!ContentProvider)
                        (crtr.!Creator)
                        (docuri.!InfoAbout)
                        (url.!URL)
                        (dscrptn.!Description)
                        (xuri.!ExternalURI)
                    : ?liste
                  &     (xmlprms.!XMLparms)
                        (pstdt.!PostData)
                        (|(nctv.!Inactive))
                    : ?toggles
                  &   (     !urlparm
                          : ? (handle.?handle) ?
                          : ? (nth.?) ?
                        & "When the user enters the form, the list of http
                           parameters is still short:
                                 handle,contactEmail,name,password,bsubmit
                           A good indication that the user hasn't toggled
                           anything is the absence of the 'nth' parameter.
                           User's input value of Inactive overrules
                           registered input."
                        & ( !urlparm:? (nctv.?) ?
                          | (nctv.) !urlparm
                          )
                      |   "Registered value of Inactive overrules user's input."
                        &   !urlparm
                          : ( ?a (nctv.?) ?z
                            | ?z&:?a
                            )
                        & (nctv.!Inactive) !a !z
                      )
                    : ?urlparm
                  & ( !urlparm:? (url.?) ?
                    |   whl
                      ' ( !toggles:(?var.?val) ?toggles
                        & ( !urlparm:? (!var.?) ?
                          | !urlparm (!var.trim$!val):?urlparm
                          )
                        )
                    )
                  &   whl
                    ' ( !liste:(?var.?val) ?liste
                      & trim$!val:?val
                      & (   !urlparm
                          :   ?a
                              (   (!var.) ?z
                                & "Replace empty value by non-empty value."
                                & !a (!var.!val) !z:?urlparm
                              |   (!var.?pval) ?z
                                &   !a (!var.trim$!pval) !z
                                  : ?urlparm
                              )
                        | !urlparm (!var.!val):?urlparm
                        )
                      )
                  & (!ToolName.!PassWord.!ContactEmail.!urlparm)
            )
          & ( staticFields
            =   staticField
              .   ( staticField
                  =     urlvars prompt urlvar
                      , internalvar fieldType attrs
                    .     !arg
                        : ( ?urlvars
                          . ?prompt
                          . ?urlvar
                          . ?internalvar
                          . ?fieldType
                          . ?attrs
                          )
                      &   ( checkParmsSimple$(!urlvars.!urlvar)
                          | 
                          )
                        : ?!internalvar
                      &   !fieldType
                        $ (!prompt.!urlvar.(val.!!internalvar) !attrs)
                  )
                &     fieldset
                    $ (   localized
                        $ ( Boilerplate
                            "Generelle oplysninger for alle v√¶rkt√∏jer"
                          )
                      .     paragraph
                          $ (   staticField
                              $ ( !arg
                                . "ToolID:"
                                . name
                                . ToolName
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ("short unique name" "kort unikt navn")
                                    )
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "Title:"
                                . fllNm
                                . FullToolName
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "full name of the tool"
                                          "V√¶rkt√∏jets fulde navn"
                                        )
                                    )
                                    (size.40)
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "Version:"
                                . vrsion
                                . ToolVersion
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "may only contain ascii letters dots  and digits"
                                          "m√• kun indeholde ascii-bogstaver, punktum og cifre"
                                        )
                                    )
                                    (required."*")
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Publisher:"
                                . pblshr
                                . ToolPublisher
                                . makeTextFormField
                                . required
                                . "*"
                                )
                                staticField
                              $ ( !arg
                                . "Content provider:"
                                . cntPrvdr
                                . ContentProvider
                                . makeTextFormField
                                . required
                                . "*"
                                )
                                staticField
                              $ ( !arg
                                . "Creator:"
                                . crtr
                                . ToolCreator
                                . makeTextFormField
                                . (size.25) (required."*")
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Email:"
                                . ml2
                                . ContactEmail
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "protection against unauthorized update"
                                          "Beskyttelse mod uautoriseret redigering af oplysninger. Email adressen bliver ikke offentliggjort eller lagret i repositoriet ved deponering af v√¶rkt√∏jets oplysninger og kan √¶ndres ved at overdrage redigeringsrettigheden til en anden person. (Se forklaring p√• Password-feltet.)"
                                        )
                                    )
                                    (readonly.yes)
                                )
                                staticField
                              $ ( !arg
                                . "Password:"
                                . psswrd
                                . PassWord
                                . makeTextFormField
                                . desc
                                .   localized
                                  $ ( "If you want to transfer the edit right of the tool to somebody else, enter a one-time password that you share with the other person. The other person must be logged in via WAYF and enter the password to gain access and the edit right."
                                      "Hvis du vil overdrage redigeringsrettigheden til en anden person, skriv en engangsadgangskode og giv den til den anden person. For at modtage redigeringsrettigheden, skal den anden person logge sig p√• via WAYF og indtaste adgangskoden. N√•r hun eller han erstatter v√¶rkt√∏jets oplysninger, bliver hans eller hendes email adresse noteret i Email-feltet og er hun eller han blevet den prim√¶re kontaktperson hvis der er sp√∏rgsm√•l eller problemer ang. v√¶rkt√∏jet."
                                    )
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "InfoAbout:"
                                . docuri
                                . InfoAbout
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "URI of documentation"
                                          "Dokumentationens URI"
                                        )
                                    )
                                    (size.40)
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "External Service URL:"
                                . xuri
                                . ToolExternalURI
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "fill out if the tool (also) functions as a web service"
                                          "udfyld hvis v√¶rkt√∏jet (ogs√•) fungerer som webservice"
                                        )
                                    )
                                    (size.40)
                                )
                            )
                            paragraph
                          $ ( staticField
                            $ ( !arg
                              . "Description:"
                              . dscrptn
                              . ToolDescription
                              . makeTextAreaFormField
                              . required
                              . "*"
                              )
                            )
                      )
                      fieldset
                    $ (   localized
                        $ ("Webservice metadata" Webserviceoplysninger)
                      .     paragraph
                          $ ( staticField
                            $ ( !arg
                              . "Service URL of the tool:"
                              . url
                              . ToolURL
                              . makeTextFormField
                              .   ( desc
                                  .   localized
                                    $ ( "Something like \"https://abc.foo/wordreverser\". Only needed for integrated tools. To wipe URL: replace with one or more blank characters."
                                        "Noget i stil med \"https://abc.foo/wordreverser\". Kun kr√¶vet for integrerede v√¶rkt√∏jer. For at udviske URL: erstat med blanktegn."
                                      )
                                  )
                                  (size.40)
                              )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Requires HTTP POST method:"
                                . pstdt
                                . ToolPostData
                                . makeCheckboxFormField
                                . 
                                )
                                staticField
                              $ ( !arg
                                . "parameters as XML (if POST):"
                                . xmlprms
                                . ToolXMLparms
                                . makeCheckboxFormField
                                . desc
                                .   localized
                                  $ ( "Check if parameters must be sent in XML format"
                                      "Marker hvis parametre skal sendes i XML-format"
                                    )
                                )
                                staticField
                              $ ( !arg
                                . "Inactive:"
                                . nctv
                                . ToolInactive
                                . makeCheckboxFormField
                                .   ( desc
                                    .   localized
                                      $ ( "Check if the tool is not integrated. Also check this box if an integrated tool temporarily cannot be used. (You need to be logged in to toggle this swicth.)"
                                          "Marker hvis v√¶rkt√∏jet er midlertidigt ude af drift eller slet ikke integreret. (Du skal v√¶re logget p√• f√∏r du kan √¶ndre dette felt.)"
                                        )
                                    )
                                    (   !handle:
                                      & (disabled.disabled)
                                    | 
                                    )
                                )
                            )
                      )
            )
          & ( featureListing
            =   listing featname inouts in outp K listIO
              .   ( listIO
                  =     in io I S L M s
                      , opt addFeature listing Is OnE
                    .   ( addFeature
                        =     moreToCome K L featname io
                            , I S listing M s optional OnE
                          .     !arg
                              : ( ?moreToCome
                                . ?K
                                . ?L
                                . ?featname
                                . ?io
                                . ?I
                                . ?S
                                . ?listing
                                . ?optional
                                . ?OnE
                                )
                            &     (str$(!featname !K "." !L !io).!I)
                                  ( !optional:
                                  | (   str
                                      $ (!featname !K "." !L !io !optional)
                                    . on
                                    )
                                  )
                                  ( !OnE:
                                  | ( str$(!featname !K "." !L !io !OnE)
                                    . on
                                    )
                                  )
                                  (     !moreToCome
                                      : (1|)
                                    & 
                                  | ( str$(!featname !K "." !L !io More)
                                    . on
                                    )
                                  )
                                  !listing
                              : ?listing
                            & 0:?M
                            & ( !S:1
                              |   whl
                                ' ( !S:%?s+?S
                                  & 1+!M:?M
                                  &     (   str
                                          $ ( !featname
                                              !K
                                              "."
                                              !L
                                              "."
                                              !M
                                              !io
                                              Spc
                                            )
                                        . !s
                                        )
                                        ( !S:0&
                                        | (   str
                                            $ ( !featname
                                                !K
                                                "."
                                                !L
                                                "."
                                                !M
                                                !io
                                                Spc
                                                More
                                              )
                                          . on
                                          )
                                        )
                                        !listing
                                    : ?listing
                                  )
                              )
                            & !listing
                        )
                      & 0:?L
                      & !arg:(?in.?io.?listing)
                      & !in:(%?in ?opt|?opt)
                      &   whl
                        ' ( !in:%?I^?S*?in
                          & (   !I:(?Is.OnE)
                              & :?OnE
                              &   whl
                                ' ( !Is:%@?I^?S*?Is
                                  & 1+!L:?L
                                  &     addFeature
                                      $ ( !Is*!in
                                        . !K
                                        . !L
                                        . !featname
                                        . !io
                                        . !I
                                        . !S
                                        . !listing
                                        . 
                                        . !OnE
                                        )
                                    : ?listing
                                  & OnE:?OnE
                                  )
                            |   1+!L:?L
                              &     addFeature
                                  $ ( !in
                                    . !K
                                    . !L
                                    . !featname
                                    . !io
                                    . !I
                                    . !S
                                    . !listing
                                    . 
                                    . 
                                    )
                                : ?listing
                            )
                          )
                      & ( !opt:
                        |       (str$(!featname !K "." !L !io More).on)
                                !listing
                            : ?listing
                          &   whl
                            ' ( !opt:%?I^?S ?opt
                              & 1+!L:?L
                              &     addFeature
                                  $ ( !opt
                                    . !K
                                    . !L
                                    . !featname
                                    . !io
                                    . !I
                                    . !S
                                    . !listing
                                    . Optional
                                    . 
                                    )
                                : ?listing
                              )
                        )
                      & !listing
                  )
                & :?listing
                &   whl
                  ' ( !arg:(?featname,?inouts) ?arg
                    & 0:?K
                    &   whl
                      ' ( !inouts:#*(?in.?outp)+?inouts
                        & 1+!K:?K
                        & listIO$(!in.Input.!listing):?listing
                        & listIO$(!outp.Output.!listing):?listing
                        & ( !inouts:0
                          |     (str$(!featname !K More).on)
                                !listing
                            : ?listing
                          )
                        )
                    )
                & !listing
            )
          & ( windfw
            =   nth Nth toolprop ZZ ToolName featjursPreexisting
              .   !arg:(?toolprop.?ToolName.?nth:?Nth)
                & !toolprop:?+(!ToolName.?featjursPreexisting)+?ZZ
                &   whl
                  ' ( !Nth:>0
                    & !ZZ:(!ToolName.?featjursPreexisting)+?ZZ
                    & !Nth+-1:?Nth
                    )
                & (!featjursPreexisting.!ZZ.!nth+-1*!Nth)
            )
          & ( unfoldInputAndOutput
            =   feat apair a z II OO zpair
              .   map
                $ ( ( 
                    =   
                      .   !arg:(?feat,?arg)
                        &   whl
                          ' ( !arg:?apair+#*(%?a+%?z.?OO)+?zpair
                            & !apair+(!a.!OO)+(!z.!OO)+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(?II.%?a+%?z)+?zpair
                            & !apair+(!II.!a)+(!II.!z)+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(^?.^?)+?zpair
                            & !apair+!zpair:?arg
                            )
                        & (!feat,!arg)
                    )
                  . !arg
                  )
            )
          & ( foldInputAndOutput
            =     feat apair a b II OO zpair
                , mpair aval zval
              .   map
                $ ( ( 
                    =   
                      .   !arg:(?feat,?arg)
                        &   whl
                          ' ( !arg:?apair+#%*(?II.?OO)+?zpair
                            & !apair+(!II.!OO)+!zpair:?arg
                            )
                        &   whl
                          ' (   !arg
                              :   ?apair
                                + #*(?a.?OO)
                                + ?mpair
                                + #*(?b.!OO)
                                + ?zpair
                            &     !apair
                                + (denumerizeSum$(!a+!b).!OO)
                                + !mpair
                                + !zpair
                              : ?arg
                            )
                        &   whl
                          ' (   !arg
                              :   ?apair
                                + #*(?II.?a)
                                + ?mpair
                                + #*(!II.?b)
                                + ?zpair
                            &     !apair
                                + (!II.denumerizeSum$(!a+!b))
                                + !mpair
                                + !zpair
                              : ?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(^?.^?)+?zpair
                            & !apair+!zpair:?arg
                            )
                        &   whl
                          ' (   !arg
                              : ?apair+#*(?aval*^?*?zval.?OO)+?zpair
                            &     !apair
                                + (denumerizeSum$(!aval*!zval).!OO)
                                + !zpair
                              : ?arg
                            )
                        &   whl
                          ' (   !arg
                              : ?apair+#*(?II.?aval*^?*?zval)+?zpair
                            &     !apair
                                + (!II.denumerizeSum$(!aval*!zval))
                                + !zpair
                              : ?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(1.?OO)+?zpair
                            & !apair+(.!OO)+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(?II.1)+?zpair
                            & !apair+(!II.)+!zpair:?arg
                            )
                        & ( !arg:0&:?arg
                          | 
                          )
                        & (!feat,!arg)
                    )
                  . !arg
                  )
            )
          & ( askOptional
            =   urlparms featinoutOptional
              .   !arg:(?urlparms.?featinoutOptional)
                &   ( checkParmsSimple$(!urlparms.!featinoutOptional)
                    | 
                    )
                  : ?!featinoutOptional
                &   makeCheckboxFormField
                  $ (optional.!featinoutOptional.val.!!featinoutOptional)
            )
          & ( askOnE
            =   urlparms featinoutOnE featinout inout values
              .     !arg
                  : (?urlparms.?featinoutOnE.?featinout.?values.?inout)
                & (   !inout:Input
                    & (   !values:% ?
                        &   ( checkParmsSimple$(!urlparms.!featinoutOnE)
                            | 
                            )
                          : ?!featinoutOnE
                        &   makeCheckboxFormField
                          $ (     !!featinoutOnE:
                                & (!!featinout:|üóé)
                              | ‚Æ≠
                            . !featinoutOnE
                            . val
                            . !!featinoutOnE
                            )
                      | !!featinout:
                      | üóé
                      )
                  | 
                  )
            )
          & ( aFeature
            =     NrRequiredAndOptional NrInOutAlternative
                , NrSpecification shortfeatname requireds
                , inout featinout featinoutMore featinoutOnE
                , featinoutOptional urlparms FieldSet
                , feattable featdescription row aboutFeature
                , specifications specificationTables
                , sameFeatureOnceMore optionals
                , sameSpecificationOnceMore full
                , additionalFieldSet additionalOptionals
                , specificationTable aSpecification
                , featinoutSpec featinoutOptMore
              .   ( sameFeatureOnceMore
                  = .!arg:(?arg.?)&(.!arg.)
                  )
                & ( aSpecification
                  =   :?sameSpecificationOnceMore
                    & 1+!NrSpecification:?NrSpecification
                    &     str
                        $ ( !shortfeatname
                            !NrInOutAlternative
                            "."
                            !NrRequiredAndOptional
                            "."
                            !NrSpecification
                            !inout
                            Spc
                          )
                      : ?featinoutSpec
                    & str$(!featinoutSpec More):?featinoutOptMore
                    & (       checkParms
                            $ ( !urlparms
                              . !featinoutSpec
                              .   !!specificationTable
                                |   readTable$!specificationTable
                                  & !!specificationTable
                              )
                          : ?!featinoutSpec
                        &     ( !!featinoutSpec:~:~1
                              | 0
                              )
                            + !specifications
                          : ?specifications
                      | :?!featinoutSpec
                      )
                    &     !row
                            makeSelectFormField
                          $ (   str
                              $ ( (     !!feattable
                                      : ? (?full.!!featinout.?) ?
                                    & localized$!full
                                  |   "featinout:"
                                      !featinout
                                      "=="
                                      !!featinout
                                      " and feattable "
                                      !feattable
                                      " looks like this:"
                                      !!feattable
                                  )
                                  " style"
                                )
                            . !featinoutSpec
                            . options
                            .   makeOptionList
                              $ (!!specificationTable.!!featinoutSpec)
                            )
                          (       checkParmsSimple
                                $ (!urlparms.!featinoutOptMore)
                              : ?!featinoutOptMore
                            & (   !!featinoutOptMore:on
                                &   '$aSpecification
                                  : (=?sameSpecificationOnceMore)
                                & makeHiddenFields$(!featinoutOptMore.on)
                              | 
                              )
                          |   makeCheckboxFormField
                            $ (localized$(more mere).!featinoutOptMore.)
                          )
                      : ?row
                    & !sameSpecificationOnceMore
                  )
                &   !arg
                  : ( ?requireds
                    . ( ?NrRequiredAndOptional
                      . ?inout
                      . ?NrInOutAlternative
                      . ?aboutFeature
                      )
                    . ?urlparms
                    )
                &   !aboutFeature
                  : ? (short.?shortfeatname) ?
                  : ? (description.?featdescription) ?
                  : ? (table.?feattable) ?
                  : ( ? (specificationTable.?specificationTables) ?
                    | ?&:?specificationTables
                    )
                & 1+!NrRequiredAndOptional:?NrRequiredAndOptional
                &     str
                    $ ( !shortfeatname
                        !NrInOutAlternative
                        "."
                        !NrRequiredAndOptional
                        !inout
                      )
                  : ?featinout
                & "e.g. facet3.2InputMore
                   shown after second input of third inputs/output(s) combination"
                & str$(!featinout More):?featinoutMore
                & str$(!featinout Optional):?featinoutOptional
                & :?!featinoutOptional
                & str$(!featinout OnE):?featinoutOnE
                & :?!featinoutOnE
                &   ( checkParms$(!urlparms.!featinout.!!feattable)
                    | 
                    )
                  : ?!featinout
                &       makeSelectFormField
                      $ ( !inout
                        . !featinout
                        .   (options.makeOptionList$(!!feattable.!!featinout))
                            (desc.localized$!featdescription)
                        )
                        askOnE
                      $ ( !urlparms
                        . !featinoutOnE
                        . !featinout
                        . !requireds
                        . !inout
                        )
                      optionalFeature$(!urlparms.!featinoutOptional)
                      (     checkParmsSimple$(!urlparms.!featinoutMore)
                          : on
                        &   '$aFeature
                          : (=?sameFeatureOnceMore)
                        & makeHiddenFields$(!featinoutMore.on)
                      |   makeCheckboxFormField
                        $ (localized$(more mere).!featinoutMore.)
                      )
                  : ?row
                & 0:?specifications
                & (   !specificationTables
                    :   ?
                        ( ? (%@:!!featinout) ?
                        .   ?specificationTable
                          & 0:?NrSpecification
                          & !aSpecification
                        )
                        ?
                  | 
                  )
                &     !!featinout
                    ^ (!specifications:~0:~|1)
                  : ?!featinout
                &   (   !!featinoutOptional:
                      &     (   !!featinoutOnE:
                              & !!featinout
                            | (OnE.!!featinout)
                            )
                            !requireds
                        : ?requireds
                      & 
                    | !!featinout
                    )
                  : ?optionals
                & paragraph$!row:?FieldSet
                &   '$shouldIAskOptionalFeature
                  : (=?optionalFeature)
                &     sameFeatureOnceMore
                    $ ( !requireds
                      . ( !NrRequiredAndOptional
                        . !inout
                        . !NrInOutAlternative
                        . !aboutFeature
                        )
                      . !urlparms
                      )
                  : (?additionalFieldSet.?requireds.?additionalOptionals)
                & tbl$(!featinoutMore,0)
                & tbl$(!featinoutOptMore,0)
                & tbl$(!featinoutOptional,0)
                & tbl$(!featinoutOnE,0)
                & tbl$(!featinout,0)
                & tbl$(!featinoutSpec,0)
                & ( !FieldSet !additionalFieldSet
                  . !requireds
                  . !optionals !additionalOptionals
                  )
            )
          & ( askFieldSet
            =     NrInOutAlternative additionalInoutpairs
                , shortfeatname inout featurePair inoutpairs
                , featurePairMore FieldSet optionalFeature ret
                , NrRequiredAndOptional optionals requireds
                , shouldIAskOptionalFeature
                , urlparms feattable featdescription formstuff
                , Input Output
              .   "askFieldSet: recursive function that returns a list of
                       fieldset elements, one for each input/output pair of the
                       current feature. After the last fieldset element follows
                       a checkbox input element inviting to create an extra
                       fieldset element if the user checks the box and reloads
                       the page. The list contains minimally one input/output
                       element.
                       askFieldSet is called recursively when the URL
                       parameter list has a <featurename><cardinal #>More
                       element, e.g. facet2More=on
                      "
                &   !arg
                  : ((?NrInOutAlternative.?aboutFeature).?urlparms)
                &   !aboutFeature
                  : ? (short.?shortfeatname) ?
                  : ? (description.?featdescription) ?
                  : ? (table.?feattable) ?
                & 1+!NrInOutAlternative:?NrInOutAlternative
                &   str$(!shortfeatname !NrInOutAlternative)
                  : ?featurePair
                & :?FieldSet
                & (optionalFeature=.)
                &   '$askOptional
                  : (=?shouldIAskOptionalFeature)
                & :?FieldSet
                & (     map
                      $ ( ( 
                          =     Lrequireds
                                OnErequired
                                additionalFieldSet
                                required
                            .   !arg:%@?inout
                              & :?requireds
                              & 0:?NrRequiredAndOptional
                              &     aFeature
                                  $ ( !requireds
                                    . ( !NrRequiredAndOptional
                                      . !inout
                                      . !NrInOutAlternative
                                      . !aboutFeature
                                      )
                                    . !urlparms
                                    )
                                : (?additionalFieldSet.?Lrequireds.?optionals)
                              & 1:?requireds:?OnErequired
                              &   whl
                                ' ( !Lrequireds:%?required ?Lrequireds
                                  & (   !required:(OnE.?required)
                                      &   !required*!OnErequired
                                        : ?OnErequired
                                    |     !required*!OnErequired
                                        : ?OnErequired
                                      &     (   !OnErequired:%*%
                                              & (!OnErequired.OnE)
                                            | !OnErequired
                                            )
                                          * !requireds
                                        : ?requireds
                                      & 1:?OnErequired
                                    )
                                  )
                              &   !FieldSet !additionalFieldSet
                                : ?FieldSet
                              & !requireds:~:~1
                              & (   !inout:Input
                                  & !requireds !optionals:?Input
                                | !requireds !optionals:?Output
                                )
                              & (shouldIAskOptionalFeature=.)
                              & (optionalFeature=.)
                          )
                        . Input Output
                        )
                    & !Input:~0
                    & !Output:~0
                    & (!Input.!Output):?inoutpairs
                  | 
                  )
                &     fieldset$(.!FieldSet)
                      ( str$(!featurePair More):?featurePairMore
                      & (   checkParmsSimple$(!urlparms.!featurePairMore)
                          &     askFieldSet
                              $ ( (!NrInOutAlternative.!aboutFeature)
                                . !urlparms
                                )
                            : (?formstuff.?additionalInoutpairs)
                          &   !inoutpairs+!additionalInoutpairs
                            : ?inoutpairs
                          & "If user has checked 'more' for opening creating
                                 another input/output pair, then 'askFieldSet'
                                 is called.
                                "
                          &   makeHiddenFields$(!featurePairMore.on)
                              !formstuff
                        |   "The last input/output combination is always
                                 followed by an invitation to add another one.
                                "
                          &   makeCheckboxFormField
                            $ (   localized
                                $ ( "Add an input/output combination"
                                    "Tilf√∏j en input/output-kombination"
                                  )
                              . !featurePairMore
                              . 
                              )
                        )
                      )
                  : ?ret
                & (!ret.!inoutpairs)
            )
          & ( createFeatureFieldset
            =     inoutpairs aboutFeature urlparms formstuff
                , featname shortfeatname
                , featdescription feattable specificationTables
              .   !arg:(?aboutFeature.?urlparms)
                & "
                   urlparms: the URL parameters in Bracmat structures. When
                   starting the edit, there is not much in them. After pressing
                   'store' or 'replace', urlparms contains all the data that is
                   in the form, including the changes the user has just made.

                   aboutFeature: the general information about a feature. This
                   is constant, system-wide info.
                  "
                &   !aboutFeature
                  : ? (name.?featname) ?
                  : ? (short.?shortfeatname) ?
                  : ? (description.?featdescription) ?
                  : ? (table.?feattable) ?
                  : ( ? (specificationTable.?specificationTables) ?
                    | ?
                    )
                & 0:?inoutpairs
                & readTable$!feattable
                &   askFieldSet$((0.!aboutFeature).!urlparms)
                  : (?formstuff.?inoutpairs)
                & ( fieldset$(localized$!featname.!formstuff)
                  .   !inoutpairs:0&
                    | (!shortfeatname,!inoutpairs)
                  )
            )
          & ( validationComments
            =     Submit otherName
                , ToolName ToolVersion FullToolName PassWord
                , ToolURL ToolPublisher ContentProvider
                , ToolCreator InfoAbout ToolDescription
                , ToolExternalURI ToolXMLparms mayNotBeEmpty
                , ToolPostData ToolInactive Nazn dNazn
              .     !arg
                  : ( ?ToolName
                    . ?PassWord
                    . ?ToolVersion
                    . ?FullToolName
                    . ?ToolURL
                    . ?ToolPublisher
                    . ?ContentProvider
                    . ?ToolCreator
                    . ?InfoAbout
                    . ?ToolDescription
                    . ?ToolExternalURI
                    . ?ToolXMLparms
                    . ?ToolPostData
                    . ?ToolInactive
                    . ?Submit
                    )
                & ( mayNotBeEmpty
                  =   
                    .   "'"
                        !arg
                        "' "
                        localized$("may not be empty" "m√• ikke v√¶re tom")
                        (br.,)
                  )
                & ( (   !ToolName:
                      & mayNotBeEmpty$ToolID
                    |   @( !ToolName
                         : allowedChar$('$NCNameStartChar) !NCName
                         )
                      & `~
                    |   str
                      $ ( "ToolID '"
                          !ToolName
                            localized
                          $ ( "' contains invalid characters. (Must be an xml:id)"
                              "' indeholder ugyldige karakterer. (Skal v√¶re et xml:id)"
                            )
                        )
                    )
                  | !ToolName:&mayNotBeEmpty$ToolID
                  |   !FullToolName:
                    & mayNotBeEmpty$Title
                  |   !ToolURL:
                    & !ToolInactive:
                    &     localized
                        $ ( "'Service URL' may not be empty if the tool is integrated and active. If the tool must be integrated in the infrastructure, but not just now, you must check the field 'Inactive'."
                            "'Service URL' m√• ikke v√¶re tom hvis v√¶rkt√∏jet er et aktivt integreret v√¶rkt√∏j. Hvis v√¶rkt√∏jet ikke skal v√¶re integreret i infrastrukturen, skal du markere feltet 'Inactive'."
                          )
                        (br.,)
                  |     !tooladm
                      :   ?
                        + ( ? (ToolID.!ToolName) ?
                          : ? (Inactive.) ?
                          : ? (ServiceURL.<>!ToolURL) ?
                          )
                        + ?
                    & !Submit:!storeToolButton
                    &     str
                        $ (   localized
                            $ ( "There is already an integrated tool with the name '"
                                "Der findes et integreret v√¶rkt√∏j med navn '"
                              )
                            !ToolName
                              localized
                            $ ( "' with another Service URL. If you are sure it is the same tool, you can change the Service URL by temporarily deactivating the tool. (Check the 'Inactive'-field, save, change the Service URL, uncheck 'Inactive', and save.)"
                                "' med en anden Service URL end den indtastede. Hvis du er sikker p√• at det er samme v√¶rkt√∏j, kan du √¶ndre Service URL ved f√∏rst midlertigt at deaktivere v√¶rkt√∏jet. (Klik 'Inactive'-feltet, gem, √¶ndr Service URL og klik 'Inactive'-feltet igen, gem.)"
                              )
                          )
                        (br.,)
                  |   !ToolURL:~
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!ToolURL) ?
                          :   ?
                              (ToolID.?otherName:<>!ToolName)
                              ?
                          )
                        + ?
                    &     str
                        $ ( localized$("Cannot save '" "Kan ikke gemme '")
                            !ToolName
                              localized
                            $ ("' on Service URL \"" "' p√• Service URL \"")
                            !ToolURL
                              localized
                            $ ( "\" (already taken by the tool '"
                                "\" (allerede i brug af v√¶rkt√∏jet '"
                              )
                            !otherName
                            "')."
                          )
                        (br.,)
                  |   ( Nazn
                      =   #
                          ( 
                          | ? (%@:~<a:~>z)
                          | `
                          )
                          (|#)
                      )
                    & '("." ()$Nazn):(=?dNazn)
                    & (   @( !ToolVersion
                           :   !Nazn
                               ( 
                               |   !dNazn
                                   ( 
                                   | !dNazn (|!dNazn)
                                   )
                               )
                           )
                        & `~
                      |   localized
                        $ ( "'Version' must match the regular expression [d]+[a-z]*[d]*(.[d]+[a-z]*[d]*){0,3}"
                            "'Version' skal matche det regul√¶re udtryk [d]+[a-z]*[d]*(.[d]+[a-z]*[d]*){0,3}"
                          )
                      )
                  |   !ToolPublisher:
                    & mayNotBeEmpty$Publisher
                  |   !ContentProvider:
                    & mayNotBeEmpty$"Content provider"
                  |   !ToolCreator:
                    & mayNotBeEmpty$Creator
                  |   !InfoAbout:
                    &     localized
                        $ ( "'InfoAbout' (tool documentation): URL may not be empty"
                            "'InfoAbout' (v√¶rkt√∏jets dokumentation): URL m√• ikke v√¶re tom"
                          )
                        (br.,)
                  |   !ToolDescription:
                    & mayNotBeEmpty$Description
                  |   !ToolPostData:
                    & !ToolXMLparms:on
                    &   ( "XMLparms ("
                          !ToolXMLparms
                            localized
                          $ ( ") must not be checked if 'POST' is not checked"
                              ") skal v√¶re umarkeret hvis 'POST' er umarkeret"
                            )
                        )
                        (br.,)
                  )
            )
          & ( storeTool
            =     A M Z Metadata admdata
                , ToolName ToolVersion FullToolName PassWord
                , ToolURL ToolPublisher ContentProvider
                , ToolCreator InfoAbout ToolDescription
                , ToolExternalURI ToolXMLparms removeEmptyValues
                , ToolPostData ToolInactive sortFacets
                , ContactEmail otherToolprop thisToolProp
                , Combine IOFeatComb IOcomb IOcombine Ocomb
                , subset unfact unfactorize force
              .     !arg
                  : ( ?Metadata
                    . ?ToolName
                    . ?PassWord
                    . ?ContactEmail
                    . ?ToolVersion
                    . ?FullToolName
                    . ?ToolURL
                    . ?ToolPublisher
                    . ?ContentProvider
                    . ?ToolCreator
                    . ?InfoAbout
                    . ?ToolDescription
                    . ?ToolExternalURI
                    . ?ToolXMLparms
                    . ?ToolPostData
                    . ?ToolInactive
                    . ?ZZ
                    . ?force
                    )
                & (   ( !ToolInactive:on
                      | !handle:~
                      )
                    &   (   !ZZ:<0
                          & (   !toolprop:?A+!Metadata+?Z
                              & ( !force:no&!toolprop
                                | !A+!Metadata+!Z
                                )
                            | !Metadata+!toolprop
                            )
                        |   !toolprop:?AA+(?.?)+!ZZ
                          & ( !AA+!ZZ:?A+!Metadata+?Z
                            | !AA+!Metadata+!ZZ
                            )
                        )
                      : ?toolprop
                    &   whl
                      ' ( !toolprop:?A+(?.)+?Z
                        & !A+!Z:?toolprop
                        )
                    & removeNumFactors$!toolprop:?toolprop
                    & ( removeEmptyValues
                      =   a b nw
                        .     !arg:?a_?b
                            &     (removeEmptyValues$!a)
                                _ (removeEmptyValues$!b)
                              : ?nw
                            & !(glf$('($arg.$nw))):?arg
                            & ( !arg:*?arg&!arg
                              | !arg:+?arg&!arg
                              | !arg:?a^&!a
                              | !arg:^?&
                              )
                          | !arg
                      )
                    & removeEmptyValues$!toolprop:?toolprop
                    & ( sortFacets
                      =   toolpropFacetsSorted Name facets
                        .   0:?toolpropFacetsSorted
                          &   whl
                            ' ( !arg:#*(?Name.?facets)+?arg
                              &     (!Name.sort$!facets)
                                  + !toolpropFacetsSorted
                                : ?toolpropFacetsSorted
                              )
                          & !toolpropFacetsSorted
                      )
                    & sortFacets$!toolprop:?toolprop
                    & removeNumFactors$!toolprop:?toolprop
                    & ( unfact
                      =     ToolName F A Z a z f
                          , O x m T y
                        .   !arg:(?ToolName.?F)
                          & (   !F:?A (?f,%?a+%?z) ?Z
                              &   unfact$(!ToolName.!A (!f,!a) !Z)
                                + unfact$(!ToolName.!A (!f,!z) !Z)
                            |   !F:?A (?f,(%?a+%?z.?O)) ?Z
                              &     unfact
                                  $ (!ToolName.!A (!f,(!a.!O)) !Z)
                                +   unfact
                                  $ (!ToolName.!A (!f,(!z.!O)) !Z)
                            |   !F:?A (?f,(?O.%?a+%?z)) ?Z
                              &     unfact
                                  $ (!ToolName.!A (!f,(!O.!a)) !Z)
                                +   unfact
                                  $ (!ToolName.!A (!f,(!O.!z)) !Z)
                            |     !F
                                :   ?A
                                    (?f,(?O.?x*?m^(%?a+%?z)*?y ?T))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!O.!x*!m^!a*!y !T))
                                        !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!O.!x*!m^!z*!y !T))
                                        !Z
                                    )
                            |     !F
                                :   ?A
                                    (?f,(?x*?m^(%?a+%?z)*?y ?T.?O))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x*!m^!a*!y !T.!O))
                                        !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x*!m^!z*!y !T.!O))
                                        !Z
                                    )
                            |     !F
                                :   ?A
                                    (?f,(%?x ?m^(%?a+%?z) ?T.?O))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x !m^!a !T.!O))
                                        !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x !m^!z !T.!O))
                                        !Z
                                    )
                            |     !F
                                :   ?A
                                    (?f,(?O.%?x ?m^(%?a+%?z) ?T))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    . !A (!f,(!O.!x !m^!a !T)) !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    . !A (!f,(!O.!x !m^!z !T)) !Z
                                    )
                            | !arg
                            )
                      )
                    & ( subset
                      =   toolprop ToolName Fe A fe subs
                        .   !arg:(?toolprop.?ToolName)
                          & !toolprop:?A+(!ToolName.?Fe)+?toolprop
                          & 0:?subs
                          &   whl
                            ' ( !toolprop:(!ToolName.?fe)+?toolprop
                              & !subs+(!ToolName.!fe):?subs
                              )
                          & ((!ToolName.!Fe)+!subs.!A+!toolprop)
                      )
                    &   subset$(!toolprop.!ToolName)
                      : (?thisToolProp.?otherToolprop)
                    & ( unfactorize
                      =   A
                        .     !arg:%?A+?arg
                            & unfact$!A+unfactorize$!arg
                          | 0
                      )
                    & unfactorize$!thisToolProp:?thisToolProp
                    & removeNumFactors$!thisToolProp:?thisToolProp
                    & ( Combine
                      =     A M Z AA ZZ Name Facet val1
                          , Vals1 Vals2
                        .     whl
                            ' (   !arg
                                :   ?A
                                  + (?Name.?val1)
                                  + ?M
                                  + ( ?
                                    .   ?AA
                                        ( (?Facet,?Vals2) ?ZZ
                                        &   !val1
                                          : !AA (!Facet,?Vals1) !ZZ
                                        )
                                    )
                                  + ?Z
                              &     !A
                                  + ( !Name
                                    . !AA (!Facet,!Vals1+!Vals2) !ZZ
                                    )
                                  + !M
                                  + !Z
                                : ?arg
                              )
                          & !arg
                      )
                    & Combine$!thisToolProp:?thisToolProp
                    & ( Ocomb
                      =   a i1 i2 o m z
                        .     !arg:?a+(?i1.?o)+?m+(?i2.!o)+?z
                            & Ocomb$(!a+(!i1+!i2.!o)+!m+!z)
                          | !arg
                      )
                    & ( IOcomb
                      =   a i o1 o2 m z
                        .     !arg:?a+(?i.?o1)+?m+(!i.?o2)+?z
                            & IOcomb$(!a+(!i.!o1+!o2)+!m+!z)
                          | Ocomb$!arg
                      )
                    & ( IOFeatComb
                      =   F vs
                        .     !arg:(?F,?vs) ?arg
                            & (!F,IOcomb$!vs) IOFeatComb$!arg
                          | 
                      )
                    & ( IOcombine
                      =   Name facets
                        .     !arg:(?Name.?facets)+?arg
                            & (!Name.IOFeatComb$!facets)+IOcombine$!arg
                          | 0
                      )
                    & IOcombine$!thisToolProp:?thisToolProp
                    & !thisToolProp+!otherToolprop:?toolprop
                    & saveToolTable$toolprop
                    & (     !tooladm
                          : ?A+(? (ToolID.!ToolName) ?)+?Z
                        & !A+!Z:?tooladm
                      | 
                      )
                    &     !tooladm
                        + (   (ToolID.!ToolName)
                              (PassWord.!PassWord)
                              (ContactEmail.!ContactEmail)
                              (Version.!ToolVersion)
                              (Title.!FullToolName)
                              (ServiceURL.!ToolURL)
                              (Publisher.!ToolPublisher)
                              (ContentProvider.!ContentProvider)
                              (Creator.!ToolCreator)
                              (InfoAbout.!InfoAbout)
                              (Description.!ToolDescription)
                              (ExternalURI.!ToolExternalURI)
                              (XMLparms.!ToolXMLparms)
                              (PostData.!ToolPostData)
                              (Inactive.!ToolInactive)
                          : ?admdata
                          )
                      : ?tooladm
                    & saveToolTable$tooladm
                    & "O.k."
                  |   str
                    $ ( "You need to be logged in to save or replace an active tool. (handle=\""
                        !handle
                        "\")"
                      )
                  )
            )
          & "Body of Register starts here"
          & log$NEW
          & log$REGISTER
          &   
            : ?servicedSources
            : ?servicedGoals
            : ?servicedSuperGoals
            : ?goalPicklists
          &   localized$("Save metadata" "Gem oplysninger")
            : ?storeToolButton
          &   localized$("Replace metadata" "Erstat oplysninger")
            : ?replaceToolButton
          &   localized$("Delete metadata" "Slet oplysninger")
            : ?deleteToolButton
          &   localized$("Show more entry fields" "Vis flere inputfelter")
            : ?UpdateButton
          & localized$("PHP wrapper" PHP-kode):?PHPbutton
          & 0:?tabind
          & :?hiddenData:?formFields:?Metadata
          & readTable$facets
          & readTable$toolprop
          & readTable$tooladm
          & readTable$features
          & ( !arg:? (handle.?handle) ?
            | :?handle
            )
          & ( !arg:? (passwordAsHandle.?passwordAsHandle) ?
            | (.):?passwordAsHandle
            )
          & ( !arg:? (mail2.?mail2) ?
            | :?mail2
            )
          & log$CallcreateBoilerPlate
          & (     createBoilerPlate$!arg
                : (?ToolName.?password.?contactEmail.?arg)
              & staticFields$!arg:?formFields
              &     ( h1
                    .   
                      ,     !ToolName:
                          &   localized
                            $ ("Register a new tool" "Registrer et nyt v√¶rkt√∏j")
                        |   localized
                          $ ( "Update tool metadata"
                              "Opdater v√¶rkt√∏jsoplysninger"
                            )
                    )
                    !formFields
                : ?formFields
              & "
                Decide in how far the features as received in the request
                string (the arg variable) or the features as defined in
                toolprop.table should be used in the ensuing process (storage
                as needed and creation of the form to be returned to the
                caller): One of the submit buttons pressed or tool not defined
                in toolprop.table (i.e. tool is not integrated): use info from
                request string.
                Otherwise: use metadata from toolprop.table.
                "
              &   (   ~
                    & !ToolName:
                    & -1:?nth
                    & "Register a new tool. The tool hasn't any features yet."
                    & !arg
                  |     !arg
                      :   ?
                          ( bsubmit
                          . @(?:(prev|next) #?nth)
                          )
                          ?
                    & "
                      If user wants to navigate to the next or previous
                      incarnation wind to the requested incarnation of tool and
                      read tools' properties from toolprop.table. ZZ is the
                      part of the toolprop table coming after this incarnation
                      of this tool. This variable is later used to decide
                      whether a 'next' button is needed and also to locate the
                      old version of the incarnation if the user wants to
                      remove or replace it.
                      "
                    &   windfw$(!toolprop.!ToolName.!nth)
                      : (?featjursPreexisting.?ZZ.?nth)
                    &   featureListing
                      $ (unfoldInputAndOutput$!featjursPreexisting)
                  |   !arg:? (nth.?nth) ?
                    & "
                      The cardinal number of the incarnation is known.
                      "
                    &   windfw$(!toolprop.!ToolName.!nth)
                      : (?featjursPreexisting.?ZZ.?nth)
                    & (   !arg:? (bsubmit.?) ?
                        & "
                          User presses one of the 'submit' buttons 
                          (!storeToolButton, !replaceToolButton,
                           !deleteToolButton, !UpdateButton, !PHPbutton).
                          The features as shown in the form should overrule the
                          properties as recorded in the toolprop table for this
                          incarnation of the tool, so ignore the preexisting
                          properties.
                          "
                        & !arg
                      |   featureListing
                        $ (unfoldInputAndOutput$!featjursPreexisting)
                      )
                  |   "We are just entering the form for the selected tool.
                       The cardinal number of the incarnation is not known.
                       Navigate to the first incarnation of the tool.
                      "
                    &   windfw$(!toolprop.!ToolName.0)
                      : (?featjursPreexisting.?ZZ.?nth)
                    & "featjursPreexisting e.g. for a tool with features
                       'facet' and 'lang':

                              ( facet
                              , ( ner*(seg*tok^PT.OnE)*(tok^simple*txt.OnE)
                                . pos^PT*seg*tok
                                )
                              )
                              (lang,(da.da))

                       Or, another tool:

                              (ambig,(una.una))
                              (facet,(lem+pos+tok+txt+(seg*tok.OnE).rep))
                              (format,(flat.html^ROTM))
                              (pres,(nml.frq))
                      
                       ZZ are other incarnations of the same tool and other
                       tools altogether, all coming AFTER the tool incarnation
                       currently being shown.

                       nth is the incarnation number.
                      
                       Unfolding makes sure that (input.output) pairs with sums
                       in the input and/or output are converted to sum of
                       pairs.

                              ( facet
                              , ( ner*(seg*tok^PT.OnE)*(tok^simple*txt.OnE)
                                . pos^PT*seg*tok
                                )
                              )
                              (lang,(da.da))

                      Or
                              (ambig,(una.una))
                              ( facet
                              ,   (lem.rep)
                                + (pos.rep)
                                + (tok.rep)
                                + (txt.rep)
                                + ((seg*tok.OnE).rep)
                              )
                              (format,(flat.html^ROTM))
                              (pres,(nml.frq))

                      "
                    &   featureListing
                      $ (unfoldInputAndOutput$!featjursPreexisting)
                  |   -1:?nth
                    & "
                      The tool hasn't any features (yet).
                      "
                    & !arg
                  )
                : ?featjursURL
              & "
                Add 'previous' and 'next' buttons as needed.
                "
              & ( !nth:<0
                |   (   !nth:>0
                      &   !formFields submit$(str$(prev !nth+-1))
                        : ?formFields
                    | 
                    )
                  & (   !ZZ:(!ToolName.?)+?
                      &   !formFields submit$(str$(next !nth+1))
                        : ?formFields
                    | 
                    )
                )
              & !formFields helplink$:?formFields
              & !features:?feats
              & "
                Step through the (short) list of features (facet, format,
                language). For each feature, create an input field and collect
                in the formFields variable. The Metadata variable collects the
                same data in a format similar to the format in the toolprop
                table. A feature can look like:

                          + ( (inDex.B)
                              (name.Language Sprog)
                              (short.lang)
                              ( description
                              .   \"Language of the text\" 
                                  \"Sproget i teksten.\"
                              )
                              (table.linguae)
                              ( sourcehelp
                              .   \"You can leave this as it is.\"
                                  \"Du m√• gerne angive inputtets sprog\"
                              )
                              ( goalhelp
                              .   \"You should fill out this field.\"
                                  \"Du b√∏r specificere outputtets sprog\"
                              )
                            )
                "
              &   whl
                ' ( !feats:%?aboutFeature+?feats
                  &   createFeatureFieldset$(!aboutFeature.!featjursURL)
                    : (?additionalFormFields.?additionalMetadata)
                  & !formFields !additionalFormFields:?formFields
                  & !Metadata !additionalMetadata:?Metadata
                  )
              & " formFields is basically a list of HTML fieldset elements.
                 The first two are for boilerplate info. Each of the remaining
                 fieldsets is dedicated to one feature (facet, language, ...).
                 These latter fieldsets are created by createFeatureFieldset.

                 Each fieldset element consists (among other fields) of a list
                 of fieldset elements, on for each input/output combination.

                 Each input/output combination has paragraph (p) elements for
                 input lines followed by output lines.

                 A line consists of a label, a select element and one or more
                 checkbox input elements.

                 Metadata: space separated list of (!shortfeatname,!inoutpairs)
                "
              & "Before editing the tool metadata, the metadata were unfolded.
                 Now, before storing them, they are refolded to save space and
                 to make computation of workflows a little bit faster. (Is that
                 also true: computations becoming faster?)
                "
              & foldInputAndOutput$!Metadata:?Metadata
              & no:?force
              & (!ToolName.!Metadata):?Metadata
              & (   ( !arg:? (bsubmit.?Submit) ?
                    | :?Submit
                    )
                  & (   !Submit:!PHPbutton
                      & wrapper$(PHP.!ToolName)
                    |     (     !Submit
                              : ( !storeToolButton
                                | !replaceToolButton
                                )
                            & (   validationComments
                                $ ( !ToolName
                                  . !PassWord
                                  . !ToolVersion
                                  . !FullToolName
                                  . !ToolURL
                                  . !ToolPublisher
                                  . !ContentProvider
                                  . !ToolCreator
                                  . !InfoAbout
                                  . !ToolDescription
                                  . !ToolExternalURI
                                  . !ToolXMLparms
                                  . !ToolPostData
                                  . !ToolInactive
                                  . !Submit
                                  )
                              |   storeTool
                                $ ( !Metadata
                                  . !ToolName
                                  . !PassWord:?password
                                  . !ContactEmail:?contactEmail
                                  . !ToolVersion
                                  . !FullToolName
                                  . !ToolURL
                                  . !ToolPublisher
                                  . !ContentProvider
                                  . !ToolCreator
                                  . !InfoAbout
                                  . !ToolDescription
                                  . !ToolExternalURI
                                  . !ToolXMLparms
                                  . !ToolPostData
                                  . !ToolInactive
                                  .     !Submit:!storeToolButton
                                      & -1
                                    | !ZZ
                                  . !force
                                  )
                              )
                          |   !Submit:!deleteToolButton
                            & (   !toolprop:?AA+(!ToolName.?)+!ZZ
                                & !AA+!ZZ:?toolprop
                                & saveToolTable$toolprop
                                &   str
                                  $ ( "Deleted current incarnation of tool "
                                      !ToolName
                                    )
                              |     !tooladm
                                  :   ?AA
                                    + (? (ToolID.!ToolName) ?)
                                    + ?ZZ
                                & !AA+!ZZ:?tooladm
                                & saveToolTable$tooladm
                                &   str
                                  $ ( "Deleted administrative metadata of tool "
                                      !ToolName
                                    )
                              )
                          | Updated
                          )
                        : ?error
                      & log$(error !error)
                      &   toML
                        $ ( !HTMLbodyContainer
                          $ ( ( !formFields:
                              |   form
                                $ ( register
                                  .   ( !handle:
                                      | makeHiddenFields$(handle.!handle)
                                      )
                                      !formFields
                                      submit$!storeToolButton
                                      ( !nth:<0&
                                      |   submit$!replaceToolButton
                                          makeHiddenFields$(nth.!nth)
                                      )
                                        makeHiddenFields
                                      $ ( (password.!password)
                                          (   !passwordAsHandle:(.)
                                            & 
                                          | ( passwordAsHandle
                                            . !passwordAsHandle
                                            )
                                          )
                                          ( !mail2:
                                          | (mail2.!mail2)
                                          )
                                          (contactEmail.!contactEmail)
                                        )
                                      submit$!deleteToolButton
                                      submit$!UpdateButton
                                      submit$!PHPbutton
                                      helplink$(usedonly.n)
                                  . POST
                                  )
                              )
                              (p.,!error (br.,))
                              (hr.,)
                            )
                          )
                    )
                | str$("unknown button: " !Submit)
                )
            |   !arg:? (name.?ToolName) ?
              &   update
                $ ( (msg."Forkert adgangskode!")
                    (selected.!ToolName)
                    (password.!password)
                    (contactEmail.!contactEmail)
                    (handle.!handle)
                  )
            |   toML
              $ ( !HTMLbodyContainer
                $ ( paragraph
                  $ ( str
                    $ (   localized
                        $ ( "Email address missing."
                            "Der mangler en email-adresse."
                          )
                        " ('mail2' HTTP parameter)"
                      )
                    )
                  )
                )
            )
      )
      ( removePercentEncodings
      =   A g h
        .   @( !arg
             :   ?A
                 "%"
                 ( %@
                 : ( ~<0:~>9
                   | ~<a:~>f
                   | ~<A:~>F
                   )
                 : ?g
                 )
                 ( %@
                 : ( ~<0:~>9
                   | ~<a:~>f
                   | ~<A:~>F
                   )
                 : ?h
                 )
                 ?arg
             )
          & !A chr$(x2d$(str$(!g !h))) removePercentEncodings$!arg
      )
      "
/*
 * storeUpload
 *
 * Administrate the storage of a copy of a file from repositorium in a place 
 * where a webservice can fetch it - the staging area of the Tools service.
 *
 * Adds an entry to a five-column table Uploads.table. 
 * The first column is unique number generated by adding 1 to the highest 
 * currently occupied number, second is the resource identifier of a 
 * resource that has been copied to a local place, where a webservice can GET
 * it. The third field 
 * contains the name of the resource as the webservice perceives it. It is a
 * concatenation of 'Uploaded' and the number in the first field.)
 * E.g. 
 *      ( 9
 *      . dkclarin:59004
 *      . 19325730679
 *      . 
 *      .
 *      )
 * The resource identifier is going to be used in the new resource's metadata.
 * The missing fifth and sixth fields are later filled out.
 * If the user provides a file by file upload, the second and third column are the same.
 *
 * Input: 
 *      item id (like dkclarin:59004/components/component/dkclarin:59003/content)
 *      date
 *      fk (optional)
 *
 * Affected tables:
 *      Uploads.table
 *
 * Output:
 *      The local file name of the resource (= fourth field)
 *
 * Called from create.java
 */"
      ( storeUpload
      =   nr item fname visibility date enam txe ext
        .   1:?nr
          &   !arg
            : ( ?item
              .   (?date.?visibility)
                | ?date&:?visibility
              )
          & str$(removePercentEncodings$!item):?item
          & (   @(rev$!item:?txe "." ?enam)
              & (   @( !txe
                     :   ?
                         ( "/"
                         | "\\"
                         | ":"
                         | " "
                         | "?"
                         | "*"
                         | "["
                         | "]"
                         | ";"
                         | "|"
                         | "="
                         | ","
                         )
                         ?
                     )
                  & :?ext
                |   rev$!enam:?item
                  & str$("." rev$!txe):?ext
                )
            | :?ext
            )
          & (readTable$Uploads|:?Uploads)
          & (   !Uploads:(?nr.?) ?
              & !nr+1:?nr
            | :?Uploads
            )
          & str$(!item "-" !nr):?fname
          &     str
              $ ( vap
                $ ( ( 
                    =   
                      .       !arg
                            : ( "/"
                              | "\\"
                              | ":"
                              | " "
                              | "?"
                              | "*"
                              | "["
                              | "]"
                              | ";"
                              | "|"
                              | "="
                              | ","
                              | "%"
                              | "&"
                              )
                          & "_"
                        | !arg
                    )
                  . !fname
                  )
                )
            : ?fname
          & str$(!fname !ext):?fname
          &     ( !nr
                .     !item:text
                    & !ext:
                    & !fname
                  | str$(!item !ext)
                . !fname
                . 
                . 
                )
                !Uploads
            : ?Uploads
          & saveTable$Uploads
          & !fname
      )
      " If something went wrong, e.g. an URL that could not be fetched, call unstore. Called from create.java "
      ( unstore
      =   A Z
        .   readTable$Uploads
          & !Uploads:?A (?.?.!arg..) ?Z
          & !A !Z:?Uploads
          & saveTable$Uploads
      )
      ( percentEncodeURL
      =   pEU
        .   ( pEU
            =   A h
              .   @(!arg:?A (%@:>"~":?h) ?arg)
                & d2x$(asc$!h):?h
                & !A "%" upp$!h pEU$!arg
            )
          & str$(pEU$!arg)
      )
      ( element
      =   name attr content
        .   !arg:(?name.?attr.?content)
          & \r\n (!name.atts$!attr,\r\n !content \r\n) \r\n
      )
      ( select
      =   car cdr a z writeList
        .     ( writeList
              =   pat a z el
                .   !arg:(?pat.?el.?arg)
                  & (   !arg:!pat
                      &   element$(!el..select$!a)
                          writeList$(!pat.!el.!z)
                    | element$(!el..select$!arg)
                    )
              )
            & !arg:%+%
            & writeList$(%?a+%?z.or.!arg)
          | !arg:%*%&writeList$(%?a*%?z.and.!arg)
          |   !arg:%?car %?cdr
            & " " select$!car " " element$(opt..select$!cdr)
          |   !arg:%?car^%?cdr
            & " " select$!car " " element$(spec..select$!cdr)
          | !arg:(0|1)&
          | !arg
      )
      ( XMLdeclaration
      = ("?"."xml version='1.0' encoding='UTF-8'") \r\n
      )
      ( shared
      =   gspc isp ispc ispcs
        .   !arg:(?gspc.?ispcs)
          & 0:?ispc
          & (   !gspc+!ispcs
              :   ?
                + ( 2*%@?isp+?
                  & !isp+!ispc:?ispc
                  & ~
                  )
            | !ispc:~0
            | 1
            )
      )
      ( unify
      =     source goal gfield ss R tail U
          , A Z other gvalues svalues gs
        .   ( U
            =   ss g go gp gs a z sp so tail ngs
              .   !arg:(?ss.?gs)
                & "take the first factor of the goal feature value"
                & !gs:%(%?g^?gp ?go)*?ngs
                & "Match it with a source feature value"
                & !ss:?a*(!g^?sp ?so)*?z
                & "At this point we may have failure."
                & "Make sure subspecifications match."
                & ( !go:!so
                  | !go:
                  | !so:
                  )
                & "At this point we may have failure."
                &   ( !gp:1&!sp
                    | !sp:1&!gp
                    | shared$(!gp.!sp):~1
                    )
                  : ?sp
                & "At this point we may have failure."
                & (   !ngs:1
                    & "All goal feature values are matched. We're done."
                    & !g^!sp !so
                  |   "Match remaining goal feature values with remaining source feature values."
                    & U$(!a*!z.!ngs):?tail
                    & (!g^!sp !so)*!tail
                  )
            )
          & !arg:(?source.?goal)
          & ( !goal:&!source
            |   !goal:(?gfield,?gvalues) ?goal
              & (   ~(!source:? (!gfield,?) ?)
                  & (   unify$(!source.!goal):?other
                      & (!gfield,!gvalues) !other
                    | `~
                    )
                |   !source:?A (!gfield,?svalues) ?Z
                  & "All gvalues must be satisfied by svalues. 
                   There may be svalues that are not satisfied by gvalues."
                  &   !gvalues
                    :   ( ~
                        :   ?
                          + ( `%?gs
                            &   !svalues
                              :   ?
                                + `%( ?ss
                                    & "Satisfy first gvalue by some svalue. If success, satisfy remaining gvalues."
                                    & U$(!ss.!gs):?R
                                    & "R is the result of the unification"
                                    & "Unify remaining goal features with remaining source features."
                                    &   unify$(!A !Z.!goal)
                                      : ?other
                                    )
                                + ?
                            )
                          + ?
                        )
                        ?
                  & (!gfield,!R) !other
                )
            )
      )
      "fold: input and output are products of feature lists.
      (1) If two feature lists are equal, with the exception of a single common
          feature with different values, then these two feature lists are
          collapsed into one feature list, multiplying the values to create a
          new common feature value.
      (2) If a feature list has the same feature twice, then these occurrences
          are collapsed into one occurrence, with the product of the original
          values as new value.
      "
      ( fold
      =   A M Z B a f v1 v2 z
        .       !arg
              :   ?A
                * ( `%?B*?Z
                  &   !B
                    :   ?a
                        (?f,?v1)
                        ( ?z
                        & !Z:?M*(!a (!f,?v2) !z)*?Z
                        )
                  )
            & fold$(!A*(!a (!f,!v1*!v2) !z)*!M*!Z)
          |     !arg
              : ?A*(?a (?f,?v1) ?M (!f,?v2) ?z)*?Z
            & fold$(!A*(!a (!f,!v1*!v2) !M !z)*!Z)
          | !arg
      )
      ( supplyMissingFields
      =     features x outfeat infeat childfeaturevalue
          , childfeaturevalues featurename featurevalue
          , nfeatures xs
        .       !arg
              : (?outfeat.(?infeat.?)|?infeat.?features)
            & fold$!infeat:?infeat
            & :?nfeatures
            &   whl
              ' (   !features
                  : (?featurename,?featurevalue) ?features
                & ( !outfeat:? (!featurename,?) ?
                  |     !nfeatures
                        ( !featurename
                        ,     !infeat
                            : ? (!featurename,?childfeaturevalues) ?
                          & 0:?xs
                          &   whl
                            ' (   !childfeaturevalues
                                : %?childfeaturevalue^?+?childfeaturevalues
                              &   whl
                                ' (   !featurevalue
                                    :   ?
                                      + ( ?+!childfeaturevalue^?+? ?
                                        . ?x
                                        )
                                      + ?featurevalue
                                  & !x+!xs:?xs
                                  )
                              )
                          & removeNumFactors$!xs
                        )
                    : ?nfeatures
                  )
                )
            &   map
              $ ( (=.!arg:~(?,)|)
                . !nfeatures
                )
          | !outfeat
      )
      ( differentOutput
      =     fields otherPath otherPaths otherFields
          , same other A Z apathfld apathflds
        .   !arg:(?fields.?otherPaths)
          & 0:?same:?other
          &   whl
            ' (   !otherPaths
                : ((?,(?otherFields.?)):?otherPath)+?otherPaths
              & !fields:?apathflds
              &   whl
                ' ( !apathflds:%?apathfld ?apathflds
                  & !otherFields:?A !apathfld ?Z
                  & !A !Z:?otherFields
                  )
              & (   !apathflds:
                  & !otherFields:
                  & !same+!otherPath:?same
                | !other+!otherPath:?other
                )
              )
          & !other:~0
          & (!same.!other)
      )
      ( unfoldIfDivertingOutputs
      =     tool ou apath A Z fields
          , pathsWithSameOutputAsApath pathsWithOtherOutputAsApath
          , goal inputprop
        .       !arg
              : ( ?tool
                , (?ou.?inputprop.((?,(?fields.?)):?apath)+?Z)
                )
            &   differentOutput$(!fields.!Z)
              : (?pathsWithSameOutputAsApath.?pathsWithOtherOutputAsApath)
            &   (!tool,(!ou.!inputprop.!apath+!pathsWithSameOutputAsApath))
              +   unfoldIfDivertingOutputs
                $ (!tool,(!ou.!inputprop.!pathsWithOtherOutputAsApath))
          |   !arg:(?goal.%?A+%?Z)
            &   (!goal.unfoldIfDivertingOutputs$!A)
              + (!goal.unfoldIfDivertingOutputs$!Z)
          | !arg
      )
      ( nofoldCount
      =   tool ou inputprop childstuff A Z goal inputprop
        .     !arg:%?A*%?Z
            & nofoldCount$!A*nofoldCount$!Z
          |   !arg:%?A+%?Z
            & nofoldCount$!A+nofoldCount$!Z
          |   !arg:(?goal.?childstuff)
            & nofoldCount$!childstuff
          |   !arg:(?tool,(?ou.?inputprop.?childstuff))
            & nofoldCount$!childstuff:?childstuff
          | 1
      )
      ( unfoldCount
      =     tool ou ou2 inputprop childstuff A Z goal
          , inputprop feature
        .     !arg:%?A*%?Z
            & unfoldCount$!A*unfoldCount$!Z
          |   !arg:%?A+%?Z
            & unfoldCount$!A+unfoldCount$!Z
          |   !arg:(?goal.?childstuff)
            & unfoldCount$!childstuff
          |     !arg
              : ( ?tool
                , ( ?A (?feature,%?ou+%?ou2) ?Z
                  . ?inputprop
                  . ?childstuff
                  )
                )
            &     unfoldCount
                $ ( !tool
                  , ( !A (!feature,!ou) !Z
                    . !inputprop
                    . !childstuff
                    )
                  )
              +   unfoldCount
                $ ( !tool
                  , ( !A (!feature,!ou2) !Z
                    . !inputprop
                    . !childstuff
                    )
                  )
          |   !arg:(?tool,(?ou.?inputprop.?childstuff))
            & unfoldCount$!childstuff:?childstuff
          | 1
      )
      ( graphCount
      =   ou parent siblings child A seen ret sibl
        .   !arg:(?parent.?siblings.?child)
          & (   !child:%*%:?seen
              & 1:?sibl
              &   whl
                ' ( !child:%?A*?arg
                  &   graphCount$(!parent !seen.!sibl.!A)
                    : (?sibl.?ret)
                  )
              & !seen
            |   !arg:%+%:?seen
              & 0:?ret
              &   whl
                ' ( !arg:%?A+?arg
                  & !ret+(!seen.!A.graphCount$!A):?ret
                  )
              & !ret
            | !arg:(?.?child)&graphCount$!child
            |   !arg:(?,(?ou.?.?child))
              & graphCount$!child:?seen
              & ( 
                |   whl
                  ' ( !ou:? ((?,%+%):?A) ?ou
                    & !seen*!A:?seen
                    )
                )
              & !seen
            | 1
            )
      )
      ( leaveFeat
      =   A
        .     !arg:%?A*%?arg
            & leaveFeat$!A*leaveFeat$!arg
          | !arg:(?,(?.?.?.?arg))&leaveFeat$!arg
          | !arg:(?,(?.?.?arg))&!arg
          |   !arg:(?.(?,?):?arg)
            & leaveFeat$!arg
          | !arg:(@,?) ?
      )
      ( subtract
      =   all org
        .   !arg:(?all.?org)
          &   map
            $ ( ( 
                =   f
                  .   !arg:(?f,?)
                    & ( !org:? (!f,?) ?&
                      | !arg
                      )
                )
              . !all
              )
      )
      ( selectCommonTracks
      =     sum eliminate result term recur
          , len spitSums spotSums
        .   ( spitSums
            =   a
              .     !arg:%*%
                  & whl'(!arg:%?a*?arg&spitSums$!a)
                |   !arg:(?,(?.?.?.?arg))
                  & spitSums$!arg
                |   !arg:%+%
                  & !arg^Q*!sums:?sums
                  & whl'(!arg:%?a+?arg&spitSums$!a)
                | 
            )
          & ( spotSums
            =   a
              .     !arg:%*%
                  & whl'(!arg:%?a*?arg&spotSums$!a)
                |   !arg:(?,(?.?.?.?arg))
                  & spotSums$!arg
                |   !arg:%+%
                  & !arg*!sums:?sums
                  & whl'(!arg:%?a+?arg&spitSums$!a)
                | 
            )
          & (len=.!arg:?+[?arg&!arg)
          & ( eliminate
            =   term O R T o i W S J D s sum
              .   !arg:(?arg.?sum.?term)
                & !arg:(?O.?W)
                & (   !W:%+%
                    & !W:!sum
                    & !W:?+!term+?
                    & (!O.!term)
                  |   !W:%*%:?S
                    & 1:?R
                    & 0:?D
                    &   whl
                      ' ( !S:%?s*?S
                        &     !R
                            * (   !s:(?T,(?o.?i.?J))
                                & eliminate$(!J.!sum.!term):?J
                                & 1:?D
                                & (!T,(!o.!i.!J))
                              | !s
                              )
                          : ?R
                        )
                    & !D:1
                    & (!O.!R)
                  |   !W:(?T,(?o.?i.?J))
                    & !J:(?.?)
                    & eliminate$(!J.!sum.!term):?J
                    & (!O.!T,(!o.!i.!J))
                  )
            )
          & ( recur
            =   OUT WAY sum term result Term sums isum
              .   0:?result
                &   whl
                  ' ( !arg:#*(?OUT.?WAY)+?arg
                    & (   1:?sums
                        & spotSums$!WAY
                        & "Sums that have a Q in the exponent are children of another sum. 
                           We only want unshielded sums, working out way down."
                        &   !sums
                          : ( ?*(%+%:?sum)*?
                            | ?*(%+%:?sum)^#*?
                            )
                        & !sum:?isum
                        &   whl
                          ' ( !isum:%?term+?isum
                            & (       eliminate
                                    $ ((!OUT.!WAY).!sum.!term)
                                  : ?Term
                                & recur$!Term:?Term
                                & !result+!Term:?result
                              | !result+!term:?result
                              )
                            & len$!result:~>1001
                            )
                      | !result+(!OUT.!WAY):?result
                      )
                    & len$!result:~>1001
                    )
                & !result
            )
          & 0:?result
          &   whl
            ' ( !arg:%?term+?arg
              & !result+recur$!term:?result
              )
          & !result
      )
      ( createNewGoal
      =   toolFeatures rfield rvals rins rin newGoal RI
        .   !arg:(?newGoal.?toolFeatures)
          &   whl
            ' ( !toolFeatures:(?rfield,?rvals) ?toolFeatures
              & 0:?rins
              &   whl
                ' ( !rvals:(?rin.?)+?rvals
                  &   whl
                    ' ( !rin:%?RI+?rin
                      & ( !rins:?+!RI+?
                        | !RI+!rins:?rins
                        )
                      )
                  )
              & (!rfield,!rins) !newGoal:?newGoal
              )
          & !newGoal
      )
      (NA=|"?"|0)
      ( product
      =   a
        .   !arg:%?a %?arg&!a*product$!arg
          | !arg
      )
      ( log1
      = .!lg:1&log$!arg|
      )
      ( matchGoalWithFeatures
      =     goaly toolFeatures
          , newGoal pathfields gfield gvaluesAlts ngoal
          , Ar Zr gvaluePoss gspc ispc gvaluesAlt
          , input A Z oinput gval done
          , matchAlternative matchOutputAlternative
          , nnewGoal toolfeat xispc updateInput
        .   ( matchOutputAlternative
            =     outAlt gvaluesAlt len gvaluePoss gspc ispc
                , PathPart
              .   !arg:(?outAlt.?gvaluesAlt)
                & (!gvaluesAlt:(?gvaluesAlt.OnE)|)
                & "gvaluesAlt can have % prefix.
                   If so, outAlt must match all factors. 
                   If not, outAlt must match exactly one factor."
                & !outAlt:?*[?len
                & !gvaluesAlt:?*[!len
                & 1:?PathPart
                &   whl
                  ' ( !outAlt:~1
                    & !gvaluesAlt:%@?gvaluePoss^?gspc*?gvaluesAlt
                    &   !outAlt
                      :     !gvaluePoss
                          ^ (   (1|!gspc)
                              & !PathPart*!gvaluePoss^!gspc:?PathPart
                            |   ?ispc
                              & ( !gspc:1
                                |   shared$(!gspc.!ispc):?xispc
                                  & !xispc:~1:?ispc
                                )
                              & !PathPart*!gvaluePoss^!ispc:?PathPart
                            )
                        * ?outAlt
                    )
                & 1:!gvaluesAlt:!outAlt
                & !PathPart
            )
          & ( updateInput
            =     Nw Inp inp nip in pu osp NW val In Ins
                , sip NIN
              .   !arg:(?Inp.?val)
                & 0:?Nw
                &   whl
                  ' ( !Inp:%?inp+?Inp
                    & :?sip
                    &   whl
                      ' ( !inp:%?Ins ?inp
                        & 1:?NW
                        &   whl
                          ' ( !Ins:%?In*?Ins
                            & (   !In:(?In.OnE)
                                & 1:?NIN
                                &   whl
                                  ' ( !In:%@?in^?pu*?nip
                                    &     !NIN
                                        *   !in
                                          ^ (   !pu:1
                                              & (     !val
                                                    : ?*!in^?osp*?
                                                  & !osp
                                                | 1
                                                )
                                            | !pu
                                            )
                                      : ?NIN
                                    & !nip:?In
                                    )
                                & !NW*(!NIN.OnE):?NW
                              |   !In:%@?in^?pu
                                &     !NW
                                    *   !in
                                      ^ (   !pu:1
                                          & (   !val:?*!in^?osp*?
                                              & !osp
                                            | 1
                                            )
                                        | !pu
                                        )
                                  : ?NW
                              )
                            )
                        & (   !Ins:1
                            & !sip !NW:?sip
                          | 
                          )
                        )
                    & (!sip:|!Nw+!sip:?Nw)
                    )
                & !Nw:~0
            )
          & ( matchAlternative
            =     toolfeat gvaluesAlt toolAlt input gfield
                , oinput A Z done newGoal
                , PathPart outAlt ninput inp
              .     !arg
                  : (?toolfeat.?gfield,?gvaluesAlt.?newGoal)
                & 0:?done
                & "Input can be a sum. Each term can have optional values,
                   but optional values cannot be products of two or more values.
                   E.g. (test.facet,((lex kwic)+(headmov*lem wrdsplt npr).Ngram))"
                &   whl
                  ' ( !toolfeat:%?toolAlt+?toolfeat
                    & (   !toolAlt
                        : ( ?input
                          .   !NA
                            |     ?
                                + ( `%?outAlt
                                  &     matchOutputAlternative
                                      $ (!outAlt.!gvaluesAlt)
                                    : ?PathPart
                                  )
                                + ?
                              &   updateInput$(!input.!PathPart)
                                : ?input
                              &   (     !pathfields
                                      : ?A (!gfield,?gval) ?Z
                                    &   !A
                                        ( !gfield
                                        ,   !gval:?+!PathPart+?
                                          | !gval+!PathPart
                                        )
                                        !Z
                                  | !pathfields (!gfield,!PathPart)
                                  )
                                : ?pathfields
                              &   (     !newGoal
                                      : ?A (!gfield,?oinput) ?Z
                                    & !oinput:?ninput
                                    &   whl
                                      ' ( !input:%?inp+?input
                                        & ( !ninput:?+!inp+?
                                          | !inp+!ninput:?ninput
                                          )
                                        )
                                    & (   !oinput:!ninput
                                        & (!gfield,!ninput)
                                      | !A (!gfield,!ninput) !Z
                                      )
                                  | !newGoal (!gfield,!input)
                                  )
                                : ?newGoal
                              & 1+!done:?done
                          )
                      | 
                      )
                    )
                & !done:~0
                & !newGoal
            )
          & !arg:(?goaly.?toolFeatures)
          & "ALL of goaly must be satisfied by a single tool.
             goaly can be a single factor of a complex goal that must be satisfied by multiple tools.
             If the goal is complex, but must be satisfied by a single tool with a complex output,
             then goaly is complex and structured as (%*%.OnE)."
          & :?newGoal
          & :?pathfields
          & 0:?done
          &   whl
            ' ( !goaly:(?gfield,?gvaluesAlts) ?ngoal
              & "Each goaly field must be satisfied."
              & (   ~(!toolFeatures:? (!gfield,?) ?)
                  & "Assume that tool leaves field unchanged: percolate output requirement to input."
                  & !pathfields (!gfield,!gvaluesAlts):?pathfields
                  & !newGoal (!gfield,!gvaluesAlts):?newGoal
                |   !goaly:(sml,nsl)
                  & !toolFeatures:? (sml,(?.?toolfeat)) ?
                |   !toolFeatures:?Ar (!gfield,?toolfeat) ?Zr
                  & "toolfeat is a sum of alternative (input.output) specs."
                  & !Ar !Zr:?toolFeatures
                  & 0:?done
                  & "gvaluesAlts is a sum of alternative goaly specifications for a single feature. 
                     A term can be the product of multiple feature values, e.g. (lem*pos*syn.OnE) for the feature 'facet'."
                  &   whl
                    ' ( !gvaluesAlts:%?gvaluesAlt+?gvaluesAlts
                      & (       matchAlternative
                              $ ( !toolfeat
                                . !gfield,!gvaluesAlt
                                . !newGoal
                                )
                            : ?newGoal
                          & 1:?done
                        | 
                        )
                      )
                  & "If this test fails, none of the goaly feature values is
                     satisfied by the current tool.
                       Consequence: whl loop is exited and 'goaly' does not get
                                    nil, causing matchGoalWithFeatures to fail.
                    "
                  & !done:1
                )
              & !ngoal:?goaly
              )
          & "Each field must match"
          & !goaly:
          & createNewGoal$(!newGoal.!toolFeatures):?nnewGoal
          & !nnewGoal:?newGoal
          & (!pathfields.sort$!newGoal)
      )
      "
/**
 * Check that pipes having multiple tasks running in parallel have compatible features and feature specialisations.
 */"
      ( illegalSolution
      =     goal pipes toolA toolB outputA outputB inputA inputB
          , vA featA vB agree explicitlySanctioned
          , WRONGPIPES OKPIPES pipe
        .   ( agree
            =   a ea b eb E
              .     !arg
                  : ( %?a^?ea
                    .   (?b.OnE)&1:?eb
                      | %?b^?eb
                    )
                & !a:!b
                & ( !ea:1
                  | !eb:1
                  | !ea:?+(%@?E&!eb:?+!E+?)+?
                  )
            )
          & ( explicitlySanctioned
            =   feat v goal v2
              .   !arg:(?feat,?v.?goal)
                &   !goal
                  :   ?
                    * ( ?
                        (!feat,?v2&agree$(!v.!v2))
                        ?
                      )
                    * ?
            )
          & !arg:(?goal.?pipes)
          & 0:?OKPIPES
          & 0:?WRONGPIPES
          &   whl
            ' ( !pipes:%?pipe+?pipes
              & (     !pipe
                    :   ?
                      * (?toolA,(?outputA.?inputA.?))
                      * ?
                      * ( ?toolB
                        ,   (?outputB.?inputB)
                          &   !outputA
                            :   ?
                                ( ?featA
                                ,   ?vA
                                  & !outputB:? (!featA,?vB) ?
                                  & ~(agree$(!vA.!vB))
                                  & ( ~( explicitlySanctioned
                                       $ (!featA,!vA.!goal)
                                       )
                                    | ~( explicitlySanctioned
                                       $ (!featA,!vB.!goal)
                                       )
                                    )
                                )
                                ?
                        )
                      * ?
                  &     ( !featA vA !vA vB !vB outputB !outputB
                        . !pipe
                        )
                      + !WRONGPIPES
                    : ?WRONGPIPES
                | !pipe+!OKPIPES:?OKPIPES
                )
              )
          & !WRONGPIPES:~0
          & (!WRONGPIPES.!OKPIPES)
      )
      ( refold
      =     A M Z AM MM ZM AZ MZ ZZ ag zg feat
          , val valZ feats featsZ tool g gZ substitute
          , ZMM
        .   ( substitute
            =   a b s d
              .   !arg:(?arg.?s.?d)
                & ( !arg:!s&!d
                  |   !arg:?a_?b
                    & (substitute$(!a.!s.!d))_(substitute$(!b.!s.!d))
                  | !arg
                  )
            )
          &   whl
            ' (   !arg
                :   ?A
                  + `%?M
                  + ( ?Z
                    &   !Z
                      :   ?AZ
                        + ( `%?MZ
                          &   !M
                            :   ?AM
                              * `%?MM
                              * ( ?ZM
                                & !MZ:!AM*?ZMM*!ZM
                                & !MM:~!ZMM
                                & !MM:(?g.?tool,?feats)
                                & !ZMM:(?gZ.!tool,?featsZ)
                                &   !g
                                  :   ?ag
                                      (?feat,?val)
                                      ( ?zg
                                      &   !gZ
                                        : !ag (!feat,?valZ) !zg
                                      & !val:~!valZ
                                      &     substitute
                                          $ (!feats.!feat,!val.)
                                        :   substitute
                                          $ (!featsZ.!feat,!valZ.)
                                      )
                                )
                          )
                        + ?ZZ
                    )
              &     !A
                  +   !AM
                    *   substitute
                      $ (!MM.!feat,!val.!feat,!val+!valZ)
                    * !ZM
                  + !AZ
                  + !ZZ
                : ?arg
              )
          & !arg
      )
      "20111024 collect worked only if the first argument was output from a 
       previous step, not if it was the very first input.
      
      collect:
      The first argument is output from previous steps, and can be ambiguous.
      It can alternatively be the very input to the workflow.

      The second argument is a feature name 'f' and its value 'v'. The value
      can be composed of several values, but is not ambiguous, i.e. just a
      single term. The second argument derives from the current goal.

      The third argument is the ambiguous list of feature values in which 'v'
      is one of the terms.
      "
      ( collect
      =     f v outp a featprod alts opts partOf V remainder
          , actualOptions A Z common partOfFunc vs strictPartOf
        .   !arg:(?arg.?f,?v.?vs)
          & ( partOf
            =   a z S Z spc
              .   !arg:(1.?a)&!a
                |     !arg
                    : ( ( %@?S^?spc*?Z
                        .   ?a
                          * `( !S
                             ^ ( !spc
                               | ?&1:!spc
                               | 1
                               )
                             )
                          * ?z
                        )
                      | (((?.OnE):?S)*?Z.?a*!S*?z)
                      )
                  & partOf$(!Z.!a*!z)
            )
          & ( strictPartOf
            =   a z S Z
              .   !arg:(1.?a)&!a
                |   !arg:(%?S*?Z.?a*`!S*?z)
                  & strictPartOf$(!Z.!a*!z)
            )
          &   (     fct$!vs
                  :   ?
                    * %( %?V+#*!V^%+?
                       & !v:? ?*!V^?*? ?
                       )
                    * ?
                & "vs looks like a*b*c+a*b^x*c+a*b^x*c
                   or            a*b*c+a*b^x*c+a*b^y*c
                   etc., giving factors (b+2*b^x) resp. (b+b^x+b^y)
                  "
                & '$strictPartOf
              | '$partOf
              )
            : (=?partOfFunc)
          & ( actualOptions
            =   a z S Z spc spc2
              .   !arg:(1.?)&1
                |   !arg:(%@?S^?spc*?Z.?z)
                  & (     !z
                        :   ?a
                            `( !S
                             ^ ( !spc
                               | ?spc2&1:!spc
                               )
                             )
                            ?z
                      & !S^!spc2*actualOptions$(!Z.!a !z)
                    | actualOptions$(!Z.!z)
                    )
            )
          & 0:?outp
          & (!v:%?v %?opts|1:?opts)
          & !arg:?alts
          & "step through the alternative paths"
          &   whl
            ' ( !alts:%?a+?alts
              & (   !a:(?featprod.?)
                  & "There are previous workflow steps (the ?)."
                  & (     fold$!featprod
                        :   ?
                          * ( ?
                              ( !f
                              ,   ?
                                + ( `%?V
                                  & partOfFunc$(!v.!V):?remainder
                                  & partOf$(!remainder.!opts)
                                  )
                                + ?
                              )
                              ?
                            )
                          * ?
                      & !a+!outp:?outp
                    | 
                    )
                |   !a:?featprod
                  & "The input itself is ambiguous!
                     (TODO: can it really be a product?)
                    "
                  & (     fold$!featprod
                        :   ?A
                            ( !f
                            ,   ?V
                              & partOf$(!v.!V):?remainder
                              &   !v*actualOptions$(!remainder.!opts)
                                : ?common
                            )
                            ?Z
                      & (!A (!f,!common) !Z)+!outp:?outp
                    | 
                    )
                | !a+!outp:?outp
                )
              )
          & !outp
      )
      " distribute:
      The first argument is a feature list designating a goal, the second
      argument is input that matches the goal, but is structured differently.
      If the goal has a multivalued feature (i.e. a product of values), then
      the input either
      (1) has a feature list for each value
      (2) has a feature list with a multivalued value, just like the goal.
      The second is the case if the multivalued feature in the goal is prefixed
      with a % sign.

      The input can be the very input to the workflow or the potential outputs
      from previous steps. In the second case, the input is a sum of
      alternative paths, each term structured as (output.path-to-output), where
      'output' can be a product of paths coming together.

      The very input to the workflow can consist of more than one file.

      The purpose of 'distribute' is to handle all features that have
      alternating values, i.e. values that are sums of two or more values
      or products of values. The result of 'distribute' is a sum of 
      disambiguated feature lists, each feature list paired with the
      corresponding workflow(s).
      "
      ( distribute
      =     Res prop input a f vs z aa v
          , incarnationInput
        .   !arg:(?prop.?input)
          & (   !prop:?a (?f,%+%:?vs) ?z
              & 0:?Res
              & !vs:?aa
              &   whl
                ' ( !aa:`%?v+?aa
                  &   collect$(!input.!f,!v.!vs)
                    : ?incarnationInput
                  &     ( !incarnationInput:0
                        |   distribute
                          $ (!a (!f,!v) !z.!incarnationInput)
                        )
                      + !Res
                    : ?Res
                  )
              & !Res
            | !arg
            )
      )
      (assert=.!arg)
      ( restrictOutputParms
      =     pathh toolFeatures outp tool ou prop in nou
          , v e es A f a b Z I
        .   !arg:(?pathh.?toolFeatures)
          &   whl
            ' ( !pathh:(?tool,(?ou.?prop.?in))+?pathh
              &     map
                  $ ( ( 
                      =   f vs val nvs i v e
                        .       !arg
                              : ( ?f
                                ,   ( %+%:?vs
                                    |   ?v^(%+%:?es)
                                      & 0:?vs
                                      &   whl
                                        ' ( !es:%?e+?es
                                          & !v^!e+!vs:?vs
                                          )
                                    )
                                  &   !toolFeatures
                                    : ? (!f,?val) ?
                                )
                            & 0:?nvs
                            &   whl
                              ' ( !vs:%?v^?e+?vs
                                & (     !val
                                      : ( 0
                                        |   ?
                                          + ( (?i.?+?*!v^(?+!e+?)*?+?)
                                            &   !i
                                              :   ?
                                                + `%?I
                                                + ( ?
                                                  &   !prop
                                                    :   ?
                                                        (!f,?+?*!I^?*?+?)
                                                        ?
                                                  )
                                            )
                                          + ?
                                        )
                                    & !nvs+!v^!e:?nvs
                                  | 
                                  )
                                )
                            & (!f,!nvs)
                          | !arg
                      )
                    . !ou
                    )
                : ?nou
              & :?outp
              &   whl
                ' ( !nou:?A (?f,%?a+%?b) ?Z
                  &     !outp
                        (!tool,(!A (!f,!a) !Z.!prop.!in))
                    : ?outp
                  & !A (!f,!b) !Z:?nou
                  )
              & !outp (!tool,(!nou.!prop.!in)):?outp
              )
          & !outp
      )
      ( getActiveTools
      =   T F L S tlprp
        .   :?L
          & readTable$tooladm
          & readTable$toolprop
          & !toolprop:?tlprp
          &   whl
            ' ( !tlprp:(?T.?F)+?tlprp
              & (     !tooladm
                    :   ?
                      + ( ? (ToolID.!T) ?
                        : ? (ServiceURL.~) ?
                        : ? (Inactive.) ?
                        )
                      + ?
                  & (!T.!F) !L:?L
                | 
                )
              )
          & 0:?S
          & whl'(!L:%?T ?L&!T+!S:?S)
          & !S
      )
      ( makeSuperGoals
      =   name os Os c o v vs ss s collector
        .   "makeSuperGoals only returns value sets for features 
             that have at least one composed feature value."
          & :?SuperSets
          & 0:?vs
          & !arg:?collector
          &   whl
            ' ( !collector:%?name^%(?os:?Os)*?collector
              & :?c
              &   whl
                ' ( !os:?+#*~#%?o+?os
                  &   whl
                    ' (!o:%?v*?o&!v+!vs:?vs)
                  )
              &   whl
                ' ( !vs:?+#*~#%@?v+?vs
                  & !Os:?os
                  & :?ss
                  &   whl
                    ' (   !os
                        : ?+(?*!v*?:#*(~#%@*?:?s))+?os
                      & !ss !s:?ss
                      )
                  & !c (!v.!ss):?c
                  )
              & (   !c:? (?.? %*% ?) ?
                  & !SuperSets (!name.!c):?SuperSets
                | 
                )
              )
          & !SuperSets
      )
      ( makeExpandedSelectLists
      =   servicedSuperGoals
        .   !arg:?servicedSuperGoals
          & readTable$features
          &   map
            $ ( ( 
                =   featName valueExpandedListPairs tbl
                  .   !arg:(?featName.?valueExpandedListPairs)
                    &   !features
                      :   ?
                        + ( ? (short.!featName) ?
                          : ? (table.?tbl) ?
                          )
                        + ?
                    & readTable$!tbl:?tbl
                    & ( !featName
                      .   makeOptgroupList
                        $ (!valueExpandedListPairs,!tbl.)
                      )
                )
              . !servicedSuperGoals
              )
      )
      ( namecell
      =   featurs short name table
        .   !arg:(?featurs.?short.?name)
          &   cell
            $ (     !featurs
                  :   ?
                    + ( ? (short.!short) ?
                      : ? (description.?description) ?
                      : ? (table.?table) ?
                      )
                    + ?
                &   helplink
                  $ ( (title.localized$!description)
                      (offset.!table)
                      (linktext.!name)
                    )
              | !name
              )
      )
      ( featurehelpcell
      =   featurs short inorout help
        .   !arg:(?featurs.?short.?inorout)
          &   cell
            $ (     !featurs
                  :   ?
                    + ( ? (short.!short) ?
                      : ? (!inorout.?help) ?
                      )
                    + ?
                & ( div
                  .   (class.tooltip)
                    ,   (small.,(small.,chu$10068))
                        (span.(class.tooltiptext),localized$!help)
                  )
              | 
              )
      )
      ( selectServicedValues
      =   short table pat Pat
        .     !arg:(?short.?table.(=?pat))
            & readTable$toolprop
            & readTable$tooladm
            & readTable$features
            & "Important! Next map fuction has local variable 'abbr', spelled just like that. '!abbr' occurs in pattern 'pat'."
            &   map
              $ ( ( 
                  =   tool Full abbr YYy
                    .   !arg:(?Full.?abbr.?YYy)
                      & !pat:(=?Pat)
                      & (   !( 
                             ' ( $toolprop
                               :   ?
                                 + (   ?tool
                                     &   $tooladm
                                       :   ?
                                         + ( ? (ToolID.!tool) ?
                                           : ? (Inactive.) ?
                                           )
                                         + ?
                                   . ? ($short,$Pat) ?
                                   )
                                 + ?
                               )
                             )
                          & (!Full.!abbr.!YYy)
                        | 
                        )
                  )
                . !table
                )
          | !table
      )
      ( createGoalPickLists
      =   preselvalsrows,expandedSelectLists including OP
        .   !arg:(?preselvalsrows.?expandedSelectLists.?including)
          &   (!including:&P|O)
            : ?OP
          &   map
            $ ( ( 
                =     short name table servicedGoalsTable
                    , servicedGoals optgroups
                  .     !arg:(?.?short.?name.?table.)
                      & (   !servicedGoals
                          : ? (!short.?servicedGoalsTable) ?
                        |       selectServicedValues
                              $ ( !short
                                . !table
                                . ( 
                                  = '(?+(?.?+?*$abbr^?*?+? ?)+?)
                                  )
                                )
                            : ?servicedGoalsTable
                          &     (!short.!servicedGoalsTable)
                                !servicedGoals
                            : ?servicedGoals
                        )
                      &   row
                        $ ( namecell$(!features.!short.localized$!name)
                            featurehelpcell$(!features.!short.goalhelp)
                            (     !expandedSelectLists
                                : ? (!short.?optgroups) ?
                              &     cell
                                  $ ( makeSelectFormField
                                    $ ( 
                                      . str$(!OP !short)
                                      . options
                                      . !optgroups
                                      )
                                    )
                                  ( !including:
                                  |   cell
                                    $ ( makeCheckboxFormField
                                      $ (   localized
                                          $ ( "Compute workflows for similar goals (= less specific)"
                                              "Beregn arbejdsgange for lignende m√•l (= mindre specifikt)"
                                            )
                                        . str$(SuperSet- !short)
                                        .   (val.)
                                            ( desc
                                            .   localized
                                              $ ( "Check this box if your requirements are MINIMAL requirements. For example, if your requirement is to have PoS tags, you may also want to see workflows that produce PoS tags AND lemmas, at the same time."
                                                  "Marker hvis dit m√•l er minimal, fx hvis du udover PoS tags ogs√• godt vil se lemmaer, i kombination med PoS tags."
                                                )
                                            )
                                        )
                                      )
                                  )
                            |   cell
                              $ ( makeSelectFormField
                                $ ( 
                                  . str$(!OP !short)
                                  . options
                                  . makeOptionList$(!servicedGoalsTable.)
                                  )
                                )
                            )
                          )
                    | 
                )
              . !preselvalsrows
              )
      )
      ( retrieveServicedOutputFeaturesAndTheirValues
      =   Feats activeTools collector SuperSets
        .   !arg:?activeTools
          & 1:?collector
          &   whl
            ' ( !activeTools:(?.?Feats)+?activeTools
              &   map
                $ ( ( 
                    =   ios o os Os a e m name z
                      .   !arg:(?name,?ios)
                        & 0:?Os
                        &   whl
                          ' ( !ios:(?.?os)+?ios
                            &   whl
                              ' ( !os:%?o+?os
                                &   whl
                                  ' ( !o:?a*%@?m^%?e*?z
                                    & !a*!m*!z:?o
                                    )
                                & !Os+!o:?Os
                                )
                            )
                        & !name^!Os*!collector:?collector
                    )
                  . !Feats
                  )
              )
          & !collector
      )
      ( fp
      =     tool source goal restriction superset makeSmell
          , fulfil memoizedSteps activeTools Calls smell resembling
          , memos duplic impassages notttcnt getSuperGoals
          , sourcegoalmatch unfulfillable notThisTool fulfilGoal
          , isfulfilled hasfulfilled fulfilGoalProduct unfoldGoal
          , getGoals getImplicatedGoals N21 inner smellCache
        .   0:?smell
          & :?smellCache
          & ( makeSmell
            =   A Z o tool sml
              .   !arg:(?tool.?arg)
                & (   !arg:?A (sml,(?o.nsl)) ?Z
                    &   ( !smellCache:? (!tool.?sml) ?
                        |     (!tool.1+!smell:?smell:?sml)
                              !smellCache
                          : ?smellCache
                        )
                        ?
                    & !A (sml,(!o.str$(S !sml))) !Z
                  | !arg
                  )
            )
          & ( isfulfilled
            =   source src goal gl tool pipe pipes
              .   !arg:(?source.?goal.?tool)
                & product$!source:?src
                & product$!goal:?gl
                & 0:?pipes
                & (   !memoizedSteps
                    :   ?
                      + ( !src
                        . !gl
                        .   ?
                          + ( (!tool,?):?pipe
                            & !pipe+!pipes:?pipes
                            & ~
                            )
                          + ?
                        )
                      + ?
                  | !pipes:~0&(!source.!goal.!pipes)
                  )
            )
          & ( hasfulfilled
            =   source src goal gl term a b m,pipe
              .   !arg:(?source.?goal.?pipe)
                &   ( product$!source:?src
                    . product$!goal:?gl
                    . !pipe
                    )
                  : ?term
                & (   !memoizedSteps:?+!term+?
                    & 1+!duplic:?duplic
                  |   !memoizedSteps:?a+(!src.!gl.?m)+?b
                    & (   !m:?+!pipe+?
                        & 1+!duplic:?duplic
                      | !a+(!src.!gl.!m+!pipe)+!b:?memoizedSteps
                      )
                  | !term+!memoizedSteps:?memoizedSteps
                  )
                & !arg
            )
          & ( inner
            =   A B BB L M a b wrong
              .     ( wrong
                    =   F A tool f v
                      .   1:?F
                        &   whl
                          ' ( !arg:?*(?tool,(%?A.?))*?arg
                            &   whl
                              ' ( !A:(?f,%@?v^?) ?A
                                & !f^!v*!F:?F
                                )
                            )
                        & !F:?*?^(%+%)*?*?^(%+%)*?
                    )
                  & !arg:%?A*%?BB
                  & :?L
                  &   whl
                    ' ( !A:%?a+?A
                      & !BB:?B
                      &   whl
                        ' ( !B:%?b+?B
                          & ( wrong$(!a*!b)
                            | !a*!b !L:?L
                            )
                          )
                      )
                  &   whl
                    ' ( !L:% %
                      & :?M
                      &   whl
                        ' ( !L:%?a %?b ?L
                          & !a+!b !M:?M
                          )
                      & !L !M:?L
                      )
                  & !L
                | !arg
            )
          & ( resembling
            =   I O
              .   !arg:(?I.?O)
                &   map
                  $ ( ( 
                      =   v w f
                        .   !arg:(?f,%?v ?w)
                          & ( !f
                            ,   !v
                                  map
                                $ ( ( 
                                    =   
                                      .       !O
                                            : ?*(? (!f,!arg) ?)*?
                                          & !arg
                                        | 
                                    )
                                  . !w
                                  )
                            )
                      )
                    . !I
                    )
            )
          & ( fulfilGoal
            =     tools forkk goaly
                , toolspath pathsonetool tool ltools path1
                , toolFeatures pathh pathfields newGoal infeat
                , memopaths restriction
                , goal source I IO O Os sourcePlus
              .   "Check whether source and goal already have been connected by tool and stored as a step."
                & !arg:(?source.?goaly.?tools.?restriction.?forkk)
                & !forkk:~0
                &     (     (unfulfillable..find)$(str$!goaly)
                          : ? (?.!source) ?
                        & 1+!impassages:?impassages
                        & 0
                      |   unify$(!source.fold$!goaly):?sourcePlus
                        & 1+!sourcegoalmatch:?sourcegoalmatch
                        & sort$!sourcePlus
                      |     (!restriction:~0|!tools)
                          : ?ltools
                        & 0:?toolspath
                        &   whl
                          ' ( !forkk:~0
                            & !ltools:(?tool.?)+?
                            & 0:?pathsonetool
                            & (     (notThisTool..find)$(str$!goaly)
                                  : ? (?.!tool.!source) ?
                                & whl'(!ltools:(!tool.?)+?ltools)
                                & 1+!notttcnt:?notttcnt
                              |     isfulfilled$(!source.!goaly.!tool)
                                  : (?source.?goal.?memopaths)
                                & 1+!memos:?memos
                                & whl'(!ltools:(!tool.?)+?ltools)
                                &   denumerizeSum$(!toolspath+!memopaths)
                                  : ?toolspath
                                & 1+!pathsonetool:?pathsonetool
                              |   whl
                                ' (   !ltools
                                    :   ?
                                      + (!tool.~:?toolFeatures)
                                      + ?ltools
                                  &   makeSmell$(!tool.!toolFeatures)
                                    : ?toolFeatures
                                  & (       matchGoalWithFeatures
                                          $ (!goaly.!toolFeatures)
                                        : (?pathfields.?newGoal)
                                      & (       fulfil
                                              $ ( !tools
                                                . !source
                                                . !newGoal
                                                . !indent+1
                                                . 0
                                                )
                                            : ?pathh
                                          &   removeNumFactors$!pathh
                                            : ?infeat
                                          &   distribute$(!newGoal.!infeat)
                                            : ?IO
                                          & 0:?memopaths
                                          &   whl
                                            ' ( !IO:(?I.?Os)+?IO
                                              &   whl
                                                ' ( !Os:%?O+?Os
                                                  &   ( !tool
                                                      , (   sort
                                                          $ ( !pathfields
                                                                supplyMissingFields
                                                              $ ( !pathfields
                                                                . !O
                                                                . !toolFeatures
                                                                )
                                                            )
                                                        . resembling$(!I.!O)
                                                        . !O
                                                        )
                                                      )
                                                    : ?pathh
                                                  & (   assert
                                                      ' ( !pathh
                                                        : ~( ?
                                                           + ( ?
                                                             , (   ?
                                                                   ( ?
                                                                   ,   %+%
                                                                     | %^(%+%)
                                                                   )
                                                                   ?
                                                               . ?
                                                               . ?
                                                               )
                                                             )
                                                           + ?
                                                           )
                                                        )
                                                    |     restrictOutputParms
                                                        $ (!pathh.!toolFeatures)
                                                      : ?pathh
                                                    )
                                                  &   whl
                                                    ' (   !pathh
                                                        : %?path1 ?pathh
                                                      & (   !toolspath
                                                          : ?+!path1+?
                                                        |       !toolspath
                                                              + !path1
                                                            : ?toolspath
                                                          &     !memopaths
                                                              + !path1
                                                            : ?memopaths
                                                        )
                                                      )
                                                  )
                                              )
                                          &   1+!pathsonetool
                                            : ?pathsonetool
                                          &   hasfulfilled
                                            $ (!source.!pathfields.!memopaths)
                                          & ( !goaly:!pathfields
                                            |   hasfulfilled
                                              $ (!source.!goaly.!memopaths)
                                            )
                                        | 0:?pathh
                                        )
                                    | "Tool's output does not match goal"
                                    )
                                  & !Calls:>0
                                  )
                              )
                            & !Calls:>0
                            & (   !pathsonetool:0
                                &   (notThisTool..insert)
                                  $ (str$!goaly.!tool.!source)
                              | 
                              )
                            )
                        & !Calls:>0
                        & "forkk will become zero if no tools can fulfil goaly!"
                        & (   !toolspath:0
                            &   (unfulfillable..insert)
                              $ (str$!goaly.!source)
                          | 
                          )
                        & !toolspath
                      | 0
                      )
                    * !forkk
                  : ?forkk
                & inner$!forkk:?forkk
                & !Calls:>0
                & !forkk
            )
          & ( fulfilGoalProduct
            =   goalterm tools forkk goaly restriction source
              .   "Check whether source and goal already have been connected by tool and stored as a step."
                & !arg:(?source.?goalterm.?tools.?restriction)
                & 1:?forkk
                &   whl
                  ' ( !forkk:~0
                    & 1+!Calls:?Calls
                    & (   mod$(!Calls,100):0
                        & log$!Calls
                        & clk$+!StartClk:>60
                        & -1*!Calls:?Calls
                      | 
                      )
                    & !Calls:>0
                    & !goalterm:%?goaly*?goalterm
                    &     fulfilGoal
                        $ (!source.!goaly.!tools.!restriction.!forkk)
                      : ?forkk
                    )
                & !Calls:>0
                & 1+!forkk+-1
            )
          & " unfoldGoal:
              Construct all 2^n combinations of n options,
              and unfold all alternatives.
              Output: a list of disambiguated goals."
          & ( unfoldGoal
            =     A Z AA ZZ AAA ZZZ M1 M2 prod
                , gfield gopts convertOptionsToAlternatives
              .   ( convertOptionsToAlternatives
                  =   gopt gopts gvaluesAlts
                    .   !arg:%?gvaluesAlts ?gopts
                      &   whl
                        ' ( !gopts:%?gopt ?gopts
                          &   !gvaluesAlts+!gvaluesAlts*!gopt
                            : ?gvaluesAlts
                          )
                      & !gvaluesAlts
                  )
                &   whl
                  ' (   !arg
                      :   ?A
                        +   ?AA
                          * ( ?AAA
                              (?gfield,(% %|%+%):?M1)
                              ?ZZZ
                            )
                          * ?ZZ
                        + ?Z
                    & convertOptionsToAlternatives$!M1:?M1
                    & !A+!Z:?arg
                    &   whl
                      ' ( !M1:%?M2+?M1
                        &   !arg+!AA*(!AAA (!gfield,!M2) !ZZZ)*!ZZ
                          : ?arg
                        )
                    )
                &   whl
                  ' (   !arg
                      :   ?A
                        +   ?AA
                          * ( ?AAA
                              (?gfield,%?M1*%?M2:?prod)
                              ?ZZZ
                            )
                          * ?ZZ
                        + ?Z
                    &     !A
                        +   !AA
                          * (!AAA (!gfield,!M1) !ZZZ)
                          * (!AAA (!gfield,!M2) !ZZZ)
                          * !ZZ
                        + !Z
                      : ?arg
                    )
                &   whl
                  ' ( !arg:?A+#%@*?M1+?Z
                    & !A+!M1+!Z:?arg
                    )
                & !arg
            )
          & ( fulfil
            =     tools source goal sourcePlus forkk found
                , goals goalterm nnnpathh indent accPipelines
                , Pipeline WRONGPIPES OKPIPES restriction
              .   !arg:(?tools.?source.?goal.?indent.?restriction)
                & "Restrict path length to max 20"
                & !indent:<20
                & (|1+!Calls:?Calls)
                & 0:?accPipelines
                & unfoldGoal$!goal:?goals
                & 0:?found
                &   whl
                  ' ( !goals:%?goalterm+?goals
                    & (     (     unify$(!source.fold$!goalterm)
                                : ?sourcePlus
                              & sort$!sourcePlus
                            |       fulfilGoalProduct
                                  $ (!source.!goalterm.!tools.!restriction)
                                : ?forkk
                              & !Calls:>0
                              &   (     !forkk
                                      : ( 0
                                        | 1
                                        | ?+[>2000
                                        )
                                    & 0
                                  |   ~
                                    &   illegalSolution$(!goalterm.!forkk)
                                      : (?WRONGPIPES.?OKPIPES)
                                    &   log
                                      $ ( WRONGPIPES
                                          !WRONGPIPES
                                          OKPIPES
                                          !OKPIPES
                                        )
                                    & (!goalterm.!OKPIPES)
                                  | (!goalterm.!forkk)
                                  )
                                : ~0
                                : ?nnnpathh
                              & refold$!nnnpathh
                            )
                          : ?Pipeline
                        & 1+!found:?found
                        & !Pipeline+!accPipelines:?accPipelines
                      | 
                      )
                    & !Calls:>0
                    )
                & !Calls:>0
                & ( !accPipelines:~0&!accPipelines
                  | !found:~0&0
                  )
            )
          & ( getGoals
            =     AllFs Inca FS Ios allOs Os O
                , X A FN a b Y Z add%
              .   ( add%
                  =   dun incar
                    .   0:?dun
                      &   whl
                        ' ( !arg:%?incar+?arg
                          &     !dun
                              +   map
                                $ ( ( 
                                    =   v f
                                      .   !arg:(?f,?v)
                                        & ( !f
                                          ,     !v:%*%
                                              & N21$!v
                                            | !v
                                          )
                                    )
                                  . !incar
                                  )
                            : ?dun
                          )
                      & !dun
                  )
                & 0:?AllFs
                &   whl
                  ' ( !arg:%?Inca+?arg
                    & :?FS
                    &   whl
                      ' ( !Inca:(?FN,?Ios) ?Inca
                        & 0:?allOs
                        &   whl
                          ' ( !Ios:(?.?Os)+?Ios
                            &   whl
                              ' ( !Os:%?O+?Os
                                & !O+!allOs:?allOs
                                )
                            & 
                            )
                        & !FS (!FN,!allOs):?FS
                        )
                    &   whl
                      ' ( !FS:?X+#*(?A (?FN,%?a+%?b) ?Z)+?Y
                        &     !X
                            + (!A (!FN,!a) !Z)
                            + (!A (!FN,!b) !Z)
                            + !Y
                          : ?FS
                        )
                    & !FS+!AllFs:?AllFs
                    )
                & add%$(removeNumFactors$!AllFs)
            )
          & ( getImplicatedGoals
            =   allios tools,restriction ios restrictedTools
              .   !arg:(?tools.?restriction)
                & 0:?allios:?restrictedTools
                & (   !tools
                    :   ?
                      + ( !restriction
                        .   ?ios
                          & !ios+!allios:?allios
                          &   (!restriction.!ios)+!restrictedTools
                            : ?restrictedTools
                          & ~
                        )
                      + ?
                  | 
                  )
                & (getGoals$!allios.!restrictedTools)
            )
          & "N21: Mark the argument as feature values all found in a single
             file. If the argument is atomic, just return the argument. Else,
             embed the product of feature values a, b and c in (a*b*c.OnE)."
          & (N21=.!arg:@|(!arg.OnE))
          & ( getSuperGoals
            =   goal nwg
              .   !arg:?goal
                & 0:?nwg
                &   map
                  $ ( ( 
                      =     feat vals A Z Val
                          , NVALS VAL VALS Vsp
                          , a agg n21s vsp z
                        .     !arg:(?feat.?vals)
                            & !goal:?A (!feat,?Val) ?Z
                            & (   !Val:@^?
                                &   map
                                  $ ( ( 
                                      =   val alts sp
                                        .   !arg:(?val.?alts)
                                          & (   !Val:!val^?sp
                                              &   map
                                                $ ( ( 
                                                    =   a z
                                                      .         ( !A
                                                                  ( !feat
                                                                  ,   (   !sp
                                                                        : 1
                                                                      |     !arg
                                                                          :   ?a
                                                                            * !val
                                                                            * ?z
                                                                        &     !a
                                                                            * !Val
                                                                            * !z
                                                                          : ?arg
                                                                      )
                                                                    & (   !arg
                                                                        : @
                                                                      |   N21
                                                                        $ !arg
                                                                      )
                                                                  )
                                                                  !Z
                                                                )
                                                              + !nwg
                                                            : ?nwg
                                                          & 
                                                        | 
                                                    )
                                                  . !alts
                                                  )
                                            | 
                                            )
                                      )
                                    . !vals
                                    )
                              |   0:?agg
                                &   map
                                  $ ( ( 
                                      =   L
                                        .   !arg:(?.?L)
                                          &   map
                                            $ ( ( 
                                                = .!arg+!agg:?agg
                                                )
                                              . !L
                                              )
                                      )
                                    . !vals
                                    )
                                & 0:?n21s
                                &   whl
                                  ' ( !agg:%?vals+?agg
                                    & (!vals:#%*?vals|)
                                    & !Val:?VALS
                                    &   whl
                                      ' ( !VALS:%@?VAL^?Vsp*?NVALS
                                        & !vals:?a*!VAL^?vsp*?z
                                        &   (   !Vsp:1
                                              & !vsp
                                            |   !vsp:1
                                              & !Vsp
                                            | !Vsp:!vsp
                                            )
                                          : ?Vsp
                                        & !a*!VAL^!Vsp*!z:?vals
                                        & !NVALS:?VALS
                                        )
                                    & (   !VALS:1
                                        & N21$!vals+!n21s:?n21s
                                      | 
                                      )
                                    )
                                &   !A (!feat,!n21s) !Z+!nwg
                                  : ?nwg
                              )
                          | 
                      )
                    . !SuperSets
                    )
                & !nwg
            )
          & !arg:(?source.?goal.?restriction.?superset)
          & readTable$toolprop
          & getActiveTools$:?activeTools
          & (   !goal:
              &   getImplicatedGoals$(!activeTools.!restriction)
                : (?goal.?restriction)
            | 0:?restriction
            )
          & (   !superset:
              &     map
                  $ ( ( 
                      =   n v
                        .     !arg:(?n,%*%:?v)
                            & (!n,(!v.OnE))
                          | !arg
                      )
                    . !goal
                    )
                : ?goal
            |   ( !servicedSuperGoals:?SuperSets
                | readTable$SuperSets
                )
              & getSuperGoals$!goal:?goal
            )
          &   0
            : ?memoizedSteps
            : ?memos
            : ?duplic
            : ?sourcegoalmatch
            : ?impassages
            : ?notttcnt
          & new$hash:?unfulfillable
          & new$hash:?notThisTool
          & 0:?Calls
          & log$("Calling fulfil" !goal)
          & ( fulfil$(!activeTools.!source.!goal.0.!restriction)
            | !Calls
            )
      )
      ( extractIOfeaturesFromHTTParg
      =     fs IorO f name short p A v Z
          , feat spec io V a z
        .   "Collects features of the input(s) or of the output. Each feature
             is mentioned once. If there are more than one input, one feature
             will have more than one value. These values are the factors in a
             product."
          & !arg:(?fs.?IorO.?arg)
          & :?io
          &   whl
            ' ( !fs:%?f+?fs
              &   !f
                : ? (name.?name) ?
                : ? (short.?short) ?
              & localized$!name:?name
              & str$(!IorO !short):?p
              &   whl
                ' ( !arg:?A (!p.?v) ?Z
                  & !A !Z:?arg
                  & (   !v:%*%
                      & :?z
                      &   whl
                        ' ( !v:%?a*?v
                          &     ( !a:%?feat^%?spec
                                |   !a:@(?:?feat "^" ?spec)
                                  & !feat^!spec
                                | !a
                                )
                                !z
                            : ?z
                          )
                      & !z:?v
                    |   str$!v:?v
                      &     vap
                          $ ( ( 
                              =   feat spec
                                .   !arg:%?feat^%?spec
                                  |   !arg:@(?:?feat "^" ?spec)
                                    & !feat^!spec
                                  | !arg
                              )
                            . !v
                            . "*"
                            )
                        : ?v
                    )
                  & ( !v:
                    |   ( !io:?a (!short,?V) ?z
                        |   1:?V
                          & !io:?z
                          & :?a
                        )
                      &   map
                        $ ( ( 
                            =   
                              .   !V:?*!arg*?
                                | !arg*!V:?V
                            )
                          . !v
                          )
                      & !a (!short,!V) !z:?io
                    | (!short,!v) !io:?io
                    )
                  )
              )
          & sort$!io
      )
      ( has
      =   rstr S
        .   !arg:(?arg.?rstr)
          & ( !arg:?*(!rstr,?)*?
            |   !arg:?*(?,(?.?.?.?S))*?arg
              & (has$(!S.!rstr)|has$(!arg.!rstr))
            )
      )
      ( filter
      =   pipes desiredtool fpipes o pipe1
        .   !arg:(?pipes.?desiredtool)
          & 0:?fpipes
          &   whl
            ' ( !pipes:(?o.?pipe1)+?pipes
              & (   has$(!pipe1.!desiredtool)
                  & ( !fpipes:?+(?.!o.!pipe1)+?
                    | (!o.!pipe1)+!fpipes:?fpipes
                    )
                | 
                )
              )
          & !fpipes
      )
      ( haz
      =   rstr S F T notfound
        .   !arg:(?arg.?rstr)
          & :?notfound
          &   whl
            ' ( :!notfound
              & !arg:%?T+?arg
              &   whl
                ' ( :!notfound
                  & !T:%?F*?T
                  & (   ( !F:(!rstr,?)
                        |   !F:(?,(?.?.?.?S))
                          & haz$(!S.!rstr)
                        )
                      & false:?notfound
                    | 
                    )
                  )
              )
          & !notfound:false
      )
      "noValueConflict: checks that all features in two feature sets are
       compatible, either by not being present, or by having the same
       values. Subspecifications are ignored."
      ( noValueConflict
      =   A B f e g
        .   !arg:(?A.?B)
          & ( !A:!B
            | ~( !A
               :   ?
                   ( ?f&!B:? (!f,?g) ?
                   , ?*(%@?e^?&~(!g:?*%@!e^?*?))*?
                   )
                   ?
               )
            )
      )
      ( noValueSpecConflict
      =   A B f e g s t
        .   !arg:(?A.?B)
          & ( !A:!B
            | ~( !A
               :   ?
                   ( ?f&!B:? (!f,?g) ?
                   ,   ?
                     * ( %@?e^?s
                       & ~( !g:?*%@!e^?t*?
                          & ( !s:!t
                            | !s:1
                            | !t:1
                            )
                          )
                       )
                     * ?
                   )
                   ?
               )
            )
      )
      "supplement: tgt and src can be very different features bundles.
       If src has a feature that tgt hasn't, then it is added to tgt.
       If src has a feature element with the same unsubspecified value as a feature element of tgt, 
       then the tgt feature element inherits the subspecifications of the src feature.
       A feature (F,a*b*c) has elements a, b and c.
      "
      ( supplement
      =   f v tgt src A Z updateWithSubSpec
        .   ( updateWithSubSpec
            =   vn v e nv nvs ve w0 ws a OnE
              .   !arg:(?vn.?ve:@?v^%?e)
                & 1:?nv
                &   whl
                  ' ( !vn:%?w0*?vn
                    &     !nv
                        * (   !w0:(?ws.?OnE)
                            & 1:?nvs
                            &   whl
                              ' ( !ws:?a*!v*?ws
                                & !nvs*!a*!ve:?nvs
                                )
                            & (!nvs*!ws.OnE)
                          | !w0:!v&!ve
                          | !w0
                          )
                      : ?nv
                    )
                & !nv
            )
          & !arg:(?tgt.?src)
          &   map
            $ ( ( 
                =   f vsc vN vtg nv A Z ve vs vN
                  .   !arg:(?f,?vsc)
                    & (   !tgt:?A (!f,?vN:?vtg) ?Z
                        &   whl
                          ' ( !vsc:%?nv*?vsc
                            & (   !nv:(?vs.OnE)
                                &   whl
                                  ' ( !vs:?*(%^%:?ve)*?vs
                                    &   updateWithSubSpec$(!vtg.!ve)
                                      : ?vtg
                                    )
                              |   !nv:%^%
                                & updateWithSubSpec$(!vtg.!nv):?vtg
                              | 
                              )
                            )
                        & ( !vtg:!vN
                          | !A (!f,!vtg) !Z:?tgt
                          )
                      |     (   !vsc:%*%
                              & (!f,(!vsc.OnE))
                            | !arg
                            )
                            !tgt
                        : ?tgt
                      )
                    & 
                )
              . !src
              )
          & sort$!tgt
      )
      "containedBy takes two feature bundles, 'short' and 'long'.
       It tries to prove that the short bundle is compatible with the long one.
       If 'long' has a value subspecification while 'short' doesn't, then
       'short' copies the subspecification from 'long'. All features in 'short'
       must match a feature in 'long'.
       The returned value is 'short', enriched with subspecifications.
      "
      ( containedBy
      =     short long fea val e E rem Val P nval nVal
          , saves savel v
        .   !arg:(?short:?saves.?long:?savel)
          & ( !short:
            |   !short:(?fea,@?val^?e) ?short
              & !long:? (!fea,!val^?E) ?
              & (   !e:(1|!E)
                  & containedBy$(!short.!long):?rem
                  & (!fea,!val^!E) !rem
                |   !E:1
                  & containedBy$(!short.!long):?rem
                  & (!fea,!val^!e) !rem
                )
            |   !short:(?fea,(?val.OnE)) ?short
              & !long:? (!fea,?Val) ?
              & (!Val:(?Val.OnE)|)
              & 1:?P
              &   whl
                ' ( !val:%@?v^?e*?nval
                  & !Val:!v^?E*?nVal
                  & (   !e:(1|!E)
                      & !P*!v^!E:?P
                    | !E:1&!P*!v^!e:?P
                    )
                  & (!nval.!nVal):(?val.?Val)
                  )
              & 1:!val:!Val
              & containedBy$(!short.!long):?rem
              & (!fea,(!P.OnE)) !rem
            |   !short:(?fea,%*%:?val) ?short
              & !long:? (!fea,?Val) ?
              & 1:?P
              &   whl
                ' ( !val:%@?v^?e*?nval
                  & !Val:!v^?E*?nVal
                  & (   !e:(1|!E)
                      & !P*!v^!E:?P
                    | !E:1&!P*!v^!e:?P
                    )
                  & (!nval.!nVal):(?val.?Val)
                  )
              & 1:!val:!Val
              & containedBy$(!short.!long):?rem
              & (!fea,!P) !rem
            )
      )
      ( rpl
      =   vals fea gold A B exp aa zz SAVEARG
        .   !arg:(?vals.?fea.?gold):?SAVEARG
          & (   !vals:%?A*%?B
              & rpl$(!A.!fea.!gold):?A
              & rpl$(!B.!fea.!gold):?B
              & !A*!B
            |   !vals:%?A %?B
              & rpl$(!A.!fea.!gold):?A
              & (rpl$(!B.!fea.!gold):?B|)
              & !A !B
            |   !vals:@?A^?B
              & (   !gold:?*(? (!fea,!vals) ?)*?
                  & !vals
                |     !gold
                    : ?*(? (!fea,?aa*!A^?exp*?zz) ?)*?
                  &   ( !B:!exp
                      | !exp:1&!B
                      | !B:1&!exp
                      )
                    : ?B
                  & !A^!B
                | !A^!B
                )
            |   !vals:(?.OnE)
              & "Instead of prepending with %, we group the product and mark it with OnE."
              & (     !gold
                    : ?*(? (!fea,?*!vals*?:?B) ?)*?
                  & !B
                | !vals
                )
            )
      )
      ( walkTreeSubspecHarmonize
      =     toolSignatures I aSource o i sub prog Os nsub
          , H h h1 H1 O SAVEIN Sources gold
        .   !arg:(?Sources.?toolSignatures):?SAVEIN
          & (   !Sources:%?aSource*%?Sources
              &   walkTreeSubspecHarmonize$(!aSource.!toolSignatures)
                : ?H
              & ( !H:0
                | !H*walkTreeSubspecHarmonize$(!Sources.!toolSignatures)
                )
            |   !Sources:(%@?prog,(?o.?i.?sub))
              & (     !toolSignatures
                    :   ?
                      * ( !prog
                        . ?O
                        .   ?I
                          & noValueSpecConflict$(!O.!o)
                          & noValueSpecConflict$(!I.!i)
                        )
                      * ?
                  & SubspecHarmonize$(!sub.!toolSignatures):?nsub
                  & ( !nsub:(0.?)&0y
                    | ( !prog
                      , ( !O
                        .       !nsub
                              : (((?,?) ?)*?:?gold.?)
                            &   map
                              $ ( ( 
                                  =   fea vals
                                    .   !arg:(?fea,?vals)
                                      & (!fea,rpl$(!vals.!fea.!gold))
                                  )
                                . !I
                                )
                          | !I
                        . !nsub
                        )
                      )
                    )
                | 0
                )
            | "Input Resource"&!Sources
            )
      )
      "SubspecHarmonize: In a given workflow, replace all occurrences of (Output.Input)
       feature bundle pairs with the possibly richer (at subspec level) version
       found in the second argument."
      ( SubspecHarmonize
      =     toolSignatures Requireds h h1 aRequired O Os
          , savearg nSources pipe Sources
        .   !arg:(?pipe.?toolSignatures):?savearg
          & "pipe is a pipe line.

             toolSignatures is a product of tool names with exponents. 
             Each exponent is a term or sum of terms. 
             A term is a dotted pair (output features.input features).
             A term can have a numeral factor."
          & (     !pipe
                : (((?,?) ?)*?:?Requireds.?Sources)
              & "If single input, Requireds is e.g 
              
                    (ambig,una)
                    (app,nrm)
                    (facet,(lem*mrf*pos^Uni*stx.OnE))
                    (format,txtann)
                    (lang,da)
                    (period,c21)
                    (pres,nml)

                  Multiple input e.g.
                    ( (ambig,una)
                      (app,nrm)
                      (facet,sent)
                      (format,txtann)
                      (lang,da)
                      (period,c21)
                      (pres,nml)
                    )
                  * ( (ambig,una)
                      (app,nrm)
                      (facet,tok^simple)
                      (format,txtann)
                      (lang,da)
                      (period,c21)
                      (pres,nml)
                    )
                  "
              &   walkTreeSubspecHarmonize$(!Sources.!toolSignatures)
                : ?nSources
              & ( !nSources:0&(0.0)
                |   1:?h
                  & "Check that the updated outputs from the tools still match the requirements.
                     If they do, also update the requirements.
                     Otherwise, return 0."
                  &   whl
                    ' ( !Requireds:%?aRequired*?Requireds
                      & "aRequired is input expected to come from one tool (or one input resource)."
                      & (     !nSources
                            : (   ?
                                * ( ?
                                  , (   ?O
                                      &   containedBy$(!aRequired.!O)
                                        : ?h1
                                    . ?
                                    )
                                  )
                                * ?
                              |   ?
                                * ( `%?O
                                  & ~(!O:(?,(?.?)))
                                  & containedBy$(!aRequired.!O):?h1
                                  )
                                * ?
                              )
                          & !h*!h1:?h
                        | 0:?h
                        )
                      & !h:~@
                      )
                  & (!h.!nSources)
                )
            | "input resource"&!pipe
            )
      )
      ( Intersection
      =   x y f v I e g V h ns vs xs ys
        .   !arg:(?x.?y)
          &     map
              $ ( ( 
                  =   
                    .   !arg:(?f,?vs)
                      & (   !y:? (!f,?ys) ?
                          & 1:?ns
                          &   whl
                            ' ( !vs:%@?v^?e*?vs
                              & (   !ys:?*!v^?g*?
                                  &     (   !e:~1
                                          & !g:~1
                                          & !e:~!g
                                          & 1
                                        |   (   ( !e:~1
                                                | !g:~1
                                                )
                                              & !e*!g:%?h^?
                                            | 1:?h
                                            )
                                          & !v^!h
                                        )
                                      * !ns
                                    : ?ns
                                | 
                                )
                              )
                          & ( !ns:1&
                            | (!f,!ns)
                            )
                        | !arg
                        )
                  )
                . !x
                )
            : ?I
          &     !I
                  map
                $ ( ( 
                    =   
                      .   !arg:(?f,?vs)
                        & (   !x:? (!f,?xs) ?
                            & 1:?ns
                            &   whl
                              ' ( !vs:%@?v^?e*?vs
                                & (   !xs:?*!v^?g*?
                                    &     (   !e:~1
                                            & !g:~1
                                            & !e:~!g
                                            & 1
                                          |   (   ( !e:~1
                                                  | !g:~1
                                                  )
                                                & !e*!g:%?h^?
                                              | 1:?h
                                              )
                                            & !v^!h
                                          )
                                        * !ns
                                      : ?ns
                                  | 
                                  )
                                )
                            & ( !ns:1&
                              |   (!f,!ns):?V
                                & ( !I:? !V ?&
                                  | !V
                                  )
                              )
                          | !I:? !arg ?&
                          | !arg
                          )
                    )
                  . !y
                  )
            : ?I
          & sort$!I
      )
      ( percolateForgottenFeatures
      =     pipes F updateOFwithNF NN
          , harmonizeSubspecsOnSimilarFeatures
          , Results pipe1 pipe2 pipe3
          , fromMethods fromInputTowardOutput fromToolOrSource
          , toMethods fromOutputTowardInput toTool
          , UpdateResultsFromMethods oUts
          , validateInputsForEachTool sig
        .   "TODO sig is not meaningful if we can have multiple OnE complexes
             (a*b*c.OnE)*d*(a*f*g.OnE)*z
             One of the problems is 'a' occuring two places.
             Better to keep OnE!
            "
          & ( sig
            =   a
              .     !arg:%?a*?arg
                  &   ( !a:(?a.OnE)&sig$!a
                      | !a:%@?a^?&!a
                      )
                    * sig$!arg
                | 1
            )
          & ( UpdateResultsFromMethods
            =     results methods nres result A method
                , Sig SR SM B
              .   ( Sig
                  =   
                    .   map
                      $ ( ( 
                          =   f v
                            .   !arg:(?f,?v)
                              & (!f,sig$!v)
                          )
                        . !arg
                        )
                  )
                & !arg:(?results.?methods)
                & 1:?nres
                &   whl
                  ' ( !results:%?result*?results
                    & Sig$!result:?SR
                    & "Compound feature values in 'result' are in OnE group."
                    &     map
                        $ ( ( 
                            =   f v
                              .     !arg:(?f,(?v.OnE))
                                  & (!f,!v)
                                | !arg
                            )
                          . !result
                          )
                      : ?B
                    &     (   !methods:?A*!B*?methods
                            & !A*!methods:?methods
                            & !result
                          |     !methods
                              :   ?A
                                * `( (?,?) ?:?method
                                   & Sig$!method:?SM
                                   &     map
                                       $ ( ( 
                                           =   
                                             .     !SM:~(? !arg ?)
                                                 & !arg:~(sml,nsl)
                                               | 
                                           )
                                         . !SR
                                         )
                                     : 
                                   )
                                * ?methods
                            & !A*!methods:?methods
                            &   map
                              $ ( ( 
                                  =   F v e E VS NVS
                                    .   !arg:(?F,?v)
                                      & ( !F
                                        ,     !v:(?VS.OnE)
                                            & 1:?NVS
                                            &   whl
                                              ' ( !VS:%@?v^?e*?VS
                                                &     !NVS
                                                    *   !v
                                                      ^ (   !e:1
                                                          & (     !method
                                                                :   ?
                                                                    ( !F
                                                                    ,   ?
                                                                      * !v^?E
                                                                      * ?
                                                                    )
                                                                    ?
                                                              & !E
                                                            | 1
                                                            )
                                                        | !e
                                                        )
                                                  : ?NVS
                                                )
                                            & (!NVS.OnE)
                                          |   !v:@?v^?e
                                            &   !v
                                              ^ (   !e:1
                                                  & (     !method
                                                        :   ?
                                                            (!F,?*!v^?E*?)
                                                            ?
                                                      & !E
                                                    | 1
                                                    )
                                                | !e
                                                )
                                        )
                                  )
                                . !result
                                )
                          | !result
                          )
                        * !nres
                      : ?nres
                    )
                & !nres
            )
          & "updateOFwithNF: let OF inherit subspecs from NF if OF and NF have same feature value, but OF is not subspecified. 
             If a feature has different values in OF and NF, replace OF's value with NF's (In this, updateOFwithNF$ is different from supplement$)
             Add any features in NF that OF does not have."
          & ( updateOFwithNF
            =   tgt src
              .   !arg:(?tgt.?src)
                &   map
                  $ ( ( 
                      =     f vsc vtg v e E A
                          , Z a z nsg nv vs
                        .   !arg:(?f,?vsc)
                          & sig$!vsc:?nsg
                          & (     !tgt
                                : ?A (!f,?vN:?vtg) ?Z
                              & (   sig$!vtg:!nsg
                                  &   whl
                                    ' ( !vsc:%?nv*?vsc
                                      & (   !nv:(?nv.OnE)
                                          &   whl
                                            ' ( !vs:?*%@?v^%?e*?vs
                                              & !vtg:?a*!v^?E*?z
                                              & ( !e:!E
                                                | !a*!v^!e*!z:?vtg
                                                )
                                              )
                                        |   !nv:@?v^%?e
                                          & !vtg:?a*!v^?E*?z
                                          & ( !e:!E
                                            | !a*!v^!e*!z:?vtg
                                            )
                                        )
                                      )
                                  & ( !vtg:!vN
                                    | !A (!f,!vtg) !Z:?tgt
                                    )
                                | !A (!f,!vsc) !Z:?tgt
                                )
                            | !arg !tgt:?tgt
                            )
                      )
                    . !src
                    )
                & sort$!tgt
            )
          & ( harmonizeSubspecsOnSimilarFeatures
            =   OF NF
              .   !arg:((@?,~(?.~OnE)) ?:?NF.?OF)
                & (supplement$(!NF.!OF).updateOFwithNF$(!OF.!NF))
            )
          & ( oUts
            =   R F
              .   1:?R
                &   whl
                  ' (   !arg
                      :   ( (?,(?F.?))
                          | (?,?) ?:?F
                          )
                        * ?arg
                    & !F*!R:?R
                    )
                & !R
            )
          & ( Results
            =   L R OF LF RF
              .     !arg:(%?L*%?R.?OF)
                  & Results$(!R.!OF):(?R.?RF)
                  &   harmonizeSubspecsOnSimilarFeatures$(!L.!OF)
                    : (?L.?LF)
                  & (!L*!R.Intersection$(!RF.!LF))
                | harmonizeSubspecsOnSimilarFeatures$!arg
            )
          & ( fromToolOrSource
            =   OF LF RF tool meta output sub
              .     !arg:(?tool,(?output.?meta.?sub).?OF)
                  & fromInputTowardOutput$(!sub.!OF):(?sub.?RF)
                  &   harmonizeSubspecsOnSimilarFeatures$(!output.!RF)
                    : (?output.?LF)
                  & ( !tool,(!output.supplement$(!meta.!RF).!sub)
                    . !LF
                    )
                | harmonizeSubspecsOnSimilarFeatures$!arg
            )
          & ( fromMethods
            =   L R OF LF RF
              .   !arg:(?arg.?OF)
                & (   !arg:%?L*%?R
                    & fromMethods$(!R.!OF):(?R.?RF)
                    & fromToolOrSource$(!L.!OF):(?L.?LF)
                    & (!L*!R.Intersection$(!RF.!LF))
                  | fromToolOrSource$(!arg.!OF)
                  )
            )
          & ( fromInputTowardOutput
            =   results methods OF NF
              .     !arg:((?results.?methods).?OF)
                  & fromMethods$(!methods.!OF):(?methods.?NF)
                  &   UpdateResultsFromMethods$(!results.oUts$!methods)
                    : ?results
                  & ((!results.!methods).!NF)
                | Results$!arg
            )
          & ( toTool
            =   OF LF RF tool meta output sub
              .   !arg:(?arg.?OF)
                & (   !arg:(?tool,(?output.?meta.?sub))
                    &   harmonizeSubspecsOnSimilarFeatures$(!output.!OF)
                      : (?output.?LF)
                    & fromOutputTowardInput$(!sub.!LF):(?sub.?RF)
                    & ( !tool,(!output.supplement$(!meta.!LF).!sub)
                      . !RF
                      )
                  |   !arg:(|(?,?) ?)
                    & harmonizeSubspecsOnSimilarFeatures$(!arg.!OF)
                  )
            )
          & ( toMethods
            =   L R OF LF RF
              .   !arg:(?arg.?OF)
                & (   !arg:%?L*%?R
                    & toMethods$(!R.!OF):(?R.?RF)
                    & toTool$(!L.!OF):(?L.?LF)
                    & (!L*!R.Intersection$(!RF.!LF))
                  | toTool$(!arg.!OF)
                  | !arg:(@,?)&(!arg.!OF)
                  )
            )
          & ( fromOutputTowardInput
            =   results methods OF NF
              .   !arg:(?arg.?OF)
                & (   !arg:(?results.?methods)
                    & Results$(!results.!OF):(?results.?NF)
                    & toMethods$(!methods.!NF):(?methods.?NF)
                    & ((!results.!methods).!NF)
                  | Results$(!arg.!OF)
                  )
            )
          & ( validateInputsForEachTool
            =   recr
              .   "Every input spec shall be identical to an output
                   spec of an immediately preceding tool."
                & ( recr
                  =   a b A aa t
                    .     !arg:%?a*%?b
                        & recr$!a
                        & recr$!b
                      | !arg:(?t,(?.?.(?,?) ?))
                      | !arg:(?,~(?.?)) ?
                      |   !arg:(?t,(?.?.?a:?aa.?b))
                        & recr$!b
                        &   whl
                          ' ( !a
                            :   ( %?A
                                &     map
                                    $ ( ( 
                                        =   f vs v nvs
                                          .   !arg:(?f,?vs)
                                            & 1:?nvs
                                            &   whl
                                              ' ( !vs:%?v*?vs
                                                & ( !v:(?v.OnE)
                                                  | 
                                                  )
                                                & !nvs*!v:?nvs
                                                )
                                            & (!f,!nvs)
                                        )
                                      . !A
                                      )
                                  : ?A
                                &   !b
                                  : (?*(?,(!A.?))*?|?*!A*?)
                                )
                              * ?a
                            )
                        & ( !a:1
                          |   ~
                            &   log
                              $ ( "In feature bundle"
                                  !A
                                  str$(\n "of tool")
                                  !t
                                  str$(\n "with input")
                                  !aa
                                    str
                                  $ ( \n
                                      "mismatch with outputs of preceding tools"
                                    )
                                  oUts$!b
                                  "arg (suppressed)"
                                )
                            & !arg:?CULPRIT
                            & lst$(CULPRIT,path$CULPRIT,RAW,NEW)
                            & ~
                          )
                  )
                & !arg:(?.?arg)
                & recr$!arg
            )
          & 0:?pipes
          & 0:?NN
          &   whl
            ' ( !arg:%?pipe1+?arg
              & 1+!NN:?NN
              & fromInputTowardOutput$(!pipe1.):(?pipe2.?F)
              & fromOutputTowardInput$(!pipe2.!F):(?pipe3.?)
              & ( !pipe3:0
                |   validateInputsForEachTool$!pipe3
                  & ( !pipes:?+!pipe3+?
                    | !pipe3+!pipes:?pipes
                    )
                | 
                | log$INVALID
                )
              )
          & !pipes
      )
      ( prunePipes
      =     As Ax NNN Z ax incarnationpipes parms
          , newpipes pipe pipes pipesN restriction
          , wantThis unfoldTree sources calls Npipes
        .   ( unfoldTree
            =     tool ou ou2 inputprop childstuff
                , A Z goal b
                , inputprop feature stop a ret
                , As stp sp
                , projectOnto rt af bf compatibleFeatureSets
              .   "Returns sum. Each term is a dot separated structure:
                 (<stop list> . <user provided output specs> . <sum of unambiguous trees>)
             The stop list is a product of (<key>.<value>) pairs, where the key is an (ambiguous) tree and the value
             is a disambiguated solution. The stop list is passed down to the leafs and also up again as part of the
             return value. In that way some consistency is assured and many inviable solutions are never attempted.
             The ambiguities (declared as terms in sums) in the original tree can be in feature values and in tool choices.
             
             The argument consists of a product of already found unfoldings and the (sub)tree to unfold, separated by a dot.
             Each factor in the product of already found unfoldings consists of the tree to unfold (the key) and the tree
             it was unfolded to (the value). Factors can have an exponent.
             
             Expects that the variable 'sources' is a list of input feature/value pairs. 
             (A single pair can contain more than one value. That is the case if there are more than one inputs.)"
                & ( compatibleFeatureSets
                  =   A B C D F V
                    .   ~(!arg:%*%)
                      |   1:?B
                        &   whl
                          ' (   !arg
                              : ((?,?) ?:?A)^?*?arg
                            & subtract$(!A.!sources)*!B:?B
                            )
                        & ~( !B
                           :   %?C
                             * ( %?D
                               &   !C
                                 :   ?
                                     ( ?F
                                     ,   ?V
                                       &   !D
                                         : ?*(? (!F,~!V) ?)*?
                                     )
                                     ?
                               )
                           )
                  )
                & !arg:(?stop.?arg)
                & 1+!calls:?calls:<567890
                & (   @(!calls:? 000)
                    & log$(calls !calls)
                  | 
                  )
                & (   !arg:%?A*%?arg
                    & "Multiply each term in unfolded first factor with each term in unfolded remaining factors."
                    & 0:?ret
                    & unfoldTree$(!stop.!A):(?stp.?a)
                    & unfoldTree$(!stop*!stp.!arg):(?sp.?b)
                    & leaveFeat$!a:?af^?
                    & leaveFeat$!b:?bf^?
                    & (   compatibleFeatureSets$(!af*!bf)
                        & !ret+(!sp.!a*!b):?ret
                      | 
                      | log$(NOTCOMPATIBLE !af AND !bf)
                      )
                    & !ret
                  |   !calls:<567890
                    & !arg:%+%
                    & log$SUMDETECTED
                    & (   !stop:?*(!arg.?projectOnto)^?*?
                        & "This removes perhaps some solutions that assume incompatible input specs."
                        & (!stop.!projectOnto)
                      |   0:?ret
                        & !arg:?As
                        &   whl
                          ' ( !As:%?A+?As
                            & unfoldTree$(!stop.!A):?Z
                            & !calls:<567890
                            &   whl
                              ' ( !Z:(?stp.?a)+?Z
                                & !ret+((!arg.!a)*!stop.!a):?ret
                                )
                            )
                        & !ret
                      )
                  |   !calls:<567890
                    & !arg:(?goal.?childstuff)
                    & unfoldTree$(!stop.!childstuff):?Z
                    & !calls:<567890
                    & 0:?ret
                    &   whl
                      ' ( !Z:(?stp.?A)+?Z
                        & !ret+(!stp.!goal.!A):?ret
                        )
                    & !ret
                  |   !calls:<567890
                    &   !arg
                      : ( ?tool
                        , ( ?A (?feature,%+%:?ou) ?Z
                          . ?inputprop
                          . ?childstuff
                          )
                        )
                    & (   !stop:?*(!ou.?projectOnto)*?
                        &   unfoldTree
                          $ ( !stop
                            .   !tool
                              , ( !A (!feature,!projectOnto) !Z
                                . !inputprop
                                . !childstuff
                                )
                            )
                      |   !calls:<567890
                        & !ou:?ou2
                        & 0:?ret
                        &   whl
                          ' ( !ou2:%?a+?ou2
                            &     unfoldTree
                                $ ( !stop*(!ou.!a)
                                  .   !tool
                                    , ( !A (!feature,!a) !Z
                                      . !inputprop
                                      . !childstuff
                                      )
                                  )
                              : ?rt
                            & !ret+!rt:?ret
                            )
                        & !calls:<567890
                        & !ret
                      )
                  |   !calls:<567890
                    & !arg:(?tool,(?ou.?inputprop.?childstuff))
                    & unfoldTree$(!stop.!childstuff):?Z
                    & 0:?ret
                    &   whl
                      ' ( !Z:(?stp.?A)+?Z
                        &   !ret+(!stp.!tool,(!ou.!inputprop.!A))
                          : ?ret
                        )
                    & !ret
                  | !calls:<567890&(!stop.!arg)
                  )
            )
          & log$prunePipes
          & "wantThis either returns the argument (if it is wanted) or
                   zero (if it isn't). So it does not FAIL."
          & ( wantThis
            =     sig nsig clashing NoValueConflicts copySpecs
                , signatures unifySignaturesAtSpecLevel
                , mergeOIbundlesWherePossible
              .   "signatures: create a product of tool names with
                         exponents that descibe output and input features, as
                         dotted pairs.

                         clashing: check whether a tool exists with two
                         signatures with a common feature that would be equal
                         if subspecifications were stripped off.
                        "
                & ( signatures
                  =   A prog o i sub
                    .     !arg:(((?,?) ?)*?.?arg)
                        & signatures$!arg
                      |   !arg:%?A*%?arg
                        & signatures$!A*signatures$!arg
                      |   !arg:(%@?prog,(?o.?i.?sub))
                        & !prog^(!o.!i)*signatures$!sub
                      | 1
                  )
                & "NoValueConflicts IGNORES subspecs"
                & ( NoValueConflicts
                  =   i I o O
                    .   !arg:((?o.?i),(?O.?I))
                      & noValueSpecConflict$(!i.!I)
                      & noValueSpecConflict$(!o.!O)
                  )
                & ( copySpecs
                  =   Ao Ai Bo Bi
                    .   !arg:((?Ao.?Ai),(?Bo.?Bi))
                      & (supplement$(!Ao.!Bo).supplement$(!Ai.!Bi))
                  )
                & ( mergeOIbundlesWherePossible
                  =   oi1 oi2 A M Z
                    .       !arg
                          :   ?A
                            + #*((?.?):?oi1)
                            + ?M
                            +   #
                              * ( (?.?):?oi2
                                & NoValueConflicts$(!oi1,!oi2)
                                )
                            + ?Z
                        &   mergeOIbundlesWherePossible
                          $ ( !A
                            + copySpecs$(!oi2,copySpecs$(!oi1,!oi2))
                            + !M
                            + !Z
                            )
                      | !arg
                  )
                & ( unifySignaturesAtSpecLevel
                  =   tool A sigs
                    .     !arg:?A*%@?tool^(%+%:?sigs)*?arg
                        &   !A
                          * !tool^mergeOIbundlesWherePossible$!sigs
                          * unifySignaturesAtSpecLevel$!arg
                      | !arg
                  )
                & ( clashing
                  =   oi1 oi2 ConflictingSpecs specConflict
                    .   ( specConflict
                        =   A B f e x y
                          .   !arg:(?A.?B)
                            &   !A
                              :   ?
                                  ( ?f
                                  ,   ?
                                    * `%@( ?e^?x
                                         &   !B
                                           : ? (!f,?*!e^?y*?) ?
                                         & !x*!y:%*%
                                         )
                                    * ?
                                  )
                                  ?
                        )
                      & ( ConflictingSpecs
                        =   i I o O
                          .   NoValueConflicts$!arg
                            & !arg:((?o.?i),(?O.?I))
                            & ( specConflict$(!i.!I)
                              | specConflict$(!o.!O)
                              )
                        )
                      &   !sjt
                        :   ?
                          + #*((?.?):?oi1)
                          + ?
                          +   #
                            * ( (?.?):?oi2
                              & ConflictingSpecs$(!oi1,!oi2)
                              )
                          + ?
                  )
                & signatures$!arg:?sig
                & "sig is a product of tool IDs. Each ID has an exponent
                   that is the sum of all (O.I) specs occuring in the
                   current computed workflow. Here, O and I are feature
                   bundles."
                & (   !sig:?*?^(%+%:clashing$)*?
                    & "Discard solutions that contain steps that are
                       equal (or at least compatible) at the un-
                       subspecified level, but clash at the spec level.
                       Such solutions are not 'wrong', but unlikely what
                       the user wants."
                    & 0
                  |   unifySignaturesAtSpecLevel$!sig:?nsig
                    & "nsig is a product of maximally compressed
                       signatures. If two (O.I) feature bundle pairs can
                       enrich each other without clashing, then those
                       pairs are merged into one. These enriched (O.I)
                       pairs do nowhere occur in the current workflow, so
                       now we substitute the rich O.I pairs for the
                       original ones."
                    & ( unspec
                      =   A B
                        .   !arg:%@?A^%&!A
                          |   !arg:?A_?B
                            & (unspec$!A)_(unspec$!B)
                          | !arg
                      )
                    & ( separate
                      =   A a B sims nonsims
                        .   !arg:#*((?.?):%?A)+?arg
                          & unspec$!A:?a
                          & !A:?sims
                          & 0:?nonsims
                          &   whl
                            ' ( !arg:#*((?.?):%?B)+?arg
                              & (   unspec$!B:!a
                                  & !sims !B:?sims
                                | !nonsims+!B:?nonsims
                                )
                              )
                          & !sims+separate$!nonsims
                      )
                    & ( signatureDotSep
                      =   tool V L v
                        .   1:?L
                          &   whl
                            ' ( !arg:%@?tool^?V*?arg
                              & separate$!V:?V
                              &   whl
                                ' ( !V:%?v+?V
                                  & !L*(!tool.!v):?L
                                  )
                              )
                          & !L
                      )
                    & signatureDotSep$!nsig:?Nsig
                    & ( trySignatures
                      =   Feats tool f pAth nsig pipes R
                        .   !arg:(?pAth.?nsig.?pipes)
                          & (   !nsig:(%?tool.%?Feats)*?nsig
                              &   whl
                                ' ( !Feats:%?f ?Feats
                                  &   trySignatures
                                    $ (!pAth*(!tool.!f).!nsig.!pipes)
                                  )
                            |     SubspecHarmonize$(!pipes.!pAth)
                                : (~0.?)
                                : ?R
                              & !pIJpen+!R:?pIJpen
                            | 
                            )
                      )
                    & (   0:?pIJpen
                        & trySignatures$(1.!Nsig.!arg)
                        & !pIJpen:~0
                        & "arg has become more complete subspec-wise.
                           Either each tool is used in exactly one way, or the
                           different ways ALL differ more than only at the
                           subspec level."
                        & !arg
                      | 0
                      )
                  )
            )
          & !arg:(?pipes.?parms.?sources)
          & 0:?calls
          & 0:?newpipes
          & log$(whl calls !calls)
          & 0:?Npipes
          &   whl
            ' ( !calls:<567890
              & !pipes:((?.?):?incarnationpipes)+?pipes
              & "incarnationpipes is (<(user or declared tool) provided output specs> . <sum of unambiguous trees>)"
              & "TODO 20190917: do not have workflows with two or more tools that do exactly the same thing.
                Strategy: 
                (1) search for a sum. 
                (2) Iterate over that sum. 
                (3) For each term, produce a (possibly still ambiguous) workflow by projecting each sum that contains that
                    term on that term. So if a sum contains the current term, ignore all terms but the current term.
                (4) Repeat this for each new workflow.
                (5) The result is a list of unambiguous workflows in which no task is performed by two different tools."
              & log$selectCommonTracks
              & selectCommonTracks$!incarnationpipes:?As
              & !As:?+[?Npipes
              & !Npipes:~>1000
              & :?pipesN
              & log$unfoldTree
              &   whl
                ' ( !As:%?Ax+?As
                  & unfoldTree$(1.!Ax):?Z
                  &   whl
                    ' ( !Z:(?.?ax)+?Z
                      & !ax !pipesN:?pipesN
                      )
                  )
              & sort$!pipesN:?pipesN
              &     ( 
                    =   L a
                      .   :?L
                        &   whl
                          ' ( !arg:%?a ?arg
                            & !a !L:?L
                            )
                        & 0:?arg
                        &   whl
                          ' ( !L:%?a ?L
                            & !a+!arg:?arg
                            )
                        & !arg
                    )
                  $ !pipesN
                : ?pipesN
              & "The 1 is the initial stop list, which is formed as a product."
              & "pipesN is (<user provided output specs> . <unfolded tree>) + ..."
              & !pipesN:?+[?NNN
              & log$(NNN !NNN)
              & (   !parms:? (desiredtool.?restriction) ?
                  & !restriction:~
                  & filter$(!pipesN.!restriction):?pipesN
                | 
                )
              & percolateForgottenFeatures$!pipesN:?pipesN
              & !pipesN:?+[?NNN
              &   whl
                ' ( !pipesN:%?pipe+?pipesN
                  & wantThis$!pipe:?pipe
                  & ( !pipe:0
                    | !newpipes:?+!pipe+?
                    | !pipe+!newpipes:?newpipes
                    )
                  )
              )
          & log$(testing calls !calls)
          & (!newpipes.!Npipes)
      )
      ( saveTask
      =   
        .   (!recentTasks:?recentTasks [30 ?|)
          & !arg !recentTasks:?recentTasks
          & saveTable$recentTasks
      )
      ( windFW
      =   nth ZZ pipes pipe
        .   !arg:(?pipes.?nth)
          & log$(nth !nth)
          & ( !nth:&!pipes
            |   !pipes:?ZZ
              & UNKNOWNS!:?pipe
              &   whl
                ' ( !nth:>0
                  & !ZZ:%?pipe+?ZZ
                  & !nth+-1:?nth
                  )
              & log$(nthNOW !nth)
              & !pipe
            )
      )
      ( Pipelines
      =     i o o-SUpPLEMENT restriction FP fP
          , superset userInput
          , calls nth parms furtherCheck o2o
          , A Z reorderedworkflowlist topologicalOrderedTools
          , B Npipes Y features nFP nr oo ou pp
          , restr returnCode supers uiin uiou usupset
        .   !arg:(?arg:?parms.?nth)
          & ( !arg:? (desiredtool.?restriction) ?
            | :?restriction
            )
          &     map
              $ ( ( 
                  =   
                    .     !arg:(@(?:SuperSet- ?arg).?)
                        & !arg
                      | 
                  )
                . !arg
                )
            : ?superset
          & readTable$features
          & extractIOfeaturesFromHTTParg$(!features.I.!arg):?i
          & extractIOfeaturesFromHTTParg$(!features.O.!arg):?o
          &   extractIOfeaturesFromHTTParg$(!features.P.!arg)
            : ?o-SUpPLEMENT
          & (   !o-SUpPLEMENT:
              & "If the user has checked a supplement box, but the feature
                 value is unspecified, then ignore the supplement mark."
              &     map
                  $ ( ( 
                      =   
                        .       !o
                              : ( ~(? (!arg,?) ?)
                                | ? (!arg,) ?
                                )
                            & 
                          | !arg
                      )
                    . !superset
                    )
                : ?superset
              & log$(superset2 !superset)
            | 
            )
          & "If there is a filled Pxyz, remove it from superset. Additional
             user data is supposed to be exactly what the user wants. (There
             is no checkbox for the user to allow more complex values.)"
          &     map
              $ ( ( 
                  =   
                    .     !o-SUpPLEMENT:? (!arg,~) ?
                        & 
                      | !arg
                  )
                . !superset
                )
            : ?superset
          & ( 
            |   log
              $ ( superset
                  !superset
                  usupset
                  !usupset
                  o-SUpPLEMENT
                  !o-SUpPLEMENT
                )
            )
          & "P values come from a subset of select boxes, when the user has
             asked for assistance to fill out the remaining fields."
          & !o-SUpPLEMENT:?pp
          & "Make pp a list of Pxyz features that do not occur as Oxyz. At the
             same time, make oo a list of Oxyz with elements replaced by Pxyz,
             if they exist."
          &     map
              $ ( ( 
                  =   f fv a z
                    .     !arg:(?f,?)
                        & !pp:?a ((!f,?):?fv) ?z
                        & !a !z:?pp
                        & !fv
                      | !arg
                  )
                . !o
                )
            : ?oo
          & (!i.sort$(!oo !pp).!restriction.!superset):?userInput
          & log$(Pipelines/userInput !userInput)
          & ( furtherCheck
            =   uiou wfs output nwfs wf
              .   log$furtherCheck1
                & !arg:(?wfs.?uiou)
                & 0:?nwfs
                &   whl
                  ' ( !wfs:((?,(?output.?)):?wf)+?wfs
                    & (     map
                          $ ( ( 
                              =   uf uv wv len u
                                .     !arg:(?uf,?uv)
                                    &   !output
                                      :   ?
                                          (!uf,(?wv.OnE)|?wv)
                                          ?
                                    & !uv:?*[?len
                                    & !wv:?*[!len
                                    &   whl
                                      ' ( !uv:%?u*?uv
                                        & !wv:!u^?*?wv
                                        )
                                    & !wv:1
                                    & !uv:1
                                    & 
                                  |   !output:~(? (!uf,?) ?)
                                    & log$(LACKING !uf)
                                    & "The feature may be missing when
                                         looking at unpruned, raw pipes"
                                    & ( !uf:sml&
                                      | STOP
                                      )
                                  | !arg
                              )
                            . !uiou
                            )
                        : ( &!nwfs+!wf:?nwfs
                          | STOP&0:?wfs:?nwfs
                          )
                      | 
                      )
                    )
                & !nwfs:~0
            )
          & (   ( !recentTasks
                | readTable$recentTasks
                |   :?recentTasks
                  & saveTable$recentTasks
                )
              & log$("look in recentTasks for" !userInput)
              &   !recentTasks
                :   ?A
                    ( !userInput
                    . ?reorderedworkflowlist
                    . ?topologicalOrderedTools
                    )
                    ?Z
              &     ( !userInput
                    . !reorderedworkflowlist
                    . !topologicalOrderedTools
                    )
                    !A
                    !Z
                : ?recentTasks
              & saveTable$recentTasks
              & log$(windFW !nth)
              &   windFW$(!reorderedworkflowlist.!nth)
                : ?reorderedworkflowlist
              & log$woundFW
              & ( !parms
                . !userInput
                . (!reorderedworkflowlist.!topologicalOrderedTools)
                . allRight
                )
            |   log$(Not in recentTasks)
              & "memoizedTrees: global variable"
              & (!memoizedTrees|:?memoizedTrees)
              & 0:?indent:?calls:?Npipes
              & (   log$("Look in meMOizedTrees" for !userInput)
                  & !userInput:(?uiin.?uiou.?restriction.?superset)
                  & "o1o The userInput may be more strict than what is found in
                     memoized trees. So each output feature in a memoized tree
                     must occur in the userInput's output specs."
                  & ( o2o
                    =   FP nFP ou wf uou uiou
                      .   !arg:(?FP.?uiou)
                        & "o-SUpPLEMENT  (facet,lem*mrf*ner*pos*seg*stx*tok)"
                        & 0:?nFP
                        &   whl
                          ' ( !FP:(?ou.?wf)+?FP
                            & "need  (ambig,una)  (app,nrm)  (facet,                 stx         )  (format,conll    )  (lang,la)               (pres,nml)
                               have  (ambig,una)  (app,nrm)  (facet,(lem*mrf*pos*seg*stx*tok.OnE))  (format,conll^clU)  (lang,la)  (period,c1)  (pres,nml)  

                               need  (ambig,una)  (app,nrm)  (facet, lem*mrf*ner*pos    *seg*stx*tok)       (format,conll    )  (lang,da)  (period,c21)  (pres,nml)
                               have  (ambig,una)  (app,nrm)  (facet,(lem*mrf*ner*pos^Uni*seg*stx*tok.OnE))  (format,conll^clU)  (lang,da)  (period,c21)  (pres,nml)
                               ZYX  (facet,(lem*mrf*ner*pos^Uni*seg*stx*tok.OnE))
                              "
                            & !uiou:?uou
                            & (       map
                                    $ ( ( 
                                        =     ft us nus u Vs
                                            , A Z a z V
                                          .   !arg:(?ft,?V)
                                            & (     !uou
                                                  : ?a (!ft,?us) ?z
                                                & !a !z:?uou
                                                & (   !V:!us^?
                                                    & 
                                                  |   !V:(?Vs.OnE)
                                                    &   whl
                                                      ' ( !us:%?u*?nus
                                                        &   !Vs
                                                          : ?a*!u^?*?z
                                                        & !a*!z:?Vs
                                                        & !nus:?us
                                                        )
                                                    & !us:1
                                                    & "all user specs were found"
                                                    & (     !o-SUpPLEMENT
                                                          : ~( ?
                                                               (!ft,?)
                                                               ?
                                                             )
                                                        & "User says nothing about feature ft"
                                                      |   !Vs:1
                                                        & "Exact match between compound feature values.
                                                           No need to supplement this feature with a superset.
                                                          "
                                                        & (     !superset
                                                              : ?A !ft ?Z
                                                            &   !A !Z
                                                              : ?superset
                                                          | 
                                                          )
                                                      )
                                                    & 
                                                  | !arg
                                                  )
                                              | 
                                              )
                                        )
                                      . !ou
                                      )
                                  : 
                                & ( !uou:
                                  | furtherCheck$(!wf.!uou):?wf
                                  )
                                & !nFP+(!ou !uou.!wf):?nFP
                              | 
                              )
                            )
                        & !nFP:~0
                    )
                  &   !memoizedTrees
                    :   ?
                        (   (!uiin.?ou.?restr.?supers)
                          &     map
                              $ ( ( 
                                  =   vs f nvs V v
                                    .     !uiou:? !arg ?
                                        & 
                                      |   !arg:(?f,?vs)
                                        & !uiou:? (!f,?V) ?
                                        &   whl
                                          ' ( !vs:%?v*?nvs
                                            & !V:?*!v*?
                                            & !nvs:?vs
                                            )
                                        & !vs:1
                                        & 
                                      | !arg
                                  )
                                . !ou
                                )
                            : 
                          & (   (!restr.!supers)
                              : (!restriction.!superset)
                            | !superset:&!ou:~
                            )
                        .   ?FP
                          & log$MEMOIZED!
                          & "o2o Now we have a set of memoized trees based on
                             weaker requirements than the current userInput
                             output specs. So we have to filter away all
                             memoized trees that conflict with the current
                             specs."
                          & o2o$(!FP.!uiou):?nFP
                        )
                        ?
                  & log$SUCCESS
                  & "o3o Probably not all user features ('uiou') where present
                     in the output specs of the memoized workflows. So we need
                     to have a closer look at the workflows actually computed
                     and filter away the workflows that do not comply with the
                     user requirements formulated in the features that were not
                     represented in the output specs."
                  &       map
                        $ ( ( 
                            =   A Z f v V
                              .   !arg:(?f,?v)
                                & ( !f
                                  ,       !o-SUpPLEMENT
                                        : ?A (!f,~:?V) ?Z
                                      & !A !Z:?o-SUpPLEMENT
                                      & !V
                                    | !v
                                  )
                            )
                          . !o
                          )
                        !o-SUpPLEMENT
                    : ?o
                  &     ((!i.!o.!restriction.!superset).!nFP)
                        !memoizedTrees
                    : ?memoizedTrees
                  & !nFP:?FP
                |   "The next call fails if no workflows found."
                  & (     !userInput
                        : (?A.?B (sml,?) ?Y.?Z)
                      & (!A.!B !Y.!Z):?userInput
                    | 
                    )
                  & log$"Call fp"
                  & fp$!userInput:?FP
                  & !FP:~#
                  & log$"Calling fp success"
                  & "prunePipes fails if tooComplex"
                  & prunePipes$(!FP.!parms.!i):(?FP.?Npipes)
                  & !Npipes:~>1000
                  & log$"Calling prunePipes success"
                  & log$(userInput !userInput)
                  &   (!userInput.!FP) !memoizedTrees
                    : ?memoizedTrees
                  & ( !memoizedTrees:?memoizedTrees [100 ?
                    | 
                    )
                )
              & ( !parms
                . !userInput
                .     !FP:(?,?) ?
                    & ((!FP.).triviallyFulfilled)
                  |   !FP:?+[>1000
                    & ((!FP.).tooMany)
                  |   ( !restriction:
                      |   !FP
                        :   ?
                          + (?.?fP&haz$(!fP.!restriction))
                          + ?
                      )
                    & (   !nth:
                        & "The returned structure is still unpruned and would
                           also be very large in serialized form. Pruning can
                           take a long time, however, so we first let the user
                           have the chance to refine the goal by looking which
                           feature values are represented in the computed
                           workflows."
                        & ((!FP.!arg).workflowsFound)
                      |   "This is unusual. If the user chooses a specific 
                           workflow, it will normally not have to be
                           recomputed. Instead, it will be found in
                           recentTasks."
                        & log$UNUSUAL!
                        & (     makeWorkflowsSequential$!FP
                              : ( ?reorderedworkflowlist
                                . ?topologicalOrderedTools
                                )
                            & allRight:?returnCode
                          |   0:?reorderedworkflowlist
                            & :?topologicalOrderedTools
                            & tooComplex:?returnCode
                          )
                        & !reorderedworkflowlist:?+[?nr
                        & log$(UNUSUALsaveTask !userInput length !nr)
                        &   saveTask
                          $ ( !userInput
                            . !reorderedworkflowlist
                            . !topologicalOrderedTools
                            )
                        &   windFW$(!reorderedworkflowlist.!nth)
                          : ?reorderedworkflowlist
                        & ( (!reorderedworkflowlist.!topologicalOrderedTools)
                          . allRight
                          )
                      )
                  | ((!FP.).onlyWithoutRestriction)
                )
            |   !FP:#:<0
              & (!parms.!userInput.(0.).tooMany)
            |   !Npipes:0
              & (!parms.!userInput.(0.).notFulfillable)
            | (!parms.!userInput.(0.).tooMany)
            )
      )
      ( composeValueString
      =   valstr v s vals specs
        .   :?valstr
          & 0:?specs
          & !arg:?vals
          &   whl
            ' ( !vals:%@?v^?s*?vals
              & !valstr "_" !v:?valstr
              & ( !s:(|1)
                | !specs+(str$("__" !v "_" !s).0):?specs
                )
              )
          & (str$!valstr.!specs)
      )
      " convert2URLs receives a list of job steps, each step describing the 
step's tool, its output and its inputs. The inputs not only tell the type of
each input, but also which step produced that input. The first step's input is
taken from the Items list. Following steps can, but need not take an item in
the Items list as input. Step descriptions in the JobStack can look like this:
  ( step1                                 STEP
  . pdf2htmlEX                            TOOL
  .   (facet,txt^ocr)                     ------
      (format,html)                       
      (lang,da)                           INPUT
      (pres,nml)                          -----
  .   (facet,txt)                         ------
      (format,pdf)                        
      (lang,da)                           OUTPUT
      (pres,nml)                          ------
  )
...
  ( step8                                  STEP
  . CST-Lem                                TOOL
  .   (facet,lem)                          ------
      (format,flat)
      (lang,da)                            INPUT
      (pres,alf)                           ------
  .   (pres,nml)                           ------
      (lang,da)
      (format,txtann)                      OUTPUT
      (facet,(pos^Par.step7))
      (facet,(tok.step5))                  ------
  )
"
      ( convert2URLs
      =     requestString Items items file files newJobs feats
          , base post2 val vals JobStack Val item In
          , jobIDoffset A OffSet addOutputsToRequestString
          , extension ID forceFeed jobNr jobID maxjobID
          , Short Long DiscerningFeature getDisFe
          , DATE Tool URL dep discerningFeature
          , feat in ou spec v nfiles fileTerm notIncompatible
          , inputs moreinputs firstinput other fh oh
          , compact compatible simpleInput someinputs
          , getDepsAndAddInputsToRequestString
          , distillInputsFromRequestString
        .   "getDisFe establishes the feature that the given tool has to look
             for among the input Items, if it needs an item from that list.
             It is not useful for steps that only take input from earlier
             steps."
          & ( getDisFe
            =   f
              .     !arg:? (?f,?) ? (!f,?) ?
                  & (!f.n)
                | (.1)
            )
          & ( Short
            =   
              .   (   !features
                    :   ?
                      + ( ? (name.? !arg ?) ?
                        : ? (short.?arg) ?
                        )
                      + ?
                  | 
                  )
                & !arg
            )
          & ( Long
            =   
              .   (   !features
                    :   ?
                      + ( ? (short.!arg) ?
                        : ? (name.?arg) ?
                        )
                      + ?
                  | 
                  )
                & localized$!arg
            )
          & ( compact
            =   A B C D E x
              .       whl
                    ' ( !arg:?A+(#*%?x.?B)+?C+(#*!x.?D)+?E
                      & !A+(!x.!B+!D)+!C+!E:?arg
                      )
                  &   whl
                    ' ( !arg:?A+#%*%?x+?C
                      & !A+!x+!C:?arg
                      )
                  & 0:?E
                  &   whl
                    ' ( !arg:?A+(?B.?C)+?arg
                      & !E+!A+(!B.compact$!C):?E
                      )
                  & !arg+!E:?arg
                | FOUT
            )
          & ( OffSet
            =   ID
              .   !jobIDoffset:&!arg
                |   @(!arg:step #?ID)
                  & str$(step !ID+!jobIDoffset)
                | !arg
            )
          & ( simpleInput
            =   a b c d e,f g h i j k
              .     !arg
                  : (   ?
                      + (I.?.?.?+(F.?)+?)
                      + ?
                      + (I.?.?.?+(F.?)+?)
                      + ?
                    | ?+(F.?)+?
                    )
                |     !arg
                    :   ?a
                      + (I.?b+(?c.?d+(?e.?f+(F.?g)+?h)+?i)+?j)
                      + ?k
                  & !a+(F.!g)+(I.!b+(!c.!d+(!e.!f+!h)+!i)+!j)+!k
            )
          & ( forceFeed
            =   requestString item file
              .   0:?requestString
                & !arg:?items
                &   whl
                  ' ( !items:(Item.%?item ?) ?items
                    & !Uploads:? (?.!item.?file.?) ?
                    &     !requestString
                        + ( !files !file:?files
                          & (F.!file)
                          )
                      : ?requestString
                    )
                & !requestString
            )
          & ( notIncompatible
            =   feats In f
              .   !arg:(?feats.?In)
                & ~( !feats
                   :   ?
                       (?f.?v)
                       ( ?
                       & !In:? (!f,(!v^?.?)) ?
                       )
                   )
            )
          & ( compatible
            =   f r v rs fv
              .   !arg:(?.~(? (?,@) ?))
                |   !arg:(?f.? (?r,@?v) ?rs)
                  & ( ~(!f:? (!r.?fv) ?)
                    | !v:!fv
                    | !v:!fv^?
                    | !fv:!v^?
                    )
                  & compatible$(!f.!rs)
            )
          & ( addOutputsToRequestString
            =   ou requestString extension feat val spec vals
              .   !arg:(?ou.?requestString)
                & xml:?extension
                &   whl
                  ' ( !ou:(?feat,?vals) ?ou
                    &   whl
                      ' ( !vals:%@?val^?spec*?vals
                        &     !requestString
                            + ( O
                              . Short$!feat
                              . !val
                              .   !spec:1&0
                                | !spec
                              )
                          : ?requestString
                        & (   !feat:(format|Format)
                            &   ( !val:flat&txt
                                |     !val
                                    : ( xm
                                      | txtbasis
                                      | txtann
                                      | teip5
                                      )
                                  & xml
                                | !val
                                )
                              : ?extension
                          | 
                          )
                        )
                    )
                & (!extension.!requestString)
            )
          & ( getDepsAndAddInputsToRequestString
            =   in nfiles requestString newJobs getCompatibleInputFile
              .   ( getCompatibleInputFile
                  =     Items FiLfeats item feats Uploads
                      , fileitem feats
                    .   !arg:(?Items.?Uploads.?FiLfeats)
                      &   !Items
                        :   ?
                            ( Item
                            .   %?item ?feats
                              &   !Uploads
                                :   ?
                                    ( ?
                                    . !item
                                    . ?fileitem
                                    . ?
                                    .   ?feats
                                      & compatible$(!feats.!FiLfeats)
                                    )
                                    ?
                            )
                            ?
                      & !fileitem
                  )
                & !arg:(?in.?nfiles.?requestString.?newJobs)
                &     map
                    $ ( ( 
                        =     feat vals Val spec file specs
                            , val dep FiLfeats fileitem
                          .   !arg:(?feat,?vals)
                            & :?dep
                            &   whl
                              ' ( !vals:%?Val*?vals
                                & 0:?specs
                                &   !Val
                                  : ( ( %@?val^?spec
                                      .     @?file
                                          & OffSet$!file:?file
                                          &   !dep (!file,pending)
                                            : ?dep
                                          & (   !newJobs
                                              :   ?
                                                  (!jobNr.!file.?.?.?.?file)
                                                  ?
                                            |   log
                                              $ (OOPS !jobNr file !file)
                                            )
                                          & (F.!file):?fileTerm
                                        |   (FiL.?FiLfeats)
                                          &     getCompatibleInputFile
                                              $ (!Items.!Uploads.!FiLfeats)
                                            : ?fileitem
                                          & !dep !fileitem:?dep
                                          & (F.!fileitem):?fileTerm
                                      )
                                    |   %@?val^?spec
                                      & 0:?fileTerm
                                    | ( ?val&1:?spec
                                      .     @?file
                                          &   composeValueString$!val
                                            : (?val.?specs)
                                          & OffSet$!file:?file
                                          &   !dep (!file,pending)
                                            : ?dep
                                          & (   !newJobs
                                              :   ?
                                                  (!jobNr.!file.?.?.?.?file)
                                                  ?
                                            |   log
                                              $ (OOPS !jobNr file !file)
                                            )
                                          & (F.!file):?fileTerm
                                        |   (FiL.?FiLfeats)
                                          &     getCompatibleInputFile
                                              $ (!Items.!Uploads.!FiLfeats)
                                            : ?fileitem
                                          & !dep !fileitem:?dep
                                          & (F.!fileitem):?fileTerm
                                      )
                                    |   ?val
                                      & log$(UNMATCHED !val)
                                      & ~
                                    )
                                &     !requestString
                                    + (   !nfiles:1
                                        & !fileTerm
                                      | 0
                                      )
                                    + ( I
                                      . Short$!feat
                                      . !val
                                      .   (   !nfiles:n
                                            & !fileTerm
                                          | 0
                                          )
                                        + (     !spec
                                              : (0|1)
                                            & 0
                                          | (!spec.0)
                                          )
                                        + !specs
                                      )
                                  : ?requestString
                                )
                            & !dep
                        )
                      . !in
                      )
                  : ?dep
                & (!dep.!requestString)
            )
          & ( distillInputsFromRequestString
            =     requestString inputs someinputs firstinput
                , moreinputs other oh fh
              .   !arg:?requestString
                &   !requestString
                  : ( ?+(F.@(?:?inputs "-step" #% ?))+?
                    |     ?
                        + ( I
                          .   ?
                            + ( ?
                              .   ?someinputs
                                + ( ?
                                  .   ?
                                    + (F.@(?:?firstinput "-step" #% ?))
                                    + ?
                                  )
                                + ?moreinputs
                              )
                            + ?
                          )
                        + ?
                      & :?inputs
                      & !someinputs+!moreinputs:?moreinputs
                      &   whl
                        ' (   !moreinputs
                            :   ?
                              + ( ?
                                .   ?
                                  + ( F
                                    . @( ?
                                       : ( ?other "-step" #% ?
                                         | ?other
                                         )
                                       )
                                    )
                                  + ?
                                )
                              + ?moreinputs
                          & @(!firstinput:?fh [%@(!other:?oh !sjt))
                          &     str
                              $ (   ( !fh:
                                    | !oh:
                                    |   @(!fh:!oh "-" #?)
                                      & :?oh
                                    )
                                  & (     !inputs
                                        : (|!firstinput)
                                      &   (   @(!firstinput:? !fh ?)
                                            & 
                                          | !fh
                                          )
                                          (   @(!firstinput:? !oh ?)
                                            & 
                                          | !oh
                                          )
                                          !firstinput
                                    | !inputs "_" !other
                                    )
                                |   ( !inputs:&!fh "_"
                                    | 
                                    )
                                    !oh
                                )
                            : ?inputs
                          )
                    )
                & !inputs
            )
          & log$convert2URLs
          & 0:?maxjobID
          & readTable$features
          & readTable$tooladm
          & readTable$toolprop
          &   !arg
            : (?jobNr.?jobIDoffset.?JobStack.?base.?post2.?Items)
          & readTable$Uploads
          & :?newJobs
          & (readTable$jobs|:?jobs)
          & "Note: this whl'() loop cannot be rewritten as a map$-ping,
             since the constructed list (newJobs) is consulted."
          &   whl
            ' ( !JobStack:(?jobID.?Tool.?ou.?in) ?JobStack
              & OffSet$!jobID:?jobID
              & 1+!maxjobID:?maxjobID
              &   !tooladm
                :   ?
                  + ( ? (ToolID.!Tool) ?
                    : ? (ServiceURL.?URL) ?
                    )
                  + ?
              &     (base.!base)
                  + (post2.!post2)
                  + (job.str$(!jobNr "-" !jobID))
                : ?requestString
              & getDisFe$!in:(?discerningFeature.?nfiles)
              &   addOutputsToRequestString$(!ou.!requestString)
                : (?extension.?requestString)
              & !in:?In
              &     getDepsAndAddInputsToRequestString
                  $ (!in.!nfiles.!requestString.!newJobs)
                : (?dep.?requestString)
              &     !dep
                    ( :?files
                    & ( !requestString:?+(F.?)+?
                      |   !Items:?items
                        &   whl
                          ' (   !items
                              : (Item.%?item ?feats) ?items
                            &   !Uploads
                              :   ?
                                  ( ?
                                  . !item
                                  . ?file
                                  . ? (DATE.?DATE) ?
                                  . ?feats
                                  )
                                  ?
                            &     !requestString
                                + (   !discerningFeature:
                                    & !files !file:?files
                                    & (F.!file)
                                  |     !feats
                                      : ? (!discerningFeature.?v) ?
                                    &   getShort$(!discerningFeature.!v)
                                      : ?v
                                    &   Long$!discerningFeature
                                      : ?DiscerningFeature
                                    & notIncompatible$(!feats.!In)
                                    & compatible$(!feats.!In)
                                    &   !In
                                      :   ?
                                          (   !discerningFeature
                                            | !DiscerningFeature
                                          ,   ?+?*!v^?*?+?
                                            | (?+?*!v^?*?+?.?)
                                            | ?+?*!v*?+?
                                            | (?+?*!v*?+?.?)
                                          )
                                          ?
                                    & !v:%@?v^?
                                    & !files !file:?files
                                    & (I.!discerningFeature.!v.F.!file)
                                  | 0
                                  )
                              : ?requestString
                            )
                      )
                    & (     !requestString
                          : ( ?+(I.?+(?.?+(?.?+(F.?)+?)+?)+?)+?
                            | ?+(F.?)+?
                            )
                        & simpleInput$!requestString:?requestString
                      |   !requestString+forceFeed$!Items
                        : ?requestString
                      )
                    & !files
                    )
                : ?inputs
              & compact$!requestString:?requestString
              &     !newJobs
                    ( !jobNr
                    . !jobID
                    . !inputs
                    . !URL
                    . !requestString
                    .   "Output from tool:"
                      &   str
                        $ ( (     !inputs
                                : ? (@(?:step ?),?) ?
                              & distillInputsFromRequestString$!requestString
                            |   ( !inputs:@
                                |   @(!jobID:? #?ID)
                                  &     2
                                      *   mod
                                        $ ( div$(!DATE*(1+clk$),1)
                                          , 4231764527
                                          )
                                    + !jobNr*100
                                    + !ID
                                )
                                "-"
                                !jobNr
                            )
                            "-"
                            !jobID
                            "."
                            !extension
                          )
                    )
                : ?newJobs
              )
          & !jobs !newJobs:?jobs
          & saveTable$jobs
          & !maxjobID
      )
      "
/**
 * getNextJobID
 *
 * Given the jobNr of a workflow, return the next job that is not pending 
 * (=waiting for an another job to produce some of its inputs).
 * Argument: jobNr
 * Returns: jobID (if job found in jobs.table)
 *          empty string (if job not found in jobs.table)
 * Called from create.java and workflow.java
 */"
      ( getNextJobID
      =   A Z jobID dep g test err
        .     -11:?err
            & !arg:(?arg.?test)
            & -12:?err
            & @(!arg:? #?arg)
            & -13:?err
            & readTable$jobs
            & -14:?err
            & (     !jobs
                  :   ?A
                      ( !arg
                      . @?jobID
                      . ~(? (?,pending) ?):?dep
                      . ?g
                      )
                      ?Z
                & -15:?err
                & (   !test:justtesting
                    & -16:?err
                    & -17:?err
                    & !jobID
                  |       !A
                          (!arg.!jobID starting.!dep.!g)
                          !Z
                      : ?jobs
                    & -18:?err
                    & (   -19:?err
                        & (   saveTable$jobs
                            & -20:?err
                            & (!jobID|!err)
                          | !err
                          )
                      | !err
                      )
                  | 
                  )
              | 
              )
          | !err
      )
      ( goodRunningThreads
      =   
        .   (|log$(goodRunningThreads !runningThreads))
          & (!runningThreads:<8&y|n)
      )
      "
/**
 * getJobArg
 *
 * Consults tables jobs.table and tooladm.table to answer several requests
 * Arguments: jobNr, jobID and one of the following requests:
 *      endpoint        the URL where the integrated tool lives
 *      filename        the name to be given to the output
 *      method          POST or GET
 *      requestString   the request string as HTTP-parameters or as XML
 *      isXML           y or n
 * Called from workflow.java
 */"
      ( getJobArg
      =     JobNr jobID jobby res A B Res makeList
          , req servurl xmlparms
        .   str
          $ (   !arg:(@(?:? #?JobNr).?jobID.?arg)
              & (!jobs|readTable$jobs)
              & !jobs:? (!JobNr.!jobID ?.?jobby) ?
              &   !arg
                : ( endpoint&!jobby:(?.?arg.?)
                  |   method
                    & !jobby:(?.?arg.?)
                    & readTable$tooladm
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!arg) ?
                          : ? (PostData.?arg) ?
                          )
                        + ?
                    &   ( !arg:on&POST
                        | GET
                        )
                      : ?arg
                  |   requestString
                    &   1+!runningThreads
                      : ?runningThreads
                      : ( >!maxRunningThreads:?maxRunningThreads
                        | ?
                        )
                    &   log
                      $ ( str
                        $ ( "getJobArg:runningThreads:"
                            !runningThreads
                            " maxRunningThreads:"
                            !maxRunningThreads
                          )
                        )
                    & !jobby:(?.?servurl.?req.?)
                    & readTable$tooladm
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!servurl) ?
                          : ? (XMLparms.?xmlparms) ?
                          )
                        + ?
                    & (   !xmlparms:on
                        & ( makeList
                          =   X el sub res
                            .   :?res
                              &   whl
                                ' ( !arg:%?X+?arg
                                  &     !res
                                        (   !X:(?el.?sub)
                                          & (!el.,makeList$!sub)
                                        | !X
                                        )
                                    : ?res
                                  )
                              & !res
                          )
                        & makeList$(parms.!req):?res
                        & str$!res:?arg
                      |   ( makeList
                          =   A B prefix res
                            .   !arg:(?prefix.?arg)
                              & :?res
                              &   whl
                                ' ( !arg:%?A+?arg
                                  &     !res
                                        (   !A:(?A.?B)
                                          &   ( !prefix:
                                              | (!prefix,!A)
                                              )
                                                makeList
                                              $ (!prefix !A.!B)
                                        | !prefix:
                                        | (!prefix,!A)
                                        )
                                    : ?res
                                  )
                              & !res
                          )
                        & makeList$(.!req):?res
                        & !res:(?A,?B) ?res
                        & !A "=" !B:?Res
                        &   whl
                          ' ( !res:(?A,?B) ?res
                            & !Res "&" !A "=" !B:?Res
                            )
                        & str$!Res:?arg
                      )
                  | filename&!jobby:(?.?.?.?arg)
                  )
              & !arg
            | SOMETHINGWRONG
            )
      )
      "
/**
  * waitingJob
  *
  * Make a job 'waiting'.
  * 
  * Input: JobNr and jobID
  *
  * Affected tables:
  *     jobs.table
  *
  * Called from workflow.java
  */"
      ( waitingJob
      =   A Z JobNr jobID ZZ jobstatus
        .     readTable$jobs
            & log$("waitingJob " !arg)
            & !arg:(@(?:? #?JobNr).?jobID)
            &   whl
              ' (   !jobs
                  : ?A (!JobNr.!jobID ?jobstatus.?ZZ) ?Z
                & !jobstatus:(|starting)
                &   !A (!JobNr.!jobID waiting.!ZZ) !Z
                  : ?jobs
                )
            & saveTable$jobs
            & 
          | "Expecting (? #JobNr.jobID)"
      )
      ( tekstXML
      =     OLACTITLE DATE EMAIL TBA AVAILABILITY Description
          , OUTPUTFACET XMLID ITEMS TOOLURIS SPANGRP
          , ret linguae BODYCONTENT niceDate noColon
          , ToolID Title ToolContentProvider Version toolURL full
          , CTB LANGUAGE type appdesc
        .     !arg
            : ( ?OLACTITLE
              . ?DATE
              . ?EMAIL
              . ?CTB
              . ?TBA
              . ?AVAILABILITY
              . ?OUTPUTFACET
              . ?XMLID
              . ?ITEMS
              . ?TOOLURIS
              . ?SPANGRP
              . ?toolURL
              . ?LANGUAGE
              )
          & ( niceDate
            =   yyyy mm dd
              .     @( !arg
                     :   (% % % %:?yyyy)
                         (% %:?mm)
                         (% %:?dd)
                     )
                  & str$(!yyyy "-" !mm "-" !dd)
                | !arg
            )
          & ( noColon
            =   A Z
              .     whl
                  ' ( @(!arg:?A "::" ?Z)
                    & str$(!A "_" !Z):?arg
                    )
                &   whl
                  ' ( @(!arg:?A ":" ?Z)
                    & str$(!A "_" !Z):?arg
                    )
                & !arg
            )
          &   
            : ?Title
            : ?ToolContentProvider
            : ?Version
            : ?ToolID
            : ?Description
          & (   !SPANGRP
              : ? ("?".@(?:? xml ? version ?)) ?SPANGRP
            | 
            )
          & (     !SPANGRP
                :   ?
                    ( spanGrp
                    .   ? (ana.@(?:"#" ?XMLID)) ?
                      | ?
                    )
                    ?
              & :?BODYCONTENT
              & annotation:?type
            |   !SPANGRP:?BODYCONTENT
              & :?SPANGRP
              & text:?type
            )
          &     (   readTable$tooladm
                  &   !tooladm
                    :   ?
                      + ( ? (ServiceURL.!TOOLURIS) ?
                        : ? (ToolID.?ToolID) ?
                        : ? (Title.?Title) ?
                        : ? (ContentProvider.?ToolContentProvider) ?
                        : ? (Version.?Version) ?
                        : ? (Description.?Description) ?
                        )
                      + ?
                  & !Title
                | !toolURL
                )
                ". "
                !Description
            : ?appdesc
          & log$(ToolID !ToolID)
          &     ("?"."xml version='1.0' encoding='UTF-8'")
                \n
                ( TEI
                .     (xmlns."http://www.tei-c.org/ns/1.0")
                      ( "xmlns:schemaLocation"
                      .   "https://www.clarin.dk/schemas/tei/TEIDKCLARIN_ANNO/xml.xsd"
                        |   !type:text
                          & "http://www.clarin.eu/cmd http:/infra.clarin.dk/cmd/dkclarin-text-md-schema.xsd"
                        | "http://www.clarin.eu/cmd http://infra.clarin.dk/cmd/dkclarin-textann-md-schema.xsd"
                      )
                  ,   \n
                      ( teiHeader
                      .   (type.!type)
                        ,   ( fileDesc
                            .   
                              ,   ( titleStmt
                                  .   
                                    ,   (title.,!OLACTITLE ", TEI-format")
                                        (sponsor.,DK-CLARIN)
                                        ( respStmt
                                        .   
                                          ,   (resp.,"a_annotation")
                                              ( name
                                              .   
                                                ,   ( note
                                                    .   (type.method)
                                                      , !ToolID
                                                    )
                                                    ( date
                                                    .   (when.niceDate$!DATE)
                                                      , 
                                                    )
                                              )
                                        )
                                  )
                                  (   !type:text
                                    & ( extent
                                      . ,(num.(type.words),)
                                      )
                                  | 
                                  )
                                  ( publicationStmt
                                  .   
                                    ,   (distributor.,!EMAIL)
                                        (idno.(type.ctb),!CTB)
                                        ( availability
                                        .   (status.free)
                                          , (ab.(type.public),)
                                        )
                                  )
                                  ( notesStmt
                                  . ,(note.,localized$!OUTPUTFACET)
                                  )
                                  ( sourceDesc
                                  .   
                                    , ( biblStruct
                                      .   
                                        , ( monogr
                                          .   
                                            ,   ( title
                                                .   ("xml:lang".!LaNg)
                                                  , monogr
                                                )
                                                ( imprint
                                                .   
                                                  ,   ( publisher
                                                      .   (n.n/a)
                                                        , !ToolContentProvider
                                                      )
                                                      ( date
                                                      .   ( when
                                                          . niceDate$!DATE
                                                          )
                                                        , 
                                                      )
                                                )
                                          )
                                      )
                                  )
                            )
                            ( "!--"
                            .   toML
                              $ ( encodingDesc
                                .   
                                  ,   (samplingDecl.,(ab.,samplingDecl))
                                      (projectDesc.,(ab.,!TBA))
                                      ( !type:text&
                                      | ( appInfo
                                        .   
                                          , ( application
                                            .     ( ident
                                                  .   !ToolID
                                                      ( !Version:
                                                      | "_" !Version
                                                      )
                                                  )
                                                  (type."a_annotation")
                                                  (subtype.!OUTPUTFACET)
                                                  (version.!Version)
                                                  ("xml:id".!XMLID)
                                              ,   (desc.,!appdesc)
                                                  ( ptr
                                                  .   (target.noColon$!ITEMS)
                                                    , 
                                                  )
                                                  ( ref
                                                  .   (target.!TOOLURIS)
                                                    , 
                                                  )
                                            )
                                        )
                                      )
                                )
                            )
                            ( profileDesc
                            .   
                              ,   ( creation
                                  .   
                                    , ( date
                                      .     (cert.high)
                                            (when.niceDate$!DATE)
                                        , 
                                      )
                                  )
                                  ( !LANGUAGE:
                                  | ( langUsage
                                    .   
                                      , ( language
                                        .   (ident.!LANGUAGE)
                                          ,     readTable$linguae
                                              &   !linguae
                                                :   ?
                                                    (?full.!LANGUAGE.?)
                                                    ?
                                              & localized$!full
                                            | 
                                        )
                                    )
                                  )
                                  ( textDesc
                                  .   
                                    ,   (channel.(mode.w),2)
                                        (constitution.,)
                                        (derivation.,)
                                        ( domain
                                        . (type.specific),general
                                        )
                                        (factuality.,)
                                        (interaction.,)
                                        (preparedness.,)
                                        (purpose.,)
                                  )
                                  (particDesc.,(person.,))
                            )
                            ( revisionDesc
                            .   
                              , ( change
                                .     (when.niceDate$!DATE)
                                      (who.!EMAIL)
                                  ,     !type:text
                                      & !appdesc
                                    | created
                                )
                            )
                      )
                      \n
                      ( text
                      .   
                        ,   ( body
                            .   
                              ,     !BODYCONTENT:~
                                  & (   !BODYCONTENT
                                      : (   ?
                                            ( text
                                            .   ?
                                              ,   ?
                                                  (body.?,?BODYCONTENT)
                                                  ?
                                            )
                                            ?
                                        | ? (body.?,?BODYCONTENT) ?
                                        |   ?
                                            (body.?)
                                            ?BODYCONTENT
                                            (.body.)
                                            ?
                                        )
                                    | 
                                    )
                                  & !BODYCONTENT
                                | ( ab
                                  .   
                                    ,     !SPANGRP:
                                        & "empty body/no text"
                                      | 
                                  )
                            )
                            \n
                            !SPANGRP
                      )
                )
            : ?ret
          & !ret
      )
      "
/**
 * relationFile
 *
 * Create a relation file ready for deposition together with an annotation.
 *
 * Input: JobNr and jobID
 * Output: String that can be saved as a semicolon separated file.
 * Consulted tables:
 *      relations.table     (for relation type, ctb and ctbid
 *      CTBs.table          (for ContentProvider and CTBID)
 *
 * Called from workflow.java
 */"
      ( 
      | NORELATIONSFILES
      | ( relationFile
        =     A Z JobNr jobID
            , ContentProvider CTBID ctb ctbid rel reltype
          .     !arg:(@(?:? #?JobNr).?jobID)
              & readTable$relations
              & readTable$CTBs
              &   !CTBs
                : ? (!JobNr.!jobID.?ContentProvider.?CTBID) ?
              & :?rel
              &   whl
                ' (   !relations
                    : ?A (!JobNr.!jobID.?reltype.?ctb.?ctbid) ?Z
                  & !A !Z:?relations
                  &     !rel
                        !reltype
                        ";"
                        !ContentProvider
                        ";"
                        !CTBID
                        ";"
                        !ctb
                        ";"
                        !ctbid
                        ";;\n"
                    : ?rel
                  )
              & (|saveTable$relations)
              & str$!rel
            | 
        )
      )
      ( isTEIoutput
      =   format JobNr jobID
        .   readTable$jobs
          & !arg:(@(?:? #?JobNr).?jobID)
          & (@(!jobID:?jobID " " ?)|)
          & (     !jobs
                :   ?
                    ( !JobNr
                    . !jobID ?
                    . ?
                    . ?
                    .   ?
                      + ( O
                        .   ?
                          + ( format
                            .   ( txtann
                                | txtbasis
                                | teip5
                                )
                              : ?format
                            . ?
                            )
                          + ?
                        )
                      + ?
                    . ?
                    )
                    ?
              & !format
            | 
            )
      )
      ( inject
      =     userProvidedMetadata autogenerated final recurse
          , Required/optional/automatic val Line tree
          , PlaceInHeader id addOrInsert remove Metadata
          , replaceOrInsert addOrInsertOneOrMoreNames metadataType
        .   ( remove
            =     PlaceInHeader tree subtree
                , place A Z a attval
              .   !arg:(?PlaceInHeader.?tree)
                & (   !PlaceInHeader:%?place ?PlaceInHeader
                    & (   !PlaceInHeader:
                        & (   !place:(?place,?attval)
                            &   whl
                              ' (   !tree
                                  :   ?A
                                      (!place.? !attval ?,?)
                                      ?Z
                                & !A !Z:?tree
                                )
                          |   whl
                            ' ( !tree:?A (!place.?,?) ?Z
                              & !A !Z:?tree
                              )
                          )
                        & !tree
                      |   (   !place:(?place,?attval)
                            &   !tree
                              :   ?A
                                  (!place.? !attval ?:?a,?subtree)
                                  ?Z
                          | !tree:?A (!place.?a,?subtree) ?Z
                          )
                        &   !A
                            (!place.!a,remove$(!PlaceInHeader.!subtree))
                            remove$(!place !PlaceInHeader.!Z)
                      )
                  | !tree
                  )
            )
          & ( replaceOrInsert
            =     PlaceInHeader val tree subtree
                , place plac at A E Z a z attval
              .   !arg:(?PlaceInHeader.?val.?tree)
                & (   !PlaceInHeader:%?place ?PlaceInHeader
                    & (   !place:(?place.?at)
                        & (     !tree
                              :   ?A
                                  (!place.?a (!at.?) ?z,?E)
                                  ?Z
                            &   !A
                                (!place.!a (!at.!val) !z,!E)
                                !Z
                          | !tree (!place.(!at.!val),)
                          )
                      |   !place:(?plac,?attval)
                        &   !tree
                          :   ?A
                              (!plac.? !attval ?:?a,?subtree)
                              ?Z
                        &   !A
                            ( !plac
                            .   !a
                              ,   replaceOrInsert
                                $ (!PlaceInHeader.!val.!subtree)
                            )
                            !Z
                      |   !tree:?A (!place.?a,?subtree) ?Z
                        &   !A
                            ( !place
                            .   !a
                              ,   replaceOrInsert
                                $ (!PlaceInHeader.!val.!subtree)
                            )
                            !Z
                      |   !tree
                          (   !place:(?plac,?attval)
                            & ( !plac
                              .   !attval
                                , replaceOrInsert$(!PlaceInHeader.!val.)
                              )
                          | ( !place
                            . ,replaceOrInsert$(!PlaceInHeader.!val.)
                            )
                          )
                      )
                  | !val
                  )
            )
          & ( recurse
            =   A Z a attval place subtree
              .   !PlaceInHeader:%?place ?PlaceInHeader
                & (   !place:(?place,?attval)
                    & (     !tree
                          :   ?A
                              (!place.? !attval ?:?a,?subtree)
                              ?Z
                        &   !A
                            (!place.!a,!arg$(!PlaceInHeader.!val.!subtree))
                            !Z
                      |   !tree
                          (!place.!attval,!arg$(!PlaceInHeader.!val.))
                      )
                  |   !tree:?A (!place.?a,?subtree) ?Z
                    &   !A
                        (!place.!a,!arg$(!PlaceInHeader.!val.!subtree))
                        !Z
                  | !tree (!place.,!arg$(!PlaceInHeader.!val.))
                  )
            )
          & ( final
            =   A Z a attval b
              .     !PlaceInHeader:@
                  & (     !tree
                        :   ?A
                            (!PlaceInHeader.?a,?b)
                            (~((!PlaceInHeader.?) ?):?Z)
                      &   !A
                          (!PlaceInHeader.!a,!b)
                          (!PlaceInHeader.!a,!val)
                          !Z
                    | !tree (!PlaceInHeader.,!val)
                    )
                |   !PlaceInHeader:(?PlaceInHeader,?attval)
                  & (     !tree
                        :   ?A
                            (!PlaceInHeader.? !attval ?:?a,?b)
                            ( ~( (!PlaceInHeader.? !attval ?,?)
                                 ?
                               )
                            : ?Z
                            )
                      &   !A
                          (!PlaceInHeader.!a,!b)
                          (!PlaceInHeader.!a,!val)
                          !Z
                    | !tree (!PlaceInHeader.!attval,!val)
                    )
            )
          & ( addOrInsert
            =   PlaceInHeader val tree
              .   !arg:(?PlaceInHeader.?val.?tree)
                & ( final$
                  | recurse$addOrInsert
                  | !val
                  )
            )
          & ( addOrInsertOneOrMoreNames
            =     PlaceInHeader val tree parnt
                , A Z a b c d e
              .   !arg:(?PlaceInHeader.?val.?tree)
                & (   !PlaceInHeader:@?parnt name
                    & (     !tree
                          :   ?A
                              (!parnt.?a,?b (name.?c,?d) ?e)
                              (~((!parnt.?) ?):?Z)
                        &   !A
                            (!parnt.!a,!b (name.!c,!d) !e)
                            (!parnt.!a,!b (name.!c,!val) !e)
                            !Z
                      |   !tree:?A (!parnt.?a,?b) ?Z
                        &   !A
                            (!parnt.!a,(name.,!val) !b)
                            !Z
                      | !tree (!parnt.,(name.,!val))
                      )
                  | final$
                  | recurse$addOrInsertOneOrMoreNames
                  | !val
                  )
            )
          & !arg:(?userProvidedMetadata.?autogenerated.?metadataType)
          & readTable$!metadataType:?Metadata
          &   whl
            ' (   !userProvidedMetadata
                : (?id.?val) ?userProvidedMetadata
              & trim$!val:?val
              & (     !Metadata
                    :   ?
                        ( ?
                        ,   ?
                            ( !id
                            . ?
                            . ?Required/optional/automatic
                            . ?
                            . ?PlaceInHeader
                            . ?
                            . ?
                            . ?
                            )
                            ?
                        )
                        ?
                  &   (     !Required/optional/automatic
                          : ( ? r ?
                            | ? o ?&!val:~
                            )
                        &   replaceOrInsert
                          $ (!PlaceInHeader.!val.!autogenerated)
                      |     !Required/optional/automatic
                          : (   ? (o|zeroOrMore) ?
                              : ~(? a ?)
                            & !val:
                            )
                        &   remove$(!PlaceInHeader.!autogenerated)
                          : ?autogenerated
                      |     !Required/optional/automatic
                          : ( ? oneOrMore ?
                            | ? zeroOrMore ?&!val:~
                            )
                        &   remove$(!PlaceInHeader.!autogenerated)
                          : ?autogenerated
                        &   whl
                          ' ( @( !val
                               : ( ?Line \n ?val
                                 | ?Line&:?val
                                 )
                               )
                            & trim$!Line:?Line
                            & ( !Line:
                              |     (     !Required/optional/automatic
                                        : ? oneOrMore ?
                                      & addOrInsertOneOrMoreNames
                                    | addOrInsert
                                    )
                                  $ (!PlaceInHeader.!Line.!autogenerated)
                                : ?autogenerated
                              )
                            & !val:~
                            )
                        & !autogenerated
                      |   !Required/optional/automatic:? a ?
                        &   replaceOrInsert
                          $ (!PlaceInHeader.!val.!autogenerated)
                      )
                    : ?autogenerated
                | 
                )
              )
          & !autogenerated
      )
      ( Filename
      =   base
        .   str
          $ ( ( @(!arg:?base ".xml")&!base
              | !arg
              )
              ".withmetadata.xml"
            )
      )
      ( 
      | NORELATIONSFILES
      | (RelationsFile=.str$(!arg ".relations.csv"))
      )
      "
/**
 * doneJob
 *
 * Marks a job as 'done' in jobs.table
 * Constructs a CTBID from date, JobNr and jobID
 * Makes sure there is a row in table CTBs connecting
 *      JobNr, jobID, email and CTBID
 * Creates isDependentOf and isAnnotationOf relations
 * Affected tables:
 *      jobs.table
 *      CTBs.table
 *      relations.table
 * Arguments: jobNR, JobID, spangroup with annotation and date. 
 *
 * Called from workflow.java
 */"
      ( doneJob
      =     A Z JobNr jobID ZZ jobid2 a z files facet S
          , prevTitle findOLACTITLEinPreviousSteps
          , ctb ctbid CTBID filename status
          , toolURL parms file TITLE DATE SPANGRPS
          , OLACTITLE DATE EMAIL TBA AVAILABILITY
          , SPANGRP SPANGRPfil SPANGRPfilWithMetadata
          , OUTPUTFACET XMLID ITEMS ZZ LANGUAGE identifier
          , userProvidedMetadata autogenerated extent
          , facets type2facet ensureRelation updateOLACTITLE
        .     readTable$jobs
            &   
              : ?TITLE
              : ?DATE
              : ?OLACTITLE
              : ?EMAIL
              : ?TBA
              : ?AVAILABILITY
              : ?OUTPUTFACET
              : ?XMLID
              : ?ITEMS
              : ?SPANGRP
              : ?LANGUAGE
            &   !arg
              : (@(?:? #?JobNr).%@?jobID ?.?SPANGRPfil.?DATE)
            & -1+!runningThreads:?runningThreads
            &   log
              $ ( str
                $ ( "doneJob:runningThreads:"
                    !runningThreads
                    " maxRunningThreads:"
                    !maxRunningThreads
                  )
                )
            & str$(!DATE "-" !JobNr "-" !jobID):?CTBID
            & (readTable$CTBs|:?CTBs)
            &   ( !SPANGRPfil:
                | get$(!SPANGRPfil,X ML)
                )
              : ?SPANGRP
            & nestML$!SPANGRP:?SPANGRP
            & ( extent
              =   n recur
                .   0:?n
                  & ( recur
                    =   S
                      .     !arg:? (w.?) ?
                          &   whl
                            ' ( !arg:? (w.?) ?arg
                              & 1+!n:?n
                              )
                        |   whl
                          ' ( !arg:? (?.?,?S) ?arg
                            & recur$!S
                            )
                    )
                  & recur$!arg
                  & !n
              )
            & readTable$Uploads
            & readTable$facets
            & ( NORELATIONSFILES
              |   (readTable$relations|:?relations)
                & ( ensureRelation
                  =   
                    .   !relations:? !arg ?
                      | !relations !arg:?relations
                  )
              )
            & ( updateOLACTITLE
              =   ELTIT TIT sam TITLE prevTitle OLACTITLE
                .   !arg:(?TITLE.?prevTitle.?OLACTITLE)
                  & (   rev$!TITLE:?ELTIT
                      & @( rev$!prevTitle
                         : ? (?sam&@(!ELTIT:?TIT !sam))
                         )
                      & ( !sam:
                        | !TIT::?TITLE
                        | str$("-" rev$!TIT):?TITLE
                        )
                    | 
                    )
                  & ( !TITLE
                    .   (!OLACTITLE:|!OLACTITLE " ")
                        !TITLE
                    )
              )
            & ( findOLACTITLEinPreviousSteps
              =     locJobs Uploads JobNr jobID files
                  , file TITLE prevTitle OLACTITLE
                .     !arg
                    : ( ?locJobs
                      . ?Uploads
                      . ?JobNr
                      . ?jobID
                      . ?prevTitle
                      . ?OLACTITLE
                      )
                  & (     !locJobs
                        : ? (!JobNr.!jobID ?.?files.?) ?
                      &   whl
                        ' ( !files:%?file ?files
                          & (     !Uploads
                                :   ?
                                    ( ?
                                    . ?
                                    . !file
                                    . ? (TITLE.?TITLE) ?
                                    . ?
                                    )
                                    ?
                              &     updateOLACTITLE
                                  $ (!TITLE.!prevTitle.!OLACTITLE)
                                : (?prevTitle.?OLACTITLE)
                            |     findOLACTITLEinPreviousSteps
                                $ ( !locJobs
                                  . !Uploads
                                  . !JobNr
                                  . !file
                                  . !prevTitle
                                  . !OLACTITLE
                                  )
                              : (?prevTitle.?OLACTITLE)
                            )
                          )
                    | 
                    )
                  & (!prevTitle.!OLACTITLE)
              )
            & :?toolURL
            &     map
                $ ( ( 
                    =   
                      .     !arg
                          : ( !JobNr
                            .   !jobID
                                ( ( 
                                  | starting
                                  | waiting
                                  | done
                                  )
                                : ?status
                                )
                            . ?files
                            . ?toolURL
                            . ?parms
                            . ?filename
                            )
                        & ( !status:done
                          |   ( !JobNr
                              . !jobID done
                              . !files
                              . !toolURL
                              . !parms
                              . !filename
                              )
                            : ?arg
                          )
                        & (   !CTBs
                            : ? (!JobNr.!jobID.!EMAIL.!CTBID) ?
                          |     (!CTBs|)
                                (!JobNr.!jobID.!EMAIL.!CTBID)
                            : ?CTBs
                          )
                        & :?prevTitle
                        &   whl
                          ' ( !files:%?file ?files
                            &     findOLACTITLEinPreviousSteps
                                $ ( !jobs
                                  . !Uploads
                                  . !JobNr
                                  . !file
                                  . !prevTitle
                                  . !OLACTITLE
                                  )
                              : (?prevTitle.?OLACTITLE)
                            & (     !CTBs
                                  : ? (!JobNr.!file.?ctb.?ctbid) ?
                                & ( NORELATIONSFILES
                                  |   ensureRelation
                                    $ ( !JobNr
                                      . !jobID
                                      . isDependentOf
                                      . !ctb
                                      . !ctbid
                                      )
                                  )
                                & ( !ITEMS:? !ctb "::" !ctbid ?
                                  |     !ITEMS
                                        (!ITEMS:|" ")
                                        !ctb
                                        "::"
                                        !ctbid
                                    : ?ITEMS
                                  )
                              | 
                              )
                            )
                        & (     !parms
                              : ?+(O.?+(facet.?facet.?)+?)+?
                            & (   readTable$subtype2facet
                                &   !subtype2facet
                                  : ? (?OUTPUTFACET.!facet) ?
                              |   readTable$type2facet
                                &   !type2facet
                                  : ? (?OUTPUTFACET.!facet) ?
                              |   !facets
                                : ? (?OUTPUTFACET.!facet.?) ?
                              )
                          | 
                          )
                        & (   !parms
                            : ?+(O.?+(lang.?LANGUAGE.?)+?)+?
                          | 
                          )
                        & !arg
                    )
                  . !jobs
                  )
              : ?jobs
            & (   !toolURL:
                &   !jobs
                  :   ?
                      (!JobNr.!jobID done.?.?toolURL.?.?)
                      ?
              | 
              )
            &   whl
              ' (   !jobs
                  :   ?A
                      ( !JobNr
                      . %@?jobid2 ?S
                      . ?a (!jobID,pending) ?z
                      . ?ZZ
                      )
                      ?Z
                &     !A
                      (!JobNr.!jobid2 !S.!a !jobID !z.!ZZ)
                      !Z
                  : ?jobs
                )
            & saveTable$CTBs
            & saveTable$jobs
            & (NOPPPES|saveTable$relations)
            & (     !SPANGRP
                  :   ?
                      ( TEI
                      .   ?
                        ,   ?
                            (teiHeader.,)
                            ?
                            (text.,?SPANGRPS)
                            ?
                      )
                      ?
                & "If a tool produces more than 1 spanGrp, it is obliged to wrap the spanGrps in another element. 
                   If the TEI doc has an empty teiHeader, it has the function of a wrapper."
              | :?SPANGRPS
              )
            & (   !SPANGRP:? (TEI.?) ?
                & !SPANGRPS:
              |   Filename$!SPANGRPfil:?SPANGRPfilWithMetadata
                &     tekstXML
                    $ ( !OLACTITLE|
                      . !DATE|
                      . !EMAIL
                      . !CTBID
                      . TBA
                      . AVAILABILITY
                      . !OUTPUTFACET
                      . XMLID
                      . str$!ITEMS
                      . !toolURL
                      .   !SPANGRPS:~
                        | !SPANGRP
                        | 
                      . !toolURL
                      . !LANGUAGE
                      )
                  : ?autogenerated
                &   put
                  $ (   str
                      $ ( toML
                        $ (   readTable$jobAbout
                            &   !jobAbout
                              :   ?
                                  ( !JobNr
                                  .   ?
                                      ( userProvidedMetadata
                                      . ?userProvidedMetadata
                                      )
                                      ?
                                  )
                                  ?
                            & (     !userProvidedMetadata
                                  : ?A (fpi.?) ?Z
                                & !A !Z:?userProvidedMetadata
                              | 
                              )
                            &   inject
                              $ (   (     !autogenerated
                                        :   ?
                                            ( TEI
                                            .   ?
                                              ,   ?
                                                  ( teiHeader
                                                  .     ?
                                                        (type.text)
                                                        ?
                                                    , ?
                                                  )
                                                  ?
                                            )
                                            ?
                                      & (fen.extent$!SPANGRP)
                                    | 
                                    )
                                    !userProvidedMetadata
                                . !autogenerated
                                . TEImetadata
                                )
                          | !autogenerated
                          )
                        )
                    , !SPANGRPfilWithMetadata
                    , NEW
                    )
                & !SPANGRPfilWithMetadata
              )
          | 
      )
      ( inputResources
      =   
        .   readTable$Uploads
          &   map
            $ ( ( 
                =   item TITLE
                  .       !Uploads
                        :   ?
                            ( ?
                            . ?item
                            . !arg
                            . ? (TITLE.?TITLE) ?
                            . ?
                            )
                            ?
                      & (item.,(id.,!item) (title.,!TITLE))
                    | 
                )
              . !arg
              )
      )
      ( toolName
      =   
        .   readTable$tooladm
          &   !tooladm
            :   ?
              + ( ? (ServiceURL.!arg) ?
                : ? (Title.?arg) ?
                )
              + ?
          & !arg
      )
      "
/**
 * abortJob
 *
 * Aborts, given a JobNr and a jobID, the specified job and all
 * pending jobs that depend on the output from the (now aborted) job.
 * Rather than removing the aborted jobs from the jobs.table list, they are
 * marked 'aborted'.
 *
 * Called from workflow.java
 */"
      ( abortJob
      =   abort JobNr jobID todelete
        .   readTable$jobs
          & log$("abortJob " !arg)
          & !arg:(@(?:? #?JobNr).?jobID)
          & (!JobNr.!jobID):?todelete
          & ( abort
            =     JobNr jobID jobid2 A Z ZZ a z
                , URL tool items todelete
              .   !arg:(?JobNr.?jobID) ?todelete
                & log$(abort !arg)
                &   !jobs
                  :   ?A
                      ( !JobNr
                      . !jobID ~aborted
                      .   ?items
                        & inputResources$!items:?items
                      . ?URL&toolName$!URL:?tool
                      . ?ZZ
                      )
                      ?Z
                & log$(going to abort !JobNr !jobID)
                &     !A
                      (!JobNr.!jobID aborted.!items.!URL.!ZZ)
                      !Z
                  : ?jobs
                & log$(aborted !JobNr !jobID)
                &   whl
                  ' (   !jobs
                      :   ?A
                          ( !JobNr
                          . %?jobid2 ?
                          . ?a (!jobID,pending) ?z
                          . ?URL&toolName$!URL:?tool
                          . ?ZZ
                          )
                          ?Z
                    & log$(depending !JobNr !jobid2)
                    &     !A
                          (!JobNr.!jobid2.!a !jobID !z.!URL.!ZZ)
                          !Z
                      : ?jobs
                    & (!JobNr.!jobid2) !todelete:?todelete
                    & log$(todelete !todelete)
                    )
                & log$(delete !todelete)
                & !todelete
            )
          &   whl
            ' ( log$(iterDO !todelete)
              & abort$!todelete:?todelete
              )
          & saveTable$jobs
      )
      ( deleteDepending
      =   jobNr jobID
        .   !arg:(?jobNr.?jobID)
          & !( 
             ' (     map
                   $ ( ( 
                       =   
                         .   !arg:($jobNr.$jobID.?)
                           | 
                       )
                     . $CTBs
                     )
                 : ?CTBs
               & ( NORELATIONSFILES
                 |     map
                     $ ( ( 
                         =   
                           .   !arg:($jobNr.$jobID.?)
                             | 
                         )
                       . $relations
                       )
                   : ?relations
                 )
               &     map
                   $ ( ( 
                       = .!arg:($jobNr.?)|
                       )
                     . $jobAbout
                     )
                 : ?jobAbout
               )
             )
      )
      ( addurl
      =   URL
        .     !arg:(?arg.?URL)
            & !URL:
            & !arg
          |   ( @(!URL:http ?)
              | str$("http://" !URL):?URL
              )
            & (a.(href.!URL),!arg)
      )
      ( jobMetaData
      =     userProvidedMetadata Metadata Heading Fields
          , listOfFields Val XPath HTML workflow
          , ID TextInUI Required Control Place
          , Notes HelpText Pattern URL type
        .     readTable$jobAbout
            & (     !jobAbout
                  :   ?
                      ( !arg
                      .   ? (human.?workflow) ?
                        :   ?
                            (userProvidedMetadata.?userProvidedMetadata)
                            ?
                      )
                      ?
                & readTable$TEImetadata:?Metadata
                &   ( !userProvidedMetadata:&TEI
                    | UserProvided
                    )
                  : ?type
                & ( XPath
                  =   el at
                    .     !arg:%?el ?arg
                        & (   !el:(?el.?at)
                            & "/" !el "/@" !at
                          | "/" !el XPath$!arg
                          )
                      | 
                  )
                & ( listOfFields
                  =   
                    .   map
                      $ ( ( 
                          =   
                            .     !arg
                                : ( ?ID
                                  . ?TextInUI
                                  . ?Required
                                  . ?Control
                                  . ?Place
                                  . ?Notes
                                  . ?HelpText
                                  . ?Pattern
                                  . ?URL
                                  )
                              & (     !userProvidedMetadata
                                    : ? (!ID.?Val) ?
                                  &   ( dt
                                      .   
                                        ,   addurl
                                          $ (localized$!TextInUI.!URL)
                                      )
                                      (dd.,"XPath: " XPath$!Place)
                                      ( dd
                                      .   
                                        ,   localized$(Value V√¶rdi)
                                            ": "
                                            ( strong
                                            .   
                                              ,   !Val:~
                                                | " "
                                            )
                                      )
                                | 
                                )
                          )
                        . !arg
                        )
                  )
                & (   map
                    $ ( ( 
                        =   Heading Fields L
                          .     !arg:(?Heading,?Fields)
                              & listOfFields$!Fields:~:?L
                              &   (h2.,localized$!Heading)
                                  (dl.,!L)
                            | 
                        )
                      . !Metadata
                      )
                  . !type
                  )
              | (.)
              )
          | (.)
      )
      ( letterData
      =     Steps menneskesprog workflow JobNr I O
          , aborted done filelist filename items JobId URL tool
        .   ( menneskesprog
            =     desc featdesc feature featvals featname
                , table specificationTables features
              .   !arg:(?arg.?features)
                & :?desc
                &   whl
                  ' ( !arg:(?feature.?featvals.?)+?arg
                    &   !features
                      :   ?
                        + ( ? (short.!feature) ?
                          : ? (name.?featname) ?
                          : ? (table.?table) ?
                          : (   ?
                                (specificationTable.?specificationTables)
                                ?
                            | ?&:?specificationTables
                            )
                          )
                        + ?
                    &     describefeature
                        $ (!featvals.!table.!specificationTables)
                      : ?featdesc
                    & ( !featdesc:
                      |     !desc
                            (!desc:|", ")
                            localized$!featname
                            "="
                            !featdesc
                        : ?desc
                      )
                    )
                & str$!desc
            )
          & ( Steps
            =     x items tool JobNr JobId
                , format I O format stage
              .       !arg
                    : ( ?JobNr
                      . @(?:? #?JobId)
                      . ?x
                      . ?items
                      . ?tool
                      . ?I
                      . ?O
                      . ?stage
                      )
                  & ( step
                    .   
                      ,   (JobNr.,!JobNr)
                          (JobId.,!JobId)
                          (name.,!x)
                          (tool.,!tool)
                          (items.,!items)
                          (input.,menneskesprog$(!I.!features))
                          (output.,menneskesprog$(!O.!features))
                          ( format
                          .   
                            ,     !O:?+(format.?format.?)+?
                                & !format
                              | 
                          )
                          (stage.,!stage)
                    )
                | 
            )
          & readTable$features
          & readTable$jobAbout
          & (   !jobAbout
              : ? (!JobNr.? (human.?workflow) ?) ?
            | :?workflow
            )
          & !arg:?JobNr
          & readTable$jobs
          & :?filelist
          &   whl
            ' ( :?aborted:?done
              &   !jobs
                :   ?
                    ( !JobNr
                    .   %@?JobId
                        (   aborted:?aborted
                          & :?done
                        |   done:?done
                          & :?aborted
                        |   ( 
                            | starting
                            | waiting
                            )
                          & :?aborted:?done
                        )
                    .   ?items
                      & inputResources$!items:?items
                    . ?URL&toolName$!URL:?tool
                    .   ?+(I.?I)+?:?+(O.?O)+?
                      | ?&:?I:?O
                    . ?filename
                    )
                    ?jobs
              &     !filelist
                    ( !JobNr
                    . !JobId
                    .   !aborted:aborted&fejl
                      | !filename
                    . !items
                    . !tool
                    . !I
                    . !O
                    .     ( !aborted:aborted
                          |   !jobs
                            : ? (!JobNr.?.? !JobId ?.?) ?
                          )
                        & 
                      | LAST
                    )
                : ?filelist
              )
          &   (workflow.,!workflow)
              (steps.,map$(Steps.!filelist))
      )
      ( doneAllJobSub
      =   JobNr
        .   readTable$jobs
          & log$("doneAllJobSub " !arg)
          & @(!arg:? #?JobNr)
          & readTable$CTBs
          & (NORELATIONSFILES|readTable$relations)
          & readTable$jobAbout
          &     map
              $ ( ( 
                  =   JobId
                    .     !arg:(!JobNr.%@?JobId ?.?.?.?.?)
                        & deleteDepending$(!JobNr.!JobId)
                        & 
                      | !arg
                  )
                . !jobs
                )
            : ?jobs
          & saveTable$jobs
          & saveTable$CTBs
          & (NORELATIONSFILES|saveTable$relations)
          & saveTable$jobAbout
      )
      (FilenameNoMetadata=.!arg)
      ( NORELATIONSFILES
      | (FilenameRelations=.str$(!arg ".relations.csv"))
      )
      ( readme
      =     jobNr date yyyy mm dd letter File Files
          , inputs results
        .     !arg
            : ( ?jobNr
              . @( ?date
                 :   (% % % %:?yyyy)
                     (% %:?mm)
                     (% %:?dd)
                 )
              . ?letter
              )
          & readTable$Uploads
          & :?Files:?inputs:?results
          &   whl
            ' ( @(!letter:? "file:" ?File ";" ?letter)
              & (@(!File:? "*" ?File)|)
              &     !Files
                    "    "
                    !File
                    (   !Uploads:? (?.!File.?) ?
                      & !inputs !File ",\r\n  ":?inputs
                      & " (input)"
                    |   @(!File:? ".xml")
                      & !results !File ",\r\n  ":?results
                      & 
                    | 
                    )
                    \r\n
                : ?Files
              )
          &   str
            $ ( README
                \r\n
                !yyyy
                "."
                !mm
                "."
                !dd
                \r\n\r\n
                "job "
                !jobNr
                \r\n\r\n
                "zip-filen ("
                !jobNr
                ".zip) indeholder:"
                \r\n
                ( !inputs:
                |   "- "
                    !inputs
                    "som er "
                    ( !inputs:@ @&inputfilen
                    | inputfilerne
                    )
                    \r\n\r\n
                )
                ( !results:
                |   "- "
                    !results
                    "som er "
                    ( !results:@ @&resultatet
                    | resultater
                    )
                    ", dvs. "
                    ( !results:@ @&inputteksten
                    | inputtekst
                    )
                    " klargjort til deponering."
                    \r\n
                    "  "
                    ( !results:@ @&"Denne fil"
                    | "Disse filer"
                    )
                    " kan deponeres i CLARIN.DK‚Äôs repositorie eller bruges som input"
                    \r\n
                    "  til annotering vha. CLARIN.DK‚Äôs v√¶rkt√∏jer."
                    \r\n\r\n
                )
                "- index.html som indeholder detaljer om klarg√∏ringsprocessen, herunder de"
                \r\n
                "  metadata der blev angivet i interfacet samt beskrivelser af de anvendte"
                \r\n
                "  v√¶rkt√∏jer."
                \r\n\r\n
                (   !inputs:
                  &   "- CMDI.xml som er CMDI metadatafilen som kan uploades sammen med din dataresurse."
                      \r\n\r\n
                |   "- resten er filerne er mellemtrin som du kan se bort fra hvis processen er"
                    \r\n
                    "  forl√∏bet korrekt. Hvis der er fejl i den klargjorte tekst, er det sikrest"
                    \r\n
                    "  at rette i et af mellemtrinnene og uploade denne fil til klarg√∏ring igen."
                    \r\n
                    "  Det er ikke tilr√•deligt at rette i tekstdelen i "
                    ( !results:@ @&filen
                    | filerne
                    )
                    "\r\n  "
                    !results
                    "da hvert enkelt ord er unik nummereret hvilket er kr√¶vet i den videre"
                    \r\n
                    "  lingvistiske processering. Metadataene kan man dog rolig rette i."
                    \r\n\r\n
                    "  Filerne er genereret i f√∏lgende r√¶kkef√∏lge:"
                    \r\n
                    !Files
                )
                \r\n\r\n
                "Hvis du har brug for hj√¶lp til at deponere dine data eller har andre sp√∏rgsm√•l"
                \r\n
                "er du velkommen til at henvende dig til info@clarin.dk"
                \r\n
              )
      )
      ( letter
      =     workflow steps resources files inps Steps html
          , metadata explain type shortletter
        .   ( inps
            =   a
              .     !arg:%?a ?arg
                  &   (a.(href.!a),!a)
                      (br.,)
                      inps$!arg
                | 
            )
          & ( explain
            =   explanation
              .     !fileFormats:? (?.!arg.?explanation) ?
                  & !explanation:~
                  & " (" localized$!explanation ") "
                | 
            )
          & ( Steps
            =     body JobNr JobId filename tool
                , items I O format id title fil
                , Href2 Href2nometa Href2relations
                , stage steps shortletter type
              .   !arg:(?steps.?shortletter.?type)
                &     map
                    $ ( ( 
                        =   relationsfil
                          .     !arg
                              : ( step
                                .   
                                  ,   (JobNr.,?JobNr)
                                      (JobId.,?JobId)
                                      (name.,?filename)
                                      (tool.,?tool)
                                      (items.,?items)
                                      (input.,?I)
                                      (output.,?O)
                                      (format.,?format)
                                      (stage.,?stage)
                                )
                            &   whl
                              ' (   !items
                                  :   ( item
                                      .   
                                        ,   ? (id.,?id) ?
                                          : ? (title.,?title) ?
                                      )
                                      ?items
                                & ( !resources:? !title ?
                                  |   !resources !title:?resources
                                    & (     !Uploads
                                          : ? (?.!title.?fil.?) ?
                                        & ( !shortletter:y
                                          |     !files
                                                "file:"
                                                !fil
                                                "*"
                                                !title
                                                ";"
                                            : ?files
                                          )
                                      | 
                                      )
                                  )
                                )
                            & (   @(!filename:fejl ?)
                                & log$fejl
                                &   ( h2
                                    .   
                                      ,   localized
                                        $ ( "The following step(s) failed:"
                                            "F√∏lgende trin fejlede:"
                                          )
                                    )
                                    ( dl
                                    .   
                                      ,   ( dt
                                          .   
                                            , ( strong
                                              .   
                                                ,   str
                                                  $ (   localized
                                                      $ ("Step " "Trin ")
                                                      !JobId
                                                    )
                                              )
                                          )
                                          (dd.,!tool)
                                    )
                              |   ( !shortletter:~y
                                  | !stage:LAST
                                  )
                                &   ( !type:TEI&
                                    | Filename$!filename
                                    )
                                  : ?Href2
                                &   FilenameNoMetadata$!filename
                                  : ?Href2nometa
                                & ( NORELATIONSFILES
                                  |     FilenameRelations$!filename
                                      : ?Href2relations
                                    &   RelationsFile$!filename
                                      : ?relationsfil
                                  )
                                &   ( dt
                                    .   
                                      , ( strong
                                        .   
                                          ,   str
                                            $ ( localized$("Step " "Trin ")
                                                !JobId
                                                (   !shortletter:y
                                                  & 
                                                |   !stage:LAST
                                                  &   localized
                                                    $ (" (last)" " (sidste)")
                                                | 
                                                )
                                              )
                                        )
                                    )
                                    ( dd
                                    .   
                                      ,   (   ( @(!O:? TEI ?)
                                              | !Href2:~
                                              )
                                            & (     !format
                                                  : ( txtbasis
                                                    | teip5
                                                    )
                                                & !type:TEI
                                                &     !files
                                                      "file:"
                                                      ( 
                                                      | NORELATIONSFILES
                                                      |   !Href2relations
                                                          ";file:"
                                                      )
                                                      !Href2nometa
                                                      ";"
                                                  : ?files
                                                &   str$(!tool ": ")
                                                    ( 
                                                    | NORELATIONSFILES
                                                    |   ( a
                                                        .   ( href
                                                            . !Href2relations
                                                            )
                                                          , !relationsfil
                                                        )
                                                        ", "
                                                    )
                                                    ( a
                                                    .   (href.!Href2nometa)
                                                      ,   localized
                                                        $ ( "with original metadata"
                                                            "med oprindelig metadata"
                                                          )
                                                    )
                                              |     !format
                                                  : ( txtann
                                                    | txtbasis
                                                    | teip5
                                                    )
                                                &     !files
                                                      "file:"
                                                      ( !Href2:
                                                      | !Href2 ";file:"
                                                      )
                                                      ( 
                                                      | NORELATIONSFILES
                                                      |   !Href2relations
                                                          ";file:"
                                                      )
                                                      !Href2nometa
                                                      ";"
                                                  : ?files
                                                &   str$(!tool ": ")
                                                    ( !Href2:
                                                    |   ( a
                                                        .   (href.!Href2)
                                                          ,   localized
                                                            $ ( "including metadata"
                                                                "inklusiv metadata"
                                                              )
                                                        )
                                                        ","
                                                    )
                                                    ( 
                                                    | NORELATIONSFILES
                                                    |   ( a
                                                        .   ( href
                                                            . !Href2relations
                                                            )
                                                          , !relationsfil
                                                        )
                                                        ", "
                                                    )
                                                    ( a
                                                    .   (href.!Href2nometa)
                                                      ,   localized
                                                        $ ( "without metadata"
                                                            "uden metadata"
                                                          )
                                                    )
                                              | !Href2:
                                              |       !files
                                                      "file:"
                                                      !Href2
                                                      "*"
                                                      !filename
                                                      ";"
                                                  : ?files
                                                &   str$(!tool ": ")
                                                    ( a
                                                    .   (href.!filename)
                                                      , basistekst
                                                    )
                                                    explain$!format
                                              )
                                          |       !files
                                                  "file:"
                                                  !Href2nometa
                                                  "*"
                                                  !filename
                                                  ";"
                                              : ?files
                                            &   str$(!tool ": ")
                                                ( a
                                                .   (href.!filename)
                                                  , data
                                                )
                                                explain$!format
                                          )
                                          ( !I:!O:
                                          | ( dl
                                            .   
                                              ,   ( !I:
                                                  |   (dt.,Input)
                                                      (dd.,!I)
                                                  )
                                                  ( !O:
                                                  |   (dt.,Output)
                                                      (dd.,!O)
                                                  )
                                            )
                                          )
                                    )
                              | 
                              )
                        )
                      . !steps
                      )
                  : ?body
                & (dl.,!body)
            )
          & !arg:(?arg.?shortletter)
          & "shortletter: y or n"
          &   ( 
              =   zippedresults zipfile
                .   ( readTable$zippedresults
                    | :?zippedresults
                    )
                  &     str
                      $ ( !arg
                          ( !shortletter:y&"-final"
                          | "-all"
                          )
                          ".zip"
                        )
                    : ?zipfile
                  & ( !zippedresults:? !zipfile ?
                    | !zipfile !zippedresults:?zippedresults
                    )
                  & saveTable$zippedresults
              )
            $ !arg
          & jobMetaData$!arg:(?metadata.?type)
          & "type == () | TEI | UserProvided"
          & readTable$fileFormats
          & readTable$Uploads
          &   (letterData$!arg|doneAllJobSub$!arg)
            : (workflow.,?workflow) (steps.,?steps)
          & :?resources:?files
          &     toML
              $ ( html
                .   
                  ,   ( head
                      .   
                        ,   (meta.charset.UTF-8)
                            ( title
                            .   
                              ,   localized
                                $ ( "Results from CLARIN-DK tools"
                                    "Resultater fra Tools"
                                  )
                            )
                            !Style
                      )
                      ( body
                      .   (class.bodycanvas)
                        , ( div
                          .   (class.canvasdiv)
                            ,   (h1.,localized$(Results Resultater))
                                (h2.,Workflow)
                                (p.,!workflow)
                                (h2.,localized$(Steps Trin))
                                (dl.,Steps$(!steps.!shortletter.!type))
                                ( !shortletter:y&
                                |   ( h2
                                    .   
                                      ,   localized
                                        $ ( "Input to the workflow:"
                                            "Workflowets input:"
                                          )
                                    )
                                    (p.,inps$!resources)
                                )
                                !metadata
                          )
                      )
                )
            : ?html
          & str$(!files !html)
      )
      ( poll
      =     n step secs steplinks links
          , serviceurl title DOWNLOAD
          , runningParagraphs JobNr hours minutes
        .   ( steplinks
            =     links locJobs file step outp ServiceURL JobNr
                , seenInputs Title
              .   !arg:(?JobNr.?locJobs)
                & log$steplinks
                & log$(JobNr !JobNr)
                & !( 
                   ' ( $locJobs
                     :   ?
                         (   ($JobNr.step1 ?.?file.?.?.?outp)
                             ?
                         : ?locJobs
                         )
                     )
                   )
                & :?seenInputs
                &     map
                    $ ( ( 
                        =   files status
                          .     !arg:(!JobNr.?status.?files.?.?.?)
                              & log$(status !status files !files)
                              &   map
                                $ ( ( 
                                    =   
                                      .     !( 
                                             ' ( $Uploads
                                               : ? (?.?.$arg.?) ?
                                               )
                                             )
                                          & log$(FOUNDinUploads !arg)
                                          & (   !seenInputs:? !arg ?
                                              & log$seen
                                              & 
                                            |     !arg !seenInputs
                                                : ?seenInputs
                                              &   log
                                                $ (seenInputs !seenInputs)
                                              &   paragraph
                                                $ ( "input:"
                                                    ( a
                                                    .   ( href
                                                        .   str
                                                          $ ( !wwwServer
                                                              "/texton/data/"
                                                              !arg
                                                            )
                                                        )
                                                      , !arg
                                                    )
                                                  )
                                            )
                                        |   log$(NOTfoundInUploads !arg)
                                          & 
                                    )
                                  . !files
                                  )
                            | 
                        )
                      . !locJobs
                      )
                  : ?links
                &   whl
                  ' (   !locJobs
                      :   ?
                          (!JobNr.?step done.?.?ServiceURL.?.?file)
                          ?locJobs
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!ServiceURL) ?
                          : ? (Title.?Title) ?
                          )
                        + ?
                    &     !links
                            paragraph
                          $ ( str$(!step ":")
                              ( a
                              .   ( href
                                  . str$(!wwwServer "/texton/data/" !file)
                                  )
                                , !file
                              )
                              " ("
                              !Title
                              ")"
                            )
                      : ?links
                    )
                & ( !links:% %
                  | !locJobs:? (!JobNr.?) ?
                  |     !links
                          paragraph
                        $ ( "output:"
                            ( a
                            .   ( href
                                . str$(!wwwServer "/texton/data/" !file)
                                )
                              , !outp
                            )
                          )
                    : ?links
                  )
                & !links
            )
          & ( !arg:(?JobNr.?secs)
            | @(!arg:? #?JobNr)&5:?secs
            )
          & ( ~
            |   readTable$jobs
              & "Without reading jobs from file the shown list is sometimes incomplete. But why?"
            | readTable$tooladm&readTable$Uploads
            )
          &   div$(!deleteAfterMillisec*86400000^-1*24*60.1)
            : ?minutes
          &   toML
            $ (   steplinks$(!JobNr.!jobs):?links
                &     ( 
                      =   locJobs n JobNr
                        .   0:?n
                          & !arg:(?locJobs.?JobNr)
                          &   whl
                            ' (   !locJobs
                                : ? (!JobNr.?) ?locJobs
                              & 1+!n:?n
                              )
                          & !n
                      )
                    $ (!jobs.!JobNr)
                  : ?n
                &     map
                    $ ( ( 
                        =   serviceurl title step
                          .       !arg
                                : ( !JobNr
                                  .   %@?step
                                      ( 
                                      | starting
                                      | waiting
                                      )
                                  . ~(? (?,pending) ?)
                                  . ?serviceurl
                                  . ?
                                  . ?
                                  )
                              &   !tooladm
                                :   ?
                                  + ( ? (ServiceURL.!serviceurl) ?
                                    : ? (Title.?title) ?
                                    )
                                  + ?
                              &   paragraph
                                $ (   localized
                                    $ ( "Currently running "
                                        "I √∏jeblikket k√∏rer "
                                      )
                                    !step
                                    " "
                                    localized$(of af)
                                    " "
                                    !n
                                    " ("
                                    !title
                                    ")"
                                  )
                            | 
                        )
                      . !jobs
                      )
                  : ?runningParagraphs
                & ( DOWNLOAD
                  =   
                    .   ( a
                        .   ( href
                            .   !wwwServer
                                "/texton/zipresults?shortletter=n&amp;JobNr="
                                !arg
                            )
                          ,   localized
                            $ ( "Download input and all results"
                                "Download input og alle resultater"
                              )
                        )
                        localized$(" OR " " ELLER ")
                        ( a
                        .   ( href
                            .   !wwwServer
                                "/texton/zipresults?shortletter=y&amp;JobNr="
                                !arg
                            )
                          ,   localized
                            $ ("Download final results" "Download slutresultater")
                        )
                  )
                & (   !runningParagraphs:
                    &   !HTMLbodyContainer
                      $ ( div
                        .   (class.canvasdiv)
                          ,   ( h1
                              .   (class.smallmargin)
                                , localized$("Done! " "F√¶rdig! ")
                              )
                              paragraph$(DOWNLOAD$!JobNr)
                              !links
                                paragraph
                              $ ( (br.,)
                                    localized
                                  $ ( "To download the results, see the links at the top of this page."
                                      "Se links √∏verst p√• denne side hvis du vil downloade resultaterne."
                                    )
                                  (br.,)
                                    localized
                                  $ ( "Click the following link to immediately DELETE your input and the results from the workflow from the server. "
                                      "Tryk p√• n√¶ste link for at fjerne din input og arbejdsgangens resultater fra serveren. "
                                    )
                                  ( a
                                  .   ( href
                                      .   !wwwServer
                                          "/texton/cleanup?JobNr="
                                          !JobNr
                                      )
                                    ,   localized
                                      $ ( "DELETE input and results from server"
                                          "FJERN input og resultaterne fra serveren"
                                        )
                                  )
                                )
                        )
                  |   refreshingXHTMLbodyContainer
                    $ ( !secs str$(!wwwServer "/texton/mypoll?job=" !JobNr)
                      . div
                      .   (class.canvasdiv)
                        ,   ( h1
                            .   (class.smallmargin)
                              , localized$("Running... " "K√∏rer... ")
                            )
                              paragraph
                            $ ( str
                              $ (   localized
                                  $ ( "Reload this page to track the status of your job. Or wait. This page auto-reloads after "
                                      "Genindl√¶s denne side hvis du vil f√∏lge status p√• arbejdsgangen. Eller vent. Siden genindl√¶ses automatisk efter "
                                    )
                                  !secs
                                  localized$(" seconds." " sekunder.")
                                )
                              )
                            !links
                            !runningParagraphs
                      )
                  )
              |   !HTMLbodyContainer
                $ (     ( 
                        =   zippedresults zipfile
                          .   readTable$zippedresults
                            &     str
                                $ (!arg ("-all"|"-final") ".zip")
                              : ?zipfile
                            & !zippedresults:? !zipfile ?
                        )
                      $ !JobNr
                    &   paragraph
                      $ ( DOWNLOAD$!JobNr
                            localized
                          $ (   str
                              $ ( " The zipped results are kept for no more than "
                                  !minutes
                                  " minutes! "
                                )
                                str
                              $ ( " De zippede resultater bliver bevaret is h√∏jst "
                                  !minutes
                                  " minutter!"
                                )
                            )
                        )
                  |   paragraph
                    $ ( localized
                      $ (   str
                          $ ( "The results have been deleted after "
                              !hours
                              " hours. "
                            )
                            str
                          $ ( "Resultaterne er blevet slettet efter "
                              !hours
                              " timer. "
                            )
                        )
                      )
                  )
              )
      )
      ( setLanguageNotPermanently
      =   
        .   ( !arg:? (UIlanguage.?arg) ?
            |   "reset to default"
              & readTable$UIlanguage:%?arg ?
            )
          & setLang$!arg
      )
      ( setTypefaceNotPermanently
      =   
        .   ( !arg:? (TyPeFaCe.?arg) ?
            |   "reset to default"
              & readTable$Typeface:%?arg ?
            )
          & setTypeFace$!arg
      )
      ( buildItemList
      =   item
        .   map
          $ ( ( 
              =   item
                .     !arg:(item|Item.?item)
                    & (@(!item:\" ?item \")|)
                    & (Item.get$(!item,X ML,MEM))
                  | 
              )
            . !arg
            )
      )
      ( buildItemListFromForeignData
      =     A Z N name Items FieldName nofonts
          , Name ContentType Size feats
          , DestinationDir LocalFileName
          , language date analyseContentType
        .   ( analyseContentType
            =     R spec nofonts ct DestinationDir LocalFileName
                , isDiplom input getInput isTabSeparated
              .     !arg
                  : (?arg.?nofonts.?DestinationDir.?LocalFileName)
                & @( !arg
                   : ((%? "/" %?:?ct) ";" ?|?ct)
                   )
                & ( getInput
                  = .@(get$(str$(!DestinationDir !LocalFileName),STR))
                  )
                & ( isDiplom
                  =   N lang input
                    .   0:?lang
                      & !arg:?input
                      &     vap
                          $ ( ( 
                              =   N la
                                .     vap$((=.!arg).!arg."|")
                                    : ? [?N
                                    : (   ( %@
                                          : @( ?
                                             :   ?
                                                 (L|l)
                                                 anguage
                                                 ?
                                             )
                                          )
                                          ( %@
                                          : @( ?
                                             :   ?
                                                 ( (   (   (D|d)
                                                           an
                                                       |   (L|l)
                                                           at
                                                       | mlg
                                                       | swe
                                                       )
                                                     : ?la
                                                   |   Svensk
                                                     & swe:?la
                                                   )
                                                 &   low$!la+!lang
                                                   : ?lang
                                                 )
                                                 ?
                                             )
                                          )
                                      | ?
                                      )
                                  & !N
                              )
                            . !input
                            . \n
                            )
                        : ? (~<17:?N) !N !N ?
                      &   (app.unn)
                          (facet.tok)
                          (format.dipl)
                          (   !lang:#*%@?lang
                            & ( lang
                              .   !lang:lat&la
                                | !lang:dan&da
                                | !lang:mlg&gml
                                | !lang:swe&sv
                              )
                          | 
                          )
                          (period.c13)
                          (pres.nml)
                  )
                & ( isTabSeparated
                  =   L H e empty
                    .   :?e
                      & (   @(!arg:? \t ? \n ? \t ? \n ?)
                          & -1:?L:?H
                          &   vap
                            $ ( ( 
                                =   K
                                  .     vap$((=..).!arg.\t)
                                      : ? [?K
                                    & (   !K:1
                                        & trim$!arg:
                                        & e:?e
                                      |   !e:?empty
                                        & (   !L:-1
                                            & !K:?L
                                          | !K:<!L:?L
                                          | 
                                          )
                                        & (   !H:-1
                                            & !K:?H
                                          | !K:>!H:?H
                                          | 
                                          )
                                      )
                                )
                              . !arg
                              . \n
                              )
                          & !L:!H
                          & (4:<!L:?L|)
                          & (format.str$(!L col !empty))
                        |     vap$((=.trim$!arg).!arg.\n)
                            : ~(? @(?:? " " ?) ?)
                            : ?L
                          & ( !L:% %&(format.1col)
                            |   @(!L:"https://alf.hum.ku.dk/korp" ?)
                              & (facet.kwic) (format.url)
                            | (facet.txt) (format.flat)
                            )
                        )
                  )
                &   !ct
                  : (   application/pdf
                      &     (   !nofonts:true
                              & (app.rom)
                            | (app.nrm)
                            )
                            (facet.txt)
                            ( format
                            .     !nofonts:true
                                & img^pdf
                              | pdf
                            )
                        : ?R
                    |   "application/vnd.ms-powerpoint"
                      &     (app.nrm)
                            (facet.txt)
                            (format.ppt)
                        : ?R
                    |   "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                      &     (app.nrm)
                            (facet.txt)
                            (format.pptx)
                        : ?R
                    |   "application/vnd.oasis.opendocument.presentation"
                      &     (app.nrm)
                            (facet.txt)
                            (format.odp)
                        : ?R
                    |   "application/vnd.ms-excel"
                      &     (app.nrm)
                            (facet.txt)
                            (format.xls)
                        : ?R
                    |   "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                      &     (app.nrm)
                            (facet.txt)
                            (format.xlsx)
                        : ?R
                    |   "application/vnd.oasis.opendocument.spreadsheet"
                      &     (app.nrm)
                            (facet.txt)
                            (format.ods)
                        : ?R
                    |   ( application/x-download
                        | application/octet-stream
                        )
                      & getInput$:?input
                      & ( @( !input
                           : ( ("%PDF" ?|"%pdf" ?)
                             &     (   !nofonts:true
                                     & (app.rom)
                                   | (app.nrm)
                                   )
                                   (facet.txt)
                                   ( format
                                   .     !nofonts:true
                                       & img^pdf
                                     | pdf
                                   )
                               : ?R
                             )
                           )
                        | isDiplom$!input:?R
                        | isTabSeparated$!input:?R
                        | :?R
                        )
                    |   application/msword
                      & @( get$(str$(!DestinationDir !LocalFileName),STR)
                         : (   ? rtf [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.rtf)
                               : ?R
                           |   ? xml [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.xml)
                               : ?R
                           |   PK ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.docx)
                               : ?R
                           |   ? [<9
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.doc)
                               : ?R
                           |   ?
                             & (app.nrm) (facet.txt):?R
                           )
                         )
                    |   "application/vnd.oasis.opendocument.text"
                      & @( get$(str$(!DestinationDir !LocalFileName),STR)
                         : (   PK ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.odt)
                               : ?R
                           |   ?
                             & (app.nrm) (facet.txt):?R
                           )
                         )
                    |   application/octet-stream
                      & @( get$(str$(!DestinationDir !LocalFileName),STR)
                         : (   ? rtf [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.rtf)
                               : ?R
                           |   ? xml [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.xml)
                               : ?R
                           |   ?
                             & (app.nrm) (facet.txt):?R
                           )
                         )
                    |   "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                      &     (app.nrm)
                            (facet.txt)
                            (format.docx)
                        : ?R
                    |   application/json
                      & (format.json) (app.drty):?R
                    |   text/html
                      &     (app.nrm)
                            (facet.txt)
                            (format.html)
                        : ?R
                    |   text/rtf
                      &     (app.nrm)
                            (facet.txt)
                            (format.rtf)
                        : ?R
                    |   text/plain
                      & getInput$:?input
                      &   ( isDiplom$!input
                          | isTabSeparated$!input
                          |   (app.nrm)
                              (facet.txt)
                              (format.flat)
                          )
                        : ?R
                    | text/x-conll&(format.flat):?R
                    |   @( ?
                         :   image/
                             (   ( gif
                                 | jpeg
                                 | pjpeg
                                 | png
                                 | tiff
                                 | "vnd.microsoft.icon"
                                 )
                               : ?spec
                             | "svg+xml"&svg:?spec
                             )
                         )
                      &     (app.rom)
                            (facet.txt)
                            (format.img^!spec)
                        : ?R
                    |   @( ?
                         :   audio/
                             ( ( basic
                               | L24
                               | mp4
                               | mpeg
                               | ogg
                               | vorbis
                               | "vnd.rn-realaudio"
                               | "vnd.wave"
                               | webm
                               )
                             : ?spec
                             )
                         )
                      & (format.snd^!spec):?R
                    |   @( ?
                         :   video/
                             ( ( mpeg
                               | mp4
                               | ogg
                               | quicktime
                               | webm
                               | x-matroska
                               | x-ms-wmv
                               | x-flv
                               )
                             : ?spec
                             )
                         )
                      & (format.vid^!spec):?R
                    |   text/xml
                      & (       get
                              $ ( str$(!DestinationDir !LocalFileName)
                                , X ML
                                , TRM
                                )
                            : ? (TEI.?) ?
                          &     (app.nrm)
                                (facet.txt)
                                (format.teip5)
                            : ?R
                        | (format.xm):?R
                        )
                    | :?R
                    )
                & (   !R
                    : ? (format.json|dipl) ?
                  | !R (ambig.una):?R
                  )
                & !R
            )
          & :?Items
          &   (   !arg:? (language.?language) ?
                & readTable$linguae
                & !linguae:? (?.!language.?) ?
                & (lang.!language)
              | 
              )
            : ?language
          & ( !arg:? (DATE.?date) ?
            | :?date
            )
          &   whl
            ' ( !arg
              :   ?
                  ( ( FieldName,?FieldName
                    . Name,?Name
                    . ContentType,%?ContentType ?nofonts
                    . Size,?Size
                    . DestinationDir,?DestinationDir
                    . LocalFileName,?LocalFileName
                    )
                  &     analyseContentType
                      $ (!ContentType.!nofonts.!DestinationDir.!LocalFileName)
                    : ?feats
                  &   !Uploads
                    : ?A (?N.?name.!LocalFileName.?.?) ?Z
                  &     !A
                        ( !N
                        . !name
                        . !LocalFileName
                        . (TITLE.!name) (DATE.!date)
                        . !language !feats
                        )
                        !Z
                    : ?Uploads
                  &   !Items (Item.str$(removePercentEncodings$!name))
                    : ?Items
                  )
                  ?arg
              )
          & saveTable$Uploads
          & !Items
      )
      ( analyzeInput
      =     item feats Items item
          , parms presels n val
          , retrieveFeatures errors
        .   !arg:(?parms.?Items.?errors)
          & readTable$features
          & ( retrieveFeatures
            =   Items item feats n val presels errors
              .   !arg:(?Items.?errors)
                & :?presels
                &   whl
                  ' ( !Items:(Item.%?item ?feats) ?Items
                    & (   !feats:
                        & itemFeats$!item:?feats
                      |   !errors:
                        &     str
                            $ ( 404~~~
                                  toML
                                $ ( !BodyContainer
                                  $ ( paragraph
                                    $ (str$("Item " !item " not found"))
                                    )
                                  )
                              )
                          : ?errors
                      | 
                      )
                    &   whl
                      ' ( !feats:(?n.?val) ?feats
                        & getShort$(!n.!val):?val
                        & !presels (!n.!val.!item):?presels
                        )
                    )
                & (!presels.!errors)
            )
          & retrieveFeatures$(!Items.!errors):(?presels.?errors)
          & (!Items.!presels.!errors)
      )
      ( initialiseSpecifyGoalShowWorkflowsChosenWorkflow
      =     itms errors hiddenData
          , Items tabind Tool parms BodyContainer
        .   startclock$
          & :?errors:?hiddenData:?Items
          & 0:?tabind
          & ?:?Tool
          & !arg:?parms
          & ( !parms:? (itms.?itms) ?
            | 1:?itms
            )
          & readTable$ItemGroupsCache
          &     map
              $ ( ( 
                  =   a v nt CLOCK wfs items
                    .     !arg:(@(?:?a ";" ?nt).?v)
                        & ( !nt:!itms&(!a.!v)
                          | 
                          )
                      |       ( !arg:(Item|itms.?)
                              |   !arg:(CLOCK.?CLOCK)
                                &   !ItemGroupsCache
                                  :   ?
                                      ( !CLOCK
                                      . ? (!itms.?items.?wfs) ?
                                      )
                                      ?
                                &   map$((=.Item.!arg).!items)
                                  : ?Items
                                & !arg
                              | 
                              )
                              !hiddenData
                          : ?hiddenData
                        & !arg
                  )
                . !parms
                )
            : ?parms
          & !HTMLbodyContainer:?BodyContainer
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & "Consult the 'Uploads'-table to find out what we know about the input(s)."
          & readTable$Uploads
          & ( !errors
            . !hiddenData
            . !Items
            . !tabind
            . !Tool
            . !parms
            . !BodyContainer
            )
      )
      ( getBatchHandleDesiredtoolSuperset
      =     parms handle rstr hiddenData lexan
          , unpackIOparm unpackIOparms checkIOparms
        .   ( lexan
            =   T A B op ops
              .   !arg:(?ops.?arg)
                & "safe alternative for get$(!arg,MEM). Ignores JBoss-life-threatening (closing) parentheses."
                & (   !arg:?A_?B
                    & (lexan$(!ops.!A))_(lexan$(!ops.!B))
                  |   !ops:%?op ?ops
                    & (   @(!arg:?A !op ?B)
                        &   !op
                          : (   " "
                              &     lexan$(!ops.!A)
                                    lexan$(!op !ops.!B)
                                : ?T
                            |   "+"
                              &     lexan$(!ops.!A)
                                  + lexan$(!op !ops.!B)
                                : ?T
                            |   "*"
                              &     lexan$(!ops.!A)
                                  * lexan$(!op !ops.!B)
                                : ?T
                            |   "^"
                              &     lexan$(!ops.!A)
                                  ^ lexan$(!op !ops.!B)
                                : ?T
                            )
                        & !T
                      | lexan$(!ops.!arg)
                      )
                  | !arg
                  )
            )
          & ( unpackIOparm
            =   A parms parm nparms val
              .   !arg:(?parms.?parm)
                & :?nparms
                &   whl
                  ' ( !parms:?A (!parm.?val) ?parms
                    & ( lexan$(" " "+" "*" "^".!val):?val
                      | 
                      )
                    & !nparms !A (!parm.!val):?nparms
                    )
                & !nparms !parms
            )
          & ( unpackIOparms
            =   f fs short p
              .   readTable$features
                & !features:?fs
                &   whl
                  ' ( !fs:%?f+?fs
                    & !f:? (short.?short) ?
                    & str$(I !short):?p
                    & (unpackIOparm$(!arg.!p):?arg|)
                    & str$(O !short):?p
                    & (unpackIOparm$(!arg.!p):?arg|)
                    )
                & !arg
            )
          & ( checkIOparms
            =   f fs short table p
              .   readTable$features
                & !features:?fs
                &   whl
                  ' ( !fs:%?f+?fs
                    &   !f
                      : ? (short.?short) ?
                      : ? (table.?table) ?
                    & readTable$!table
                    & str$(I !short):?p
                    & (checkParms$(!arg.!p.!!table)|)
                    & str$(O !short):?p
                    & (checkParms$(!arg.!p.!!table)|)
                    )
            )
          & !arg:(?parms.?hiddenData)
          &     ( 
                | "Shall we treat all resources in one job (non-batch) or shall we
               send each input through a different (though similar) job?"
                )
                ( batch
                .       !parms
                      : ( ? (action.batch) ?
                        | ? (batch.on) ?
                        |   ~(? (action.?) ?)
                          & ~(? (batch.?) ?)
                        )
                    & on
                  | off
                )
                (   !parms:? (handle.?handle) ?
                  & (handle.!handle)
                | 
                )
                ( 
                | "Does the user want to decide which tool to use or does she want
                 to let the infrastructure work out a way to reach a set goal?"
                )
                (   !parms:? (desiredtool.?rstr) ?
                  & (desiredtool.!rstr)
                | 
                )
                  map
                $ ( ( 
                    =   
                      .   !arg:(@(?:SuperSet- ?).?)
                        | 
                    )
                  . !parms
                  )
                !hiddenData
            : ?hiddenData
          & unpackIOparms$!parms:?parms
          & checkIOparms$!parms
          & (!parms.!hiddenData.!batch)
      )
      "
/**
 * specifyGoal
 *
 * Prepare a workflow.
 * Functions as a wizard, taking input from various stages.
 * The function creates a resource by choice of goal
 * Arguments:
 *      - http parameters
 * http parameters:
 *      mail2=<address>
 *      action=batch | batch=on | batch=off
 *      bsubmit=next step|Submit|View details
 *      (item=<itemid>)+
 *      (Item=<itemid>)+
 *      I<feature>=<featurevalue>
 *      O<feature>=<featurevalue>
 * features are (currently): facet, format and lang
 * feature values are complex strings consisting of a feature value and,
 * optionally, a specialisation of the feature values, separated from the
 * former by a caret.
 *
 * Called from enact.java
 */"
      ( specifyGoal
      =     Tool item parms Items items presels
          , errors batch desiredTools sourcesAndGoals BodyContainer
          , handle A itms rstr
          , "We are at the start. Show an input form."
        .   ( desiredTools
            =   L ToolID Title S
              .   readTable$tooladm
                & 0:?S
                & :?L
                & (   !tooladm
                    :   ?
                      + (   ~(? (Inactive.on) ?)
                          : ? (ToolID.?ToolID) ?
                          : ? (Title.?Title) ?
                        & !S+(low$!Title.!Title.!ToolID):?S
                        & ~
                        )
                      + ?
                  | 
                  )
                &   whl
                  ' ( !S:(?.?Title.?ToolID)+?S
                    & !L (!Title.!ToolID):?L
                    )
                &   fieldset
                  $ (     localized
                        $ ( "Restrict list of workflow candidates. (Optional if you specified your goal in the fields above.)"
                            "Indskr√¶nk listen med kandiderende arbejdsgange. (Kan springes over hvis du har specificeret dit m√•l i rubrikken ovenover.)"
                          )
                        (br.,)
                          localized
                        $ ( "If you did not specify a goal (i.e. "
                            "V√¶rkt√∏jet er det sidste i arbejdsgangene hvis du "
                          )
                        (strong.,localized$(ALL INTET))
                          localized
                        $ ( " fields are empty), the Text Tonsorium computes all workflows that have the selected tool as the last step."
                            " har specificeret i rubrikken ovenover."
                          )
                    .   paragraph
                      $ ( makeSelectFormField
                        $ (   localized
                            $ ( "Workflow must utilize the tool:"
                                "Arbejdsgang skal inkludere v√¶rkt√∏jet:"
                              )
                          . desiredtool
                          . options
                          . makeOptionList$(!L.)
                          )
                        )
                    )
            )
          & ( sourcesAndGoals
            =     f fs name short
                , servicedGoalsTable cmptblWrkflws
                , servicedSourcesTable
                , description itms Types linkedWorkflows
                , table presel L
                , preselvalsrows items item spec
                , preselvals presels
                , createArgs G sourcePicklists
                , B C D E R hide n nt p prod x
                , mentionBookmarkedWorkflows linksAndLinked
                , allLinked features links
              .   ( cmptblWrkflws
                  =   itemGroups presels
                    .   !arg:(?itemGroups.?presels)
                      & (!wrkflws|readTable$wrkflws)
                      &   map
                        $ ( ( 
                            =   n itm knownInputFeatures fitm
                              .   !arg:(?n.?itm:%?fitm ?)
                                & ( !n
                                  . !itm
                                  .       map
                                        $ ( ( 
                                            =   f v
                                              .       !arg
                                                    : (?f.?v.!fitm)
                                                  & (!f.!v)
                                                | 
                                            )
                                          . !presels
                                          )
                                      : ?knownInputFeatures
                                    &   map
                                      $ ( ( 
                                          =   name i o wf
                                            .     !arg
                                                : (?name.(?i.?o).?wf)
                                              & (       map
                                                      $ ( ( 
                                                          =   a b
                                                            .       !arg
                                                                  : (?a.?b)
                                                                &   !i
                                                                  :   ?
                                                                      (!a,!b)
                                                                      ?
                                                                & !arg
                                                              | 
                                                          )
                                                        . !knownInputFeatures
                                                        )
                                                    : !knownInputFeatures
                                                  & !name
                                                | 
                                                )
                                          )
                                        . !wrkflws
                                        )
                                  )
                            )
                          . !itemGroups
                          )
                  )
                & ( linksAndLinked
                  =   stable exr L itmgrp id
                    .   !arg:(?stable.?exr)
                      & !exr:?itmgrp
                      & (!itmgrp:";" ?itmgrp|)
                      & (   !stable:%? [?L
                          & (   "item_group_" !itmgrp:?id
                              & ( a
                                .   (href.str$("#" !id))
                                  ,   str
                                    $ ( !L
                                        " "
                                        localized$(workflow arbejdsgang)
                                        ( !L:1&
                                        | localized$(s e)
                                        )
                                      )
                                )
                            .   ( p
                                .   (id.str$!id)
                                  ,   !itmgrp:&
                                    |   str
                                      $ (   localized
                                          $ ( "Workflows compatible with input in column"
                                              "Arbejdsgange der passer til input i kolonne"
                                            )
                                          " "
                                          !itmgrp
                                        )
                                )
                                  map
                                $ ( ( 
                                    =   low full idval o
                                      .   !arg:(?low.?full.?idval)
                                        &   \r\n
                                            ( input
                                            .     (type.submit)
                                                  (name.str$(bview- !full))
                                                  (value.üîç)
                                              , 
                                            )
                                            \r\n
                                            ( input
                                            .     (type.submit)
                                                  ( name
                                                  . str$(bsubmit- !full)
                                                  )
                                                  (value.‚ñ∫)
                                              , 
                                            )
                                            \r\n
                                            !full
                                            ( div
                                            .   (class.tooltip)
                                              ,   ‚à¥
                                                  ( span
                                                  .   (class.tooltiptextL)
                                                    ,     !wrkflws
                                                        :   ?
                                                            ( !full
                                                            . (?.?o)
                                                            . ?
                                                            )
                                                            ?
                                                      & inoutdesc$!o
                                                  )
                                            )
                                            (br.,)
                                            (br.,)
                                    )
                                  . !stable
                                  )
                            )
                        | (.)
                        )
                  )
                & ( mentionBookmarkedWorkflows
                  =   items allLinked
                    .   !arg:?items
                      & :?allLinked
                      & ( ( tr
                          .   (class.specialrow)
                            ,     cell
                                $ ( localized
                                  $ ( "Bookmarked workflows"
                                      "Markerede arbejdsgange"
                                    )
                                  )
                                  cell
                                $ ( ( div
                                    .   (class.tooltip)
                                      ,   (small.,(small.,chu$10068))
                                          ( span
                                          .   (class.tooltiptext)
                                            ,   localized
                                              $ ( "You can ignore all form fields below if you choose a bookmarked workflow."
                                                  "Du kan ignorere alle formularfelter hernede hvis du v√¶lger en markeret workflow."
                                                )
                                          )
                                    )
                                  | 
                                  )
                                  map
                                $ ( ( 
                                    =     nt wrkfls exr stable
                                        , links linked
                                      .   !arg:(?nt.?arg.?wrkfls)
                                        & (   !items:% %
                                            & (exr=";" !nt)
                                          | :?exr
                                          )
                                        &   cell
                                          $ ( !wrkfls:
                                            |       listToThreeColumnTable
                                                  $ !wrkfls
                                                : ?stable
                                              & (       linksAndLinked
                                                      $ (!stable.!exr)
                                                    : (?links.?linked)
                                                  &     !linkedWorkflows
                                                        (!nt.!linked)
                                                    : ?linkedWorkflows
                                                  & !links
                                                | ( select
                                                  .     ( tabindex
                                                        .   1+!tabind
                                                          : ?tabind
                                                        )
                                                        ( name
                                                        .   str
                                                          $ (workflow !exr)
                                                        )
                                                    ,   makeOptionListSimple
                                                      $ (!stable.bookmarked-)
                                                  )
                                                )
                                            )
                                    )
                                  . !items
                                  )
                          )
                        . !allLinked
                        )
                  )
                & !arg:(?presels.?createArgs)
                & :?linkedWorkflows
                & readTable$features
                & !features:?fs
                &     map
                    $ ( ( 
                        =   
                          .       !arg
                                : (FieldName,?.Name,?arg.?)
                              & !arg
                            | 
                        )
                      . !createArgs
                      )
                  : ?items
                & 1:?prod
                & :?preselvalsrows
                &   whl
                  ' ( !fs:%?f+?fs
                    &   !f
                      : ? (name.?name) ?
                      : ? (short.?short) ?
                      : ? (description.?description) ?
                      : ? (table.?table) ?
                    & ( !f:? (hide.?hide) ?
                      | :?hide
                      )
                    & readTable$!table
                    &     map
                        $ ( ( 
                            =   
                              .     !arg:(!short.?presel.?item)
                                  & ( !items:? !item ?
                                    | !items !item:?items
                                    )
                                  & !item^!presel*!prod:?prod
                                  & (!presel.!item)
                                | 
                            )
                          . !presels
                          )
                      : ?preselvals
                    &     !preselvalsrows
                          (!preselvals.!short.!name.!!table.!hide)
                      : ?preselvalsrows
                    )
                &   whl
                  ' ( !prod:?A*%?B^%?x*?C*%?D^!x*?E
                    & !A*(!B !D)^!x*!C*!E:?prod
                    )
                & :?items
                & !prod:?p
                & 0:?R
                &   whl
                  ' ( !p:(? [?n:%?itms)^%?*?p
                    & (!n.!itms)+!R:?R
                    )
                &   whl
                  ' ( !R:(?.?itms)+?R
                    & (.!itms) !items:?items
                    )
                & 0:?nt
                &     map
                    $ ( ( 
                        =   
                          .     !arg:(.?arg)
                              & (!nt+1:?nt.!arg)
                            | 
                        )
                      . !items
                      )
                  : ?items
                &     map
                    $ ( ( 
                        =   seen a b c d e
                          .   !arg:(?a.?b.?c.?d.?e)
                            & 0:?seen
                            & (   map
                                $ ( ( 
                                    =   presel item comb
                                      .     !arg:(?presel.?item)
                                          &   !prod
                                            :   ?
                                              * (? !item ?:?comb)^?
                                              * ?
                                          & (   !seen:?+!comb+?
                                              & 
                                            |   !comb+!seen:?seen
                                              & (!presel.!comb)
                                            )
                                        | !arg
                                    )
                                  . !a
                                  )
                              . !b
                              . !c
                              . !d
                              . !e
                              )
                        )
                      . !preselvalsrows
                      )
                  : ?preselvalsrows
                & "Notice: this function does not have local variable 'abbr' !"
                &     map
                    $ ( ( 
                        =   exr
                          .       !arg
                                : (?preselvals.?short.?name.?table.)
                              & (   !servicedSources
                                  :   ?
                                      (!short.?servicedSourcesTable)
                                      ?
                                |       selectServicedValues
                                      $ ( !short
                                        . !table
                                        . ( 
                                          =   
                                            ' ( ?
                                              + (     ?
                                                    +   ?
                                                      * ( $abbr^?
                                                        | ( ?*$abbr^?*?
                                                          . OnE
                                                          )
                                                        )
                                                      * ?
                                                    + ?
                                                    ?
                                                . ?
                                                )
                                              + ?
                                              )
                                          )
                                        )
                                    : ?servicedSourcesTable
                                  &     (!short.!servicedSourcesTable)
                                        !servicedSources
                                    : ?servicedSources
                                )
                              & (   !items:% %
                                  & (exr=";" !nt)
                                | :?exr
                                )
                              &   row
                                $ (   namecell
                                    $ (!features.!short.localized$!name)
                                      featurehelpcell
                                    $ (!features.!short.sourcehelp)
                                      map
                                    $ ( ( 
                                        =   
                                          .   !arg:(?nt.?arg)
                                            &   cell
                                              $ (     !preselvals
                                                    :   ?
                                                        (%?presel^?spec.!arg)
                                                        ?
                                                  & (   !spec:1
                                                      &   makeSelectFormField
                                                        $ ( 
                                                          .   str
                                                            $ (I !short !exr)
                                                          . options
                                                          .   makeOptionList
                                                            $ ( !servicedSourcesTable
                                                              . !presel
                                                              )
                                                          )
                                                    |   makeSelectFormField
                                                      $ ( 
                                                        .   str
                                                          $ (I !short !exr)
                                                        . options
                                                        .     !features
                                                            :   ?
                                                              + (   ?
                                                                    ( short
                                                                    . !short
                                                                    )
                                                                    ?
                                                                :   ?
                                                                    ( specificationTable
                                                                    .   ?
                                                                        (   ?
                                                                            ( %@
                                                                            : !presel
                                                                            )
                                                                            ?
                                                                        . ?Types
                                                                        )
                                                                        ?
                                                                    )
                                                                    ?
                                                                )
                                                              + ?
                                                          & readTable$!Types
                                                          &   makeOptionList
                                                            $ ( !!Types
                                                              . !spec
                                                              .   str
                                                                $ (!presel "^")
                                                              )
                                                        )
                                                    )
                                                |   makeSelectFormField
                                                  $ ( 
                                                    . str$(I !short !exr)
                                                    . options
                                                    .   makeOptionList
                                                      $ ( !servicedSourcesTable
                                                        . 
                                                        )
                                                    )
                                                )
                                        )
                                      . !items
                                      )
                                  )
                            | 
                        )
                      . !preselvalsrows
                      )
                  : ?sourcePicklists
                & getActiveTools$:?activeTools
                & (   !servicedSuperGoals:
                    &     makeSuperGoals
                        $ ( retrieveServicedOutputFeaturesAndTheirValues
                          $ !activeTools
                          )
                      : ?servicedSuperGoals
                  | 
                  )
                & readTable$features
                & (   !goalPicklists:
                    & !LaNg:?G
                    &     map
                        $ ( ( 
                            =   expandedSelectLists
                              .   setLang$!arg
                                &     makeExpandedSelectLists
                                    $ !servicedSuperGoals
                                  : ?expandedSelectLists
                                & ( !arg
                                  .   createGoalPickLists
                                    $ ( !preselvalsrows
                                      . !expandedSelectLists
                                      . including
                                      )
                                  )
                            )
                          . !lANgs
                          )
                      : ?goalPicklists
                    & setLang$!G
                  | 
                  )
                & cmptblWrkflws$(!items.!presels):?items
                & ( !items
                  .     fieldset
                      $ (     !items:? (?.?.% ?) ?
                            &   localized
                              $ ( "Text Tonsorium can enact a pre-existing, bookmarked workflow or compute and enact a workflow that fulfils your goal."
                                  "Text Tonsorium kan afvikle en allerede eksisterende og markeret arbejdsgang eller beregne og udf√∏re en arbejdsgang som opfylder dit m√•l."
                                )
                          |   !items:% %
                            &   localized
                              $ ( "Text Tonsorium has analysed the types of your inputs. Choose one of them and specify the desired output (your goal)."
                                  "Text Tonsorium har analyseret dine inputs. V√¶lg en inputstype og forts√¶t med at specificere den √∏nskede output (dit m√•l)."
                                )
                          |   localized
                            $ ( "Text Tonsorium has analysed the type of your input. Please specify the desired output (your goal)."
                                "Text Tonsorium har analyseret din input. Forts√¶t med at specificere den √∏nskede output (dit m√•l)."
                              )
                        .   Table
                          $ ( id,inputs
                            .   row
                              $ ( cell$()
                                  cell$()
                                    map
                                  $ ( ( 
                                      =   nt wrkfls
                                        .   !arg:(?nt.?arg.?wrkfls)
                                          &     map
                                              $ ( ( 
                                                  = .!arg (br.,)
                                                  )
                                                . !arg
                                                )
                                            : ?arg (br.,)
                                          & cell$!arg
                                      )
                                    . !items
                                    )
                                )
                            .   (   !items:? (?.?.% ?) ?
                                  &   mentionBookmarkedWorkflows$!items
                                    : (?links.?allLinked)
                                  & !links
                                | :?allLinked
                                )
                                (   !items:% %
                                  & 0:?nt
                                  &   row
                                    $ (   cell
                                        $ ( localized
                                          $ ( "Inputs are dissimilar. Select a column."
                                              "Inputs er ulige. V√¶lg en kolonne."
                                            )
                                          )
                                        cell$()
                                          map
                                        $ ( ( 
                                            =   nt wrkfls
                                              .     !arg
                                                  : (?nt.?arg.?wrkfls)
                                                &   cell
                                                  $ ( input
                                                    .     (type.radio)
                                                          (name.itms)
                                                          (value.!nt)
                                                          (   !nt:1
                                                            & ( checked
                                                              . checked
                                                              )
                                                          | 
                                                          )
                                                      , 
                                                    )
                                            )
                                          . !items
                                          )
                                      )
                                | 
                                )
                                !sourcePicklists
                            )
                        )
                        fieldset
                      $ (   (strong.,localized$("Your goal" "Dit m√•l"))
                            (br.,)
                            localized$("Fill out only " "Udfyld ")
                            (strong.,localized$(two to))
                            localized$(" or " " eller ")
                            (strong.,localized$(three tre))
                              localized
                            $ ( " fields and leave the other fields "
                                " felter og lad de √∏vrige felter v√¶re "
                              )
                            (strong.,localized$(blank blank))
                              localized
                            $ ( ". In general, more filled out fields = fewer workflow candidates."
                                ". Generelt g√¶lder: jo flere udfyldte feldter, desto f√¶rre foresl√•ede arbejdsgange."
                              )
                            (br.,)
                              localized
                            $ ( "You can skip these fields and choose a tool instead, see below. In that case, the tool will be the last in the workflow."
                                "Du kan lade felterne st√• tomme, og i stedet v√¶lge et v√¶rkt√∏j i rubrikken forneden. I s√• fald er v√¶rkt√∏jet det sidste i arbejdsgangen."
                              )
                        .   Table
                          $ ( id,goal
                            . row$(cell$() cell$() cell$)
                            .   ( 
                                =   R
                                  .   !arg:? (!LaNg.?R) ?
                                    & !R
                                )
                              $ !goalPicklists
                            )
                        )
                  . !linkedWorkflows
                  )
            )
          & ( "We are at the start. Show an input form."
            =     formFields presels nt CLOCK sourceAndGoal
                , itemGroupsExt linkedWorkflows
                , hiddenData Items
              .   !arg:(?presels.?hiddenData.?Items)
                & (   !Items:
                    &   str
                      $ ( 200~~~
                            toML
                          $ ( !BodyContainer
                            $ ( paragraph
                              $ ( localized
                                $ ( "No input is specified, or the input is not accessible."
                                    "Inputtet er ikke specificeret, eller inputtet er ikke tilg√¶ngeligt."
                                  )
                                )
                              )
                            )
                        )
                  |     sourcesAndGoals$(!presels.!arg)
                      : (?itemGroupsExt.?sourceAndGoal.?linkedWorkflows)
                    &   (   !itemGroupsExt:(@.@.?)
                          & !Items !hiddenData
                        |   readTable$ItemGroupsCache
                          & (   !ItemGroupsCache
                              : ? (?CLOCK.!itemGroupsExt) ?
                            |       (clk$:?CLOCK.!itemGroupsExt)
                                    !ItemGroupsCache
                                : ?ItemGroupsCache
                              & saveTable$ItemGroupsCache
                            )
                          & (CLOCK.!CLOCK) !hiddenData
                        )
                      : ?hiddenData
                    & !sourceAndGoal desiredTools$:?formFields
                    &   str
                      $ ( 200~~~
                            toML
                          $ ( !BodyContainer
                            $ ( !formFields:
                              |     form
                                  $ ( showworkflows
                                    .   makeHiddenFields$!hiddenData
                                        !formFields
                                        submit$(localized$!"next step")
                                          submit
                                        $ (localized$!helpmespecifymygoal)
                                        helplink$
                                    )
                                  (br.,)
                                  ( !linkedWorkflows:
                                  |   ( h1
                                      .   
                                        ,   localized
                                          $ ( "Bookmarked workflows"
                                              "Markerede arbejdsgange"
                                            )
                                      )
                                        map
                                      $ ( ( 
                                          =   nt linkedWorkflows
                                            .     !arg
                                                : (?nt.?linkedWorkflows)
                                              &   form
                                                $ ( chosenworkflow
                                                  .     makeHiddenFields
                                                      $ ( !hiddenData
                                                          (itms.!nt)
                                                        )
                                                      !linkedWorkflows
                                                  )
                                          )
                                        . !linkedWorkflows
                                        )
                                  )
                              )
                            )
                        )
                  )
            )
          & log$NEW
          & log$CREATELOGJE
          &   initialiseSpecifyGoalShowWorkflowsChosenWorkflow$!arg
            : ( ?errors
              . ?hiddenData
              . ?Items
              . ?tabind
              . ?Tool
              . ?parms
              . ?BodyContainer
              )
          & "First build a list of items."
          & (   !Items:
              & buildItemListFromForeignData$!parms:?Items
            | 
            )
          &   analyzeInput$(!parms.!Items.!errors)
            : (?Items.?presels.?errors)
          & ( !errors:~
            |     getBatchHandleDesiredtoolSuperset$(!parms.!hiddenData)
                : (?parms.?hiddenData.?batch)
              & readTable$tooladm
              &   "We are at the start. Show an input form."
                $ (!presels.!hiddenData.!Items)
            )
      )
      ( supplementParmsAndHiddenData
      =   Submit batch,handle parms rstr nth
        .     getBatchHandleDesiredtoolSuperset$!arg
            : (?parms.?hiddenData.?batch)
          & readTable$tooladm
          & (   (   !parms:? (bsubmit.?Submit) ?
                  & 
                |     (     !parms
                          : ? (@(?:bview- ?nth).?) ?
                        &   localized
                          $ (localized$("View details" "Se detaljer"))
                      |     !parms
                          : ? (@(?:bsubmit- ?nth).?) ?
                        & Submit
                      )
                    : ?Submit
                  & (nth.!nth)
                )
                !parms
            . !Submit
            . !hiddenData
            . !batch
            )
      )
      ( NotFulfillable
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ (   paragraph
                    $ ( localized
                      $ ( "Your goal cannot be fulfilled with the currently integrated tools. Try to make your goal less specific."
                          "Dit m√•l kan ikke opfyldes med de v√¶rkt√∏jer der p.t. er integreret i infrastrukturen. Pr√∏v at lave dit m√•l mindre specifikt."
                        )
                      )
                    (p.,str$("(Returncode: " !arg ")"))
                  )
                )
            )
      )
      ( FulfillableWithoutRestriction
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ ( paragraph
                  $ (   localized
                      $ ( "None of the found workflows involves the tool '"
                          "Ingen af de fundne arbejdsgange anvender v√¶rkt√∏jet '"
                        )
                      ToolTitle$!arg
                      "'."
                    )
                  )
                )
            )
      )
      ( TooExpensive
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ ( paragraph
                  $ ( localized
                    $ ( "The computation takes too much time. It may succeed if you narrow your goal."
                        "Beregningen tager for lang tid. M√•ske vil det lykkes hvis du definerer dit m√•l lidt n√¶rmere."
                      )
                    )
                  )
                )
            )
      )
      ( UnexpectedReturnCode
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ ( paragraph
                  $ ( localized$("Unexpected return code '" "Uvented kode '")
                      !arg
                      "'."
                    )
                  )
                )
            )
      )
      ( canConsumeMetadata
      =   a b
        .     !arg
            : ( ?
              ,   txtbasis^?
                | txtann^?
                | teip5^?
              )
          |   !arg:?a_?b
            & (canConsumeMetadata$!a|canConsumeMetadata$!b)
      )
      ( updateOargFromParg
      =   a z A Z val ft
        .     whl
            ' ( !arg:?A (@(?:P ?ft).?val) ?Z
              & ( !val:&!A !Z:?arg
                |   !A !Z:?a (@(?:O !ft).?) ?z
                  & !a (str$(O !ft).!val) !z:?arg
                  & (     !arg
                        : ?A (@(?:SuperSet- !ft).?) ?Z
                      & !A !Z:?arg
                    | 
                    )
                )
              )
          & !arg
      )
      ( makeArgsForHiddenFields
      =   superset
        .   !arg:(?arg.?superset)
          &   map
            $ ( ( 
                =   f
                  .       !arg
                        : (   bsubmit
                            | method
                            | DATE
                            | @( ?:SuperSet- ?f
                               & !superset:~(? !f ?)
                               )
                          . ?
                          )
                      & 
                    | !arg
                )
              . !arg
              )
      )
      "
/**
 * showworkflows
 *
 * Computes or retrieves available workflows given the user's I/O whishes.
 * Either produces a list of these workflows that the user can choose from, or
 * produces a new set of output specification form fields with option lists
 * that are restricted to the values that are represented in the found
 * workflows. Using these select fields, the user can close in on his/her
 * goal, making the list of candidate workflows shorter and closer to the
 * user's whishes.
 *
 * Called from enact.java
 */"
      ( showworkflows
      =     Tool parms Items NothingToDo Submit
          , presels errors BodyContainer topologicalOrderedTools
          , PIPE A Z TooManyWorkflows updateUploads 2or3things
          , ShowAllPipes rstr reorderedworkflowlist orgarg pipe
          , val allpipes batch returnCode restriction sources
          , ShowAllPipesIfNotTooExpensive add makeGoals makeValRows
          , B M Y f fixed formFields fvs nfvs nvs output
          , pipes pps rwl superset tool updatedArg userInput vs
        .   ( ShowAllPipes
            =     hiddenData reorderedworkflowlist
                , "visualizedWorkFlow(s)" struct
              .     !arg
                  : ( ?hiddenData
                    . ?reorderedworkflowlist
                    . ?topologicalOrderedTools
                    )
                & log$(ShowAllPipes hiddenData !hiddenData)
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ (   !reorderedworkflowlist:%+%
                            &     makeWorkflowRadioButtons
                                $ ( !reorderedworkflowlist
                                  . !topologicalOrderedTools
                                  )
                              : ?"visualizedWorkFlow(s)"
                            &   (h3.,localized$(Workflows Arbejdsgange))
                                ( p
                                .   
                                  ,   ( a
                                      .   (href."#below")
                                        , localized$(Below Forneden)
                                      )
                                        localized
                                      $ ( " are the workflows that fulfil the goal set by you."
                                          " er arbejdsgangene som l√∏ser din opgave."
                                        )
                                      (br.,)
                                        localized
                                      $ ( "You can use the table if you first want to learn which tools can be combined."
                                          "Du kan bruge tabellen hvis du f√∏rst vil unders√∏ge hvilke v√¶rkt√∏jer lader sig kombinere."
                                        )
                                )
                                  form
                                $ ( chosenworkflow
                                  .   (br.,)
                                      makeHiddenFields$!hiddenData
                                      !"visualizedWorkFlow(s)"
                                  )
                          |   !reorderedworkflowlist:(?,(?.?struct))
                            &   makeWorkflowVisualisation$!struct
                              : ?"visualizedWorkFlow(s)"
                            &   (h3.,Workflow)
                                ( p
                                .   
                                  ,   localized
                                    $ ( "This is the workflow that fulfils the goal set by you."
                                        "Dette er arbejdsgangen som l√∏ser din opgave."
                                      )
                                )
                                  form
                                $ ( chosenworkflow
                                  .   submit$Submit
                                      helplink$()
                                      (br.,)
                                      makeHiddenFields$!hiddenData
                                      !"visualizedWorkFlow(s)"
                                  )
                          )
                        )
                    )
            )
          & ( NothingToDo
            =   hiddenData rstr
              .   !arg:?hiddenData
                & ( !hiddenData:? (desiredtool.?rstr) ?
                  | :?rstr
                  )
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ ( ( h3
                            .   
                              ,   localized
                                $ ("Nothing to do" "Der er intet at lave")
                            )
                            ( p
                            .   
                              ,     !rstr:
                                  &   localized
                                    $ ( "The goal is trivially fulfilled by the input. Go to the previous screen and specify your goal (or even the input) in more detail."
                                        "Inputtet opfylder allerede m√•let. G√• tilbage til forrige sk√¶rm og specificer dit m√•l (og eventuelt ogs√• inputtet) n√¶rmere."
                                      )
                                |     localized
                                    $ ( "The goal is trivially fulfilled by the input. Go to the previous screen and either specify your goal in more detail, or do not specify a goal at all. If you choose the second option, an implicit goal will be derived from the tool that you specified."
                                        "Inputtet opfylder allerede m√•let. G√• tilbage til forrige sk√¶rm og specificer dit m√•l n√¶rmere, eller lad v√¶re med at specificere et m√•l. Hvis du v√¶lger det sidste, bliver m√•let implicit bestemt af det v√¶rkt√∏j du har valgt."
                                      )
                                    " ("
                                    ToolTitle$!rstr
                                    ")"
                            )
                          )
                        )
                    )
            )
          & ( TooManyWorkflows
            =   
              .   str
                $ ( 404~~~
                      toML
                    $ ( !BodyContainer
                      $ ( paragraph
                        $ ( localized
                          $ ( "There are unmanageable many possible workflows leading to your goal. Try to specify more details for your goal."
                              "Der er uoverskuelig mange mulige workflows der f√∏rer til dit m√•l. Pr√∏v at specificere dit m√•l n√¶rmere."
                            )
                          )
                        )
                      )
                  )
            )
          & ( add
            =   fvs
              .   !arg:(?arg.?fvs)
                &   map
                  $ ( ( 
                      =   f v
                        .   !arg:(?f,?v)
                          & (!v:(?v.OnE)|)
                          & !f^!v*!fvs:?fvs
                      )
                    . !arg
                    )
                & !fvs
            )
          & ( ShowAllPipesIfNotTooExpensive
            =     returnCode reorderedworkflowlist
                , userInput topologicalOrderedTools
                , hiddenData i o r superset
              .       !arg
                    : ( ?returnCode
                      . ?hiddenData
                      . ?userInput:(?.?.?.?superset)
                      . ?reorderedworkflowlist
                      . ?topologicalOrderedTools
                      )
                  & !returnCode:allRight
                  &   saveTask
                    $ ( !userInput
                      . !reorderedworkflowlist
                      . !topologicalOrderedTools
                      )
                  & "TODO update hiddenData"
                  & updateOargFromParg$!orgarg:?updatedArg
                  &   makeArgsForHiddenFields$(!updatedArg.!superset)
                    : ?hiddenData
                  & !hiddenData
                  &   ShowAllPipes
                    $ ( !hiddenData
                      . !reorderedworkflowlist
                      . !topologicalOrderedTools
                      )
                |   !returnCode:tooComplex
                  & TooExpensive$
            )
          & log$WORKFLOWLISTLOGJE
          & !arg:?orgarg
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & :?PIPE
          &   initialiseSpecifyGoalShowWorkflowsChosenWorkflow$!arg
            : ( ?errors
              . ?hiddenData
              . ?Items
              . ?tabind
              . ?Tool
              . ?parms
              . ?BodyContainer
              )
          & "First build a list of items."
          & buildItemList$!parms:?Items
          &   analyzeInput$(!parms.!Items.!errors)
            : (?Items.?presels.?errors)
          & ( !errors:~
            |     supplementParmsAndHiddenData$(!parms.!hiddenData)
                : (?parms.?Submit.?hiddenData.?batch)
              & "Add any info about the input that the user has provided, e.g. language of the resource."
              & ( updateUploads
                =     A nr Item stagingName
                    , meta feats Z parms
                  .   !arg:?parms
                    & readTable$Uploads:?Uploads
                    & readTable$features:?features
                    &   map
                      $ ( ( 
                          =   
                            .     !arg:(Item.?Item)
                                &   !Uploads
                                  :   ?A
                                      (?nr.!Item.?stagingName.?meta.?feats)
                                      ?Z
                                &     !A
                                      ( !nr
                                      . !Item
                                      . !stagingName
                                      . !meta
                                      .   map
                                        $ ( ( 
                                            =   key val
                                              .       !arg
                                                    : ( @(?:I ?key)
                                                      . ~:?val
                                                      )
                                                  &   !features
                                                    :   ?
                                                      + ( ?
                                                          (short.!key)
                                                          ?
                                                        )
                                                      + ?
                                                  & (!key.!val)
                                                | 
                                            )
                                          . !parms
                                          )
                                      )
                                      !Z
                                  : ?Uploads
                              | 
                          )
                        . !parms
                        )
                    & saveTable$Uploads
                )
              & updateUploads$!parms
              & 0:?allpipes
              &     localized
                  $ ("No workflows found." "Ingen arbejdsgange fundet.")
                : ?returnCode
              & :?restriction
              & log$CALL-Pipelines
              & (     Pipelines$(!parms.)
                    : ( ?
                      . (?sources.?):?userInput
                      . ?2or3things
                      . ?returnCode
                      )
                  & (   !returnCode:allRight
                      & log$"returnCode:allRight"
                      &   !2or3things
                        : (?reorderedworkflowlist.?topologicalOrderedTools)
                    | !2or3things:(?pipes.?parms)
                    )
                  & log$("back from Pipelines" !returnCode)
                  & "allRight
                     onlyWithoutRestriction
                     triviallyFulfilled
                     tooComplex
                     workflowsFound
                     tooMany"
                  & (     !returnCode
                        : (workflowsFound|allRight)
                      & log$(Submit !Submit)
                      & log$(zubmit localized$!helpmespecifymygoal)
                      & (   localized$!"next step":!Submit
                          & (   !returnCode:workflowsFound
                              & (     makeWorkflowsSequential$!pipes
                                    : ( ?reorderedworkflowlist
                                      . ?topologicalOrderedTools
                                      )
                                  & allRight:?returnCode
                                |   0:?reorderedworkflowlist
                                  & :?topologicalOrderedTools
                                  & tooComplex:?returnCode
                                )
                            | 
                            )
                          &   ShowAllPipesIfNotTooExpensive
                            $ ( !returnCode
                              . !hiddenData
                              . !userInput
                              . !reorderedworkflowlist
                              . !topologicalOrderedTools
                              )
                        |   localized$!helpmespecifymygoal:!Submit
                          & 1:?fvs
                          & (   !returnCode:workflowsFound
                              & !pipes:?pps
                              &   whl
                                ' ( !pps:%?pipe+?pps
                                  &   ( 
                                      =   userspec wfs tool output
                                        .   !arg:(?userspec.?wfs)
                                          &   whl
                                            ' (   !wfs
                                                : (?tool,(?output.?))+?wfs
                                              &   add$(!output.!fvs)
                                                : ?fvs
                                              )
                                      )
                                    $ !pipe
                                  )
                            |   !reorderedworkflowlist:?rwl
                              &   whl
                                ' (   !rwl
                                    : (?,(?.? (?tool.?.?.?output)))+?rwl
                                  & add$(!output.!fvs):?fvs
                                  )
                            )
                          & "It is not unimportant how fvs is obtained.
                             Reorderedworkflowlist outputs can have features
                             that are not (yet) in the output of pipes."
                          & 1:?nfvs:?fixed
                          &   whl
                            ' ( !fvs:%?f^%?vs*?fvs
                              & (   !vs:%+%
                                  & 0:?nvs
                                  &   whl
                                    ' ( !vs:%?A+?vs
                                      &   whl
                                        ' ( !A:?B*%?M^%*?Y
                                          & !B*!M*!Y:?A
                                          )
                                      & !nvs+!A:?nvs
                                      )
                                  & !nvs:%+%
                                  &   whl
                                    ' ( !nvs:%?A+?nvs
                                      & (!A:#%*?A|)
                                      & !vs+!A:?vs
                                      )
                                  & !f^!vs*!nfvs:?nfvs
                                | !fixed*!f^!vs:?fixed
                                )
                              )
                          & (   !nfvs:(1|sml^?)
                              & (   !returnCode:workflowsFound
                                  &   (     makeWorkflowsSequential$!pipes
                                          : ( ?reorderedworkflowlist
                                            . ?topologicalOrderedTools
                                            )
                                        & allRight
                                      |   0:?reorderedworkflowlist
                                        & :?topologicalOrderedTools
                                        & tooComplex
                                      )
                                    : ?returnCode
                                | 
                                )
                              & log$(returnCode !returnCode)
                              &   ShowAllPipesIfNotTooExpensive
                                $ ( !returnCode
                                  . !hiddenData
                                  . !userInput
                                  . !reorderedworkflowlist
                                  . !topologicalOrderedTools
                                  )
                            |   ( makeValRows
                                =     fs name short description table
                                    , hide preselvalsrows
                                  .   readTable$features
                                    & !features:?fs
                                    & :?preselvalsrows
                                    &   whl
                                      ' ( !fs:%?f+?fs
                                        &   !f
                                          : ? (name.?name) ?
                                          : ? (short.?short) ?
                                          :   ?
                                              (description.?description)
                                              ?
                                          : ? (table.?table) ?
                                        & (   !f
                                            : ? (hide.?hide) ?
                                          | :?hide
                                          )
                                        & (   !arg:?*!short^?vs*?
                                            & !hide:
                                            & readTable$!table
                                            &     !preselvalsrows
                                                  ( ?
                                                  . !short
                                                  . localized$!name
                                                  .   map
                                                    $ ( ( 
                                                        =   
                                                          .     !arg
                                                              : ( ?
                                                                . [%( !vs
                                                                    :   ?
                                                                      +   ?
                                                                        * !sjt
                                                                        * ?
                                                                      + ?
                                                                    )
                                                                . ?
                                                                )
                                                            | 
                                                        )
                                                      . !!table
                                                      )
                                                  . 
                                                  )
                                              : ?preselvalsrows
                                          | 
                                          )
                                        )
                                    &   log
                                      $ ( makeValRows-preselvalsrows
                                          !preselvalsrows
                                        )
                                    & !preselvalsrows
                                )
                              &     createGoalPickLists
                                  $ ( makeValRows$!nfvs
                                    .   makeExpandedSelectLists
                                      $ (makeSuperGoals$!nfvs)
                                    . 
                                    )
                                : ?formFields
                              & "postpone pruning, which is costly. Instead, show input fields again, but with restricted option lists."
                              &   str
                                $ ( 200~~~
                                      toML
                                    $ ( !BodyContainer
                                      $ ( ( h1
                                          .   
                                            ,   localized
                                              $ ( "Refinement of your goal"
                                                  "N√¶rmere bestemmelse af dit m√•l"
                                                )
                                          )
                                          ( form
                                          .     (action.showworkflows)
                                                (class.formRounded)
                                            ,   ( p
                                                .   
                                                  ,     localized
                                                      $ ( "There are workflow candidates with different output specifications. "
                                                          "Vi fandt arbejdsgange med forskellige outputspecifikationer. "
                                                        )
                                                      (   !nfvs:?*[>1
                                                        &   localized
                                                          $ ( "Here you can supply more specifiations for the output. It is advisable to do this one specification at a time. In that way, you do not run the risk of selecting a combination of values for which no workflow exists."
                                                              "P√• denne side kan du v√¶lge flere specifikationer, men det er bedst at v√¶lge fra √©n liste ad gangen. P√• den m√•de undg√•r du at du kommer til at selektere en kombination af v√¶rdier som ikke resulterer i nogen arbejdsgangkandidater."
                                                            )
                                                      |   localized
                                                        $ ( "Here you can supply the missing specification and thereby reduce the number of proposed workflow candidates."
                                                            "P√• denne side kan du give den manglende specifikation og p√• den m√•de reducere antallet af foresl√•ede arbejdsgange."
                                                          )
                                                      )
                                                )
                                                ( 
                                                &   !userInput
                                                  : (?.?.?.?superset)
                                                &     updateOargFromParg
                                                    $ !orgarg
                                                  : ?updatedArg
                                                &     ( 
                                                      =     updatedArg
                                                          , fixed ft v
                                                          , A Z
                                                        .     !arg
                                                            : ( ?updatedArg
                                                              . ?fixed
                                                              )
                                                          &   whl
                                                            ' (   !fixed
                                                                :     %?ft
                                                                    ^ (#*%@?v)
                                                                  * ?fixed
                                                              &     (   str
                                                                      $ (O !ft)
                                                                    . !v
                                                                    )
                                                                    (     !updatedArg
                                                                        :   ?A
                                                                            ( @( ?
                                                                               :   O
                                                                                   !ft
                                                                               )
                                                                            . ?
                                                                            )
                                                                            ?Z
                                                                      & !A !Z
                                                                    | !updatedArg
                                                                    )
                                                                : ?updatedArg
                                                              )
                                                          & !updatedArg
                                                      )
                                                    $ (!updatedArg.!fixed)
                                                  : ?updatedArg
                                                &   makeHiddenFields
                                                  $ ( makeArgsForHiddenFields
                                                    $ (!updatedArg.!superset)
                                                    )
                                                )
                                                ( div
                                                .   (class.topmargin)
                                                  , !formFields
                                                )
                                                ( div
                                                .   (class.topmargin)
                                                  ,     submit
                                                      $ (localized$!"next step")
                                                      (   !nfvs:?*[>1
                                                        &   submit
                                                          $ ( localized
                                                            $ !helpmespecifymygoal
                                                            )
                                                      | 
                                                      )
                                                )
                                                (paragraph.,helplink$)
                                          )
                                        )
                                      )
                                  )
                            )
                        )
                    |   !returnCode:onlyWithoutRestriction
                      &   !parms
                        : ? (desiredtool.?restriction) ?
                      & FulfillableWithoutRestriction$!restriction
                    |   !returnCode:triviallyFulfilled
                      & localized$!"next step":!Submit
                      & NothingToDo$!hiddenData
                    |     !returnCode
                        : (tooMany|tooComplex)
                      & TooManyWorkflows$
                    |   !returnCode:notFulfillable
                      & NotFulfillable$!returnCode
                    )
                | NotFulfillable$!returnCode
                )
            )
      )
      "
/**
 * chosenworkflow
 *
 * Called from enact.java
 */"
      ( chosenworkflow
      =     Tool item parms Items
          , val mail2 ERR
          , Submit
          , JobStack JobNr presels
          , errors batch
          , jobIDoffset subjobs
          , nth BodyContainer
          , PIPE lookForLanguage
          , makejobstack
          , NoNeedForMetadata
          , ApplyThePipelineToTheInput
          , ShowOnlyTheCurrentPipe AddMetadata
          , "The user has selected a workflow."
          , errorInMetadata
          , MetadataInParms
          , rememberMetadata
        .   ( ShowOnlyTheCurrentPipe
            =   formFields struct nth bm
              .   !arg:(?struct.?nth.?bm.?err)
                & makeWorkflowVisualisation$!struct:?formFields
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ ( ( !nth:#<1
                            |     (br.,)
                                  submit$Submit
                                  (br.,)
                                  (br.,)
                                  submit$Bookmark
                                    makeTextFormField
                                  $ (   localized
                                      $ ( "Name for this workflow"
                                          "Navn for denne arbejdsgang"
                                        )
                                    . bm
                                    .   (val.!bm)
                                        ( desc
                                        .   localized
                                          $ ( "A unique name that tells you and other users what the workflow is about."
                                              "Et unikt navn som giver mening for dig og for andre brugere."
                                            )
                                        )
                                        (size.40)
                                        ( required
                                        . span
                                        . (class.requiblue),"*"
                                        )
                                    )
                                  ( !bm:
                                  |   !err:
                                    & "(" localized$(saved gemt) ")"
                                  |   localized
                                    $ ("Already in use!" "Allerede brugt!")
                                  )
                                  !formFields
                              : ?formFields
                            )
                          & ( !formFields:
                            |   form
                              $ ( chosenworkflow
                                .   !formFields
                                    ( !nth:#<1&
                                    |   makeHiddenFields
                                      $ ((nth.!nth) !hiddenData)
                                    )
                                )
                            )
                          )
                        )
                    )
            )
          & ( AddMetadata
            =     formFields nth val
                , parms ERR metadataType hiddenData
              .   !arg:(?metadataType.?nth.?parms.?ERR.?hiddenData)
                &     !Style
                        map
                      $ ( ( 
                          =     tekst inputs
                              , "Tekst i gr√¶nsefladen"
                              , "Required / optional  / automatic"
                              , "Placering i header" Noter Hj√¶lpetekst id
                              , "line / lines / box / empty" URL
                              , table typeOfError
                            .     !arg:(?tekst,?inputs)
                                &   fieldset
                                  $ ( localized$!tekst
                                    .   map
                                      $ ( ( 
                                          =   
                                            .     !arg
                                                : ( ?id
                                                  . ?"Tekst i gr√¶nsefladen"
                                                  . ?"Required / optional  / automatic"
                                                  . ?"line / lines / box / empty"
                                                  . ?"Placering i header"
                                                  . ?Noter
                                                  . ?Hj√¶lpetekst
                                                  . ?
                                                  . ?URL
                                                  )
                                              & (     !"Required / optional  / automatic"
                                                    :   ?
                                                        ( o
                                                        | r
                                                        | oneOrMore
                                                        | zeroOrMore
                                                        )
                                                        ?
                                                  & ( div
                                                    .   (class.row)
                                                      ,   (     !"line / lines / box / empty"
                                                              : select ?table
                                                            &   readTable
                                                              $ !table
                                                            &   makeSelectFormField
                                                              $ (   addurl
                                                                  $ (   localized
                                                                      $ !"Tekst i gr√¶nsefladen"
                                                                    . !URL
                                                                    )
                                                                . !id
                                                                .   ( options
                                                                    .   makeOptionList
                                                                      $ ( !!table
                                                                        .       !parms
                                                                              :   ?
                                                                                  ( !id
                                                                                  . ?val
                                                                                  )
                                                                                  ?
                                                                            & !val
                                                                          | 
                                                                        )
                                                                    )
                                                                    ( desc
                                                                    .   localized
                                                                      $ !Hj√¶lpetekst
                                                                    )
                                                                    ( required
                                                                    .       !"Required / optional  / automatic"
                                                                          :   ?
                                                                              ( r
                                                                              | oneOrMore
                                                                              )
                                                                              ?
                                                                        & ( span
                                                                          .   ( class
                                                                              . requiblue
                                                                              )
                                                                            , "*"
                                                                          )
                                                                      | 
                                                                    )
                                                                )
                                                          |   (     !"line / lines / box / empty"
                                                                  : ( box
                                                                    | lines
                                                                    )
                                                                & makeTextAreaFormField
                                                              | makeTextFormField
                                                              )
                                                            $ (     addurl
                                                                  $ (   localized
                                                                      $ !"Tekst i gr√¶nsefladen"
                                                                    . !URL
                                                                    )
                                                                  (     !"Required / optional  / automatic"
                                                                      :   ?
                                                                          a
                                                                          ?
                                                                    & ( span
                                                                      .   ( class
                                                                          . italics
                                                                          )
                                                                        ,   str
                                                                          $ ( " ("
                                                                                localized
                                                                              $ ( "autogenerated if left blank"
                                                                                  "automatisk genereret hvis ikke udfyldt"
                                                                                )
                                                                              ") "
                                                                            )
                                                                      )
                                                                  | 
                                                                  )
                                                              . !id
                                                              .   ( val
                                                                  .       !parms
                                                                        :   ?
                                                                            ( !id
                                                                            . ?val
                                                                            )
                                                                            ?
                                                                      & !val
                                                                    | 
                                                                  )
                                                                  ( desc
                                                                  .   localized
                                                                    $ !Hj√¶lpetekst
                                                                  )
                                                                  ( required
                                                                  .       !"Required / optional  / automatic"
                                                                        :   ?
                                                                            ( r
                                                                            | oneOrMore
                                                                            )
                                                                            ?
                                                                      & ( span
                                                                        .   ( class
                                                                            . requiblue
                                                                            )
                                                                          , "*"
                                                                        )
                                                                    | 
                                                                  )
                                                              )
                                                          )
                                                          (     !ERR
                                                              : ( !id
                                                                . ?typeOfError
                                                                . ?
                                                                )
                                                            & ( span
                                                              .   ( class
                                                                  . required
                                                                  )
                                                                , !typeOfError
                                                              )
                                                          | 
                                                          )
                                                    )
                                                |     !"Required / optional  / automatic"
                                                    : ? a ?
                                                  &   !"Tekst i gr√¶nsefladen"
                                                    : ~
                                                  & ( div
                                                    .   (class.row)
                                                      ,   makeStaticTextFormField
                                                        $ (   localized
                                                            $ !"Tekst i gr√¶nsefladen"
                                                          . span
                                                          .   (class.autogen)
                                                            ,   str
                                                              $ ( " ("
                                                                    localized
                                                                  $ ( autogenerated
                                                                      "automatisk genereret"
                                                                    )
                                                                  ") "
                                                                )
                                                          )
                                                    )
                                                | 
                                                )
                                          )
                                        . !inputs
                                        )
                                    )
                              | 
                          )
                        . readTable$!metadataType
                        )
                  : ?formFields
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ ( !formFields:
                          |   ( h1
                              .   
                                ,   localized
                                  $ ("Add metadata" "Tilf√∏j metadata")
                              )
                              (br.,)
                                form
                              $ ( chosenworkflow
                                .   !formFields
                                    ( !nth:<1&
                                    |     makeHiddenFields
                                        $ ((nth.!nth) !hiddenData)
                                        (br.,)
                                        submit$Submit
                                    )
                                )
                          )
                        )
                    )
            )
          & ( makejobstack
            =   NOS stepNo stepping
              .   ( stepping
                  =     a b ID NO I O input
                      , step ad bd deps stp c
                      , nc x y InoOnE
                    .   !arg:(?arg.?deps)
                      & (   !arg:%?a %?b
                          & stepping$(!a.!deps):(?a.?ad)
                          & stepping$(!b.!ad):(?b.?bd)
                          & (!a !b.!bd)
                        |   !arg:(%?a,%?b)
                          & stepping$(!a.!deps):(?a.?ad)
                          & stepping$(!b.!deps):(?b.?bd)
                          & (!a !b.!ad !bd)
                        |   !arg:(.?NO.?I.?O)
                          & !NOS:? (!NO.?step) ?
                          & (.!step.!O)
                        |   !arg:(?ID.?NO.?I.?O)
                          &   str$(step (1+!stepNo:?stepNo))
                            : ?step
                          & ( !NO:
                            | (!NO.!step) !NOS:?NOS
                            )
                          & (   !I:?InoOnE
                              &   whl
                                ' (   !InoOnE
                                    : ?a (?x,(?b.OnE)) ?c
                                  & !a (!x,!b) !c:?InoOnE
                                  )
                              &   !deps
                                : (?stp.!InoOnE:(?a,?b) ?c)
                              & (!a,(!b.!stp)):?I
                              &   whl
                                ' ( !c:%?a ?c
                                  & !a !I:?I
                                  )
                              & ((!step.!ID.!O.!I).!step.!O)
                            |   (     !I
                                    : ?a (?b,%*%:?input) ?c
                                  & :?nc
                                  &   whl
                                    ' ( !input:%?ad*?input
                                      & ( !ad:(?ad.OnE)
                                        | 
                                        )
                                      &     !nc
                                            (     !deps
                                                :   ?x
                                                    ( ?stp
                                                    . ? (!b,!ad) ?
                                                    )
                                                    ?y
                                              & !x !y:?deps
                                              & (!b,(!ad.!stp))
                                            | ( !b
                                              , ( !ad
                                                . FiL
                                                . !a (!b.!ad) !c
                                                )
                                              )
                                            )
                                        : ?nc
                                      )
                                  & !a !nc !c:?I
                                |   !I:(?b,?input) ?c
                                  &   (!b,(!input.FiL.!I)) !c
                                    : ?I
                                )
                              & ((!step.!ID.!O.!I).!step.!O)
                            )
                        )
                  )
                & :?NOS
                & 0:?stepNo
                & stepping$(!arg.):(?arg.?)
                & !arg
            )
          & ( ApplyThePipelineToTheInput
            =     struct batch jobIDoffset parms
                , retrieveMetadataFromParms
                , Items item subjobs mail2 JobId metadataType
              .     !arg
                  : (?metadataType.?struct.?batch.?Items.?mail2.?parms)
                & ( retrieveMetadataFromParms
                  =   metadataType parms
                    .   !arg:(?metadataType.?parms)
                      &   map
                        $ ( ( 
                            =   inputs
                              .     !arg:(?,?inputs)
                                  &   map
                                    $ ( ( 
                                        =   id V
                                          .   !arg:(?id.?)
                                            & (     !parms
                                                  : ? (!id.?V) ?
                                                & (!id.!V)
                                              | 
                                              )
                                        )
                                      . !inputs
                                      )
                                | 
                            )
                          . readTable$!metadataType
                          )
                  )
                & makejobstack$!struct:?JobStack
                & ( readTable$jobNr
                  | 0:?jobNr&saveTable$jobNr
                  )
                & !jobNr+1:?jobNr:?JobNr
                & saveTable$jobNr
                & (   !batch:on
                    & 0:?jobIDoffset
                    &   whl
                      ' ( !Items:%?item ?Items
                        &     convert2URLs
                            $ ( !jobNr
                              . !jobIDoffset
                              . !JobStack
                              . toolsdataURL$
                              . toolsUploadURL$
                              . !item
                              )
                          : ?subjobs
                        & !subjobs+!jobIDoffset:?jobIDoffset
                        )
                  |   convert2URLs
                    $ ( !jobNr
                      . 
                      . !JobStack
                      . toolsdataURL$
                      . toolsUploadURL$
                      . !Items
                      )
                  )
                & (readTable$jobAbout|:?jobAbout)
                &     ( !JobNr
                      .   (mail2.!mail2)
                          (human.makeWorkflowVisualisation$!struct)
                          ( userProvidedMetadata
                          . retrieveMetadataFromParms$(!metadataType.!parms)
                          )
                      )
                      !jobAbout
                  : ?jobAbout
                & saveTable$jobAbout
                & getNextJobID$(!JobNr.justtesting):?JobId
                &   str
                  $ ( 200
                      "~"
                      !JobNr
                      "~"
                      !JobId
                      "~"
                      (   !JobId:
                        &   toML
                          $ ( !BodyContainer
                            $ ( paragraph
                              $ ( localized
                                $ ( "There is nothing to do. The goal seems to be fulfilled already. Go back with the \"back\" button."
                                    "Der er intet at lave. G√• tilbage med knappen \"Forrige\"."
                                  )
                                )
                              )
                            )
                      | poll$(!JobNr.1)
                      )
                    )
            )
          & ( NoNeedForMetadata
            =   
              .   str
                $ ( 200~~~
                      toML
                    $ ( !BodyContainer
                      $ ( paragraph
                        $ ( localized
                          $ ( "The chosen workflow does not produce resources that can be deposited and therefore you do not need to enter metadata."
                              "Den valgte workflow producerer ingen deponerbare resurser og du skal derfor ikke indtaste metadata."
                            )
                          )
                        )
                      )
                  )
            )
          & ( errorInMetadata
            =     pattern metadataType
                , "Tekst i gr√¶nsefladen" id ERR val Metadata
              .   !arg:(?metadataType.?arg)
                & readTable$!metadataType:?Metadata
                & :?ERR
                &   !Metadata
                  :   ?
                      ( ?
                      ,   ?
                          ( ?id
                          . ?"Tekst i gr√¶nsefladen"
                          .     (r|oneOrMore)
                              &   !arg
                                : (   ?
                                      ( !id
                                      .   ?val
                                        & trim$!val:
                                      )
                                      ?
                                  | ~(? (!id.?) ?)
                                  )
                              &   ( !id
                                  . localized$(required kr√¶vet)
                                  . localized$!"Tekst i gr√¶nsefladen"
                                  )
                                : ?ERR
                            | ?
                          . ?
                          . ?
                          . ?
                          . ?
                          .     %?pattern ?
                              & !arg:? (!id.~:?val) ?
                              & ~(@(!val:!!pattern)&)
                              &   ( !id
                                  . localized$(format format)
                                  . localized$!"Tekst i gr√¶nsefladen"
                                  )
                                : ?ERR
                            | &!ERR:~
                          . ?
                          )
                          ?
                      )
                      ?
                & !ERR
            )
          & ( MetadataInParms
            =   id Metadata metadataType
              .   !arg:(?metadataType.?arg)
                & readTable$!metadataType:?Metadata
                &   !Metadata
                  :   ?
                      ( ?
                      ,   ?
                          (   ?id
                            & !arg:? (!id.?) ?
                          . ?
                          )
                          ?
                      )
                      ?
                & !arg
            )
          & ( rememberMetadata
            =   mail2 userProvidedMetadata metadataType
              .   !arg:(?metadataType.?arg)
                & ( MetadataInParms$(!metadataType.!arg)
                  |   (   !arg:? (mail2.?mail2) ?
                        & readTable$jobAbout
                        &   !jobAbout
                          :   ?
                              ( ?
                              .   ?
                                  (mail2.!mail2)
                                  ?
                                  (userProvidedMetadata.?userProvidedMetadata)
                                  ?
                              )
                              ?
                      | :?userProvidedMetadata
                      )
                    & !userProvidedMetadata !parms
                  )
            )
          & ( "The user has selected a workflow."
            =     Submit hiddenData
                , parms nth batch Items mail2 ERR
                , allpipes ViewDetails
                , returnCode struct whichButton
                , restriction sources bm err
                , goals topologicalOrderedTools wf
              .   ( whichButton
                  =   
                    .   !arg:?bm
                      & (     !Submit
                            : ( !ViewDetails (" - " ?nth|)
                              | @(?:(prev|next) ?)
                              )
                          & ShowOnlyTheCurrentPipe$(!struct.!nth.!bm.)
                        |   !Submit:Metadata
                          & (     !parms
                                : ~( ?
                                     ( Iformat
                                     .   ( txtbasis
                                         | txtann
                                         | teip5
                                         )
                                       ^ ?
                                     )
                                     ?
                                   )
                              & canConsumeMetadata$!struct
                              &   rememberMetadata$(TEImetadata.!parms)
                                : ?parms
                              &   AddMetadata
                                $ (TEImetadata.!nth.!parms..!hiddenData)
                            | NoNeedForMetadata$
                            )
                        |   !Submit:Bookmark
                          & ((!sources.!goals).!struct):?wf
                          & ( !wrkflws:
                            | readTable$wrkflws
                            )
                          &   ShowOnlyTheCurrentPipe
                            $ ( !struct
                              . !nth
                              .     !parms:? (bm.?bm) ?
                                  & (   !wrkflws:? (!bm.?) ?
                                      & inuse:?err
                                    |     (!bm.!wf) !wrkflws
                                        : ?wrkflws
                                      & :?err
                                      & saveTable$wrkflws
                                    )
                                  & !bm
                                | 
                              . !err
                              )
                        |   !Submit:Submit
                          & (     !parms
                                : ~( ?
                                     ( Iformat
                                     .   ( txtbasis
                                         | txtann
                                         | teip5
                                         )
                                       ^ ?
                                     )
                                     ?
                                   )
                              & canConsumeMetadata$!struct
                              & (   MetadataInParms$(TEImetadata.!parms)
                                  &   errorInMetadata$(TEImetadata.!parms)
                                    : ?ERR
                                |   ~(MetadataInParms$(TEImetadata.!parms))
                                  &   !parms
                                    :   ?
                                        ( Oformat
                                        .   ( txtbasis
                                            | txtann
                                            | teip5
                                            )
                                          ^ ?
                                        )
                                        ?
                                  &   rememberMetadata$(TEImetadata.!parms)
                                    : ?parms
                                )
                              &   AddMetadata
                                $ (TEImetadata.!nth.!parms.!ERR.!hiddenData)
                            |   ApplyThePipelineToTheInput
                              $ ( TEImetadata
                                . !struct
                                . !batch
                                . !Items
                                . !mail2
                                . !parms
                                )
                            )
                        )
                  )
                &   !arg
                  : (?parms.?Submit.?hiddenData.?batch.?Items.?mail2)
                & 0:?allpipes
                & :?returnCode:?restriction
                &   !parms
                  : ( ? (nth.?nth) ?
                    | ?&1:?nth
                    )
                &   localized$("View details" "Se detaljer")
                  : ?ViewDetails
                & (   !nth:#
                    & log$(calling Pipelines !nth)
                    &   Pipelines$(!parms.!nth)
                      : ( ?
                        . (?sources.?goals.?)
                        . ( (?.?.?.?.?),(?.?struct)
                          . ?topologicalOrderedTools
                          )
                        . ?returnCode
                        )
                    & log$(returnCode !returnCode)
                    & "!returnCode:(allRight
                                   |triviallyFulfilled
                                   |tooComplex
                                   |tooMany
                                   |onlyWithoutRestriction
                                   |notFulfillable
                                   )"
                    & (   !returnCode:allRight
                        & log$whichButton
                        & whichButton$
                      | UnexpectedReturnCode$!returnCode
                      )
                  |   !wrkflws:? (!nth.?.?struct) ?
                    & whichButton$!nth
                  | NotFulfillable$NoPipelinesFound
                  )
            )
          & (|log$NEW)
          & log$SINGLEWORKFLOWLOGJE
          & :?PIPE
          &   initialiseSpecifyGoalShowWorkflowsChosenWorkflow$!arg
            : ( ?errors
              . ?hiddenData
              . ?Items
              . ?tabind
              . ?Tool
              . ?parms
              . ?BodyContainer
              )
          & "First build a list of items."
          & (   !Items:
              & buildItemList$!parms:?Items
            | 
            )
          &   analyzeInput$(!parms.!Items.!errors)
            : (?Items.?presels.?errors)
          & ( !errors:~
            |     supplementParmsAndHiddenData$(!parms.!hiddenData)
                : (?parms.?Submit.?hiddenData.?batch)
              &   log
                $ ( "The user has selected a workflow."
                    parms
                    !parms
                    Submit
                    !Submit
                    hiddenData
                    !hiddenData
                  )
              &   "The user has selected a workflow."
                $ (!parms.!Submit.!hiddenData.!batch.!Items.!mail2)
            )
      )
      "
/**
 * getStatusCode
 *
 *  Given a HTTP status code and an informatory text, return an HTML-file
 * with a heading containing the status code and the official short description
 * of the status code, a paragraph containing the informatory text and a 
 * paragraph displaying a longer text explaining the code (From wikipedia).
 * 
 * This function could just as well have been written in Java.
 * 
 * Called from create.java, register.java,
 * stresstest.java, update.java, upload.java
 */"
      ( getStatusCode
      =   code tekst explanation
        .   readTable$HTTP-status-codes
          & !arg:(?code.?tekst)
          & !HTTP-status-codes:? (!code.?arg.?explanation) ?
          &   toML
            $ ( !HTMLbodyContainer
              $ ( heading$(1.!code " " !arg)
                  paragraph$!tekst
                  paragraph$!explanation
                )
              )
      )
      "
/**
 * keep
 *
 * Check whether a result from a tool in the staging area can be deleted.
 *
 * Results that for some reason are needed by other tasks must be kept.
 * The function looks for outstanding jobs that take the argument as input.
 * Argument: file name, may be preceded by a slash
 *      /19231210291
 *
 * NOTICE: If the file need not be kept, the file's name is deleted from
 * several tables, so calling keep has side effects!
 * Affected tables:
 *      jobs.table
 *      Uploads.table
 *      CTBs.table
 *      relations.table
 *      jobAbout.table
 *
 * Called from data.java and cleanup.java
 */"
      ( readJobTables
      =   
        .   readTable$jobs
          & readTable$Uploads
          & readTable$CTBs
          & (NORELATIONSFILES|readTable$relations)
          & readTable$jobAbout
          & readTable$ItemGroupsCache
      )
      ( saveJobTables
      =   
        .   saveTable$jobs
          & saveTable$Uploads
          & saveTable$CTBs
          & (NORELATIONSFILES|saveTable$relations)
          & saveTable$jobAbout
          & saveTable$ItemGroupsCache
      )
      ( keep
      =     jobNr jobID jobstatus files toolURL parms file
          , find jobNrParm stagingName stem
        .   ( find
            =   x T L R
              .   !arg:(?x.?T)&!x:!T
                |   !T:?L_?R
                  & (find$(!x.!L)|find$(!x.!R))
            )
          & log$(keep !arg)
          & !arg:(?stagingName.?jobNrParm)
          & (@(!stagingName:? "/" ?stagingName)|)
          & (   (   @(!stagingName:?stem ".withmetadata.xml")
                  & str$(!stem ".xml")
                |   ~
                  & NORELATIONSFILES
                  & @(!stagingName:?stem ".relations.csv")
                  & !stem
                )
              : ?stagingName
            | 
            )
          & (   @( !stagingName
                 : !jobNrParm ("-all"|"-final") ".zip"
                 )
              & no
            |   !jobNrParm:
              & (     !jobs
                    :   ?
                        ( ( ?jobNr
                          . %?jobID ?jobstatus
                          . ?files
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                        & ( !files:? !stagingName ?
                          | !file:!stagingName
                          |   !parms:?+(I.?parms)+?
                            & find$(!stagingName.!parms)
                          )
                        &   !jobstatus
                          : ( 
                            | waiting
                            | starting
                            )
                        )
                        ?
                  & yes
                |       map
                      $ ( ( 
                          =   jobNr jobID files file
                            .       !arg
                                  : ( ( ?jobNr
                                      . %?jobID ?
                                      . ?files
                                      . ?
                                      . ?
                                      . ?file
                                      )
                                    & ( !files:? !stagingName ?
                                      | !file:!stagingName
                                      )
                                    )
                                & deleteDepending$(!jobNr.!jobID)
                                & 
                              | !arg
                          )
                        . !jobs
                        )
                    : ?jobs
                  &     map
                      $ ( ( 
                          =   Name
                            .     !arg:(?.?Name.!stagingName.?)
                                &     map
                                    $ ( ( 
                                        =   
                                          .       !arg
                                                : ( ?
                                                  .   ?
                                                      (?.? !Name ?)
                                                      ?
                                                  )
                                              & 
                                            | !arg
                                        )
                                      . !ItemGroupsCache
                                      )
                                  : ?ItemGroupsCache
                                & 
                              | !arg
                          )
                        . !Uploads
                        )
                    : ?Uploads
                  & no
                )
            |     !jobs
                :   ?
                    ( (!jobNrParm.?.?files.?.?parms.?file)
                    & ( !files:? !stagingName ?
                      | !file:!stagingName
                      |   !parms:?+(I.?parms)+?
                        & find$(!stagingName.!parms)
                      )
                    )
                    ?
              & ~( !jobs
                 :   ?
                     ( (~!jobNrParm.?.?files.?.?parms.?file)
                     & ( !files:? !stagingName ?
                       | !file:!stagingName
                       |   !parms:?+(I.?parms)+?
                         & find$(!stagingName.!parms)
                       )
                     )
                     ?
                 )
              & no
            | yes
            )
      )
      "
/**
 * help
 */"
      ( illustration
      =   stappen steps connections centr polygonPoints
        .   ( polygonPoints
            =   points x y
              .   !arg:((?x.?y).?points)
                & ( points
                  . 
                  .       map
                        $ ( ( 
                            =   X Y
                              .   !arg:(?X.?Y)
                                &   " "
                                    div$(!x+!X+1/2.1)
                                    ","
                                    div$(!y+!Y+1/2.1)
                            )
                          . !points
                          )
                      : " " ?points
                    & str$!points
                  )
            )
          & ( centr
            =   cx cy x1 x2 y1 y2 xs ys N
              .     !arg:?+(cx.?cx)+?:?+(cy.?cy)+?
                  & (!cx.!cy)
                |     !arg
                    : ?+(x1.?x1)+?
                    : ?+(x2.?x2)+?
                    : ?+(y1.?y1)+?
                    : ?+(y2.?y2)+?
                  & (div$(!x1+!x2.2).div$(!y1+!y2.2))
                |     !arg
                    : ?+(x.?x1)+?
                    : ?+(width.?x2)+?
                    : ?+(y.?y1)+?
                    : ?+(height.?y2)+?
                  & (!x1+div$(!x2.2).!y1+div$(!y2.2))
                |   !arg:?+(points..?points)+?
                  & 0:?xs:?ys:?N
                  &   vap
                    $ ( ( 
                        =   x y
                          .     vap$((=.!arg).!arg.",")
                              : #%?x #%?y
                            & !x+!xs:?xs
                            & !y+!ys:?ys
                            & 1+!N:?N
                        )
                      . !points
                      . " "
                      )
                  & (div$(!xs.!N).div$(!ys.!N))
            )
          &     ( triangle1
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    . (-10.9) (10.9) (0.-8)
                                    )
                                + (fill..lime)
                                + (stroke..blue)
                                + (stroke-width.2)
                                + (fill-rule..evenodd)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( triangle2
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    . (-10.-9) (10.-9) (0.8)
                                    )
                                + (fill..lime)
                                + (stroke..blue)
                                + (stroke-width.2)
                                + (fill-rule..evenodd)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( 5-star
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-16)
                                        (-10.12)
                                        (15.-4)
                                        (-15.-4)
                                        (10.12)
                                    )
                                + (stroke..red)
                                + (stroke-width.1)
                                + (fill-rule..nonzero)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( 5-star2
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-16)
                                        (-10.12)
                                        (15.-4)
                                        (-15.-4)
                                        (10.12)
                                    )
                                + (stroke..lightblue)
                                + (stroke-width.1)
                                + (fill-rule..nonzero)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( pentagon
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-16)
                                        (15.-4)
                                        (10.12)
                                        (-10.12)
                                        (-15.-4)
                                    )
                                + (fill..grey)
                                + (stroke..red)
                                + (stroke-width.1)
                                + (fill-rule..evenodd)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( square2
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-16)
                                        (16.0)
                                        (0.16)
                                        (-16.0)
                                    )
                                + (fill..black)
                                + (stroke..red)
                                + (stroke-width.2)
                                + (fill-rule..nonzero)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( romb
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-16)
                                        (8.0)
                                        (0.16)
                                        (-8.0)
                                    )
                                + (fill..white)
                                + (stroke..blue)
                                + (stroke-width.2)
                                + (fill-rule..nonzero)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( 6-star
                . ( 
                  =   chrono step offset ill
                    .   !arg:(?step.?chrono.?ill.?offset)
                      & (   (Create..polygon)
                          + ( attributes
                            .       polygonPoints
                                  $ ( !offset
                                    .   (0.-128015258/5000000)
                                        (2131454/500000.-36917871/5000000)
                                        (11086447/500000.-64007626/5000000)
                                        (4262909/500000.0)
                                        (11086447/500000.64007629/5000000)
                                        (2131455/500000.36917869/5000000)
                                        (0.128015259/5000000)
                                        (-2131453/500000.36917869/5000000)
                                        (-11086446/500000.64007629/5000000)
                                        (-4262908/500000.0)
                                        (-11086446/500000.-64007632/5000000)
                                        (-2131454/500000.-36917861/5000000)
                                        (0.-128015258/5000000)
                                    )
                                + (stroke..blue)
                                + (stroke-width.2)
                                + (fill-rule..nonzero)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( ellipse
                . ( 
                  =   chrono step cx cy ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & (   (Create..ellipse)
                          + ( attributes
                            .     (cx.!cx)
                                + (cy.!cy)
                                + (rx.16)
                                + (ry.10)
                                + (fill..yellow)
                                + (stroke..blue)
                                + (stroke-width.1)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( circle
                . ( 
                  =   chrono step cx cy ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & (   (Create..circle)
                          + ( attributes
                            .     (cx.!cx)
                                + (cy.!cy)
                                + (r.13)
                                + (fill..blue)
                                + (stroke..yellow)
                                + (stroke-width.4)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( circle2
                . ( 
                  =   chrono step cx cy ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & (   (Create..circle)
                          + ( attributes
                            .     (cx.!cx)
                                + (cy.!cy)
                                + (r.13)
                                + (fill..grey)
                                + (stroke..blue)
                                + (stroke-width.4)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( ellipsisje
                . ( 
                  =   chrono step cx cy ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & (   (Create..path)
                          + ( attributes
                            .     ( D
                                  . 
                                  .   str
                                    $ ( "M "
                                        !cx+3
                                        " "
                                        !cy+3
                                        " l -6 0 l 0 6 l 6 0 l 0 -6"
                                      )
                                  )
                                + (fill..grey)
                                + (stroke..blue)
                                + (stroke-width.4)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( ellipsis
                . ( 
                  =   chrono step cx cy ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & (   (Create..path)
                          + ( attributes
                            .     (cx.!cx)
                                + (cy.!cy)
                                + ( d
                                  . 
                                  .   str
                                    $ ( "M "
                                        !cx+-7
                                        " "
                                        -3+!cy
                                        " l -6 0 l 0 -6 l 6 0 l 0 6"
                                        " m "
                                        10
                                        " "
                                        0
                                        " l -6 0 l 0 -6 l 6 0 l 0 6"
                                        " m "
                                        10
                                        " "
                                        0
                                        " l -6 0 l 0 -6 l 6 0 l 0 6"
                                      )
                                  )
                                + (r.13)
                                + (fill..grey)
                                + (stroke..grey)
                                + (stroke-width.1)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
                ( rect
                . ( 
                  =   chrono step cx cy w2 h2 ill
                    .   !arg:(?step.?chrono.?ill.?cx.?cy)
                      & 10:?w2
                      & 10:?h2
                      & (   (Create..rect)
                          + ( attributes
                            .     (x.!cx+-1*!w2)
                                + (y.!cy+-1*!h2)
                                + (width.2*!w2)
                                + (height.2*!h2)
                                + (fill..red)
                                + (stroke..black)
                                + (stroke-width.3)
                              , 
                            )
                          + (step.!step)
                          + (chrono.!chrono)
                          + (enact.!ill)
                        , 
                        )
                  )
                )
            : ?Shapes
          & (500.500):(?canvasX.?canvasY)
          &   (   !arg:createAndEnact
                & (   (0.1.0.triangle1.545/1074.0)
                      (1.6.1.rect.0.963/8023)
                      (2.9.2.romb.115/1074.1502/8023)
                      (3.5.3.6-star.1269/1432.1822/8023)
                      (4.8.4.pentagon.95/537.2403/8023)
                      (5.4.-1.5-star.185/537.3643/8023)
                      (6.3.-1.circle.90/179.4303/8023)
                      (7.2.-1.square2.310/537.4783/8023)
                      (8.13.5.circle.355/1074.5083/8023)
                      (9.20.5.circle.215/537.5563/8023)
                      (10.15.-1.circle2.1.5943/8023)
                      (11.1.6.ellipse.1709/4296.7463/8023)
                      (12.1.7.triangle2.545/1074.1)
                  .   (4.11.23.10)
                      (3.11.22.-1)
                      (5.9.21.-1)
                      (9.11.20.-1)
                      (1.11.19.-1)
                      (6.11.18.-1)
                      (4.10.17.-1)
                      (3.10.16.-1)
                      (10.11.15.-1)
                      (5.8.14.-1)
                      (8.11.13.9)
                      (3.7.12.8)
                      (3.4.11.8)
                      (1.2.10.7)
                      (2.4.9.6)
                      (4.5.8.6)
                      (0.1.7.5)
                      (1.3.6.4)
                      (3.5.5.4)
                      (5.6.4.4)
                      (6.7.3.4)
                      (7.11.2.3)
                      (11.12.1.2)
                  )
              | (   (2.8.7.ellipsis.145/537.1403/8023)
                    (3.7.-1.5-star.265/537.3043/8023)
                    (6.6.-1.ellipsis.370/537.1003/8023)
                    (7.9.-1.ellipsis.440/537.1303/8023)
                    (8.3.8.5-star2.285/537.3043/8023)
                    (10.13.3.circle.355/1074.7083/8023)
                    (20.20.3.ellipse.275/537.7563/8023)
                    (30.8.-1.square2.130/179.6303/8023)
                .   (8.20.21.-1)
                    (8.10.14.-1)
                    (8.30.7.7)
                    (3.20.21.-1)
                    (3.10.14.-1)
                    (7.8.15.-1)
                    (6.8.13.-1)
                    (2.3.16.-1)
                    (3.30.7.7)
                )
              )
            : (?shapes.?snoitcennoc)
          & :?connections
          &   whl
            ' ( !snoitcennoc:%?A ?snoitcennoc
              & !A !connections:?connections
              )
          &     map
              $ ( ( 
                  =   chrono step type offset ill fnc
                    .   !arg:(?step.?chrono.?ill.?type.?offset)
                      & !Shapes:? (!type.(=?fnc)) ?
                      & fnc$(!step.!chrono.!ill.!offset)
                  )
                .   map
                  $ ( ( 
                      =   step chrono shape X Y ill
                        .   !arg:(?step.?chrono.?ill.?shape.?X.?Y)
                          & ( !step
                            . !chrono
                            . !ill
                            . !shape
                            . 20+div$((!canvasX+-40)*!X.1)
                            . 20+div$((!canvasY+-40)*!Y.1)
                            )
                      )
                    . !shapes
                    )
                )
            : ?steps
          &     map
              $ ( ( 
                  =   from to afrom ato cfrom cto text
                    .   !arg:(?from.?to.?kro.?text)
                      &   !steps
                        :   ?
                            (   ?+(step.!from)+?
                              : ?+(attributes.?afrom,)+?
                            , 
                            )
                            ?
                      &   !steps
                        :   ?
                            (   ?+(step.!to)+?
                              : ?+(attributes.?ato,)+?
                            , 
                            )
                            ?
                      & centr$!afrom:(?x1.?y1)
                      & centr$!ato:(?x2.?y2)
                      &   ( 
                          | (   (Create..line)
                              + ( attributes
                                .     (x1.!x1)
                                    + (y1.!y1)
                                    + (x2.!x2)
                                    + (y2.!y2)
                                    + (stroke..black)
                                    + (stroke-width.4)
                                  , 
                                )
                              + (from.!from)
                              + (to.!to)
                              + (chrono.!kro)
                              + (ill.!text)
                            , 
                            )
                          )
                          (   (Create..path)
                            + ( attributes
                              .     (stroke..white)
                                  + (stroke-width.4)
                                  + ( d
                                    . 
                                    .   str
                                      $ (M !x1 " " !y1 " " !x2 " " !y2)
                                    )
                                , 
                              )
                            + (fromw.!from)
                            + (to.!to)
                            + (chrono.!kro)
                            + (ill.!text)
                          , 
                          )
                          (   (Create..path)
                            + ( attributes
                              .     (stroke..black)
                                  + (stroke-width.3)
                                  + ( d
                                    . 
                                    .   str
                                      $ (M !x1 " " !y1 " " !x2 " " !y2)
                                    )
                                , 
                              )
                            + (from.!from)
                            + (to.!to)
                            + (chrono.!kro)
                            + (ill.!text)
                          , 
                          )
                  )
                . !connections
                )
            : ?Edgez
          & jsn$(,!Edgez !steps):?stappen
          & (   !arg:createAndEnact
              &   ( svg
                  .     (id.svgwortel)
                        (width.!canvasX)
                        (height.!canvasY)
                        (viewBox.str$("0 0 " !canvasX " " !canvasY))
                        (onload."main(evt)")
                    ,   ( rect
                        .     (class.Border)
                              (x.1)
                              (y.1)
                              (width.!canvasX+-2)
                              (height.!canvasY+-2)
                              (fill.white)
                              (stroke.lightblue)
                              (stroke-width.3)
                              (stroke-linejoin.round)
                          , 
                        )
                        ( g
                        .   (id.ip2) (transform."rotate(0)")
                          , 
                        )
                        ( text
                        .     (id.input)
                              (x.div$(1/2*!canvasX.1)+-40)
                              (y.21)
                              (font-size.smaller)
                          , input
                        )
                        ( text
                        .     (id.uploaded)
                              (x.div$(1/2*!canvasX.1)+17)
                              (y.21)
                              (font-size.smaller)
                          ,   "("
                                localized
                              $ ( "uploaded by the user"
                                  "som brugeren har uploadet"
                                )
                              ")"
                        )
                        ( text
                        .     (id.output)
                              (x.div$(1/2*!canvasX.1)+-47)
                              (y.!canvasY+-15)
                              (font-size.smaller)
                          , output
                        )
                        ( text
                        .     (id.goal)
                              (x.div$(1/2*!canvasX.1)+17)
                              (y.!canvasY+-15)
                              (font-size.smaller)
                          ,   "("
                                localized
                              $ ( "goal as set by the user"
                                  "m√•l som brugeren har specificeret"
                                )
                              ")"
                        )
                  )
                  ( script
                  .   
                    ,   "
var svgns = 'http://www.w3.org/2000/svg';
var steps = "
                        !stappen
                        ";

function navigationShape(cx,cy,shape,g) {
    var knap = document.createElementNS(svgns, 'path');
    knap.setAttribute('stroke','currentcolor');
    knap.setAttribute('stroke-linecap','round');
    knap.setAttribute('stroke-linejoin','round');
    knap.setAttribute('stroke-width','2');
    d = '';
    switch(shape) {
        case -2:
            d = 'M'+(cx-7)+' '+(cy-14)+' L'+(cx-7)+' '+(cy)+' '+(cx+7)+' '+(cy-14)+' '+(cx+7)+' '+(cy+14)+' '+(cx-7)+' '+(cy)+' '+(cx-7)+' '+(cy+14)+'';
            break;
        case -1:
            d = 'M'+(cx-7)+' '+(cy)+' L'+(cx+7)+' '+(cy-14)+' '+(cx+7)+' '+(cy+14)+' '+(cx-7)+' '+(cy)+'';
            break;
        case 0:
            break;
        case 1:
            d = 'M'+(cx+7)+' '+(cy)+' L'+(cx-7)+' '+(cy-14)+' '+(cx-7)+' '+(cy+14)+' '+(cx+7)+' '+(cy)+'';
            break;
        case 2:
            d = 'M'+(cx+7)+' '+(cy-14)+' L'+(cx+7)+' '+(cy)+' '+(cx-7)+' '+(cy-14)+' '+(cx-7)+' '+(cy+14)+' '+(cx+7)+' '+(cy)+' '+(cx+7)+' '+(cy+14)+'';
            break;
    }
    knap.setAttribute('d', d);
    knap.setAttribute('fill', 'black');
    g.appendChild(knap);
    return knap;
}

function ei(chrono, trin, cx, cy, r) {
    var g = document.createElementNS(svgns, 'g');

    function plotThing(thing) {
        var create = thing['Create'];
        var thng = document.createElementNS(svgns, thing['Create']);
        attrbutes = thing['attributes'];
        var keys = Object.keys(attrbutes);
        var j;
        for(j = 0;j < keys.length;++j){
            thng.setAttribute(keys[j],attrbutes[keys[j]]);
        }
    
        keys = Object.keys(thing);
        var Here = -1;
        var From = -1;
        var To = -1;
        for (i = 0; i < keys.length; i++) {
            if (keys[i] == 'step') {
                Here = thing['step'];
                name = 'step'+Here;
                break;
            }
            else if (keys[i] == 'from')  {
                From = thing['from'];
                To = thing['to'];
                name = 'from' + From + 'to'+To;
                break;
            }
            else if (keys[i] == 'fromw')  {
                From = thing['fromw'];
                To = thing['to'];
                name = 'fromw' + From + 'to'+To;
                break;
            }
        }
        thng.setAttribute('id',name);
        if(Here == 0 || Here == 12)
            thng.setAttribute('opacity',1);
        else
            thng.setAttribute('opacity',0.15);
        g.appendChild(thng);
    }

    
    this.chrono = chrono;
    this.trin = trin;
    var svg = this;
    
    this.homenode = navigationShape("
                        div$(!canvasX*3/4.1)
                        ","
                        53
                        ",-2,g);
    this.previousnode = navigationShape("
                        div$(!canvasX*3/4.1)+30
                        ","
                        53
                        ",-1,g);
    this.nextnode = navigationShape("
                        div$(!canvasX*3/4.1)+60
                        ","
                        53
                        ",1,g);
    this.endnode = navigationShape("
                        div$(!canvasX*3/4.1)+90
                        ","
                        53
                        ",2,g);
    steps.forEach(plotThing);

    this.svg = g;
    //this.root2 = document.getElementById('svgwortel');

    this.homenode.addEventListener('click', clickhome, false);
    this.previousnode.addEventListener('click', clickfewer, false);
    this.nextnode.addEventListener('click', clickmore, false);
    this.endnode.addEventListener('click', clickend, false);

    var ip2 = document.getElementById('ip2');
    ip2.appendChild(this.svg);

    return g;
};

var chrono = -1;
var trin = 0;

function updateVis2(trin) {

    function updateThing(thing) {
        keys = Object.keys(thing);
        var Here = -1;
        var From = -1;
        var To = -1;
        for (i = 0; i < keys.length; i++) {
            if (keys[i] == 'step') {
                Here = thing['step'];
                ill = thing['react'];
                name = 'step'+Here;
                if(Here == trin) {
                    enact = thing['enact'];
                }
                break;
            }
            else if (keys[i] == 'from')  {
                From = thing['from'];
                To = thing['to'];
                name = 'from' + From + 'to'+To;
                break;
            }
            else if (keys[i] == 'fromw')  {
                From = thing['fromw'];
                To = thing['to'];
                name = 'fromw' + From + 'to'+To;
                break;
            }
        }

        if(Here == 0 || Here == 12)
            return;

        thenums = name.match(/\\d+/g);
        visibility = 'visible';
        opacity = 1;
        thenums.forEach(function(thenum) {
            if(thenum > trin) {
                visibility = 'hidden';
                opacity = 0.15;
            }
        });

        thng = document.getElementById(name);

//        thng.setAttribute('visibility',visibility);
        thng.setAttribute('opacity',opacity);
    }
    enact = -1;
    steps.forEach(updateThing);
    for (text = 0;text < 23;++text) {
        id = 'enact'+text;
        li = document.getElementById(id);
        if(li != null) {
            if(text == enact) {
                li.setAttribute('style','background-color:yellow');
            }
            else {
                li.setAttribute('style','background-color:white');
            }
        }
    }
}

function updateVis3(chrono) {

    function updateThing(thing) {
        keys = Object.keys(thing);
        var Here = -1;
        var From = -1;
        var To = -1;
        for (i = 0; i < keys.length; i++) {
            if (keys[i] == 'step') {
                Here = thing['step'];
                name = 'step'+Here;
                break;
            }
            else if (keys[i] == 'from')  {
                From = thing['from'];
                To = thing['to'];
                name = 'from' + From + 'to'+To;
                break;
            }
            else if (keys[i] == 'fromw')  {
                From = thing['fromw'];
                To = thing['to'];
                name = 'fromw' + From + 'to'+To;
                break;
            }
        }

        theChrono = thing['chrono'];

        if(Here == 0 || Here == 12)
            return;

        visibility = 'visible';
        opacity = 1;
        if (theChrono > chrono) {
            visibility = 'hidden';
            opacity = 0.15;
        }
        else if(theChrono == chrono) {
            ill = thing['ill'];
            if(ill != null) {
                theId = ill;
            }
        }
        

        thng = document.getElementById(name);

        thng.setAttribute('visibility',visibility);
        thng.setAttribute('opacity',opacity);
    }
    theId = 1;
    steps.forEach(updateThing);
    for (text = 0;text < 23;++text) {
        id = 'pole'+text;
        li = document.getElementById(id);
        if(li != null) {
            if(text == theId) {
                li.setAttribute('style','background-color:yellow');
            }
            else {
                li.setAttribute('style','background-color:white');
            }
        }
    }
}

function whiteoutEnact(evt) {
    for (j = 0;j < 23;++j) {
        id = 'enact'+j;
        li = document.getElementById(id);
        if(li != null) {
            li.setAttribute('style','background-color:white');
        }
    }
}

function whiteoutComp(evt) {
    for (j = 0;j < 23;++j) {
        id = 'pole'+j;
        li = document.getElementById(id);
        if(li != null) {
            li.setAttribute('style','background-color:white');
        }
    }
}

function clickhome(evt) {
    chrono = 0;
    trin = 0;
    updateVis3(chrono);
    whiteoutEnact(evt);
}

function clickfewer(evt) {
    if (chrono > 0) {
        chrono -= 1;
        if(chrono <= 23) {
            if(chrono == 23) {
                for (text = 0;text < 23;++text) {
                    id = 'enact'+text;
                    li = document.getElementById(id);
                    if(li != null) {
                        li.setAttribute('style','background-color:white');
                    }
                }
            }
            updateVis3(chrono);
        }
        else {
            trin = chrono - 24;
            updateVis2(trin);
        }
    }
}

function clickmore(evt) {
    if(chrono < (23+12+1)) {
        chrono += 1;
        if(chrono <= 23) {
            updateVis3(chrono);
        }
        else {
            if(chrono == 24) {
                for (text = 0;text < 23;++text) {
                    id = 'pole'+text;
                    li = document.getElementById(id);
                    if(li != null) {
                        li.setAttribute('style','background-color:white');
                    }
                }
            }
            trin = chrono - 24;
            updateVis2(trin);
        }
    }
}

var endat = 0;

function clickend(evt) {
    whiteoutComp(evt);
    whiteoutEnact(evt);
    endat = (1-endat);
    if(endat == 1) {
        chrono = 23;
        trin = 0;
        updateVis3(chrono);
    }
    else {
        chrono = 23+12+1;
        trin = chrono - 24;
        updateVis2(trin);
    }
}

function main(evt) {
    new ei(chrono, trin, 100, 100, 45);
}
"
                  )
            |   ( svg
                .     (id.svgwortel2)
                      (width.!canvasX)
                      (height.!canvasY)
                      (viewBox.str$("0 0 " !canvasX " " !canvasY))
                      (onload."main2(evt)")
                  ,   ( rect
                      .     (class.Border)
                            (x.1)
                            (y.1)
                            (width.!canvasX+-2)
                            (height.!canvasY+-2)
                            (fill.white)
                            (stroke.lightblue)
                            (stroke-width.3)
                            (stroke-linejoin.round)
                        , 
                      )
                      ( g
                      . (id.ip3) (transform."rotate(0)"),
                      )
                )
                ( script
                .   
                  ,   "
var steps2 = "
                      !stappen
                      ";
var state = 0;

function yolk(cx, cy, r) {
    var g = document.createElementNS(svgns, 'g');

    function plotThing(thing) {
        var create = thing['Create'];
        var thng = document.createElementNS(svgns, thing['Create']);
        attrbutes = thing['attributes'];
        var keys = Object.keys(attrbutes);
        var j;
        for(j = 0;j < keys.length;++j){
            thng.setAttribute(keys[j],attrbutes[keys[j]]);
        }
    
        keys = Object.keys(thing);
        var Here = -1;
        var From = -1;
        var To = -1;
        for (i = 0; i < keys.length; i++) {
            if (keys[i] == 'step') {
                Here = thing['step'];
                name = 'sdep'+Here;
                break;
            }
            else if (keys[i] == 'from')  {
                From = thing['from'];
                To = thing['to'];
                name = 'frrom' + From + 'to'+To;
                console.log('name:'+name);
                break;
            }
            else if (keys[i] == 'fromw')  {
                From = thing['fromw'];
                To = thing['to'];
                name = 'frromw' + From + 'to'+To;
                console.log('name:'+name);
                break;
            }
        }
        thng.setAttribute('id',name);
        thng.setAttribute('opacity',1);
        if(From == 3 || From == 8)
            thng.setAttribute('stroke-dasharray','20,10');
        g.appendChild(thng);
    }
    
    var svg2 = this;

    this.startstate = navigationShape("
                      div$(!canvasX*3/4.1)
                      ","
                      53
                      ",-2,g);
    this.previousstate = navigationShape("
                      div$(!canvasX*3/4.1)+30
                      ","
                      53
                      ",-1,g);
    this.nextstate = navigationShape("
                      div$(!canvasX*3/4.1)+60
                      ","
                      53
                      ",1,g);
    this.endstate = navigationShape("
                      div$(!canvasX*3/4.1)+90
                      ","
                      53
                      ",2,g);
   
    steps2.forEach(plotThing);

    this.svg2 = g;
    //this.root2 = document.getElementById('svgwortel');

    this.startstate.addEventListener('click', clickStartState, false);
    this.previousstate.addEventListener('click', clickPreviousState, false);
    this.nextstate.addEventListener('click', clickNextState, false);
    this.endstate.addEventListener('click', clickEndState, false);

    var ip3 = document.getElementById('ip3');
    ip3.appendChild(this.svg2);

    return g;
};

function updateVis4(state) {

    function updateThing(thing) {
        keys = Object.keys(thing);
        console.log('keys:'+keys);
        var Here = -1;
        var From = -1;
        var To = -1;
        for (i = 0; i < keys.length; i++) {
            if (keys[i] == 'step') {
                Here = thing['step'];
                name = 'sdep'+Here;
                console.log('Here:'+Here);
                break;
            }
            else if (keys[i] == 'from')  {
                From = thing['from'];
                To = thing['to'];
                console.log('From:'+From+' To:'+To);
                name = 'frrom' + From + 'to'+To;
                break;
            }
            else if (keys[i] == 'fromw')  {
                From = thing['fromw'];
                To = thing['to'];
                console.log('From:'+From+' To:'+To);
                name = 'frromw' + From + 'to'+To;
                break;
            }
        }

        thenums = name.match(/\\d+/g);
        console.log('thenums:'+thenums);
        opacity = 1;

        switch(state) {
            case 1:
                break;
            case 2:
                thenums.forEach(function(thenum) {
                    if(thenum > 5 && thenum < 10) {
                        opacity = 0.15;
                    }
                });                
                break;
            case 3:
                if(  From == 8 && (To == 10 || To == 20)
                  || From == 3 && To == 30
                  )
                    opacity = 0.15;
                break;
            case 4:
                if(  From == 8 && (To == 10 || To == 30)
                  || From == 3 && To == 20
                  )
                    opacity = 0.15;
                break;
            case 5:
                if(  From == 8 && (To == 20 || To == 30)
                  || From == 3 && To == 10
                  )
                    opacity = 0.15;
                break;
            case 6:
                if(  From == 8 && To == 10
                  || From == 3 && (To == 20 || To == 30)
                  )
                    opacity = 0.15;
                break;
            case 7:
                if(  From == 8 && To == 20
                  || From == 3 && (To == 10 || To == 30)
                  )
                    opacity = 0.15;
                break;
            case 8:
                if(  From == 8 && To == 30
                  || From == 3 && (To == 10 || To == 20)
                  )
                    opacity = 0.15;
                break;
            case 9:
                thenums.forEach(function(thenum) {
                    if(thenum < 5 ) {
                        opacity = 0.15;
                    }
                });                
        }

        thng = document.getElementById(name);
        if(thng) {
            thng.setAttribute('opacity',opacity);
            if(From == 8 || From == 3) {
                if(state == 1) {
                    thng.setAttribute('stroke-dasharray','20,10');
                }
                else {
                    thng.setAttribute('stroke-dasharray','');
                }
            }
        }
           
    }
    steps2.forEach(updateThing);
    for (text = 0;text < 23;++text) {
        id = 'unprun'+text;
        li = document.getElementById(id);
        if(li != null) {
            if(text == state) {
                li.setAttribute('style','background-color:yellow');
            }
            else {
                li.setAttribute('style','background-color:white');
            }
        }
    }
}

function clickStartState(evt) {
    state = 1;
    updateVis4(state);
}

function clickPreviousState(evt) {
    if (state > 1) {
        state -= 1;
        updateVis4(state);
    }
}

function clickNextState(evt) {
    if(state < 9) {
        state += 1;
        updateVis4(state);
    }
}

function clickEndState(evt) {
    state = 9;
    updateVis4(state);
}


function main2(evt) {
    new yolk(100, 100, 45);
}
"
                )
            )
      )
      ( ChangeLog
      =     tools langlist toolsSorted Title toolNr ToolID
          , features feats cumfeat usedonly usedFeatures
        .   log$CHANGELOG
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & log$(ChangeLog !arg)
          & readTable$changelog:?changelog
          &   toML
            $ ( HTML-SVG-bodyContainer
              $ ( ChangeLog
                .   (h1.,"Text Tonsorium - Changelog")
                    ( dl
                    .   
                      ,   map
                        $ ( ( 
                            =   n d t
                              .     !arg
                                  : ( @( ?
                                       :   (% % % %:?yyyy)
                                           (% %:?mm)
                                           (% %:?dd)
                                       )
                                    . ?futureuse
                                    . ?change
                                    )
                                &   (dt.,!yyyy "-" !mm "-" !dd)
                                    (dd.,localized$!change)
                            )
                          . !changelog
                          )
                    )
                )
              )
      )
      ( help
      =     tools langlist toolsSorted Title toolNr ToolID
          , features feats cumfeat usedonly usedFeatures
        .   log$HELP
          & ( !arg:? (usedonly.?usedonly) ?
            | y:?usedonly
            )
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & log$(help !arg)
          & readTable$tooladm
          & readTable$toolprop
          & readTable$features
          & ( toolsSorted
            =   tool sorted tools L Title sortje
              .   0:?sorted
                &   whl
                  ' (   !tooladm
                      :   ?
                        + ( ? (Inactive.) ?
                          : ? (Title.?Title) ?
                          : ?tool
                          )
                        + ?tooladm
                    & (low$!Title.!tool)+!sorted:?sorted
                    )
                & :?tools
                &   whl
                  ' ( !sorted:(?L.%?sortje)+?sorted
                    & (!L.!sortje) !tools:?tools
                    )
                & :?sorted
                &   whl
                  ' ( !tools:%?sortje ?tools
                    & !sortje !sorted:?sorted
                    )
                & !sorted
            )
          & ( langlist
            =   tp L R langs l a b
              .     !toolprop:?+(!arg.~(? (lang,?) ?))+?
                  & 
                |   !toolprop:?tp
                  & 0:?L
                  &   whl
                    ' (   !tp
                        : ?+(!arg.? (lang,?langs) ?)+?tp
                      &   whl
                        ' ( !langs:(?a.?b)+?langs
                          & !L+!a+!b:?L
                          )
                      )
                  & :?R
                  &   whl
                    ' (!L:#*%@?l+?L&!l !R:?R)
                  & :?L
                  &   whl
                    ' (!R:%?l ?R&", " !l !L:?L)
                  & ( !L:", " ?L&str$!L
                    | 
                    )
            )
          & sum2list$!features:?feats
          & toolsSorted$:?tools
          & ( usedFeatures
            =   ToolID id tools toolprp cumfeat coll fts
              .   ( coll
                  =   R
                    .   1:?R
                      &   map
                        $ ( ( 
                            =   r e
                              .   1:?r
                                &   whl
                                  ' ( !arg:%?e+?arg
                                    & !e*!r:?r
                                    )
                                & !r*!R:?R
                                & 
                            )
                          . !arg
                          )
                      & !R
                  )
                & !arg:(?tools.?toolprp)
                & 0:?cumfeat
                &   whl
                  ' (   !toolprp
                      :   ?
                        + (   ?ToolID
                            &   !tools
                              :   ?
                                  ( ?
                                  .   ? (ToolID.?id) ?
                                    & !id:!ToolID
                                  )
                                  ?
                          . ?fts
                          )
                        + ?toolprp
                    &   map
                      $ ( ( 
                          =   feat in inou in ou
                            .   !arg:(?feat,?inou)
                              &   whl
                                ' ( !inou:(?in.?ou)+?inou
                                  &   !feat\L(coll$!in*coll$!ou)+!cumfeat
                                    : ?cumfeat
                                  )
                          )
                        . !fts
                        )
                    )
                & !cumfeat
            )
          &   (   !usedonly:y
                & usedFeatures$(!tools.!toolprop)
              | 
              )
            : ?cumfeat
          & 0:?toolNr
          &   toML
            $ ( HTML-SVG-bodyContainer
              $ ( help
                .   (h1.,"Text Tonsorium")
                    ( p
                    .   
                      ,   localized
                        $ ( "The Text Tonsorium is a workflow management system that not only executes workflows, but also composes workflows from building blocks. Each building block encapsulates a Natural Language Processing tool."
                            "Text Tonsorium er et workflow management system som ikke kun f√∏rer data gennem workflows, men ogs√• designer workflows ved hj√¶lp af 'byggeklodser'. Hver byggeklods indeholder et sprogteknologisk v√¶rkt√∏j."
                          )
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "In contrast to other workflow management systems, the Text Tonsorium focuses on results rather than on tools, so a general understanding of how the desired result is described is useful. Still, you may like to also know which tools currently are integrated in the Text Tonsorium. This page gives you information about both."
                            "N√•r du arbejder med Text Tonsorium, skal dit fokus v√¶re p√• det resultat som du vil opn√•, og ikke p√• de v√¶rkt√∏jer der er i v√¶rkt√∏jskassen. Derfor er det nyttigt at vide hvordan det √∏nskede resultat bedst kan beskrives. Du vil m√•ske alligevel ogs√• vide hvilke v√¶rkt√∏jer er integreret i Text Tonsorium. Denne side giver dig information om begge dele."
                          )
                    )
                    (h2.,localized$(Overview Overblik))
                    ( dl
                    .   
                      ,   ( dt
                          .   
                            , ( a
                              .   (href."#working")
                                ,     localized
                                    $ ( "How does the Text Tonsorium compute and enact workflows?"
                                        "Hvordan bliver arbejdsgange beregnet og eksekveret?"
                                      )
                                  : ?workingTitle
                              )
                          )
                          ( dt
                          .   
                            , ( a
                              .   (href."#UIflow")
                                ,     localized
                                    $ ( "Working with the Text Tonsorium"
                                        "At arbejde med Text Tonsorium"
                                      )
                                  : ?UIflowTitle
                              )
                          )
                          ( dt
                          .   
                            , ( a
                              .   (href."#features")
                                ,   localized$(Features Tr√¶k)
                                  : ?featuresTitle
                              )
                          )
                          ( dt
                          .   
                            , ( a
                              .   (href."#tools")
                                ,   localized$(Tools V√¶rkt√∏jer)
                                  : ?toolsTitle
                              )
                          )
                    )
                    ( h2
                    .   
                      , ( a
                        .   (id.working) (name.working)
                          , !workingTitle
                        )
                    )
                    ( p
                    .   
                      ,     localized
                          $ ( "A workflow design consists of one or more tools connected by data streams, see Figure 1. In this diagra, we depict tools as shapes (squares, circles, stars, etc.) and data streams as edges between the shapes. "
                              "En arbejdsgang best√•r af et eller flere v√¶rkt√∏jer forbundet ved datastr√∏mme, se Figur 1. I diagrammet afbildes v√¶rkt√∏jer som figurer (firkanter, cirkler, stjerne, o.s.v.) og datastr√∏mme som linjer imellem dem. "
                            )
                          (br.,)
                            localized
                          $ ( "Broadly speaking, the Text Tonsorium can do two things with workflows: compose them and enact them. "
                              "Text Tonsorium kan g√∏re to helt forskellige ting med arbejdsgange: det kan sammens√¶tte arbejdsgange og det kan eksekvere dem. "
                            )
                            localized
                          $ ( "Here we show how it is done. "
                              "Her viser vi hvordan. "
                            )
                    )
                    ( div
                    .   (style."width: 100%; overflow: hidden;")
                      ,   ( div
                          .   (style."width: 550px; float: left;")
                            , ( figure
                              .   
                                ,   ( figcaption
                                    .   
                                      ,   ( a
                                          .   (id.Fig2)
                                            , localized$("Figure 1" "Figur 1")
                                          )
                                          ". "
                                            localized
                                          $ ( "Computation and enactment of workflow design."
                                              "Beregning og eksekvering af en arbejdsgang."
                                            )
                                    )
                                    illustration$createAndEnact
                              )
                          )
                          ( div
                          .   (style."margin-left: 550px;")
                            ,   ( h3
                                .   
                                  ,   localized
                                    $ ( "Composition of workflow design"
                                        "At s√¶tte en arbejdsgang sammen"
                                      )
                                )
                                ( ol
                                .   
                                  ,   ( li
                                      .   (id.pole1)
                                        ,     localized
                                            $ ( "Top of the diagram: The user has uploaded one or more documents that she wants to process using the Text Tonsorium. "
                                                "Toppen af diagrammet: Brugeren har uploadet en eller flere dokumenter som hun vil processere ved hj√¶lp af Text Tonsorium. "
                                              )
                                            (br.,)
                                              localized
                                            $ ( "Bottom of the diagram: The user has also specified the output she wishes to get from the Text Tonsorium. "
                                                "Bunden af diagrammet: Brugeren har ogs√• specificeret hvilket resultat hun √∏nsker at f√• fra Text Tonsorium."
                                              )
                                      )
                                      ( li
                                      .   (id.pole2)
                                        ,   localized
                                          $ ( "The first tool the Text Tonsorium adds to the design is in fact the last tool of the workflow: a tool that satisfies the user's goal. From there, it works backwards toward the input. "
                                              "Det f√∏rste v√¶rkt√∏j som Text Tonsorium tilf√∏jer til sit plan er faktisk det sidste v√¶rkt√∏j i arbejdsgangen: et v√¶rkt√∏j som opfylder brugerens m√•l. Derfra g√•r det bagl√¶ns mod inputtet. "
                                            )
                                      )
                                      ( li
                                      .   (id.pole3)
                                        ,   localized
                                          $ ( "Once the last tool of the workflow has been established, its input requirements become the new goal."
                                              "N√•r det sidste v√¶rkt√∏j i arbejdsgangen er valgt, bliver dets inputkrav det nye m√•l."
                                            )
                                      )
                                      ( li
                                      .   (id.pole4)
                                        ,   localized
                                          $ ( "This process of moving the goal repeats for each addition of a tool to the workflow design."
                                              "Dette forl√∏b, hvor m√•let bliver flyttet n√•r et v√¶rkt√∏j er tilf√∏jet, kan blive gentaget adskillige gange."
                                            )
                                      )
                                      ( li
                                      .   (id.pole5)
                                        ,   localized
                                          $ ( "When a tool is found that takes the user's uploaded document as input, it is still too early to claim that a viable workflow design has been found."
                                              "N√•r et v√¶rkt√∏j bliver tilf√∏jet som tager brugerens dokument som input, er det stadig for tidligt at p√•st√• at en arbejdsgang er fundet."
                                            )
                                      )
                                      ( li
                                      .   (id.pole6)
                                        ,     localized
                                            $ ( "Text Tonsorium retraces its path to see whether any of the tools in the path needs more inputs. "
                                                "Text Tonsorium f√∏lger stien bagl√¶ns og unders√∏ger om der undervejs er v√¶rkt√∏jer der forlanger flere inputs. "
                                              )
                                              localized
                                            $ ( "When Text Tonsorium finds such a tool, it again seeks toward the input to pick up the missing data. "
                                                "N√•r Text Tonsorium finder et s√•dant v√¶rkt√∏j, g√•r det igen mod inputtet for at pr√∏ve at opfylde behovet. "
                                              )
                                            (br.,)
                                              localized
                                            $ ( "Sometimes, another tool is added to the workflow design to fulfill the need."
                                                "Sommetider skal endnu et v√¶rkt√∏j tilf√∏jes for at opfylde behovet."
                                              )
                                      )
                                      ( li
                                      .   (id.pole7)
                                        ,   localized
                                          $ ( "In other cases, the needed input is the output of an already established component in the workflow."
                                              "I andre tilf√¶lde kan outputtet fra et andet v√¶rkt√∏j genanvendes."
                                            )
                                      )
                                      ( li
                                      .   (id.pole8)
                                        ,   localized
                                          $ ( "Again, Text Tonsorium crawls back towards the goal and tries to obtain any still missing inputs."
                                              "Text Tonsorium g√•r igen tilbage mod m√•let for at fors√∏ge at opfylde endnu ikke opfyldte inputkrav."
                                            )
                                      )
                                      ( li
                                      .   (id.pole9)
                                        ,     localized
                                            $ ( "Sometimes the Text Tonsorium inserts the same tool in the workflow design multiple times. "
                                                "Nogle gange inds√¶tter Text Tonsorium det samme v√¶rkt√∏j flere gange i arbejdsgangen. "
                                              )
                                              localized
                                            $ ( "In such cases, all incarnations of the tool have different parameters, so they do different things. "
                                                "I s√•danne tilf√¶lde bliver alle forekomster af v√¶rkt√∏jet styret med forskellige parametre, s√• de laver forskellige ting. "
                                              )
                                      )
                                      ( li
                                      .   (id.pole10)
                                        ,   localized
                                          $ ( "The Text Tonsorium has completed the composition of a viable workflow design when the last tool produces the output that the user wants and all tools get the inputs they need."
                                              "Text Tonsorium er f√¶rdig med konstruktionen af en brugbar arbejdsgang n√•r brugeren kan f√• det output hun √∏nsker fra det sidste v√¶rkt√∏j og alle v√¶rkt√∏jer f√•r de n√∏dvendige inputs."
                                            )
                                      )
                                )
                                ( h3
                                .   
                                  ,   localized
                                    $ ( "Enactment of a workflow"
                                        "At eksekvere en arbejdsgang"
                                      )
                                )
                                ( ol
                                .   
                                  ,   ( li
                                      .   (id.enact0)
                                        ,   localized
                                          $ ( "Once the Text Tonsorium has designed a workflow, we can ask it to enact the workflow with data that we have uploaded as input."
                                              "N√•r Text Tonsorium har sat en arbejdsgang sammen, kan vi lade Text Tonsorium eksekvere den med input som vi har uploadet."
                                            )
                                      )
                                      ( li
                                      .   (id.enact1)
                                        ,   localized
                                          $ ( "The input data is sent to the first tool in the workflow."
                                              "Inputtet er sent til det f√∏rste v√¶rkt√∏j i arbejdsgangen."
                                            )
                                      )
                                      ( li
                                      .   (id.enact2)
                                        ,   localized
                                          $ ( "The output from the first tool is sent to the second tool."
                                              "Outputtet fra det f√∏rste v√¶rkt√∏j sendes til det andet v√¶rkt√∏j."
                                            )
                                      )
                                      ( li
                                      .   (id.enact3)
                                        ,   localized
                                          $ ( "The output from the first tool is also sent to the third tool. Depending on the involved tools and the availability of processing units, this can happen at the same time."
                                              "Outputtet fra det f√∏rste v√¶rkt√∏j sendes ogs√• til det tredje v√¶rkt√∏j. Afh√¶ngig af de involverede v√¶kt√∏jer, kan v√¶rkt√∏jer aktiveres samtidig."
                                            )
                                      )
                                      ( li
                                      .   (id.enact4)
                                        ,   localized
                                          $ ( "A tool is not activated before all its required inputs are present."
                                              "Et v√¶rkt√∏j aktiveres ikke f√∏rend alle dets inputs er til stede."
                                            )
                                      )
                                      ( li
                                      .   (id.enact5)
                                        ,   localized
                                          $ ( "The same tool, with the same input, but with different parameters and therefore a different output."
                                              "Samme v√¶rkt√∏j, med det samme input, men styret af andre parametere og derfor med et andet output som f√∏lge."
                                            )
                                      )
                                      ( li
                                      .   (id.enact6)
                                        ,   localized
                                          $ ( "Many datastreams come together in the last tool in the workflow. This happens often, since users often wish to see many annotation layers in the output."
                                              "Mange datastr√∏mme kommer sammen i det sidste v√¶rkt√∏j i arbejdsgangen. Dette sker ofte. Brugere √∏nsker ofte at se mange annotationslag i outputtet."
                                            )
                                      )
                                      ( li
                                      .   (id.enact7)
                                        ,   localized
                                          $ ( "A single datstream, containing all required annotation layers, is made available to the user."
                                              "√ân enkel datastr√∏m, som indeholder alle annotationslag, st√•r til brugerens r√•dighed."
                                            )
                                      )
                                )
                          )
                    )
                    ( p
                    .   (style."clear:left;")
                      ,     localized
                          $ ( "The diagram above is a gross simplification. The main omission is that the Text Tonsorium always attempts to find not just one, but all roads leading to a goal."
                              "Ovenst√•ende tegning giver et forenklet billede. Hvad du ikke kan se er at Text Tonsorium altid fors√∏ger at finde ikke kun √©n, men alle veje der f√∏rer til m√•let."
                            )
                          (br.,)
                            localized
                          $ ( "The Text Tonsorium finds all workflows by trying out all tools and all tool parameter combinations."
                              "Text Tonsorium finder alle arbejdsgange ved at afpr√∏ve alle v√¶rkt√∏jer og alle v√¶rkt√∏jsindstillinger."
                            )
                    )
                    (h3.,localized$(Pruning Besk√¶ring))
                    ( p
                    .   
                      ,   localized
                        $ ( "The full set of workflows found by the Text Tonsorium is not presented to the user in its entirety. In general, there will be workflows that do not make much sense to a user. Many workflows will be pruned away."
                            "Brugeren bliver ikke pr√¶senteret for den fulde samling af de arbejdsgange som Text Tonsorium har fundet. Der vil n√¶sten altid v√¶re arbejdsgange som ikke giver s√• meget mening for en bruger. Derfor finder der en kraftig besk√¶ring sted som fjerner mange arbejdsgange."
                          )
                    )
                    ( h4
                    .   
                      ,   localized
                        $ ( "Tools that compete for the same goal"
                            "V√¶rkt√∏jer som konkurerer om samme m√•l"
                          )
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "In the following example, two tools compete to create output fulfilling the same goal. There are three tools that 'consume' the output. The consuming tools cannot take output from both competing tools. The question is: which of the competing tools should they choose?"
                            "I n√¶ste eksempel er der to v√¶rkt√∏jer som konkurerer om at levere output som opfylder samme m√•l. Der er tre v√¶rkt√∏jer som tager dette output som input. Disse tre v√¶rkt√∏jer kan ikke tage output fra to v√¶rkt√∏jer p√• √©n gang, men m√• v√¶lge."
                          )
                    )
                    ( div
                    .   (style."width: 100%; overflow: hidden;")
                      ,   ( div
                          .   (style."width: 550px; float: left;")
                            , ( figure
                              .   
                                ,   ( figcaption
                                    .   
                                      ,   ( a
                                          .   (id.Fig2)
                                            , localized$("Figure 2" "Figur 2")
                                          )
                                          ". "
                                          localized$("Pruning." "Besk√¶ring.")
                                    )
                                    illustration$prune
                              )
                          )
                          ( div
                          .   (style."margin-left: 550px;")
                            ,   ( ol
                                .   
                                  ,   ( li
                                      .   (id.unprun1)
                                        ,   localized
                                          $ ( "Non pruned, ambiguous workflow design containing two tools fulfillng the same goal."
                                              "Ikke-besk√•ret, flertydig arbejdsgang som indeholder to v√¶rkt√∏jer som opfylder det samme m√•l."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun2)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that ignores the second tool completely, configuration 1."
                                              "Besk√•ret, utvetydig arbejdsgang som ignorere det andet af de to v√¶rkt√∏jer, konfiguration 1."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun3)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 2."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 2."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun4)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 3."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 3."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun5)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 4."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 4."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun6)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 5."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 5."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun7)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 6."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 6."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun8)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that includes both tools, configuration 7."
                                              "Besk√•ret, utvetydig arbejdsgang som inkluderer begge v√¶rkt√∏jer, konfiguration 7."
                                            )
                                      )
                                      ( li
                                      .   (id.unprun9)
                                        ,   localized
                                          $ ( "Pruned, unambiguous workflow design that ignores the first tool completely, configuration 8."
                                              "Besk√•ret, utvetydig arbejdsgang som ignorere det f√∏rste af de to v√¶rkt√∏jer, konfiguration 8."
                                            )
                                      )
                                )
                                ( p
                                .   
                                  ,   localized
                                    $ ( "If a goal can be satified in M ways and there are N workflow nodes setting that goal, then there are N^M viable configurations. In the example, M = 2 and N = 3, so there are 2^3 = 8 confugurations."
                                        "Hvis et m√•l kan opfyldes p√• M m√•der og der er N knuder i arbejdsgangen som definerer dette m√•l, er der N^M gyldige konfigurationer. I eksemplet er M = 2 og N = 3, s√• der er 2^3 = 8 gyldige konfigurationer."
                                      )
                                )
                                ( p
                                .   
                                  ,   localized
                                    $ ( "As more and more tools were integrated in the the Text Tonsorium, situations where tools were competing arose more often, resulting in enormous amounts (sometimes tens of thousands) of viable workflow designs that the user would not be able to choose from."
                                        "Med tiden blev flere og flere v√¶rt√∏jer integreret i Text Tonsorium, og situationer hvor v√¶rkt√∏jer konkurerer forekom oftere og oftere. Det resulterede i uoverskuelig store m√¶ngder (nogle gange titusinder) af arbejdsgange som brugeren umuligt kunne v√¶lge imellem."
                                      )
                                )
                                ( p
                                .   
                                  ,   localized
                                    $ ( "Pruning reduces the amount of workflows that is presented to the user by excluding all workflow designs that contain two or more competing tools. Thus, in the example, only the first and the last configuration survive the pruning process. So, in the end, there are not N^M, but only M configurations."
                                        "Besk√¶ring nedbringer antallet af arbejdsgange som brugeren f√•r pr√¶senteret. Alle arbejdsgange som indeholder to eller flere konkurerende v√¶rkt√∏jer bliver sk√•ret v√¶k. I eksemplet er det kun den f√∏rste og den sidste konfiguration som overlever besk√¶ringen. Tilbage er derfor ikke N^M, men blot M konfigurationer."
                                      )
                                )
                          )
                    )
                    ( h4
                    .   
                      ,   localized
                        $ ( "Tools repelling another tool by 'smell'"
                            "V√¶rkt√∏jer som frast√∏der et andet v√¶rkt√∏j med 'lugtmarkering'"
                          )
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "Some tools should never occur in the same workflow design. For example, two Optical Character Recognition systems will, in general, output different numbers of tokens when given the same input, e.g. bacause one system sees white space where the other does not."
                            "Nogle v√¶rkt√∏jer b√∏r aldrig forekomme i den samme arbejdsgang. For eksempel vil to OCR-programmer (OCR=Optical Character Recognition) n√¶sten altid v√¶re uenige om antallet af ord i inputtet fordi det ene v√¶rkt√∏j ser blanktegn hvor det andet ikke g√∏r."
                          )
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "In the Text Tonsorium, tools that should not co-occur can be given a value for a 'smell' feature that spreads throughout the workflow. If two different smells collide, the workflow design is discarded."
                            "Text Tonsorium kan give forskellige v√¶rdier for et 'lugt'-attribut til v√¶rkt√∏jer som ikke passer sammen. Lugten spr√¶der sig gennem arbejdsgangen, men hvis den st√∏der in i en anden lugt, bliver arbejdsgangen kasseret."
                          )
                    )
                    ( h2
                    .   
                      , ( a
                        .   (id.UIflow) (name.UIflow)
                          , !UIflowTitle
                        )
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "The Text Tonsorium may compose many workflows that all lead to your goal. It will then ask you to choose one of the proposed workflows. In general, the more detail you add to your goal, the fewer solutions the Text Tonsorium will find, even zero. "
                            "Ofte beregner Text Tonsorium mange workflows, som alle f√∏rer til dit m√•l, og s√• skal du v√¶lge en af disse. Som tommelfingerregel g√¶lder det at hvis du udtrykker dit m√•l i flere detaljer, vil der v√¶re f√¶rre forslag til workflows, og m√•ske endda ingen."
                          )
                    )
                    ( dl
                    .   
                      ,   (dt.,"1: " localized$Upload)
                          ( dd
                          .   
                            ,     localized
                                $ ( "You can upload your input in three ways:"
                                    "Du kan uploade din tekst p√• tre m√•der:"
                                  )
                                ( dl
                                .   
                                  ,   ( dt
                                      .   
                                        ,   localized
                                          $ ("file upload" "fil upload")
                                      )
                                      ( dd
                                      .   
                                        ,     localized
                                            $ ( "Text Tonsorium can handle many different input formats."
                                                "Text Tonsorium kan h√•ndtere mange forskellige inputformater."
                                              )
                                            (br.,)
                                              localized
                                            $ ( "You are not limited to uploading a single file. We have done batches of over 100 files."
                                                "Du er ikke begr√¶nset til upload af en enkel fil. Vi har gode erfaringer med grupper med over 100 filer."
                                              )
                                      )
                                      (dt.,localized$("via URL" "via URL"))
                                      ( dd
                                      .   
                                        ,   localized
                                          $ ( "You can enter a list of URLs. Notice that some web pages require JavaScript to be active in the browser. Such webpages cannot be fetched successfully."
                                              "Du kan give en liste af URLer. Bem√¶rk at nogle websider kr√¶ver at JavaScript er aktiveret i din browser. S√•danne sider kan ikke hentes af Text Tonsorium."
                                            )
                                      )
                                      ( dt
                                      .   
                                        , localized$("direct typing" skrive)
                                      )
                                      ( dd
                                      .   
                                        ,   localized
                                          $ ( "You can type in a text"
                                              "Du kan skrive en tekst."
                                            )
                                      )
                                )
                          )
                          ( dt
                          .   
                            ,   "2: "
                                  localized
                                $ ("Specify what you want" "Fort√¶l hvad du vil")
                          )
                          (dd.,Input)
                          (dd.,localized$(Goal M√•l))
                          ( dt
                          .   
                            ,   "3: "
                                  localized
                                $ ("Select a workflow" "V√¶lg en arbejdsgang")
                          )
                          ( dt
                          .   
                            ,   "4: "
                                  localized
                                $ ( "Launch the selected workflow"
                                    "Start den valgte arbejdsgang"
                                  )
                          )
                          ( dt
                          .   
                            ,   "5: "
                                  localized
                                $ ( "Inspect/download results"
                                    "Inspicer/Hent resultater"
                                  )
                          )
                    )
                    ( h2
                    .   
                      , ( a
                        .   (id.features) (name.features)
                          , !featuresTitle
                        )
                    )
                    ( p
                    .   
                      ,     localized
                          $ ( "Data streams, but also the input and output specifications of tools, are described in terms of 'features'. "
                              "Datastr√∏mme, men ogs√• et v√¶rkt√∏js input- og outputspecifikationer, bliver beskrevet ved hj√¶lp af 'tr√¶k'. "
                            )
                            localized
                          $ ( "Features express things such as the language used in a text, file format, and the type of content."
                              "Tr√¶k beskriver ting som sproget som er anvendt i en text, filformat, og indholdstype."
                            )
                          (br.,)
                            localized
                          $ ( "Users are confronted with features and feature values when they specify the goal of a workflow design. "
                              "Brugere bliver konfronteret med tr√¶k og tr√¶kv√¶rdier n√•r de specificerer m√•let for en arbejdsgang. "
                            )
                            localized
                          $ ( "There is a second level of feature specification, a level that users normally aren't bothered with: "
                              "Der findes et andet niveau i tr√¶kspecifikationen, et niveau som brugeren normalt ikke skal bekymre sig om: "
                            )
                            localized
                          $ ( "feature values can be further specified with 'style descriptors'. "
                              "tr√¶kv√¶rdier kan blive beriget med 'stilindikatorer'. "
                            )
                          (br.,)
                            localized
                          $ ( "Feature values and style descriptors are always chosen from predefined sets of values, using drop down lists. "
                              "Tr√¶kv√¶rdier og stilindikatorer skal altid v√¶lges fra foruddefinerede v√¶rdiklasser. Det sker ved hj√¶lp af dropdownlister. "
                            )
                    )
                    ( p
                    .   
                      ,   localized
                        $ ( "This is the list of features that currently is defined in this instance of Text Tonsorium:"
                            "Dette er listen over tr√¶k som anvendes i denne version af Text Tonsorium:"
                          )
                    )
                    ( dl
                    .   
                      ,   map
                        $ ( ( 
                            =   n d t
                              .     !arg
                                  : ( 
                                    .   ? (name.?n) ?
                                      : ? (description.?d) ?
                                      : ? (table.?t) ?
                                    )
                                &   ( dt
                                    .   
                                      , ( a
                                        .   (href.str$("#" !t))
                                          , localized$!n
                                        )
                                    )
                                    (dd.,localized$!d)
                            )
                          . !feats
                          )
                    )
                      map
                    $ ( ( 
                        =   n t s sT description
                          .     !arg
                              : ( 
                                .   ? (name.?n) ?
                                  : ? (table.?t) ?
                                  : ? (short.?s) ?
                                  : ( ? (specificationTable.?sT) ?
                                    | ?&:?sT
                                    )
                                  : ? (description.?description) ?
                                )
                            & readTable$!t
                            &   ( a
                                .   (id.!t) (name.!t)
                                  , (h3.,localized$!n)
                                )
                                (p.,localized$!description)
                                ( dl
                                .   
                                  ,   map
                                    $ ( ( 
                                        =   n d a p f
                                          .   !arg:(?n.?a.?d)
                                            & (     !cumfeat
                                                  : ( 
                                                    | ?+!s\L(?*!a^?p*?)+?
                                                    )
                                                &   (dt.,localized$!n)
                                                    ( !d:
                                                    | (dd.,localized$!d)
                                                    )
                                                    (     !sT
                                                        :   ?
                                                            (? !a ?.?f)
                                                            ?
                                                      & readTable$!f
                                                      & ( dd
                                                        .   
                                                          , ( dl
                                                            .   
                                                              ,   map
                                                                $ ( ( 
                                                                    =     full
                                                                          short
                                                                          dsc
                                                                      .       !arg
                                                                            : ( ?full
                                                                              . ?short
                                                                              . ?dsc
                                                                              )
                                                                          &   !cumfeat
                                                                            : ( 
                                                                              |   ?
                                                                                +   !s
                                                                                  \L ( ?
                                                                                    *   !a
                                                                                      ^ ( ?
                                                                                        +   ?
                                                                                          * !short
                                                                                          * ?
                                                                                        + ?
                                                                                        )
                                                                                    * ?
                                                                                    )
                                                                                + ?
                                                                              )
                                                                          &   ( dt
                                                                              .   
                                                                                ,   localized
                                                                                  $ !full
                                                                              )
                                                                              ( dd
                                                                              .   
                                                                                ,   localized
                                                                                  $ !dsc
                                                                              )
                                                                        | 
                                                                    )
                                                                  . !!f
                                                                  )
                                                            )
                                                        )
                                                    | 
                                                    )
                                              | 
                                              )
                                        )
                                      . !!t
                                      )
                                )
                        )
                      . !feats
                      )
                    ( h2
                    .   
                      , ( a
                        .   (id.tools) (name.tools)
                          , !toolsTitle
                        )
                    )
                    (p.,blbla)
                    ( table
                    .   
                      ,   ( thead
                          .   
                            ,   (th.,"#")
                                (th.,"Name of the tool")
                                (th.,"Supported languages")
                          )
                          ( tbody
                          .   
                            ,   map
                              $ ( ( 
                                  =   Title
                                    .     !arg
                                        : ( ?
                                          .   ? (Title.?Title) ?
                                            : ? (ToolID.?ToolID) ?
                                          )
                                      & ( tr
                                        .   
                                          ,   ( td
                                              . ,!toolNr+1:?toolNr
                                              )
                                              ( td
                                              .   
                                                , ( a
                                                  .   ( href
                                                      . str$("#" !ToolID)
                                                      )
                                                    , !Title
                                                  )
                                              )
                                              (td.,langlist$!ToolID)
                                        )
                                  )
                                . !tools
                                )
                          )
                    )
                      map
                    $ ( ( 
                        =   Description ToolID Title
                          .       !arg
                                : ( ?
                                  .   ? (ToolID.?ToolID) ?
                                    : ? (Title.?Title) ?
                                    : ? (Description.?Description) ?
                                  )
                              &   ( a
                                  .   (id.!ToolID) (name.!ToolID)
                                    , (h3.,!Title)
                                  )
                                  (p.,!Description)
                            | 
                        )
                      . !tools
                      )
                )
              )
      )
      "
/**
 * cleanup
 *
 * Delete all references to files that no longer exist.
 * Argument: a list of the files that still exist in the Staging area.
 * Affected tables:
 *      Uploads.table
 *      jobs.table
 *      CTBs.table
 *      relations.table
 *      jobAbout.table 
 *
 * Called from cleanup.java
 */"
      ( cleanup
      =     jobNr jobID jobstatus files toolURL parms file
          , A Z a z F deleteDependingJobs existingFiles
          , feats item meta nr stagingName
        .   ( deleteDependingJobs
            =     A Z jobNr locJobs
                , file files jobID jobstatus parms toolURL
              .   !arg:(?arg.?locJobs)
                &   whl
                  ' (   !locJobs
                      :   ?A
                          ( ?jobNr
                          . %?jobID ?jobstatus
                          . ? !arg ?
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                          ?Z
                    & deleteDepending$(!jobNr.!jobID)
                    &     map
                        $ ( ( 
                            =   
                              .       !arg
                                    : ( !jobNr
                                      . %?jobID ?jobstatus
                                      . ?files
                                      . ?toolURL
                                      . ?parms
                                      . ?file
                                      )
                                  & deleteDepending$(!jobNr.!jobID)
                                  & 
                                | !arg
                            )
                          . !A !Z
                          )
                      : ?locJobs
                    )
                & !locJobs
            )
          & log$(cleanup !arg)
          & readTable$ItemGroupsCache
          & readTable$Uploads
          & readTable$jobs
          & readTable$CTBs
          & (NORELATIONSFILES|readTable$relations)
          & readTable$jobAbout
          & !arg:?existingFiles
          &   ( 
              =   existingFiles zippedresults
                .   !arg:?existingFiles
                  & readTable$zippedresults
                  &     map
                      $ ( ( 
                          =   
                            .     !existingFiles:? !arg ?
                                & !arg
                              | 
                          )
                        . !zippedresults
                        )
                    : ?zippedresults
                  & saveTable$zippedresults
              )
            $ !existingFiles
          &     map
              $ ( ( 
                  =   
                    .       !arg
                          : ( ?
                            .   ?
                                ( ?
                                .   ?
                                    ( %@?item
                                    &   !Uploads
                                      : ( ~(? (?.!item.?) ?)
                                        |   ?
                                            ( ?
                                            . !item
                                            .   ?stagingName
                                              & ~( !existingFiles
                                                 : ? !stagingName ?
                                                 )
                                            . ?
                                            )
                                            ?
                                        )
                                    )
                                    ?
                                )
                                ?
                            )
                        & 
                      | !arg
                  )
                . !ItemGroupsCache
                )
            : ?ItemGroupsCache
          &     map
              $ ( ( 
                  =   
                    .   !arg:(?nr.?item.?stagingName.?meta.?feats)
                      & (   ~(!existingFiles:? !stagingName ?)
                          &     map
                              $ ( ( 
                                  =   
                                    .       !arg
                                          : (?.? (?.? !item ?) ?)
                                        & 
                                      | !arg
                                  )
                                . !ItemGroupsCache
                                )
                            : ?ItemGroupsCache
                          &   deleteDependingJobs$(!stagingName.!jobs)
                            : ?jobs
                          & 
                        | !arg
                        )
                  )
                . !Uploads
                )
            : ?Uploads
          &     map
              $ ( ( 
                  =   
                    .     !arg
                        : ( ?jobNr
                          . %?jobID ?jobstatus
                          . ?files
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                      & (   (   !files
                              :   ?
                                  ( %@?F
                                  & ~(!existingFiles:? !F ?)
                                  )
                                  ?
                            | ~(!existingFiles:? !file ?)
                            )
                          & deleteDepending$(!jobNr.!jobID)
                          & 
                        | !arg
                        )
                  )
                . !jobs
                )
            : ?jobs
          &   whl
            ' (   !CTBs
                :   ?a
                    ( (?jobNr.?jobID.?)
                    & ~(!jobs:? (!jobNr.!jobID ?.?) ?)
                    )
                    ?z
              & !a !z:?CTBs
              )
          & ( NORELATIONSFILES
            |   whl
              ' (   !relations
                  :   ?a
                      ( (?jobNr.?jobID.?)
                      & ~( !jobs
                         : ? (!jobNr.!jobID ?.?) ?
                         )
                      )
                      ?z
                & !a !z:?relations
                )
            )
          &   whl
            ' (   !jobAbout
                :   ?a
                    ( (?jobNr.?)
                    & ~(!jobs:? (!jobNr.?) ?)
                    )
                    ?z
              & !a !z:?jobAbout
              )
          & saveTable$Uploads
          & saveTable$jobs
          & saveTable$CTBs
          & (NORELATIONSFILES|saveTable$relations)
          & saveTable$jobAbout
          & saveTable$ItemGroupsCache
      )
      "
/*
 * stresstest
 *
 * Do a computation that occupies Bracmat for several seconds.
 * Usage: activate the stresstest from several browsers at
 * about the same time, so they have to queue up and wait for
 * the previous to finish.
 *
 * Purpose: check that the transition from Java's multiple threads
 * to the Bracmat JNI's single thread and back goes smooth.
 *
 * Input: a HTTP-parameter 'stress' with a numerical value > 0.
 *
 * The function computes the first 'stress' terms in the decimal 
 * approximation of œÄ.
 *
 * Called from stresstest.java
 */"
      ( stresstest
      =   PI err pi
        .     ( pi
              =   s1,s2,isgn,isgn1,err1,err2,i,j
                .   0:?s1
                  & 1:?isgn
                  & 1:?i
                  &   whl
                    ' ( !i:~>!arg
                      & 2*!i+-1:?j
                      & !s1+!isgn*(!j*5^!j)^-1:?s1
                      & -1*!isgn:?isgn
                      & 1+!i:?i
                      )
                  & 16*((2*!arg+1)*5^(2*!arg+1))^-1:?err1
                  & !isgn:?isgn1
                  & 16*!s1:?s1
                  & 0:?s2
                  & 1:?isgn
                  & 1:?i
                  &   whl
                    ' ( 2*!i+-1:?j
                      & (!j*239^!j)^-1:?err2
                      & 4*!err2:>!err1
                      & !s2+!isgn*!err2:?s2
                      & -1*!isgn:?isgn
                      & 1+!i:?i
                      )
                  & flt$(!isgn1*(!err1+4*!err2),2):?err
                  & !s1+-4*!s2
              )
            &   !arg
              : ? (stress.~/#?arg:>0:<1001) ?
            & (readTable$pies|:?pies)
            & pi$!arg:?PI
            & !pies (!arg.!PI !err):?pies
            & saveTable$pies
            &   toML
              $ ( !HTMLbodyContainer
                $ ( paragraph
                  $ ( str
                    $ ( "Your number:"
                        !arg
                        " Your approximation of pi:"
                        flt$(!PI,!arg)
                        " error "
                        !err
                      )
                    )
                  )
                )
          |   toML
            $ ( !HTMLbodyContainer
              $ (paragraph$(str$("Not understood:" !arg)))
              )
      )
      ( setLanguage
      =   A Z
        .     !arg:? (UIlanguage.?arg) ?
            & (   readTable$UIlanguage
                & (   !UIlanguage:?A !arg ?Z
                    & !arg !A !Z:?UIlanguage
                    & saveTable$UIlanguage
                    & setLang$!arg:?arg
                    &   toML
                      $ ( !HTMLbodyContainer
                        $ (paragraph$(str$("Sprog er nu sat til " !arg)))
                        )
                  |   toML
                    $ ( !HTMLbodyContainer
                      $ (paragraph$(str$("Det forstod jeg ikke:" !arg)))
                      )
                  )
              |   toML
                $ ( !HTMLbodyContainer
                  $ ( paragraph
                    $ "Table UIlanguage listing ISO codes of supported UI languages could not be read."
                    )
                  )
              )
          |   toML
            $ ( !HTMLbodyContainer
              $ (paragraph$"Expected parameter 'UIlanguage'")
              )
      )
      ( countGraphNodes
      =   count tools feats feat i o cnt tcnt fcnt tool
        .   "Unfold toolprop. Each subspecification doubles count due to specification.
             Counts 360 tools that are active (not 'inactive') 20130424"
          & readTable$toolprop
          & readTable$tooladm
          & !toolprop:?tools
          & ( count
            =   ret term spcno factor spcs
              .   0:?ret
                &   whl
                  ' ( !arg:%?term+?arg
                    & 1:?spcno
                    &   whl
                      ' ( !term
                        :   ?
                          * ( %?factor %?spcs*?term
                            &   whl
                              ' ( !spcs:% ?spcs
                                & !spcno+!spcno:?spcno
                                )
                            )
                        )
                    & !ret+!spcno:?ret
                    )
                & !ret
            )
          & 0:?cnt
          &   whl
            ' (   !tools
                :   ?
                  + (   ?tool
                      &   !tooladm
                        :   ?
                          + ( ? (ToolID.!tool) ?
                            : ? (Inactive.) ?
                            )
                          + ?
                    . ?feats
                    )
                  + ?tools
              & 1:?tcnt
              &   whl
                ' ( !feats:(?,?feat) ?feats
                  & 0:?fcnt
                  &   whl
                    ' ( !feat:(?i.?o)+?feat
                      & !fcnt+count$!i*count$!o:?fcnt
                      )
                  & !tcnt*!fcnt:?tcnt
                  )
              & !cnt+!tcnt:?cnt
              )
          & !cnt
      )
      ( countGraphNodesTool
      =   count tools feats feat i o cnt tcnt fcnt tool
        .   "Unfold toolprop. Each subspecification doubles count due to specification.
             Counts 360 tools that are active (not 'inactive') 20130424"
          & !arg:?tools
          & ( count
            =   ret term spcno fix opt,Nspc Nopt
              .   0:?ret
                &   whl
                  ' ( !arg:%?term+?arg
                    & !term:%?fix ?opt
                    & 1:?spcno
                    &   whl
                      ' ( !fix
                        :     %?
                            ^ ( ?+[?Nspc
                              &   !spcno*(!Nspc:~0|1)
                                : ?spcno
                              )
                          * ?fix
                        )
                    & 0:?Nopt
                    &   whl
                      ' ( !opt:%?^(?+[?Nspc) ?opt
                        &   (!Nspc:~0|1)+!Nopt
                          : ?Nopt
                        )
                    & !ret+!spcno*2^!Nopt:?ret
                    )
                & !ret
            )
          & 0:?cnt
          &   whl
            ' ( !tools:#?*(?tool.?feats)+?tools
              & 1:?tcnt
              &   whl
                ' ( !feats:(?,?feat) ?feats
                  & 0:?fcnt
                  &   whl
                    ' ( !feat:(?i.?o)+?feat
                      & !fcnt+count$!i*count$!o:?fcnt
                      )
                  & !tcnt*!fcnt:?tcnt
                  )
              & !cnt+!tcnt:?cnt
              )
          & !cnt
      )
      ( entry
      =   X Y
        .   setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          &   toML
            $ ( ("!DOCTYPE"." html")
                ( html
                .   (lang.!LaNg)
                  ,   ( head
                      .   
                        ,   ( meta
                            .     (http-equiv.Content-Type)
                                  (content."text/html; charset=UTF-8")
                              , 
                            )
                            ( title
                            .   
                              ,   localized
                                $ ( "Text Tonsorium - Natural Language Processing toolchains automatically composed and scheduled for you"
                                    "Text Tonsorium - automatisk sammens√¶tning og aktivering af sprogteknologiske v√¶rkt√∏jer"
                                  )
                            )
                            !StyleFront
                            ( meta
                            .     (name.description)
                                  ( content
                                  .   localized
                                    $ ( "This NLP workflow managment system automatically combines the necessary natural language processing tools to achieve your goal, in a way similar to how a trip planner computes the best route from your current position to your destination."
                                        "Dette workflow managment system kombinerer automatisk de sprogteknologiske v√¶rkt√∏jer som kan klare det m√•l du vil opn√•, p√• en m√•de som ligner hvordan en routeplanner beregner den bedste route fra din nuv√¶rende position til din destination."
                                      )
                                  )
                              , 
                            )
                      )
                      ( body
                      .   (class.bodycanvas)
                        , ( div
                          .   (class.canvasdiv)
                            ,   ( div
                                .   (class.overflowing)
                                  ,   ( div
                                      .   (class.rightfloating)
                                        , ( p
                                          .   
                                            ,   helplink$()
                                                " "
                                                changeloglink$()
                                                " "
                                                ( a
                                                .   ( href
                                                    .   str
                                                      $ ( "/texton/?UIlanguage="
                                                          dezilacol$!lANgs
                                                          "&TyPeFaCe="
                                                            queryEncode
                                                          $ ( !TyPeFaCe
                                                            | "Comic Sans MS"
                                                            )
                                                        )
                                                    )
                                                  ,   localized
                                                    $ ( UILangNames
                                                      $ (dezilacol$!lANgs)
                                                      )
                                                )
                                          )
                                      )
                                      ( div
                                      .   (class.leftfloating)
                                        , ( h1
                                          .   (class.smallmargin)
                                            ,   "Text Tonsorium "
                                                ("!--"."&#128136;")
                                                "¬†¬†¬† "
                                                ( small
                                                .   
                                                  , ( small
                                                    .   
                                                      ,   localized
                                                        $ ( "A salon de beaut√© for Natural Language Processing"
                                                            "En sk√∏nhedssalon for Sprogteknologi"
                                                          )
                                                    )
                                                )
                                          )
                                      )
                                )
                                ( div
                                .   
                                  ,   ( p
                                      .   
                                        ,   localized
                                          $ ( " Upload your input using the form on this page. On the next page you specify the desired final result - there are several annotation types, file formats, languages and other traits to choose from. The hard part - picking and orchestrating the Natural Language Processing tools that are needed to achieve your goal - is handled by this service. "
                                              "Upload dit input ved hj√¶lp af formularen p√• denne side. P√• n√¶ste side specificerer du dit m√•l - der er adskillige indholdstyper, filformater, sprog og andre tr√¶k at v√¶lge imellem. Det sv√¶re - at finde og orkestrere de sprogteknologiske v√¶rkt√∏jer som er n√∏dvendige for at opn√• dit m√•l - bliver h√•ndteret af denne service."
                                            )
                                      )
                                      ( form
                                      .     (enctype.multipart/form-data)
                                            (method.post)
                                            (action.specifyGoal)
                                            (class.formRounded)
                                        , ( fieldset
                                          .   (class.topmargin)
                                            ,   ( legend
                                                .   (class.firstpage)
                                                  ,   localized
                                                    $ ( "Upload input"
                                                        "Upload input"
                                                      )
                                                )
                                                ( div
                                                .   (class.fileupload)
                                                  ,   ( label
                                                      .     (for.inp)
                                                            (class.firstpage)
                                                        ,   localized
                                                          $ ( "Select one or more files"
                                                              "Selekt√©r en eller flere filer"
                                                            )
                                                      )
                                                      ( input
                                                      .     (type.file)
                                                            (name.input)
                                                            (id.inp)
                                                            (size.50)
                                                            ( multiple
                                                            . multiple
                                                            )
                                                        , 
                                                      )
                                                )
                                                ( p
                                                .   (class.smallmargin)
                                                  , ( strong
                                                    .   
                                                      , ( small
                                                        .   
                                                          ,   localized
                                                            $ ( "... or ..."
                                                                "... eller ..."
                                                              )
                                                        )
                                                    )
                                                )
                                                ( div
                                                .   (class.URLs)
                                                  ,   ( label
                                                      .     (for.area)
                                                            (class.firstpage)
                                                        ,     localized
                                                            $ ( "Enter addresses of web pages,"
                                                                "Indtast adresser af websider,"
                                                              )
                                                            (br.,)
                                                              localized
                                                            $ ( "one URL per line, each starting with http:// or https://"
                                                                "√©n URL pr. linje, startende med http:// eller https://"
                                                              )
                                                      )
                                                      ( textarea
                                                      .     (name.URLS)
                                                            (rows.3)
                                                            (cols.68)
                                                            (id.area)
                                                        , 
                                                      )
                                                )
                                                ( p
                                                .   (class.smallmargin)
                                                  , ( strong
                                                    .   
                                                      , ( small
                                                        .   
                                                          ,   localized
                                                            $ ( "... or ..."
                                                                "... eller ..."
                                                              )
                                                        )
                                                    )
                                                )
                                                ( div
                                                .   (class.typein)
                                                  ,   ( label
                                                      .     (for.free)
                                                            (class.firstpage)
                                                        ,   localized
                                                          $ ( "Type or copy and paste some text"
                                                              "Skriv eller kopi√©r tekst"
                                                            )
                                                      )
                                                      ( textarea
                                                      .     (name.text)
                                                            (rows.3)
                                                            (cols.68)
                                                            (id.free)
                                                        , 
                                                      )
                                                )
                                                ( div
                                                .   (class.topmargin)
                                                  ,   ( label
                                                      .   (class.firstpage)
                                                        ,   localized
                                                          $ ( "Next step: "
                                                              "N√¶ste trin: "
                                                            )
                                                      )
                                                      ( input
                                                      .     (type.submit)
                                                            ( value
                                                            .   localized
                                                              $ ( "Specify the required result"
                                                                  "Specificer m√•l"
                                                                )
                                                            )
                                                        , 
                                                      )
                                                )
                                                ( input
                                                .     (type.hidden)
                                                      (name.UIlanguage)
                                                      ( value
                                                      . localized$!lANgs
                                                      )
                                                  , 
                                                )
                                                ( input
                                                .     (type.hidden)
                                                      (name.TyPeFaCe)
                                                      (value.!TyPeFaCe)
                                                  , 
                                                )
                                                ( input
                                                .     (type.hidden)
                                                      (name.action)
                                                      (value.batch)
                                                  , 
                                                )
                                          )
                                      )
                                      ( p
                                      .   (class.indent)
                                        , ( small
                                          .   
                                            ,     localized
                                                $ ( "Find the most recent source code of the Text Tonsorium on "
                                                    "Find den seneste version af kildekoden af Text Tonsorium p√• "
                                                  )
                                                ( a
                                                .   ( href
                                                    . "https://github.com/kuhumcst/texton"
                                                    )
                                                  , GitHub
                                                )
                                                  localized
                                                $ ( ", where you can also contact us. "
                                                    ". Der kan du ogs√• kontakte os."
                                                  )
                                          )
                                      )
                                      ( p
                                      .   (class.indent)
                                        , ( small
                                          .   
                                            ,   localized
                                              $ ( "This service is free for small amounts of text. Do not send sensitive data to this service and use it at your own risk! "
                                                  "Brug denne side for sm√• m√¶ngder af tekst. Upload aldrig f√∏lsomme data. Brugen af tjenesten er p√• egen risiko!"
                                                )
                                          )
                                      )
                                      ( p
                                      .   (class.indent)
                                        , ( small
                                          .   
                                            ,     localized
                                                $ ( "Change typeface to "
                                                    "Skift skrifttype til "
                                                  )
                                                ( a
                                                .   ( href
                                                    .   str
                                                      $ ( "/texton/?UIlanguage="
                                                          !LaNg
                                                          "&TyPeFaCe="
                                                            queryEncode
                                                          $ (     !TyPeFaCe
                                                                : "Comic Sans MS"
                                                              & sans-serif
                                                            | "Comic Sans MS"
                                                            )
                                                        )
                                                    )
                                                  ,       !TyPeFaCe
                                                        : "Comic Sans MS"
                                                      & sans-serif
                                                    | "Comic Sans MS"
                                                )
                                                ". "
                                                localized$("Why " "Hvorfor ")
                                                ( a
                                                .   ( href
                                                    . "https://theestablishment.co/hating-comic-sans-is-ableist-bc4a4de87093/"
                                                    )
                                                  , "Comic Sans"
                                                )
                                                "? "
                                          )
                                      )
                                      readTable$footer
                                )
                          )
                      )
                )
              )
      )
      (Uploads=)
      (LaNg=)
      (lANgs=en da)
  : ?Globals
& (setLang$da|);

r=
  get'"toolsProg.bra"
& rmv$"toolsProg.bak"
& ren$("toolsProg.bra"."toolsProg.bak")
&   put
  $ ( "{toolsProg.bra


    Copyright 2014, Bart Jongejan
    This file is part of the DK-ClarinTools.

    DK-ClarinTools is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    DK-ClarinTools is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with DK-ClarinTools.  If not, see <http://www.gnu.org/licenses/>.





Source code for DK-Clarin tools webservice 

To neatly re-format this source code, load the file in a running instance of
Bracmat:

    get$\"toolsprog.bra\"
    
Now, after you have made changes to the source code in a text editor, reload
the source code in Bracmat using the command:

    !r

This command re-reads the file, renames the previous version from toolsprog.bra
to toolsprog.bak and then saves the source code. Some editors will notice that
the text has changed on disk and offer you to reload the source code.

To change the comment near the start of this file, you need to go to the bottom
of the file and find the text there. A change made to that text takes effect
after saving once and pressing !r two times. Remember to escape quotes \" with
a backslash \\. Comments elsewhere (i.e. text enclosed by braces { and } is NOT
saved. Use string expressions if you want a comment somewhere.

The following commands can be issued by sending an 'expression' HTTP parameter
to the 'bracmatevaluator' servlet.

To get started from a file containing all tables called 'alltablesxxx' (replace
xxx with actual characters in the file name), e.g., alltables.GPL:

importTables$\"alltables.GPL\"

This reads the named file and stores each table in a separate file in a folder
structure
work/
    job/
    meta/
        feature/
        style/

(This folder structure must already exist.) Finally, the same file is
rewritten, so all lay-out is normalized (Bracmat style).
This command reads all single file tables from the folder structure and saves
them to 'alltablesxxx'. The command knows the actual name of the file to write
to because that name is stored in the variable AAA, which is itself stored
alongside all tables, and is therefore known after the last time 
importTables$alltablesxxx was called. It is possible to change context by
reading an 'alltablesyyy' that is different from 'alltablesxxx'.

If <prod> is the empty string \"\", then the table tooladm is anonymized by 
changing all domains in service URLs \"http:\\localhost\" and by changing all
contact emails to \"x@x.xxx\".

To export all tables to a different file, do

exportTables$(<prod>.\"alltableszzz\")

where alltableszzz must be a valid file name that starts with 'alltables'.



To do a clean up, removing almost all that is not defined in this file from 
Bracmat's memory, call the clean function

    clean$
    
Changes made to table files take immediately effect. It is advised to use the
admin page to register new tools. Some changes cannot be made using the admin
page, such as adding a new feature or feature value.
    
Server:
Add following line to /etc/httpd/conf.d/proxy_ajp.conf:
    ProxyPass /toolsdata !
(Restart Apache sudo /etc/init.d/httpd restart)
    
Make sure bracmat is in JBoss's or Tomcat PATH:
    /usr/lib/libbracmat.so -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1 -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1.0

The conf/properties.xml file has an entry \"toolsHome\". The value of this entry
is the location of this file, toolsprog.bra.
}

"
    , "toolsProg.bra"
    , NEW BIN
    )
& lst'(toolsProg,"toolsProg.bra",APP BIN)
& put'(\n,"toolsProg.bra",APP BIN)
& lst'(r,"toolsProg.bra",APP BIN);
