{corenlpx.bra

Transform Clarin token/segment annotation to plain text, one sentence per line. Run CoreNLP.
Output JSON.
}

X=
  ( doit
  =     output tmp1 tmp2 A B C D E F G H formatO
      , xmlseg xmltok lang language properties period
      , cor lem mrf ner pos seg snt stc stx tok
    .   ( turnTEIP5intoPlain
        =   
          .   !arg:(?inputtok.?inputseg)
            &   !inputseg
              :   ( span
                  .     ? (from.@(?:"#" ?fr)) ?
                      : ? (to.@(?:"#" ?to)) ?
                      : ? ("xml:id".?Sid) ?
                    , 
                  )
                  ?inputseg
            & :?sep
            &   map
              $ ( ( 
                  =   
                    .     !arg
                        : ( span
                          .     ? (from.?from) ?
                              : ? ("xml:id".?Tid) ?
                            , ?word
                          )
                      &   !sep
                          ( (   !Tid:!to
                              & 1:?wno
                              & \n:?sep
                              &   !inputseg
                                :   ( span
                                    .     ? (from.@(?:"#" ?fr)) ?
                                        : ? (to.@(?:"#" ?to)) ?
                                        : ? ("xml:id".?Sid) ?
                                      , 
                                    )
                                    ?inputseg
                            |   1+!wno:?wno
                              & :?sep
                            )
                          & !word
                          )
                          " "
                  )
                . !inputtok
                )
        )
      & ( turnJSONintoTEIP5
        =   s segid sentnr S L P tfrom tto
          .   !arg:?json
            & !json:((sentences.,?sentences),)
            & ( TEI
              .   (xmlns."http://www.tei-c.org/ns/1.0")
                ,   (teiHeader.,)
                    ( text
                    .   
                      ,   ( spanGrp
                          .   (ana.lemma)
                            ,   map
                              $ ( ( 
                                  =   
                                    .   !arg:(?tid.?lemma.?pos.?mrf.?to.?h)
                                      & (span.(from.str$("#" !tid)),!lemma)
                                  )
                                . !conllT
                                )
                          )
                          ( spanGrp
                          .   (ana.pos)
                            ,   map
                              $ ( ( 
                                  =   
                                    .   !arg:(?tid.?lemma.?pos.?mrf.?to.?h)
                                      & (span.(from.str$("#" !tid)),!pos)
                                  )
                                . !conllT
                                )
                          )
                          ( spanGrp
                          .   (ana.morphology)
                            ,   map
                              $ ( ( 
                                  =   
                                    .   !arg:(?tid.?lemma.?pos.?mrf.?to.?h)
                                      & (span.(from.str$("#" !tid)),!mrf)
                                  )
                                . !conllT
                                )
                          )
                          ( spanGrp
                          .   (ana.syntax)
                            ,   map
                              $ ( ( 
                                  =   
                                    .   !arg:(?tid.?lemma.?pos.?mrf.?to.?h)
                                      & ( span
                                        .   (from.str$("#" !tid))
                                          ,   (     !to
                                                  : (0|)
                                                & 
                                              | ( link
                                                . (target.str$("#" !to)),
                                                )
                                              )
                                              (term.,str$("ud-syn:" !h))
                                        )
                                  )
                                . !conllT
                                )
                          )
                    )
              )
        )
      & (trim=.str$(vap$(.!arg." ")))
      & ( getProperties
        =     file javaProperties extra
            , cor lem mrf ner pos seg snt stc stx tok
            , transl lang filter ftr
          .     !arg
              : ( ?file
                . ?extra
                . ?cor,?lem,?mrf,?ner,?pos,?seg,?snt,?stc,?stx,?tok
                . ?lang
                )
            &     (tokenize.tok)
                  ("cdc_tokenize".tok)
                  (cleanxml.)
                  (ssplit.seg)
                  (pos.pos)
                  (lemma.lem)
                  (ner.ner)
                  (parse.stc)
                  (depparse.stx)
                  (coref.cor)
                  (natlog.)
                  (openie.)
                  (kbp.)
                  (entitylink.ner)
                  (sentiment.snt)
                  (quote.)
                  (mwt.tok)
              : ?transl
            & get$(!file,STR):?javaProperties
            & put$(!javaProperties,javaProperties,NEW)
            &   (     mop
                    $ ( 
                      .   vap
                        $ ( ( 
                            =   
                              .   @(!arg:"#" ?)&
                                |   @( !arg
                                     : (?prop "=" ?val|?prop ":" ?val)
                                     )
                                  & trim$!prop:?prop
                                  & trim$!val:?val
                                  & (   !prop:annotators
                                      &     mop
                                          $ ( 
                                            .     vap
                                                $ ( ( 
                                                    =   
                                                      .     (   !transl
                                                              :   ?
                                                                  ( !arg
                                                                  .   ?tt
                                                                    &   !!tt
                                                                      : 1
                                                                  )
                                                                  ?
                                                            |   !lang:zh
                                                              &   !arg
                                                                : lemma
                                                              & "lemma is no-op for Chinese but currently needed because coref demands it (bad old requirements system)"
                                                            )
                                                          & !arg
                                                        | 
                                                    )
                                                  . !val
                                                  . ","
                                                  )
                                              : ?filter
                                            . (=a b)
                                            . (=,)
                                            )
                                        : ?val
                                    |   @(!prop:?ftr "." ?)
                                      & put$(!ftr \n,filter,APP)
                                      & put$(!filter \n,filter,APP)
                                      &     (     !lang
                                                : (ar|zh)
                                              & segment
                                            | 
                                            )
                                            !filter
                                        : ? !ftr ?
                                    )
                                  & (!prop..str$!val)
                                | 
                            )
                          . !javaProperties
                          . \n
                          )
                      . (=a b)
                      . (=+)
                      )
                  + !extra
                , 
                )
              : ?jsonProperties
            & lst$(jsonProperties,jsonProperties0,NEW)
            & jsn$!jsonProperties:?jsonProperties
            & put$(!jsonProperties,jsonProperties,NEW)
            & !jsonProperties
        )
      & ( percentencode
        =   c prc reserved
          .   ( prc
              =   
                .     @(!arg:%@?c ?arg)
                    &   (   !c:"+"
                          & "%2B is decoded to a space, presumably because percent decoding is done a second time somewhere. The solution is a hack: Percent encoding the %!"
                          & "%25"
                        | "%"
                        )
                        d2x$(asc$!c)
                        prc$!arg
                  | 
              )
            &   str
              $ ( vap
                $ ( ( 
                    =   
                      .     ( !('("-" "." "_" "~":? ()$arg ?))
                            |   !arg
                              : (~<A:~>Z|~<a:~>z)
                            )
                          & !arg
                        | prc$!arg
                    )
                  . !arg
                  )
                )
        )
      & ( transform
        =     Tokenized/SegmentedPlainText tmp1 tmp2 formatO lang language properties period
            , cor lem mrf ner pos seg snt stc stx tok
          .     !arg
              : ( ?formatO
                . ?lang
                . ?language
                . ?properties
                . ?period
                . ?Tokenized/SegmentedPlainText
                . ?tmp1
                . ?tmp2
                . ?cor
                . ?lem
                . ?mrf
                . ?ner
                . ?pos
                . ?seg
                . ?snt
                . ?stc
                . ?stx
                . ?tok
                )
            & put$(!Tokenized/SegmentedPlainText,!tmp1,NEW)
            & put$(!Tokenized/SegmentedPlainText,tmp1,NEW)
            & put$(!properties,properties,NEW)
            &     getProperties
                $ ( !properties
                  . (outputFormat..json)+(timeout..500000)
                  . !cor,!lem,!mrf,!ner,!pos,!seg,!snt,!stc,!stx,!tok
                  . !lang
                  )
              : ?properties
            & put$(!properties,properties2,NEW)
            &     str
                $ ( "wget --post-file "
                    !tmp1
                    " 'http://localhost:9000/?properties="
                    percentencode$!properties
                    "' -O "
                    !tmp2
                    " --"
                  )
              : ?command
            & put$(str$!command,command,NEW,BIN)
            & sys$!command
            & ( !formatO:jsn&get$(!tmp2,STR)
              |   get$(!tmp2,JSN):?json
                & lst$(json,json,NEW)
                & turnJSONintoTEIP5$!json
              )
        )
      &   !arg
        : ( ?formatO
          . ?lang
          . ?language
          . ?properties
          . ?period
          . ?inputtok
          . ?inputseg
          . ?output
          . ?tmp1
          . ?tmp2
          . ?cor
          . ?lem
          . ?mrf
          . ?ner
          . ?pos
          . ?seg
          . ?snt
          . ?stc
          . ?stx
          . ?tok
          )
      &   put
        $ (   formatO
              !formatO
              lang
              !lang
              language
              !language
              properties
              !properties
              inputtok
              !inputtok
              inputseg
              !inputseg
              cor
              !cor
              lem
              !lem
              mrf
              !mrf
              ner
              !ner
              pos
              !pos
              seg
              !seg
              snt
              !snt
              stc
              !stc
              stx
              !stx
              tok
              !tok
          , Lang
          , NEW
          , BIN
          )
      & (get$"langtable.bra":?langtable|)
      &   (   @(!inputseg:?format "/")
            & ( !format:flat&get$(!inputtok,STR)
              |     nestML$(get$(!inputtok,X ML TRM))
                  : ? (spanGrp.?,?xmlsent) ?
                &   str
                  $ ( map
                    $ ( ( 
                        =   
                          .   !arg:(?.?,?arg)&!arg \n
                            | 
                        )
                      . !xmlsent
                      )
                    )
              )
          |     nestML$(get$(!inputtok,X ML TRM))
              : ? (spanGrp.?,?xmltok) ?
            &   nestML$(get$(!inputseg,X ML TRM))
              : ? (spanGrp.?,?xmlseg) ?
            & str$(turnTEIP5intoPlain$(!xmltok.!xmlseg))
          )
        : ?Tokenized/SegmentedPlainText
      & lst$(Tokenized/SegmentedPlainText,TokenizedSegmentedPlainText,NEW)
      &     transform
          $ ( !formatO
            . !lang
            . !language
            . !properties
            . !period
            . !Tokenized/SegmentedPlainText
            . !tmp1
            . !tmp2
            . !cor
            . !lem
            . !mrf
            . !ner
            . !pos
            . !seg
            . !snt
            . !stc
            . !stx
            . !tok
            )
        : ?jsonable
      & put$(!jsonable,!output,NEW)
  )
  ( new
  =   
    .   ~
      |     ( arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            )
          : ( ?formatO
            . ?lang
            . ?language
            . ?properties
            . ?period
            . ?inputtok
            . ?inputseg
            . ?output
            . ?tmp1
            . ?tmp2
            . ?cor
            . ?lem
            . ?mrf
            . ?ner
            . ?pos
            . ?seg
            . ?snt
            . ?stc
            . ?stx
            . ?tok
            )
        &   (its.doit)
          $ ( !formatO
            . !lang
            . !language
            . !properties
            . !period
            . !inputtok
            . !inputseg
            . !output
            . !tmp1
            . !tmp2
            . !cor
            . !lem
            . !mrf
            . !ner
            . !pos
            . !seg
            . !snt
            . !stc
            . !stx
            . !tok
            )
  );

r=
  get'("corenlpx.bra",TXT)
& rmv$(str$(corenlpx ".bak"))
& ren$("corenlpx.bra".str$(corenlpx ".bak"))
&   put
  $ ( "{corenlpx.bra

Transform Clarin token/segment annotation to plain text, one sentence per line. Run CoreNLP.
Output JSON.
}

"
    , "corenlpx.bra"
    , NEW
    , BIN
    )
& lst'(X,"corenlpx.bra",APP,BIN,WYD)
& put'(\n,"corenlpx.bra",APP,BIN)
& lst'(r,"corenlpx.bra",APP,BIN,WYD)
& put$(str$("\nnew'" X ";\n"),"corenlpx.bra",APP,BIN)
& ;

new'X;
