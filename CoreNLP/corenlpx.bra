{corenlpx.bra

Transform Clarin token/segment annotation to plain text, one sentence per line. Run CoreNLP.
Output JSON or TEI-P5.
}

X=
  ( turnJSONintoTEIP5
  =     cor lem mrf ner pos seg sent snt stc stx tok
      ,   spanGrpTok
          spanGrpSent
          spanGrpSnt
          spanGrpSeg
          spanGrpMrf
          spanGrpNer
          spanGrpLemma
          spanGrpCor
          spanGrpPos
          spanGrpStc
          spanGrpSyn
    .   !arg:(?json.?cor,?lem,?mrf,?ner,?pos,?seg,?sent,?snt,?stc,?stx,?tok)
      &   ( cor !cor
          , lem !lem
          , mrf !mrf
          , ner !ner
          , pos !pos
          , seg !seg
          , sent !sent
          , snt !snt
          , stc !stc
          , stx !stx
          , tok !tok
          )
        : ?opts
      &   
        : ?spanGrpTok
        : ?spanGrpSent
        : ?spanGrpSnt
        : ?spanGrpSeg
        : ?spanGrpMrf
        : ?spanGrpNer
        : ?spanGrpLemma
        : ?spanGrpCor
        : ?spanGrpPos
        : ?spanGrpStc
        : ?spanGrpSyn
      & !json:((sentences.,?sentences),)
      & characterOffsetBegin characterOffsetEnd index lemma ner originalText pos word
      & 0:?s
      & :?idfix
      & 0:?anoid
      & (ano=."xml:id".str$(a (!anoid+1:?anoid)))
      & ( idfy
        =   
          .   map
            $ ( ( 
                =   e a c
                  .     !arg:(?e.?a,?c)
                      & ( !e
                        .     (   !a:? ("xml:id".?) ?
                                & 
                              | ano$
                              )
                              !a
                          , idfy$!c
                        )
                    | !arg
                )
              . !arg
              )
        )
      & ( standoff
        =   what xml naps ana parent
          .   !arg:(?what,?ana,?parent,?this.?xml)
            & :?naps
            &     map
                $ (   
                    ' ( a c A W Z e from to id d
                      .     !arg:((w|c):?e.?a,?c)
                          & !a:?A ($what.?W) ?Z
                          &   !A !Z
                            : ?a
                            :   ?
                                ("xml:id".@(?id:? (#% ?:?d)))
                                ?
                          &     ( span
                                .     ("xml:id".str$($this !d))
                                      (   !c:% %
                                        &   !c
                                          :   ( ?
                                              .   ? ("xml:id".?from) ?
                                                , ?
                                              )
                                              ?
                                              ( ?
                                              .   ? ("xml:id".?to) ?
                                                , ?
                                              )
                                        &   (from.str$("#" !from))
                                            (to.str$("#" !to))
                                      |   @(!id:? (#% ?:?from))
                                        & (from.str$("#" ()$parent !from))
                                      )
                                  , !W
                                )
                                !naps
                            : ?naps
                          & (!e.!a,!c)
                        | !arg
                      )
                  . !xml
                  )
              : ?xml
            & ((spanGrp.(ana.!ana),inv$!naps).!xml)
        )
      & ( stand2off
        =   dat what xml XML naps ana spans prnt
          .   ( dat
              =   
                .   !arg:@
                  |   map
                    $ ( ( 
                        =   
                          .   !arg:(?.?,?arg)&dat$!arg
                            | 
                        )
                      . !arg
                      )
              )
            & !arg:(?what,?ana,?this.?XML.?prnt)
            & :?naps
            & !prnt:(spanGrp.?,?spans)
            &     map
                $ (   
                    ' ( a c A W Z e from id
                      .     !arg:((w|c):?e.?a,?c)
                          & !a:?A ($what.?W) ?Z
                          & !A !Z:?a
                          & (   !c
                              :   (?.? ("xml:id".?id) ?,?)
                                  %
                            | !a:? ("xml:id".?id) ?
                            )
                          & (     !spans
                                :   ?
                                    ( span
                                    .     ? (from.@(?:"#" !id)) ?
                                        : ? ("xml:id".?from) ?
                                      , ?
                                    )
                                    ?spans
                              & (   @(!from:? (#% ?:?xmlid))
                                  &     ( span
                                        .     ("xml:id".str$($this !xmlid))
                                              (from.str$("#" !from))
                                          , !W
                                        )
                                        !naps
                                    : ?naps
                                  & (!e.!a,!c)
                                | ("!--".BAH) !arg
                                )
                            |   ("!--".str$("BEH " !id " from " !from " c " !c))
                                !arg
                            )
                        | !arg
                      )
                  . !XML
                  )
              : ?xml
            & ((spanGrp.(ana.!ana),inv$!naps).!xml)
        )
      & ( cutOut
        =   ana B
          .   !arg:(?arg.?what.?ana)
            &     map
                $ (   
                    ' ( 
                      .       !arg
                            : (spanGrp.? (ana.$what) ?,?B)
                          & !B
                        | 
                      )
                  . !arg
                  )
              : ?spanGrp
            &     map
                $ (   
                    ' ( 
                      .       !arg
                            : (spanGrp.? (ana.$what) ?,?)
                          & 
                        | !arg
                      )
                  . !arg
                  )
              : ?arg
            & (   !spanGrp:
                | (spanGrp.(ana.!ana),!spanGrp)
              . !arg
              )
        )
      & ( sentence
        =   sents
          .   ( text
              =   
                .   str
                  $ ( map
                    $ ( ( 
                        =   
                          .       !arg
                                : (c.? (type.s) ?,?)
                              & " "
                            | !arg:(?.?,?arg)&text$!arg
                            | !arg
                        )
                      . !arg
                      )
                    )
              )
            &     map
                $ ( ( 
                    =   
                      .     !arg:(p.?,?s)
                          &   map
                            $ ( ( 
                                =   e
                                  .   !arg:(s.?,?arg)
                                    &   !arg
                                      :   ?
                                          ( ( ?
                                            .     ~( ?
                                                     ("xml:id".@(?:a #))
                                                     ?
                                                   )
                                                : ?af
                                              , ?cf
                                            )
                                          : ?first
                                          )
                                          ?
                                    &   whl
                                      ' ( !arg:?narg (?e.?al,?cl)
                                        & !e:spanGrp
                                        & !narg:?arg
                                        )
                                    & (   !cf
                                        :   ( ?
                                            .   ? ("xml:id".?idf) ?
                                              , ?
                                            )
                                            ?
                                      | !af:? ("xml:id".?idf) ?
                                      )
                                    & (   !cl
                                        :   ?
                                            ( ?
                                            .   ? ("xml:id".?idl) ?
                                              , ?
                                            )
                                      | !al:? ("xml:id".?idl) ?
                                      )
                                    & ( span
                                      .     (from.str$("#" !idf))
                                            (   !idf:!idl
                                              & 
                                            | (to.str$("#" !idl))
                                            )
                                        , text$!arg
                                      )
                                )
                              . !s
                              )
                        | 
                    )
                  . !arg
                  )
              : ?sents
            & (spanGrp.(ana.sent),!sents)
        )
      & ( segment
        =   spanSent spanTok from a z ind
          .   !arg:((?.?,?spanSent).?.?,?spanTok)
            & 0:?ind
            & ( spanGrp
              .   (ana.seg)
                ,   map
                  $ ( ( 
                      =   from to a aa z id idto
                        .     !arg
                            : (span.?a (from.?from) ?z,?)
                          & (   !a !z:?aa ("xml:id".?) ?z
                              & !aa !z:?a
                              & :?z
                            | 
                            )
                          & (   !a !z:?aa (to.?to) ?z
                              & !aa:?a
                              &   !spanTok
                                :   ?
                                    ( ?
                                    .       ?
                                            (from|to.!to)
                                            ?
                                        : ? ("xml:id".?idto) ?
                                      , ?
                                    )
                                    ?
                            | :?to
                            )
                          &   !spanTok
                            :   ?
                                ( ?
                                .     ? (from.!from) ?
                                    : ? ("xml:id".?id) ?
                                  , ?
                                )
                                ?
                          & ( span
                            .     ("xml:id".str$(seg (1+!ind:?ind)))
                                  !a
                                  (from.str$("#" !id))
                                  ( !to:
                                  | (to.str$("#" !idto))
                                  )
                                  !z
                              , 
                            )
                      )
                    . !spanSent
                    )
              )
        )
      & ( divvy
        =     P sind index lemma ner originalText
            , pos word atts e a c characterOffsetBegin characterOffsetEnd
          .     !arg
              : ( ?sind
                . ?index
                . ?lemma
                . ?ner
                . ?originalText
                . ?pos
                . ?word
                . ?characterOffsetBegin
                . ?characterOffsetEnd
                )
            &     ("xml:id".str$(i !sind "." !index))
                  (!lemma:|(lemma.!lemma))
                  (!ner:|(ner.!ner))
                  (!pos:|(pos.!pos))
                  (!word:|(token.!word))
                  (characterOffsetBegin.!characterOffsetBegin)
                  (characterOffsetEnd.!characterOffsetEnd)
              : ?atts
            & :?P
            &     vap
                $ ( ( 
                    =   
                      .   (   @(ugc$!arg:(P|S) ?)
                            & !P !arg:?P
                          | 
                          )
                        & !arg
                    )
                  . !originalText
                  )
              : ?originalText
            & :?ww
            &   whl
              ' ( !P:%?p ?P
                & !originalText:?a !p ?originalText
                &     !ww
                      (!a:|(w.,str$!a))
                      (c.(type.p),!p)
                  : ?ww
                )
            &   ( !ww:&str$!originalText
                | !originalText:&!ww
                | !ww (w.,str$!originalText)
                )
              : ?arg
            & ( !arg:(?e.?a,?c)&(!e.!a !atts,!c)
              | (w.!atts,!arg)
              )
        )
      & ( trim
        =   
          .   vap$(.!arg):?arg
            &   whl
              ' ( !arg
                :   ( " "
                    | \n
                    | \r
                    | \t
                    | \v
                    )
                    ?arg
                )
            &   whl
              ' ( !arg
                :   ?arg
                    ( " "
                    | \n
                    | \r
                    | \t
                    | \v
                    )
                )
            & str$!arg
        )
      & ( from2
        =   fromId toId
          .     !arg
              :   ( ?
                  .   ? ("xml:id".@(?:? (#% ?:?fromId))) ?
                    , ?
                  )
                  ?
              :   ?
                  ( ?
                  .   ? ("xml:id".@(?:? (#% ?:?toId))) ?
                    , ?
                  )
            & (!fromId.!toId)
        )
      & ( removeO
        =   ana spans
          .   !arg:(spanGrp.?ana,?spans)
            & ( spanGrp
              .   !ana
                ,   map
                  $ ( (=.!arg:(?.?,~O)|)
                    . !spans
                    )
              )
        )
      & 0:?entId:?sentId:?depId:?synId
      &   ("?"."xml version=\"1.0\" encoding=\"UTF-8\"")
          ( TEI
          .   (xmlns."http://www.tei-c.org/ns/1.0")
            ,   (teiHeader.,)
                ( text
                .   
                  ,       (p.)
                            mop
                          $ ( ( 
                              =   sind lemma ner pos
                                .   1+!s:?s
                                  &   !arg
                                    : (   ?+(index.?sind)+?+(tokens.,?tokens)+?
                                        : ( ?+(entitymentions.,?entitymentions)+?
                                          |   ?
                                            & :?entitymentions
                                          )
                                        : (   ?
                                            & !stc:0
                                            & :?parse
                                          | ?+(parse..?parse)+?
                                          | ?&:?parse
                                          )
                                        : ( ?+(sentiment..?sentiment)+?
                                          |   ?
                                            & :?sentiment
                                          )
                                        : (   ?
                                            + ( sentimentDistribution
                                              . ,?sentimentDistribution
                                              )
                                            + ?
                                          |   ?
                                            & :?sentimentDistribution
                                          )
                                        : ( ?+(sentimentTree..?sentimentTree)+?
                                          |   ?
                                            & :?sentimentTree
                                          )
                                        : ( ?+(sentimentValue..?sentimentValue)+?
                                          |   ?
                                            & :?sentimentValue
                                          )
                                      , 
                                      )
                                  & (   !stx:1
                                      &   !arg
                                        : (   ?+(enhancedPlusPlusDependencies.,?deps)+?
                                            | ?+(enhancedDependencies.,?deps)+?
                                            | ?+(basicDependencies.,?deps)+?
                                            | ?&:?deps
                                          , 
                                          )
                                    | :?deps
                                    )
                                  &   (     !tokens
                                          :   (?+(before..?before)+?,)
                                              ?
                                        & @( !before
                                           : (? \n ?|? \r ?)
                                           )
                                        & (.p.) (p.)
                                      | 
                                      )
                                      (s.)
                                      (     map
                                          $ ( ( 
                                              =   
                                                .     !arg
                                                    : (   (   ?
                                                            + (before..?before)
                                                            + ?
                                                          |   ?
                                                            & :?before
                                                          )
                                                        :   ?
                                                          + ( characterOffsetBegin
                                                            . ?characterOffsetBegin
                                                            )
                                                          + ( characterOffsetEnd
                                                            . ?characterOffsetEnd
                                                            )
                                                          + ?
                                                        : ( ?+(index.?index)+?
                                                          |   ?
                                                            & :?index
                                                          )
                                                        : ( ?+(lemma..?lemma)+?
                                                          |   ?
                                                            & :?lemma
                                                          )
                                                        : ( ?+(ner..?ner)+?
                                                          |   ?
                                                            & :?ner
                                                          )
                                                        : (   ?
                                                            + ( originalText
                                                              . 
                                                              . ?originalText
                                                              )
                                                            + ?
                                                          |   ?
                                                            &   
                                                              : ?originalText
                                                          )
                                                        : ( ?+(pos..?pos)+?
                                                          |   ?
                                                            & :?pos
                                                          )
                                                        : (   ?+(word..?word)+?
                                                            & (   !word:
                                                                &   low$!pos
                                                                  : ?word
                                                              | 
                                                              )
                                                          |   ?
                                                            & :?word
                                                          )
                                                      , 
                                                      )
                                                  &   ( !before:
                                                      | ( c
                                                        .       trim$!before
                                                              : 
                                                            & ((type.s),)
                                                          | ( (type.p)
                                                            , !before
                                                            )
                                                        )
                                                      )
                                                        divvy
                                                      $ ( !sind
                                                        . !index
                                                        . !lemma
                                                        . !ner
                                                        . !originalText
                                                        . !pos
                                                        . !word
                                                        . !characterOffsetBegin
                                                        . !characterOffsetEnd
                                                        )
                                              )
                                            . !tokens
                                            )
                                        : (   ( c
                                              . ? (type.s) ?,
                                              )
                                              ?segtok
                                          | ?segtok
                                          )
                                      & idfy$!segtok:?segtok
                                      )
                                      ( !deps:
                                      | ( spanGrp
                                        .   (ana.depparse)
                                          ,   map
                                            $ ( ( 
                                                =   
                                                  .       !arg
                                                        : (   (dep..?dep)
                                                            + (dependent.?dependent)
                                                            + ( dependentGloss
                                                              . 
                                                              . ?dependentGloss
                                                              )
                                                            + (governor.?governor)
                                                            + ( governorGloss
                                                              . 
                                                              . ?governorGloss
                                                              )
                                                          , 
                                                          )
                                                      & ( span
                                                        .     ( "xml:id"
                                                              .   str
                                                                $ ( dep
                                                                    ( 1+!depId
                                                                    : ?depId
                                                                    )
                                                                  )
                                                              )
                                                              ( from
                                                              .   str
                                                                $ ( "#t"
                                                                    !sind
                                                                    "."
                                                                    !dependent
                                                                  )
                                                              )
                                                          ,   (     !governor
                                                                  : >0
                                                                & ( link
                                                                  .   ( target
                                                                      .   str
                                                                        $ ( "#t"
                                                                            !sind
                                                                            "."
                                                                            !governor
                                                                          )
                                                                      )
                                                                    , 
                                                                  )
                                                              | 
                                                              )
                                                              (term.,!dep)
                                                        )
                                                    | 
                                                )
                                              . !deps
                                              )
                                        )
                                      )
                                      ( !entitymentions:
                                      | ( spanGrp
                                        .   (ana.entitymentions)
                                          ,   map
                                            $ ( ( 
                                                =   
                                                  .     !arg
                                                      : (     ( characterOffsetBegin
                                                              . ?characterOffsetBegin
                                                              )
                                                            + ( characterOffsetEnd
                                                              . ?characterOffsetEnd
                                                              )
                                                            + ?
                                                            + (ner..?ner)
                                                            + ?
                                                            + (text..?text)
                                                            + ?
                                                          : (   ?
                                                              + ( normalizedNER
                                                                . 
                                                                . ?normalizedNER
                                                                )
                                                              + ?
                                                            |   ?
                                                              &   
                                                                : ?normalizedNER
                                                            )
                                                        , 
                                                        )
                                                    &   !segtok
                                                      :   ?
                                                          ( ?
                                                          .       ?
                                                                  ( characterOffsetBegin
                                                                  . !characterOffsetBegin
                                                                  )
                                                                  ?
                                                              :   ?
                                                                  ( "xml:id"
                                                                  . @( ?
                                                                     :   ?
                                                                         ( #% ?
                                                                         : ?fromId
                                                                         )
                                                                     )
                                                                  )
                                                                  ?
                                                            , ?
                                                          )
                                                          ?
                                                      :   ?
                                                          ( ?
                                                          .       ?
                                                                  ( characterOffsetEnd
                                                                  . !characterOffsetEnd
                                                                  )
                                                                  ?
                                                              :   ?
                                                                  ( "xml:id"
                                                                  . @( ?
                                                                     :   ?
                                                                         ( #% ?
                                                                         : ?toId
                                                                         )
                                                                     )
                                                                  )
                                                                  ?
                                                            , ?
                                                          )
                                                          ?
                                                    & ( span
                                                      .     ( "xml:id"
                                                            .   str
                                                              $ ( ent
                                                                  ( 1+!entId
                                                                  : ?entId
                                                                  )
                                                                )
                                                            )
                                                            (from.str$("#t" !fromId))
                                                            (     !fromId
                                                                : !toId
                                                              & 
                                                            | (to.str$("#t" !toId))
                                                            )
                                                            (type.!ner)
                                                        ,   !normalizedNER:~
                                                          | !text
                                                      )
                                                )
                                              . !entitymentions
                                              )
                                        )
                                      )
                                      ( !parse:
                                      |   from2$!segtok:(?fromId.?toId)
                                        & ( spanGrp
                                          .   (ana.parse)
                                            , ( span
                                              .     ( "xml:id"
                                                    .   str
                                                      $ ( syn
                                                          (1+!synId:?synId)
                                                        )
                                                    )
                                                    (from.str$("#t" !fromId))
                                                    (   !toId:!fromId
                                                      & 
                                                    | (to.str$("#t" !toId))
                                                    )
                                                , !parse
                                              )
                                          )
                                      )
                                      ( !sentiment:
                                      |   from2$!segtok:(?fromId.?toId)
                                        & ( spanGrp
                                          .   (ana.sentiment)
                                            , ( span
                                              .     ( "xml:id"
                                                    .   str
                                                      $ ( sent
                                                          ( 1+!sentId
                                                          : ?sentId
                                                          )
                                                        )
                                                    )
                                                    (from.str$("#t" !fromId))
                                                    (   !toId:!fromId
                                                      & 
                                                    | (to.str$("#t" !toId))
                                                    )
                                                , !sentiment
                                              )
                                          )
                                      )
                                      ( !sentimentTree:
                                      |   from2$!segtok:(?fromId.?toId)
                                        & ( spanGrp
                                          .   (ana.sentimentTree)
                                            , ( span
                                              .     ( "xml:id"
                                                    .   str
                                                      $ ( sent
                                                          ( 1+!sentId
                                                          : ?sentId
                                                          )
                                                        )
                                                    )
                                                    (from.str$("#t" !fromId))
                                                    (   !toId:!fromId
                                                      & 
                                                    | (to.str$("#t" !toId))
                                                    )
                                                , !sentimentTree
                                              )
                                          )
                                      )
                                      (.s.)
                              )
                            . !sentences
                            . (=a b)
                            )
                          (.p.)
                      : ?XML
                    & cor lem mrf ner pos seg sent snt stc stx tok
                    & (   !stc:1
                        & cutOut$(!XML.parse.parse):(?spanGrpStc.?XML)
                      | 
                      )
                    & (   !stx:1
                        & cutOut$(!XML.depparse.depparse):(?spanGrpSyn.?XML)
                      | 
                      )
                    & (   !snt:1
                        & cutOut$(!XML.sentiment.sentiment):(?spanGrpSnt.?XML)
                        &   cutOut$(!XML.sentimentTree.sentimentTree)
                          : (?spanGrpSntTree.?XML)
                      | 
                      )
                    & (   !ner:1
                        &   cutOut$(!XML.entitymentions.entitymentions)
                          : (?spanGrpEntitymentions.?XML)
                      | 
                      )
                    &   standoff$(token,token,i,t.!XML)
                      : (?spanGrpTok.?XML)
                    &   stand2off$(lemma,lemma,l.!XML.!spanGrpTok)
                      : (?spanGrpLemma.?XML)
                    &   stand2off$(pos,pos,p.!XML.!spanGrpTok)
                      : (?spanGrpPos.?XML)
                    &   stand2off$(ner,ner,n.!XML.!spanGrpTok)
                      : (?spanGrpNer.?XML)
                    & removeO$!spanGrpNer:?spanGrpNer
                    &     map
                        $ ( ( 
                            =   
                              .       !arg
                                    : ( ?e
                                      .     ?a
                                            (characterOffsetBegin.?)
                                            (characterOffsetEnd.?)
                                            ?z
                                        , ?c
                                      )
                                  & (!e.!a !z,!c)
                                | !arg
                            )
                          . !XML
                          )
                      : ?XML
                    & nestML$!XML:?XML
                    & sentence$!XML:?spanGrpSent
                    & segment$(!spanGrpSent.!spanGrpTok):?spanGrpSeg
                    &   !XML
                        ( !tok:1&!spanGrpTok
                        | 
                        )
                        ( !sent:1&!spanGrpSent
                        | 
                        )
                        ( !seg:1&!spanGrpSeg
                        | 
                        )
                        ( !mrf:1&!spanGrpMrf
                        | 
                        )
                        ( !pos:1&!spanGrpPos
                        | 
                        )
                        (   !ner:1
                          & !spanGrpNer !spanGrpEntitymentions
                        | 
                        )
                        ( !lem:1&!spanGrpLemma
                        | 
                        )
                        ( !stc:1&!spanGrpStc
                        | 
                        )
                        ( !stx:1&!spanGrpSyn
                        | 
                        )
                        ( !snt:1&!spanGrpSnt !spanGrpSntTree
                        | 
                        )
                        ( !cor:1&!spanGrpCor
                        | 
                        )
                )
          )
  )
  ( doit
  =     output tmp1 tmp2 A B C D E F G H formatO
      , xmlseg xmltok lang language properties
      , cor lem mrf ner pos seg sent snt stc stx tok
    .   ( turnTEIP5intoPlain
        =   fr to inputtok inputseg word
          .   !arg:(?inputtok.?inputseg)
            &   !inputseg
              :   ( span
                  .     ? (from.@(?:"#" ?fr)) ?
                      : ( ? (to.@(?:"#" ?to)) ?
                        | ?&!fr:?to
                        )
                    , 
                  )
                  ?inputseg
            & :?sep
            &   map
              $ ( ( 
                  =   
                    .     !arg
                        : ( span
                          .     ? (from.?from) ?
                              : ? ("xml:id".?Tid) ?
                            , ?word
                          )
                      &   !word
                          " "
                          (   !Tid:!to
                            &   !inputseg
                              :   ( span
                                  .     ? (from.@(?:"#" ?fr)) ?
                                      : ( ? (to.@(?:"#" ?to)) ?
                                        | ?&!fr:?to
                                        )
                                    , 
                                  )
                                  ?inputseg
                            & \n
                          | 
                          )
                  )
                . !inputtok
                )
        )
      & (trim=.str$(vap$(.!arg." ")))
      & ( inv
        =   j K
          .   :?K
            & whl'(!arg:%?j ?arg&!j !K:?K)
            & !K
        )
      & ( getProperties
        =     file javaProperties extra nextline
            , cor lem mrf ner pos seg sent snt stc stx tok
            , transl lang filter ftr lines pasted line
          .     !arg
              : ( ?file
                . ?extra
                . ?cor,?lem,?mrf,?ner,?pos,?seg,?sent,?snt,?stc,?stx,?tok
                . ?lang
                )
            &     (tokenize.tok)
                  ("cdc_tokenize".tok)
                  (cleanxml.)
                  (ssplit.seg)
                  (pos.pos)
                  (lemma.lem)
                  (ner.ner)
                  (parse.stc)
                  (depparse.stx)
                  (coref.cor)
                  (natlog.)
                  (openie.)
                  (kbp.)
                  (entitylink.ner)
                  (sentiment.snt)
                  (quote.)
                  (mwt.tok)
              : ?transl
            & ( get$(!file,STR):?javaProperties
              | put$(str$("cannot read " !file \n),"../log/CoreNLP.log",APP,BIN)
              )
            &     vap
                $ ( ( 
                    =   
                      .     whl
                          ' @( !arg
                             : ?arg (\r|" "|\t)
                             )
                        & !arg
                    )
                  . !javaProperties
                  . \n
                  )
              : ?lines
            & :?pasted
            &   whl
              ' ( !lines:%?line ?lines
                & (   (@(!line:? "=")|@(!line:?line "\\"))
                    & !lines:%?nextline ?lines
                    &   whl
                      ' @( !nextline
                         : ("#"|" "|\t) ?nextline
                         )
                    & str$(!line !nextline) !lines:?lines
                  | !line !pasted:?pasted
                  )
                )
            & inv$!pasted:?javaProperties
            &   (     mop
                    $ ( 
                      .   map
                        $ ( ( 
                            =   aa zz
                              .   @(!arg:"#" ?)&
                                |   @( !arg
                                     : (?prop "=" ?val|?prop ":" ?val)
                                     )
                                  & trim$!prop:?prop
                                  & trim$!val:?val
                                  & (   !prop:annotators
                                      & (   !lang:en
                                          & (   !stc:1
                                              & ( @(!val:? ",parse" ?)
                                                | str$(!val ",parse"):?val
                                                )
                                            |   @(!val:?aa ",parse" ?zz)
                                              & str$(!aa !zz):?val
                                            | 
                                            )
                                          & ( @(!val:? ",sentiment" ?)
                                            |   !snt:1
                                              & str$(!val ",sentiment"):?val
                                            | 
                                            )
                                        |   !lang:fr
                                          & ( @(!val:? ",parse" ?)
                                            |   !stc:1
                                              & str$(!val ",parse"):?val
                                            | 
                                            )
                                        |   !lang:zh
                                          & ( @(!val:? ",depparse" ?)
                                            |   !stx:1
                                              & str$(!val ",depparse"):?val
                                            | 
                                            )
                                        | 
                                        )
                                      &     mop
                                          $ ( 
                                            .     vap
                                                $ ( ( 
                                                    =   
                                                      .     (     !transl
                                                                :   ?
                                                                    (!arg.?tt)
                                                                    ?
                                                              & !!tt:1
                                                            |   !lang:zh
                                                              &   !arg
                                                                : lemma
                                                              & "lemma is no-op for Chinese but currently needed because coref demands it (bad old requirements system)"
                                                            )
                                                          & !arg
                                                        | 
                                                    )
                                                  . !val
                                                  . ","
                                                  )
                                              : ?filter
                                            . (=a b)
                                            . (=,)
                                            )
                                        : ?val
                                    |   @(!prop:?ftr "." ?)
                                      &     (     !lang
                                                : (ar|zh)
                                              & segment
                                            | 
                                            )
                                            !filter
                                        : ? !ftr ?
                                    )
                                  & (!prop..str$!val)
                                | 
                            )
                          . !javaProperties
                          )
                      . (=a b)
                      . (=+)
                      )
                  + !extra
                , 
                )
              : ?jsonProperties
            & jsn$!jsonProperties
        )
      & ( percentencode
        =   c prc reserved
          .   ( prc
              =   
                .     @(!arg:%@?c ?arg)
                    &   (   !c:"+"
                          & "%2B is decoded to a space by CoreNLP, presumably because percent decoding is done a second time somewhere. The solution is a hack: Percent encoding the %!"
                          & "%25"
                        | "%"
                        )
                        d2x$(asc$!c)
                        prc$!arg
                  | 
              )
            &   str
              $ ( vap
                $ ( ( 
                    =   
                      .     ( !('("-" "." "_" "~":? ()$arg ?))
                            |   !arg
                              : ( ~<A:~>Z
                                | ~<a:~>z
                                | ~<0:~>9
                                )
                            )
                          & !arg
                        | prc$!arg
                    )
                  . !arg
                  )
                )
        )
      & ( getSentiment
        =   
          .   !arg:? (TEI.?,? (text.,?spanGrps) ?) ?
            &   !spanGrps
              : ? (spanGrp.(ana.sentiment),?sentiment) ?
              : ? (spanGrp.(ana.sentimentTree),?sentimentTree) ?
            & ( words
              =   
                .   vap
                  $ ( ( 
                      =   
                        .     vap$(.!arg." "):? %@?arg
                            & " " !arg
                          | 
                      )
                    . !tree
                    . ")"
                    )
              )
            &   str
              $ ( map
                $ ( ( 
                    =   from to value
                      .     !arg
                          : ( span
                            .     ? (from.?from) ?
                                : ( ? (to.?to) ?
                                  | ?&!from:?to
                                  )
                              , ?value
                            )
                        & (     !sentimentTree
                              :   ( span
                                  .     ? (from.!from) ?
                                      :   ?
                                          (to|from.!to)
                                          ?
                                    , ?tree
                                  )
                                  ?sentimentTree
                            & !value ":" words$!tree \n !tree \n\n
                          | !value \n\n
                          )
                    )
                  . !sentiment
                  )
                )
        )
      & ( transform
        =     Tokenized/SegmentedPlainText tmp1 tmp2 formatO lang language properties
            , cor lem mrf ner pos seg sent snt stc stx tok
          .     !arg
              : ( ?formatO
                . ?lang
                . ?language
                . ?properties
                . ?Tokenized/SegmentedPlainText
                . ?tmp1
                . ?tmp2
                . ?cor
                . ?lem
                . ?mrf
                . ?ner
                . ?pos
                . ?seg
                . ?sent
                . ?snt
                . ?stc
                . ?stx
                . ?tok
                )
            & ( doChunk
              =   chunk JSON theText tmp1 properties tmp2 command RETURN
                .   !arg:(?chunk.?tmp1.?properties.?tmp2)
                  &   put
                    $ (   str
                        $ ( map
                          $ ( ( 
                              = .!arg:(.?arg)&!arg \n\n
                              )
                            . !chunk
                            )
                          )
                      , !tmp1
                      , NEW
                      )
                  & get$(!tmp1,STR):?theText
                  & (       str
                          $ ( "wget --post-file "
                              !tmp1
                              " 'http://localhost:9000/?properties="
                              !properties
                              "' -O "
                              !tmp2
                              " --"
                            )
                        : ?command
                      & sys$!command:?RETURN
                      & !RETURN:0
                      & get$(!tmp2,JSN)
                    |     put
                        $ ( str$("cannot execute command [" !command "]
RETURN CODE: " !RETURN)
                          , "../log/CoreNLP.log"
                          , APP
                          , BIN
                          )
                      & ERROR
                    )
              )
            & ( callInChunks
              =   JSON properties Tokenized/SegmentedPlainText linesz chunk
                .   !arg:(?Tokenized/SegmentedPlainText.?properties)
                  &     vap
                      $ ( ( 
                          =   
                            . 
                            .   vap
                              $ ( ( 
                                  =   
                                    .   whl'@(!arg:" " ?arg)
                                      & whl'@(!arg:?arg " ")
                                      & !arg
                                  )
                                . !arg
                                . \r
                                )
                          )
                        . !Tokenized/SegmentedPlainText
                        . \n
                        )
                    : ?linesz
                  & :?JSON
                  &   whl
                    ' ( !linesz:?chunk (.) ?linesz
                      & ( !chunk:
                        | doChunk$(!chunk.!tmp1.!properties.!tmp2) !JSON:?JSON
                        )
                      )
                  & ( !linesz:
                    | doChunk$(!linesz.!tmp1.!properties.!tmp2) !JSON:?JSON
                    )
                  & :?L
                  &   whl
                    ' (!JSON:%?json ?JSON&!json !L:?L)
                  & -1:?ind
                  & ( ( sentences
                      .   
                        ,   map
                          $ ( ( 
                              =   
                                .   !arg:((sentences.,?arg),)
                                  &   map
                                    $ ( ( 
                                        =   A Z
                                          .   !arg:(?A+(index.?)+?Z,)
                                            & ( !A+(index.1+!ind:?ind)+!Z
                                              , 
                                              )
                                        )
                                      . !arg
                                      )
                              )
                            . !L
                            )
                      )
                    , 
                    )
              )
            &     percentencode
                $ ( getProperties
                  $ ( !properties
                    . (outputFormat..json)+(timeout..500000)
                    . !cor,!lem,!mrf,!ner,!pos,!seg,!sent,!snt,!stc,!stx,!tok
                    . !lang
                    )
                  )
              : ?properties
            & put$(str$(\n "properties:" \n),"../log/CoreNLP.log",APP)
            & lst$(properties,"../log/CoreNLP.log",APP,RAW)
            & callInChunks$(!Tokenized/SegmentedPlainText.!properties):?json
            & ( !formatO:json&jsn$!json
              |       (its.turnJSONintoTEIP5)
                    $ (!json.!cor,!lem,!mrf,!ner,!pos,!seg,!sent,!snt,!stc,!stx,!tok)
                  : ?spanGrps
                & ( !formatO:flat&getSentiment$!spanGrps
                  | str$(toML$!spanGrps)
                  )
              )
        )
      &   !arg
        : ( ?formatO
          . ?lang
          . ?language
          . ?properties
          . ?inputtok
          . ?inputseg
          . ?output
          . ?tmp1
          . ?tmp2
          . ?cor
          . ?lem
          . ?mrf
          . ?ner
          . ?pos
          . ?seg
          . ?sent
          . ?snt
          . ?stc
          . ?stx
          . ?tok
          )
      &   (   @(!inputseg:?format "/")
            & ( !format:flat&get$(!inputtok,STR)
              |     nestML$(get$(!inputtok,X ML TRM))
                  : ? (spanGrp.?,?xmlsent) ?
                &   str
                  $ ( map
                    $ ( ( 
                        =   
                          .   !arg:(?.?,?arg)&!arg \n
                            | 
                        )
                      . !xmlsent
                      )
                    )
              )
          |     nestML$(get$(!inputtok,X ML TRM))
              : ? (spanGrp.?,?xmltok) ?
            &   nestML$(get$(!inputseg,X ML TRM))
              : ? (spanGrp.?,?xmlseg) ?
            & str$(turnTEIP5intoPlain$(!xmltok.!xmlseg))
          )
        : ?Tokenized/SegmentedPlainText
      &     transform
          $ ( !formatO
            . !lang
            . !language
            . !properties
            . !Tokenized/SegmentedPlainText
            . !tmp1
            . !tmp2
            . !cor
            . !lem
            . !mrf
            . !ner
            . !pos
            . !seg
            . !sent
            . !snt
            . !stc
            . !stx
            . !tok
            )
        : ?OuTput
      & put$(str$!OuTput,!output,NEW)
  )
  ( new
  =   
    .   ~
      |     ( arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            . arg$
            )
          : ( ?formatO
            . ?lang
            . ?language
            . ?properties
            . ?inputtok
            . ?inputseg
            . ?output
            . ?tmp1
            . ?tmp2
            . ?cor
            . ?lem
            . ?mrf
            . ?ner
            . ?pos
            . ?seg
            . ?sent
            . ?snt
            . ?stc
            . ?stx
            . ?tok
            )
        &   (its.doit)
          $ ( !formatO
            . !lang
            . !language
            . !properties
            . !inputtok
            . !inputseg
            . !output
            . !tmp1
            . !tmp2
            . !cor
            . !lem
            . !mrf
            . !ner
            . !pos
            . !seg
            . !sent
            . !snt
            . !stc
            . !stx
            . !tok
            )
  );

r=
  get'("corenlpx.bra",TXT)
& rmv$(str$(corenlpx ".bak"))
& ren$("corenlpx.bra".str$(corenlpx ".bak"))
&   put
  $ ( "{corenlpx.bra

Transform Clarin token/segment annotation to plain text, one sentence per line. Run CoreNLP.
Output JSON or TEI-P5.
}

"
    , "corenlpx.bra"
    , NEW
    , BIN
    )
& lst'(X,"corenlpx.bra",APP,BIN,WYD)
& put'(\n,"corenlpx.bra",APP,BIN)
& lst'(r,"corenlpx.bra",APP,BIN,WYD)
& put$(str$("\nnew'" X ";\n"),"corenlpx.bra",APP,BIN)
& ;

new'X;
