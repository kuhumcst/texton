{teitok.bra
ùïåùïãùîΩ-ùü†
Takes a TEI P5 document and creates <w> and <c> elements.
Get the casing right for Danish TEI P5 texts}

X=
  ( teitok
  =   input abbreviations style language,SentenceEndingAbbrSeen
    .   !arg:(?input.?style.?abbreviations.?language)
      & :?SentenceEndingAbbrSeen
      & new$hash:?Mabbr
      & new$hash:?Eabbr
      & (Mabbr..ISO)$
      & (Eabbr..ISO)$
      &   map
        $ ( ( 
            =   
              .   (   @(!arg:" " ?arg)
                    & (Eabbr..insert)$(!arg.)
                  | (Mabbr..insert)$(!arg.)
                  )
                & !arg
            )
          . !abbreviations
          )
      & nestML$(get$(!input,X ML TRM)):?xml
      &   !xml
        : ?XXX (TEI.?teiatt,?AAA (text.?textatt,?text) ?DDD) ?YYY
      & 0:?tok:?sen:?IS
      & ( Sen
        =   R
          .   !IS:?R
            & 0:?IS
            & !R+!sen:?sen
        )
      & ( trm
        =   
          .     whl
              ' @( !arg
                 :   (" "|\t|\n|\r)
                     ?arg
                 )
            &   whl
              ' @( !arg
                 :   ?arg
                     (" "|\t|\n|\r)
                 )
            & !arg
        )
      & ( trim
        =   A B
          .   !arg:?A %@?B ?arg&!A trm$!B trim$!arg
            | !arg
        )
      & ( trq
        =   att sub nm A Z a z w,wa W ad XX ad
          .     whl
              ' (   !arg
                  :   ?A
                      (w.?wa,?W)
                      (   (add|del|ex)
                        : ?ad
                      .   ?att
                        ,   ~(? (c.? (type.p) ?,?) ?)
                          : ?XX
                      )
                      ?Z
                &     !A
                      (w.!wa,trim$!W (!ad.!att,content$!XX))
                      ( !ad:del&!Z
                      | tok-1$(!Z.!wa)
                      )
                  : ?arg
                )
            &   whl
              ' (   !arg
                  :   ?A
                      (   (add|del|ex)
                        : ?ad
                      . ?att,?XX
                      )
                      (w.?wa,?W)
                      ?Z
                &     !A
                      (w.!wa,(!ad.!att,content$!XX) trim$!W)
                      ( !ad:del&!Z
                      | tok-1$(!Z.!wa)
                      )
                  : ?arg
                )
            &   whl
              ' (   !arg
                  :   ?A
                      (w.(S.?) (T.?):?wa,?W)
                      (w.(S.?) (T.?):?att,?XX)
                      ?Z
                & !A (w.!wa,trim$(!W !XX)) tok-1$(!Z.!wa):?arg
                )
            & :?narg
            &   whl
              ' (   !arg
                  : ?A (lb.(break.no),) (w.?wb,?W) ?Z
                & :?L
                &   whl
                  ' ( !A:?A (?e.?I)
                    & !e:~w
                    & (   !e:c
                        & !I:(? (type.s) ?,?)
                      | (!e.!I) !L:?L
                      )
                    )
                & !e:w
                & !I:(?wa,?V)
                & trim$(!V !L (lb.(break.no),) !W):?XXY
                &     !narg
                      !A
                      (   !XXY:? (c.?,?) ?
                        &   map
                          $ ( ( 
                              =   
                                .   !arg:@&(w.!wa,!arg)
                                  | !arg
                              )
                            . !XXY
                            )
                      | (w.!wa,!XXY)
                      )
                  : ?narg
                & tok-1$(!Z.!wa):?arg
                )
            & !narg !arg:?arg
            &   map
              $ ( ( 
                  =   
                    .     !arg:(?e.?att,?sub)
                        & (!e.!att,trq$!sub)
                      | !arg
                  )
                . !arg
                )
        )
      & ( findIDs
        =   fnd IDs
          .   new$hash:?IDs
            & ( fnd
              =   att sub nm id
                .   whl
                  ' ( !arg:? (?.?att,?sub) ?arg
                    & (   !att
                        :   ?
                            ( [%( low$!sjt:(id|"xml:id")
                                & !sjt:?nm
                                )
                            . ?id&(IDs..insert)$(!id.!nm)
                            )
                            ?
                      | 
                      )
                    & fnd$!sub
                    )
              )
            & fnd$!arg
            & !IDs
        )
      & findIDs$!text:?IDs
      & 0:?ID
      & ( IDgen
        =   id
          .   !arg:? ("xml:id".?) ?&
            |     whl
                ' ( 1+!ID:?ID
                  & str$(i !ID):?id
                  & (IDs..find)$!id
                  )
              & !id
        )
      & ( assignIDs
        =   asn
          .   ( asn
              =   att sub nm A Z a z
                .   map
                  $ ( ( 
                      =   
                        .     !arg:(?e.?att,?sub)
                            & (   !e:(w|c)
                                & (     !att
                                      :   ?a
                                          ( [%(   low$!sjt
                                                : (id|"xml:id")
                                              & !sjt:?nm
                                              )
                                          . ?id
                                          )
                                          ?z
                                    & ( !e
                                      .   !a ("xml:id".!id) !z
                                        ,     !e:w
                                            & trim$!sub
                                          | !sub
                                      )
                                  | ( !e
                                    .   !att
                                      ,   !e:w&trim$!sub
                                        | !sub
                                    )
                                  )
                              | (!e.!att,asn$!sub)
                              )
                          | !arg
                      )
                    . !arg
                    )
              )
            & asn$!arg
        )
      & ( inc1
        =   a z T e c
          .     !arg:(?e.?a (T.?T) ?z,?c)
              & (!e.!a (T.1+!T) !z,!c)
            | !arg
        )
      & ( inc2
        =   a z T e c
          .     !arg:(?e.?a (T.?T) ?z,?c)
              & (!e.!a (T.2+!T) !z,!c)
            | !arg
        )
      & ( contr
        =   a b A B S T E
          .     whl
              ' (   !arg
                  :   ?A
                      (w.(S.?S) (T.?T),?B)
                      (c.(type.p) (S.!S) (T.!T),"'")
                      ( w
                      .   (S.!S) (T.!T)
                        ,   ( ll
                            | ve
                            | re
                            | s
                            | m
                            | d
                            )
                          : ?E
                      )
                      ?Z
                &     !A
                      (w.(S.!S) (T.!T),!B)
                      (c.(type.p) (S.!S) (T.!T+1),"'")
                      (w.(S.!S) (T.!T+1),!E)
                      map$(inc1.!Z)
                  : ?arg
                )
            &   whl
              ' (   !arg
                  :   ?A
                      (w.(S.?S) (T.?T),@(?:%?B n))
                      (c.(type.p) (S.!S) (T.!T),"'")
                      (w.(S.!S) (T.!T),t)
                      ?Z
                &     !A
                      (w.(S.!S) (T.!T),!B)
                      (w.(S.!S) (T.!T+1),n)
                      (c.(type.p) (S.!S) (T.!T+1),"'")
                      (w.(S.!S) (T.!T+1),t)
                      map$(inc1.!Z)
                  : ?arg
                )
            &   whl
              ' (   !arg
                  :   ?A
                      (w.(S.?S) (T.?T),d)
                      (c.(type.p) (S.!S) (T.!T),"'")
                      (w.(S.!S) (T.!T),ye)
                      ?Z
                &     !A
                      (w.(S.!S) (T.!T),d)
                      (c.(type.p) (S.!S) (T.!T),"'")
                      (w.(S.!S) (T.!T+1),ye)
                      map$(inc1.!Z)
                  : ?arg
                )
            &   whl
              ' (   !arg
                  :   ?A
                      (w.(S.?S) (T.?T),more)
                      (c.(type.p) (S.!S) (T.!T),"'")
                      (w.(S.!S) (T.!T),n)
                      ?Z
                &     !A
                      (w.(S.!S) (T.!T),more)
                      (c.(type.p) (S.!S) (T.!T+1),"'")
                      (w.(S.!S) (T.!T+1),n)
                      map$(inc1.!Z)
                  : ?arg
                )
            &   whl
              ' (   !arg
                  :   ?A
                      (c.(type.p) (S.?S) (T.?T),"'")
                      ( w
                      .   (S.!S) (T.!T)
                        , @(?:t ((is|was):?B))
                      )
                      ?Z
                &     !A
                      (c.(type.p) (S.!S) (T.?T),"'")
                      (w.(S.!S) (T.!T),t)
                      (w.(S.!S) (T.!T+1),!B)
                      map$(inc1.!Z)
                  : ?arg
                )
            &   whl
              ' (   !arg
                  :   ?A
                      ( w
                      .   (S.?S) (T.?T)
                        , [%( (whaddya.wha dd ya) (whatcha.wha t cha)
                            : ? (!sjt.%?a %?b %?c) ?
                            )
                      )
                      ?Z
                &     !A
                      (w.(S.!S) (T.!T),!a)
                      (w.(S.!S) (T.!T+1),!b)
                      (w.(S.!S) (T.!T+2),!c)
                      map$(inc2.!Z)
                  : ?arg
                )
            &   whl
              ' (   !arg
                  :   ?A
                      ( w
                      .   (S.?S) (T.?T)
                        , [%(   (cannot.can not)
                                (gimme.gim me)
                                (gonna.gon na)
                                (gotta.got ta)
                                (lemme.lem me)
                                (wanna.wan na)
                            : ? (!sjt.%?a %?b) ?
                            )
                      )
                      ?Z
                &     !A
                      (w.(S.!S) (T.!T),!a)
                      (w.(S.!S) (T.!T+1),!b)
                      map$(inc1.!Z)
                  : ?arg
                )
            & !arg
        )
      & ( rcontr
        =   rc S T ot nt s t
          .   ( rc
              =   att sub nm A Z a z e
                .   map
                  $ ( ( 
                      =   
                        .     !arg:(?e.?att,?sub)
                            & contr$!sub:?sub
                            & (!e.!att,rc$!sub)
                          | !arg
                      )
                    . !arg
                    )
              )
            & rc$!arg
        )
      & ( SplitAbbr
        =   A k K it OO wcount
          .   :?OO
            & 1:?it
            & 0:?wcount
            &   whl
              ' (   !arg
                  :   ?A
                      ( %@?k
                      : ( "'"
                        | "-"
                        | ‚Ä¶
                        | "."
                        | "("
                        | ")"
                        | "["
                        | "]"
                        | "{"
                        | "}"
                        | ":"
                        | ","
                        | ‚Äì
                        | ‚Äî
                        | "!"
                        | ‚Äπ
                        | ‚Ä∫
                        | ¬´
                        | ¬ª
                        | "?"
                        | ‚Äò
                        | ‚Äô
                        | ‚Äú
                        | ‚Äù
                        | ";"
                        | "\\"
                        | "/"
                        | \"
                        | "`"
                        )
                      )
                      ?arg
                & !k:?K
                & whl'(!arg:%@!k ?arg&!k !K:?K)
                &     !OO
                      ( !A:
                      | ( w
                        .     (S.Sen$)
                              ( T
                              .       (   0:!wcount
                                        & 1:?wcount
                                      | !it
                                      )
                                    + !tok
                                  : ?tok
                                & 0:?it
                                & !tok
                              )
                          ,   trim$(str$!A):?A
                            & (   upp$!A:!A
                                & ( low$!A:!A
                                  |   @(!A:? [>1)
                                    & 1:?it
                                  )
                              | 
                              )
                            & !A
                        )
                      )
                      ( c
                      .     (type.p)
                            (S.Sen$)
                            ( T
                            .   !it+!tok:?tok
                              & 0:?it
                              & !tok
                            )
                        , str$!K
                      )
                  : ?OO
                )
            &   !OO
                ( !arg:
                | ( w
                  .     (S.Sen$)
                        ( T
                        .   !it+!tok:?tok
                          & 0:?it
                          & !tok
                        )
                    , trim$(str$!arg)
                  )
                )
        )
      & ( Split
        =   A k K it OO
          .   :?OO
            & 1:?it
            &   whl
              ' (   !arg
                  :   ?A
                      ( %?k
                      : ( "'"
                        | "-"
                        | ‚Ä¶
                        | "."
                        | "("
                        | ")"
                        | "["
                        | "]"
                        | "{"
                        | "}"
                        | ":"
                        | ","
                        | ‚Äì
                        | ‚Äî
                        | "!"
                        | ‚Äπ
                        | ‚Ä∫
                        | ¬´
                        | ¬ª
                        | "?"
                        | ‚Äò
                        | ‚Äô
                        | ‚Äú
                        | ‚Äù
                        | ";"
                        | "\\"
                        | "/"
                        | \"
                        | "`"
                        )
                      )
                      ?arg
                & !k:?K
                & whl'(!arg:%@!k ?arg&!k !K:?K)
                & "K is a list of punct chars
                   '    does not increase token id
                   -    does not increase token id
                   ‚Ä¶    increases token id if nothing comes after it
                   .    increases token id if nothing comes after it
                
                   Other (sequences of) punctuation always increase token id."
                &     !OO
                      ( !A:
                      | ( w
                        .     (S.Sen$)
                              ( T
                              .   !it+!tok:?tok
                                & 0:?it
                                & !tok
                              )
                          , trim$(str$!A)
                        )
                      )
                      ( c
                      .     (type.p)
                            (S.Sen$)
                            ( T
                            .       !K
                                  : ( "." "." "."
                                    | ‚Ä¶
                                    | "."
                                    |   ( "("
                                        | ")"
                                        | "["
                                        | "]"
                                        | "{"
                                        | "}"
                                        | ":"
                                        | ","&~(!A:? #%@)
                                        | ‚Äì
                                        | ‚Äî
                                        | "!"
                                        | ‚Äπ
                                        | ‚Ä∫
                                        | ¬´
                                        | ¬ª
                                        | "?"
                                        | ‚Äò
                                        | ‚Äô
                                        | ‚Äú
                                        | ‚Äù
                                        | ";"
                                        | "\\"
                                        | "/"
                                        | \"
                                        | "`"
                                        )
                                        ?
                                    )
                                & 0:?it
                                & (   !arg:
                                    & "If nothing follows after punct, increase token id."
                                    & 1+!tok:?tok
                                  |   "These characters can be inside a token, but not at the end. So if there is something
                                         directly after, the previous, this and the next something all have the same token id.
                                         But we need to know whether there was something before this thing! (Not start of sentence, not space.)"
                                    & ( rep
                                      =   pat
                                        .   !arg:(=?pat)
                                          &   !sjt
                                            : %@!pat (|rep$!arg)
                                      )
                                    &   !K
                                      : ( rep$(="'")
                                        | rep$(="-")
                                        | rep$(="/")
                                        | rep$(=":")
                                        | ‚Ä¶
                                        | rep$(=".")
                                        )
                                    & !tok
                                  | 2+!tok:?tok&-1+!tok
                                  )
                              |   !it+!tok:?tok
                                & 0:?it
                                & !tok
                            )
                        , str$!K
                      )
                  : ?OO
                )
            &   !OO
                ( !arg:
                | ( w
                  .     (S.Sen$)
                        ( T
                        .   !it+!tok:?tok
                          & 0:?it
                          & !tok
                        )
                    , trim$(str$!arg)
                  )
                )
        )
      & ( getAll
        =   K p
          .   !arg:(?K.?p)
            & !p:?P
            & whl'(!K:?K !p&!p !P:?P)
            & (!K.!P)
        )
      & ( llAteg
        =   K p
          .   !arg:(?K.?p)
            & !p:?P
            & whl'(!K:!p ?K&!p !P:?P)
            & (!K.!P)
        )
      & ( considerAbbrev
        =   A P kar kars nxt KRS Z
          .   !arg:(?arg.?nxt)
            & !arg:?A "."
            & getAll$(!A."."):(?A.?P)
            & (   ( !abb:abbr
                  |   !language:da
                    &   !A
                      : ~( ?
                           (%@:~(#|"."|","))
                           ?
                         )
                  |     !arg
                      : ? ((%@?kar&let$!kar) ?:?kars)
                    & str$!kars:?KRS
                    & ( (Mabbr..find)$!KRS
                      |   (Eabbr..find)$!KRS:? (!KRS.?) ?
                        & !KRS:?SentenceEndingAbbrSeen
                      |   upp$!KRS:!KRS
                        & !kars:? (%@?kar&~(let$!kar)) ?Z
                        & !Z:
                      | !nxt:(","|";"|":") ?
                      )
                  | !arg:% "." % ".":~(? "." "." ?)
                  )
                & SplitAbbr$!arg
              |   Split$!A
                  ( c
                  .     (type.p)
                        ( S
                        .   1+!tok:?TOK
                          & (   !tok:0
                              & 1+!sen:?sen
                            |   0:?tok
                              & 1:?IS
                              & !sen
                            )
                        )
                        (T.!TOK)
                    , str$!P
                  )
              )
        )
      & ( toksplit
        =   A N P Z tp PZ z F L,abb TOK chars kars kar
          .   !arg:(?arg.?abb)
            & ( !SentenceEndingAbbrSeen:
              |   :?SentenceEndingAbbrSeen
                & (   vap$((=.!arg).!arg):%?frst ?
                    & upp$!frst:!frst
                    & low$!frst:~!frst
                    & 0:?tok
                    & 1:?IS
                  | 
                  )
              )
            & ( !arg:
              |   vap$((=.!arg).!arg):?chars
                & ( considerAbbrev$(!chars.)
                  |     !chars
                      : ?A ((","|";"|":"):?P)
                    & getAll$(!A.!P):(?A.?P)
                    &   (considerAbbrev$(!A.!P)|Split$!A)
                        ( c
                        .     (type.p)
                              (S.Sen$)
                              (T.1+!tok:?tok)
                          , !P
                        )
                  |   !chars:?A (("!"|"?"):?P)
                    & getAll$(!A.!P):(?A.?P)
                    &   (considerAbbrev$(!A.!P)|Split$!A)
                        ( c
                        .     (type.p)
                              ( S
                              .   1+!tok:?TOK
                                & (   !tok:0
                                    & 1+!sen:?sen
                                  |   0:?tok
                                    & 1:?IS
                                    & !sen
                                  )
                              )
                              (T.!TOK)
                          , !P
                        )
                  |   ( sep
                      =   "("
                        | ")"
                        | "{"
                        | "}"
                        | "["
                        | "]"
                        | "<"
                        | ">"
                        | ‚Äú
                        | ‚Äù
                        | ‚Äò
                        | ‚Äô
                        | \"
                        | ‚Äπ
                        | ‚Ä∫
                        | ¬´
                        | ¬ª
                        | "|"
                        | "'"
                        | "`"
                      )
                    &   !chars
                      :   @( ?F
                           : ("-"|‚Äì|!sep)
                           )
                          ?A
                    & llAteg$(!A.!F):(?A.?F)
                    &   ( c
                        .     (type.p)
                              (S.Sen$)
                              (T.1+!tok:?tok)
                          , !F
                        )
                        toksplit$(str$!A.!abb)
                  |   !('($chars:%?A @(?F:$sep)))
                    & getAll$(!A.!F):(?A.?F)
                    &   toksplit$(str$!A.!abb)
                        ( c
                        .     (type.p)
                              (S.Sen$)
                              (T.1+!tok:?tok)
                          , !F
                        )
                  | Split$!chars
                  )
              )
        )
      & ( Tx
        =   abb efter f√∏r
          .   !arg:(?arg.?abb.?f√∏r,?efter)
            & ( !arg:
              |     vap
                  $ ( ( 
                      =   
                        .   (@(!arg:?arg \r)|)
                          &   (c.(type.s),\n)
                              ( !arg:
                              |       vap
                                    $ ( ( 
                                        =   T
                                          .   ( 1+!tok:?tok
                                              & (c.(type.s)," ")
                                              )
                                              ( !arg:
                                              |   vap
                                                $ ( ( 
                                                    =   T
                                                      .   !arg:
                                                        | toksplit$(!arg.!abb)
                                                    )
                                                  . !arg
                                                  . \t
                                                  )
                                              )
                                        )
                                      . !arg
                                      . " "
                                      )
                                  :   (c.(type.s) ?,?)
                                      ?arg
                                & !arg
                              )
                      )
                    . !arg
                    . \n
                    )
                : (c.(type.s) ?,?) ?arg
              )
            & ( concS
              =   A s S SER RES res
                .   :?SER:?RES
                  &   whl
                    ' ( !arg:~
                      & :?S
                      &   whl
                        ' (   !arg
                            : (c.(type.s) ?,?A) ?arg
                          & !A !S:?S
                          )
                      &     (   !S:
                              & !arg:%?A ?arg
                              & !A
                            |   :?s
                              &   whl
                                ' ( !S:%?A ?S
                                  & !A !s:?s
                                  )
                              & (     !f√∏r
                                    : ( c
                                      | lb
                                      | space
                                      )
                                  & 
                                |   !arg:
                                  &   !efter
                                    : ( c
                                      | lb
                                      | space
                                      )
                                  & 
                                | (c.(type.s),str$!s)
                                )
                            )
                            !SER
                        : ?SER
                      & :?f√∏r
                      )
                  &   whl
                    ' ( !SER:%?res ?SER
                      & !res !RES:?RES
                      )
                  & !RES
              )
            & concS$!arg
        )
      & ( space
        =   
          .       !arg
                :   @( ?
                     :   ( " "
                         | \n
                         | \r
                         | \t
                         )
                         ?
                     )
                    (~(c|lb|space).?)
                    ?
              & (c.(type.s),)
            | 
        )
      & ( ecaps
        =   f√∏r B
          .       !arg
                : ( @( ?
                     :   ?B
                         ( " "
                         | \n
                         | \r
                         | \t
                         )
                     )
                  . ?f√∏r
                  )
              & (   ( !f√∏r:(c|lb|space)
                    | trm$!B:
                    )
                  & 
                | (c.(type.s),)
                )
            | 
        )
      & ( trav
        =   A e a S B aS abb f√∏r LIST
          .     !arg:(?arg.?abb.?f√∏r)
              & :?LIST
              &   whl
                ' ( !arg:?A (?e.?aS) ?B
                  &     ( 
                        .   Tx$(!A.!abb.!f√∏r,!e)
                            ( (   !e:w
                                & !aS:(?a,?S)
                                &   ecaps$(!A.!f√∏r)
                                    ( w
                                    .     !a
                                          (S.Sen$)
                                          (T.1+!tok:?tok)
                                      , trim$!S
                                    )
                                    space$!B
                              |   !e:c
                                & !aS:(?a,?S)
                                &   ( c
                                    .     !a
                                          (S.Sen$)
                                          (T.1+!tok:?tok)
                                      , !S
                                    )
                                    (   !a:? (type.s) ?
                                      & 
                                    | space$!B
                                    )
                              |   !e:(add|ex)
                                &   ecaps$(!A.!f√∏r)
                                    ( !e
                                    .     !aS:(?a,?S)
                                        & (!a,trav$(!S.!abb.))
                                      | !aS
                                    )
                                    space$!B
                              |   !e:del
                                & ecaps$(!A.!f√∏r) (!e.!aS) space$!B
                              |     !e
                                  : ( rdg
                                    | lem
                                    | app
                                    | linkGrp
                                    )
                                & (!e.!aS)
                              | (   !e
                                  : (   ( p
                                        | u
                                        | s
                                        | seg
                                        | head
                                        | note
                                        | back
                                        | front
                                        | div
                                        | argument
                                        | byline
                                        | closer
                                        | dateline
                                        | docAuthor
                                        | docDate
                                        | epigraph
                                        | floatingText
                                        | opener
                                        | postscript
                                        | rs
                                        | salute
                                        | signed
                                        | trailer
                                        )
                                      & 1:?IS
                                      & 0:?tok
                                    | ?
                                    )
                                .     !aS:(?a,?S)
                                    & ( !a
                                      ,   trav
                                        $ ( !S
                                          . !e:abbr|!abb
                                          . 
                                          )
                                      )
                                  | !aS
                                )
                              )
                            : ? (?f√∏r.?)
                            )
                        )
                        !LIST
                    : ?LIST
                  & !B:?arg
                  )
              & !arg:~(? (?.?) ?)
              & (.Tx$(!arg.!abb.!f√∏r,)) !LIST:?LIST
              & :?B
              &   whl
                ' ( !LIST:(.?A) ?LIST
                  & !A !B:?B
                  )
              & !B
            | 
        )
      & ( contractwadddel
        =   content
          .   ( content
              =   A c
                .     !arg:?A (w.?,?c) ?arg
                    & str$(!A !c content$!arg)
                  | !arg
              )
            & ( tok-1
              =   E sen
                .   !arg:(?arg.? (S.?sen) ?)
                  & ( E
                    =   A e a s p q t
                      .       !arg
                            :   ?A
                                ( ?e
                                .     ( ~(? (S.?) ?)
                                      | ? (S.Sen$) ?
                                      )
                                    : ?a
                                  , ?s
                                )
                                ?arg
                          &   !A
                              ( !e
                              .     !a:?p (T.?t) ?q
                                  & (!p (T.-1+!t) !q,!s)
                                | (!a,E$!s)
                              )
                              E$!arg
                        | !arg
                    )
                  & E$!arg
              )
            & trq$!arg
        )
      & ( remST
        =   E1 E2 S Sn e a c sent Sno acc A Z
          .   !arg:(?arg.?Sno)
            & :?acc:?sent
            &   whl
              ' ( !arg:%?E ?arg
                &   !E
                  : ( @&!acc !E:?acc
                    |   (?e.?a,?c)
                      & remST$(!c.!Sno):?c
                      & (   !a:?A (S.~!Sno:?Sno) ?Z
                          &     !sent
                                (   !acc
                                  : % %
                                  :   ?
                                      (?.? (S.?) ?,?)
                                      ?(s.,!acc)
                                | !acc
                                )
                            : ?sent
                          & :?acc
                        | !acc (!e.!A !Z,!c):?acc
                        )
                    )
                )
            &   !sent
                (   !acc
                  : % %
                  : ? (?.? (S.?) ?,?) ?(s.,!acc)
                | !acc
                )
        )
      & ( inverse
        =   L e
          .   :?L
            & whl'(!arg:%?e ?arg&!e !L:?L)
            & !L
        )
      & ( reverseAndProvideMissingOpeningTags
        =   el intra tnes closed sent artni e
          .   !arg:(?artni.?tnes)
            & inverse$!tnes:?SeNt
            & :?sent:?intra:?closed
            &   whl
              ' ( !tnes:%?el ?tnes
                & (   !el:(.?.)
                    & !el !closed:?closed
                  |   !el:(?e.?)
                    & !closed:(.!e.) ?closed
                  | 
                  )
                & !el !sent:?sent
                )
            &   whl
              ' ( !closed:~
                & !artni:%?el ?artni
                & (   !el:(?e.?)
                    & !closed:(.!e.) ?closed
                  | 
                  )
                & !el !sent:?sent
                )
            & (!artni.!sent)
        )
      & ( constructAsentence
        =   intra tnes sents artni sent SorT
          .   !arg:(?intra.?tnes.?sents.?SorT.?AT)
            & inverse$!intra:?artni
            & reverseAndProvideMissingOpeningTags$(!artni.!tnes):(?artni.?sent)
            &   (   !SorT:S
                  & ( s
                    .   |(where.!AT)
                      ,   map
                        $ ( ( 
                            =   a z
                              .     !arg:(w.?,?a (w.?) ?z)
                                  &   !a !z
                                    : ? (w|c.?) ?
                                  & !arg
                                | !arg:(w.?,?arg)&!arg
                                | !arg
                            )
                          . ser$(!sent.T)
                          )
                    )
                | (w.|(where.!AT),!sent)
                )
                !artni
                !sents
        )
      & ( ser
        =   tnes open theS intra sents closed ort sent artni SorT
          .     
              : ?tnes
              : ?open
              : ?theS
              : ?intra
              : ?sents
            & !arg:(?arg.?SorT)
            & !( 
               ' ( $arg
                 : ?intra ((?.? ($SorT.?theS) ?) ?:?arg)
                 )
               )
            &   whl
              ' ( !arg:%?el ?arg
                & (     !el
                      : (@|(?.?,?)|("!--".?))
                    & "Element is string, empty or comment."
                    & (   !open:
                        & (   !( 
                               ' ( $arg
                                 : ? (?.? ($SorT.?S) ?) ?
                                 )
                               )
                            & (   !theS:!S
                                & "Sequence continues."
                                & !el !tnes:?tnes
                              |   "'el' not required in sentence"
                                &   constructAsentence$(!intra.!tnes.!sents.!SorT.A)
                                  : ?sents
                                & :?intra:?tnes
                                & "Continue from start of next sequence."
                                & !( 
                                   ' ( $arg
                                     :   ?intra
                                         (   (?.? ($SorT.?theS) ?)
                                             ?
                                         : ?arg
                                         )
                                     )
                                   )
                                & !el !intra:?intra
                              )
                          |   "No more sequences."
                            &   constructAsentence$(!intra.!tnes.!sents.!SorT.B)
                              : ?sents
                            & !el !arg:?intra
                            & :?arg
                          )
                      |   "Some sequence element is still open. Wait for closing tag or end of sentence"
                        & !el !tnes:?tnes
                      )
                  |   !el:(.?e.)
                    & "Closing tag."
                    & (   !open:(!e.?) ?open
                        & "Tag belongs to sequence."
                        & (   !open:
                            & (   !( 
                                   ' ( $arg
                                     : ? (?.? ($SorT.?S) ?) ?
                                     )
                                   )
                                & (   !theS:!S
                                    & "Sequence continues."
                                    & !el !tnes:?tnes
                                  |   "'el' required in sequence"
                                    & !el !tnes:?tnes
                                    &   constructAsentence$(!intra.!tnes.!sents.!SorT.AA)
                                      : ?sents
                                    & :?intra:?tnes
                                    & "Continue from start of next sequence."
                                    & !( 
                                       ' ( $arg
                                         :   ?intra
                                             (   (?.? ($SorT.?theS) ?)
                                                 ?
                                             : ?arg
                                             )
                                         )
                                       )
                                  )
                              |   "No more sequences."
                                & !el !tnes:?tnes
                                &   constructAsentence$(!intra.!tnes.!sents.!SorT.BB)
                                  : ?sents
                                & inverse$!arg:?intra
                                & :?arg
                              )
                          | !el !tnes:?tnes
                          )
                      |   !( 
                           ' ( $arg
                             : ? (?.? ($SorT.?S) ?) ?
                             )
                           )
                        & (   !S:!theS
                            & "Tag belongs to sequence."
                            & !el !tnes:?tnes
                          |   "Tag not needed in sequence, it seems."
                            &   constructAsentence$(!intra.!tnes.!sents.!SorT.C)
                              : ?sents
                            & :?intra:?tnes
                            & !( 
                               ' ( $arg
                                 :   ?intra
                                     ( (?.? ($SorT.?theS) ?) ?
                                     : ?arg
                                     )
                                 )
                               )
                            & !el !intra:?intra
                          )
                      |   "No more sequences."
                        & !open:
                        & constructAsentence$(!intra.!tnes.!sents.!SorT.D):?sents
                        & !el !arg:?intra
                        & :?arg
                      | 
                      )
                  |   !el:(?e.?a)
                    & (   !('($a:? ($SorT.?S) ?))
                        & "Open tag with T and S attributes."
                        & (   !S:~!theS:?theS
                            & "New sequence"
                            & (   !open:
                                &   constructAsentence$(!intra.!tnes.!sents.!SorT.E)
                                  : ?sents
                                & :?intra:?tnes
                                & !el !open:?open
                                & !el !tnes:?tnes
                              |     "A New sequence started, but previous sequence has elements that are not closed."
                                    !el
                                    OPEN
                                    !open
                                & 
                              )
                          |   "Old seqence"
                            & !el !open:?open
                            & !el !tnes:?tnes
                          )
                      |   "Open tag not carrying T and S attributes."
                        & !( 
                           ' ( $arg
                             : ? (?.? ($SorT.?S) ?) ?
                             )
                           )
                        & "Still sequence(s) to do."
                        & (   !open:
                            & !S:~!theS:?theS
                            & "New sequence"
                            &   constructAsentence$(!intra.!tnes.!sents.!SorT.F)
                              : ?sents
                            & !( 
                               ' ( $arg
                                 :   ?intra
                                     ( (?.? ($SorT.?theS) ?) ?
                                     : ?arg
                                     )
                                 )
                               )
                            & !el !intra:?intra
                          |   "Old seqence"
                            & !el !open:?open
                            & !el !tnes:?tnes
                          )
                      |   "No more sequences hereafter."
                        & !open:
                        & constructAsentence$(!intra.!tnes.!sents.!SorT.G):?sents
                        & !el !arg:?intra
                        & :?arg
                      )
                  )
                )
            & inverse$(!intra !sents)
        )
      & ( structsub
        =   e a c A S Z
          .   1+!subn:?subn
            &   map
              $ ( ( 
                  =   
                    .     !arg:(?e.?a,?c)
                        & (   !a:?A (S.?S) ?Z
                            & (!e.!A (S.str$(!S "." !subn)) !Z,!c)
                          | !e:c&!arg
                          | (!e.!a,structsub$!c)
                          )
                      | !arg
                  )
                . !arg
                )
        )
      & ( substruct
        =   e a c
          .   "If a substructure of an <s> (e.g. <rs>) has two or more S values,
               then make them all unique by adding '.n',
               where 'n' is a text-wide unique number.
               A substructure is an element embedded in an element that has children with S and T attributes."
            & (   !arg:? (?.? (S.?) ?,?) ?
                & "arg seems to be the content of e.g. an <s>. Now check each element in arg for substructures with S'es."
                &   map
                  $ ( ( 
                      =   
                        .     !arg:(?e.?a,?c)
                            & (   !a:? (S.?) ?
                                & !arg
                              | !e:c&!arg
                              | (!e.!a,structsub$!c)
                              )
                          | !arg
                      )
                    . !arg
                    )
              |   map
                $ ( ( 
                    =   
                      .     !arg:(?e.?a,?c)
                          & ( !e:c&!arg
                            | (!e.!a,substruct$!c)
                            )
                        | !arg
                    )
                  . !arg
                  )
              )
        )
      & ( collectSvals
        =   S a c
          .   map
            $ ( ( 
                =   
                  .     !arg:(?.?a,?c)
                      & ( !a:? (S.?S) ?&!S
                        | collectSvals$!c
                        )
                    | 
                )
              . !arg
              )
        )
      & ( retrieveSsequences
        =   e a c A S Z
          .   "If an element has no children with S and T elements, then its substructures may not share the same S value if any of those substructures has more than one S value. So this should not be allowed:
                            ( address
                            . , (c.(type.s),\" \")
                                ( addrLine
                                . , (w.(S.1) (T.4),Hr)
                                    ( c
                                    . (type.p) (S.1) (T.5),\".\"
                                    )
                                    (c.(type.s),\" \")
                                    (w.(S.2) (T.2),mag)
                                    ( c
                                    . (type.p) (S.2) (T.2),\".\"
                                    )
                                    (w.(S.2) (T.2),art)
                                )
                                (c.(type.s),\" \")
                                ( addrLine
                                . , ( persName
                                    . (ref.\"#np56\")
                                      , (w.(S.2) (T.6),Louis)
                                        (c.(type.s),\" \")
                                        (w.(S.2) (T.8),Hjelmslev)
                                    )
                                )
                                (c.(type.s),\" \")
                            )
              "
            & (   !arg:? (?.? (S.?) ?,?) ?
                & "There is at least one sibling with an S attribute.
                   So this comprises one or more complete or inclomplete sentences.
                   Make a list of all S values occurring in arg."
                & (collectSvals$!arg.!arg)
              |   map
                $ ( ( 
                    =   
                      .     !arg:(?e.?,?c)
                          & ( !e:c&
                            | retrieveSsequences$!c
                            )
                        | 
                    )
                  . !arg
                  )
              )
        )
      & "replacestruct: Replace S values that continue into next substructure by new unique values."
      & ( replacestruct
        =   e a c O N
          .     !TransS:(!arg.?O.?N) ?TransS
              & sub$(!arg.(S.!O).S.!N)
            |   map
              $ ( ( 
                  =   
                    .     !arg:(?e.?a,?c)
                        & (!e.!a,replacestruct$!c)
                      | !arg
                  )
                . !arg
                )
        )
      & trav$(!text..):?nbody
      & contractwadddel$!nbody:?nbody2
      &   (!style:PT&rcontr$!nbody2|!nbody2)
        : ?nmbody2
      & assignIDs$!nmbody2:?nnbody
      & 0:?subn
      & substruct$!nnbody:?nnbodys
      & retrieveSsequences$!nnbodys:?Sseq
      & ( CreateReplacementTriplets
        =   a A M Z
          .   "Find two consecutive elements in TransS where the first ends with an S value equal to the first S value in the second element,
               and where the first or the second element also contains another S value."
            & :?TransS
            & (   !arg
                :   ?
                    (?A %@?M.?a)
                    (   %@!M ?Z
                      & ( !A:? (%@:~!M) ?
                        | !Z:? (%@:~!M) ?
                        )
                      &   !TransS (!a.!M.str$(!M "." (1+!subn:?subn)))
                        : ?TransS
                      & ~
                    . 
                    )
                    ?
              | !TransS
              )
        )
      & CreateReplacementTriplets$!Sseq:?TransS
      & replacestruct$!nnbodys:?nnbodys2
      & get$(toML$!nnbodys2,X ML MEM):?serial
      & ser$(!serial.S):?nrbody
      & 0:?ID
      & ( removeOutliers
        =   
          .   map
            $ ( ( 
                =   e a c
                  .   !arg:(s.?,?)
                    |   !arg:(w|c.?,?)
                      & 
                    |   !arg:(?e.?a,?c)
                      & (!e.!a,removeOutliers$!c)
                    | !arg
                )
              . !arg
              )
        )
      & ( vlooi
        =   
          .   map
            $ ( ( 
                =   e a c
                  .     !arg:((w|c):?e.?a,?c)
                      &     map
                          $ ( ( 
                              =   
                                .     !arg:(S|T.?)
                                    & 
                                  | !arg
                              )
                            . !a
                            )
                        : ?a
                      & (!e.("xml:id".IDgen$!a) !a,vlooi$!c)
                    |   !arg:(?e.?a,?c)
                      &     map
                          $ ( ( 
                              =   
                                .     !arg:(S|T.?)
                                    & 
                                  | !arg
                              )
                            . !a
                            )
                        : ?a
                      & (!e.!a,vlooi$!c)
                    |   !arg:((w|c):?e.?a)
                      &     map
                          $ ( ( 
                              =   
                                .     !arg:(S|T.?)
                                    & 
                                  | !arg
                              )
                            . !a
                            )
                        : ?a
                      & (!e.("xml:id".IDgen$!a) !a)
                    | !arg
                )
              . !arg
              )
        )
      &   !XXX
          ( TEI
          .   !teiatt
            , !AAA (text.!textatt,vlooi$(removeOutliers$(nestML$!nrbody))) !DDD
          )
          !YYY
  )
  ( new
  =   input abbr style
    .   ~
      |   ~
        &   (its.teitok)$("test/acc-1992_0005_032_Uldall_0010-tei-final.xml".simple..da)
          : ?XMLL
        & toML$!XMLL:?XMLLL
        & put$(!XMLLL,"test/ellipsis.out.xml",NEW)
      |   ~
        &   (its.teitok)$("test/acc-1992_0005_030_Western_0090-tei-final.xml".simple..nb)
          : ?XMLL
        & toML$!XMLL:?XMLLL
        & put$(!XMLLL,"test/ellipsis.out.xml",NEW)
      |   ~
        & vap$((=.!arg).get$(abbr,STR).\n):?abbr
        &   (   get$(nabbr,STR):?nabbr
              & vap$((=.!arg).!nabbr.\n)
            | 
            )
          : ?nabbr
        & (its.teitok)$("test\\ellipsis.xml".simple.!nabbr !abbr.da):?XMLL
        & toML$!XMLL:?XMLLL
        & put$(!XMLLL,"test\\ellipsis.out.xml",NEW)
      |   ~
        & vap$((=.!arg).get$(abbr,STR).\n):?abbr
        &   (   get$(nabbr,STR):?nabbr
              & vap$((=.!arg).!nabbr.\n)
            | 
            )
          : ?nabbr
        &     (its.teitok)
            $ ("test\\ParlaMint-DK_2020-06-22-20191-M134-369.xml".simple.!nabbr !abbr.da)
          : ?XMLL
        & toML$!XMLL:?XMLLL
        & put$(!XMLLL,"test\\ParlaMint-DK_2020-06-22-20191-M134-369.out.xml",NEW)
      |   ~
        & vap$((=.!arg).get$(abbr,STR).\n):?abbr
        &   (   get$(nabbr,STR):?nabbr
              & vap$((=.!arg).!nabbr.\n)
            | 
            )
          : ?nabbr
        &   (its.teitok)$("test\\ParlaMint...shorter.xml".simple.!nabbr !abbr.da)
          : ?XMLL
        & toML$!XMLL:?XMLLL
        & put$(!XMLLL,"test\\ParlaMint...shorter.out.xml",NEW)
      |   ~
        & vap$((=.!arg).get$(abbr,STR).\n):?abbr
        & (its.teitok)$("ParlaMint-DK_2022-03-03-20211-M71.xml".simple.!abbr.da):?XMLL
        & toML$!XMLL:?XMLLL
        & put$(!XMLLL,"ParlaMint-DK_tokenerror.out.xml",NEW)
      |   arg$:?input
        & arg$:?output
        & arg$:(PT|simple):?style
        & arg$:?abbreviations
        & arg$:?language
        &   ( !abbreviations:"-"&
            | vap$((=.!arg).get$(!abbreviations.STR).\n)
            | 
            )
          : ?abbr
        &   (   get$(nabbr,STR):?nabbr
              & vap$((=.!arg).!nabbr.\n)
            | 
            )
          : ?nabbr
        & (!language:~"-"|):?lang
        &   put
          $ (toML$((its.teitok)$(!input.!style.!nabbr !abbr.!lang)),!output,NEW)
  );

r=
  get'("teitok.bra",TXT)
& rmv$(str$(teitok ".bak"))
& ren$("teitok.bra".str$(teitok ".bak"))
&   put
  $ ( "{teitok.bra
ùïåùïãùîΩ-ùü†
Takes a TEI P5 document and creates <w> and <c> elements.
Get the casing right for Danish TEI P5 texts}

"
    , "teitok.bra"
    , NEW
    , WYD
    , BIN
    )
& lst'(X,"teitok.bra",APP,WYD,BIN)
& put'(\n,"teitok.bra",APP,WYD,BIN)
& lst'(r,"teitok.bra",APP,WYD,BIN)
& put$(str$("\nnew'" X ";\n"),"teitok.bra",APP,BIN)
& ;

new'X;
