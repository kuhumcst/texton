{toolsProg.bra


    Copyright 2014, Bart Jongejan
    This file is part of the DK-ClarinTools.

    DK-ClarinTools is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    DK-ClarinTools is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with DK-ClarinTools.  If not, see <http://www.gnu.org/licenses/>.





Source code for DK-Clarin tools webservice 

To neatly re-format this source code, load the file in a running instance of
Bracmat:

    get$"toolsprog.bra"
    
Now, after you have made changes to the source code in a text editor, reload
the source code in Bracmat using the command:

    !r

This command re-reads the file, renames the previous version from toolsprog.bra
to toolsprog.bak and then saves the source code. Some editors will notice that
the text has changed on disk and offer you to reload the source code.

To change the comment near the start of this file, you need to go to the bottom
of the file and find the text there. A change made to that text takes effect
after saving once and pressing !r two times. Remember to escape quotes " with
a backslash \. Comments elsewhere (i.e. text enclosed by braces { and } is NOT
saved. Use string expressions if you want a comment somewhere.

The following commands can be issued by sending an 'expression' HTTP parameter
to the 'bracmatevaluator' servlet.

To get started from a file containing all tables called 'alltablesxxx' (replace
xxx with actual characters in the file name), e.g., alltables.GPL:

importTables$"alltables.GPL"

This reads the named file and stores each table in a separate file in a folder
structure
work/
    job/
    meta/
        feature/
        style/

(This folder structure must already exist.) Finally, the same file is
rewritten, so all lay-out is normalized (Bracmat style).

After changes have been made to the single table files, for example because
new tools are registered, the 'alltablesxxx' file is made up to date with

exportTables$

This command reads all single file tables from the folder structure and saves
them to 'alltablesxxx'. The command knows the actual name of the file to write
to because that name is stored in the variable AAA, which is itself stored
alongside all tables, and is therefore known after the last time 
importTables$alltablesxxx was called. It is possible to change context by
reading an 'alltablesyyy' that is different from 'alltablesxxx'.

To export all tables to a different file, do

exportTables$"alltableszzz"

where alltableszzz must be a valid file name that starts with 'alltables'.

To do a clean up, removing almost all that is not defined in this file from 
Bracmat's memory, call the clean function

    clean$
    
Changes made to table files take immediately effect. It is advised to use the
admin page to register new tools. Some changes cannot be made using the admin
page, such as adding a new feature or feature value.
    
Server:
Add following line to /etc/httpd/conf.d/proxy_ajp.conf:
    ProxyPass /toolsdata !
(Restart Apache sudo /etc/init.d/httpd restart)
    
Make sure bracmat is in JBoss's or Tomcat PATH:
    /usr/lib/libbracmat.so -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1 -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1.0

The conf/properties.xml file has an entry "toolsHome". The value of this entry
is the location of this file, toolsprog.bra.
}

toolsProg=
  (setLang$da|)
&     (indent=0)
      (logno=0)
      (tabind=0)
      (globval=)
      ( headerTitle
      = "Text Tonsorium - Natural Language Processing toolchains automatically composed and scheduled for you"
      )
      (hiddenData=)
      ( "Set from boot"
        (toolshome=)
        (documentRoot=)
        (wwwServer=)
        (deleteAfterMillisec=)
        86400000
        (stagingArea=)
        (repoServiceUrl=)
        (baseUrlTools=)
        (path=)
      )
      (servicedSources=)
      (servicedGoals=)
      (StartClk=)
      (startclock=.-1*clk$:?StartClk)
      ( clock
      =   
        .   ( !StartClk:&startclock$
            | 
            )
          & str$("[" jsn$(clk$+!StartClk) "]")
      )
      ( 2to3col
      =   features specificationTables table specificationTable norm
        .   ( norm
            =   o n a b
              .   readTable$!arg
                & !!arg:?o
                & :?n
                &   whl
                  ' ( !o:(?a.?b) ?o
                    & (!b:(?.?)|(!b.):?b)
                    & !n (!a.!b):?n
                    )
                & !n:?!arg
                & saveTable$!arg
            )
          & readTable$features
          &   whl
            ' (   !features
                :   ( ? (table.?table) ?
                    : (     ?
                            (specificationTable.?specificationTables)
                            ?
                        &   whl
                          ' (   !specificationTables
                              :   (?.?specificationTable)
                                  ?specificationTables
                            & norm$!specificationTable
                            )
                      | ?
                      )
                    )
                  + ?features
              & norm$!table
              )
          & log$done
      )
      ( localized
      =   
        .   ( !LaNg:da&!arg:%@ %@?arg
            | !arg:%?arg ?
            )
          & !arg
      )
      "Reusable patterns in errorInMetadata function"
      ( ISO639
      = [%( readTable$linguae
          & !( 
             ' ( $linguae
               : ( ? (?.$sjt.?) ?
                 | ? (? ()$sjt ?.?.?) ?
                 )
               )
             )
          )
      )
      ( DATE
      =   (   #%@?y1 #%@?y2 #%@?y3 #%@?y4 "-" #%@?m1 #%@?m2 "-" #%@?d1 #%@?d2
            & 10*!m1+!m2:~<1:~>12
            & 10*!d1+!d2:~<1:~>31
          | #%@?y1 #%@?y2 #%@?y3 #%@?y4
          )
        & 1000*!y1+100*!y2+10*!y3+!y4:<2100
      )
      ( MEDIATYPE
      =   ( application
          | audio
          | example
          | image
          | message
          | model
          | multipart
          | text
          | video
          | chemical
          )
          "/"
            ( 
            =   sub parms suf name
              .   @(!sjt:(?sub ";" ?parms|?sub))
                & whl'@(!sub:?sub " ")
                & @( !sub
                   : ( (vnd|prs|x) "." ?name
                     | ?name
                     )
                   )
                & (   @(!name:? "+" ?suf)
                    & (   !suf
                        : ( xml
                          | json
                          | ber
                          | der
                          | fastinfoset
                          | wbxml
                          | zip
                          | cbor
                          | binary
                          | vrml
                          )
                      | `~
                      )
                  | 
                  )
                & ?
            )
          $ 
      )
      (path=.str$(!toolshome !arg))
      "
/**
 * toolsdata
 *
 * Return the full file system path to Tool's staging area.
 * The input can be a file name: this name is appended to the returned value.
 *
 * Called from workflow.java
 */"
      ( toolsdata
      = .str$(!documentRoot (|!stagingArea) !arg)
      )
      "
/**
 * toolsdataURL
 *
 * Return the full URL to Tool's staging area.
 * The input can be a file name: this name is appended to the returned value.
 *
 * Called from workflow.java
 */"
      (toolsdataURL=.str$(!baseUrlTools !stagingArea !arg))
      (toolsUploadURL=.str$(!baseUrlTools "/texton/upload" !arg))
      ( log
      =   c spc i logfile
        .   path$"log.txt":?logfile
          & (   !arg:NEW
              & put$(,!logfile,NEW)
              & startclock$
              & 0:?logno
            |   (!logno|0:?logno)
              &     ( :?spc
                    & NEWSPEC
                    & 1+!logno:?logno
                    & !indent:?i
                    &   whl
                      ' ( !i+-1:>0:?i
                        & " " !spc:?spc
                        )
                    & str$("[" !indent "] " !logno !spc)
                    )
                    !arg
                : ?arg
              & put$(clock$,!logfile,APP)
              &   whl
                ' ( !arg:%?c ?arg
                  & put$(!c " ",!logfile,APP)
                  )
              & put$(\n,!logfile,APP)
            )
      )
      ( read
      = .get$(path$((!arg:~|all) ".bra"))
      )
      ( importTables
      =   
        .     @(!arg:alltables ?)
            & ( get$(path$!arg)&saveAllTables$
              | str$("Cannot read " !arg)&~
              )
          |   str
            $ "Usage: importTables$\"<file name>\" .  <file name> must start with 'alltables'."
      )
      ( exportTables
      =   tabs tab Tables folder error
        .     ( !where:(?.?) ?
              | readTable$where
              )
            & (   !arg:(|@(?:alltables ?))
                & 0:?tabs
                & :?error
                & (   !where
                    :   ?
                        ( ?Tables
                        .   ?folder
                          &   whl
                            ' ( !Tables
                              :   ( %@?tab
                                  & (   readTableFromFolder$(!folder.!tab)
                                      & !tab+!tabs:?tabs
                                    |   log
                                      $ ( str
                                        $ ( " Cannot read ["
                                            !tab
                                            "] in ["
                                            !folder
                                            "]."
                                          )
                                        )
                                    )
                                  )
                                  ?Tables
                              )
                          & ~
                        )
                        ?
                  |   ( !tabs:?+where+?
                      | where+!tabs:?tabs
                      )
                    & (   @(!arg:alltables ?)
                        & !arg:?AAA
                      | 
                      )
                    & (   lst$(!tabs,path$!AAA,NEW)
                        &   str
                          $ ( "Read all tables and saved them in '"
                              path$!AAA
                              "'. To restore, type importTables$\""
                              !AAA
                              "\"."
                              (!error:|!error)
                            )
                      |   str
                        $ ( "Cannot write to ["
                            path$!AAA
                            "]. Check file access rights for JBoss/Tomcat."
                          )
                      )
                  )
              |   str
                $ "'exportTables$' must be called without argument or with the name of a file that must start with 'alltables'."
              )
          | str$"Cannot read table 'where'"&~
      )
      ( readTableFromFolder
      =   folder file
        .     !arg:(?folder.?file)
            & get$(path$(!folder !file)):?!file
          | str$("Cannot read " !arg)&~
      )
      ( readTable
      =   folder
        .     !arg:%@
            & (   !arg:(AAA|where)
                & (get$(path$!arg):?!arg|`~)
              |   ( !where:(?.?) ?
                  | readTable$where
                  )
                & !where:? (? !arg ?.?folder) ?
                & get$(path$(!folder !arg)):?!arg
              )
          | log$("Cannot read " !arg)&~
      )
      ( saveAllTables
      =   tab saved folder
        .   !arg:
          & :?saved
          & (   !where
              :   ?
                  ( ?Tables
                  .   ?folder
                    &   whl
                      ' ( !Tables
                        :   ( %?tab
                            & saveTable$(!folder.!tab)
                            & !saved !tab:?saved
                            )
                            ?Tables
                        )
                    & ~
                  )
                  ?
            | Saved !saved
            )
      )
      ( saveTable
      =   tab saved folder
        .     !arg:
            & :?saved
            & (   !where
                :   ?
                    ( ?Tables
                    .   ?folder
                      &   whl
                        ' ( !Tables
                          :   ( %?tab
                              & saveTable$(!folder.!tab)
                              & !saved !tab:?saved
                              )
                              ?Tables
                          )
                      & ~
                    )
                    ?
              | Saved !saved
              )
          |   !arg:(?folder.?tab)
            & lst$(!tab,path$(!folder !tab),NEW,RAW)
          |     whl
              ' ( !arg:%?tab ?arg
                & (   !where:? (? !tab ?.?folder) ?
                    & lst$(!tab,path$(!folder !tab),NEW,RAW)
                  | 
                  )
                )
            & 
      )
      (recentTasks=)
      ( saveToolTable
      = .saveTable$!arg&:?recentTasks
      )
      ( setLang
      =   full YYY A Z
        .       (   @(low$!arg:d (a|k) ?)
                  & da
                | en
                )
              : ?LaNg
            & readTable$linguae
            & !linguae:? (?full.!LaNg.?YYY) ?
            & localized$!full
            & (   !hiddenData:?A (UIlanguage.?) ?Z
                & !A !Z:?hiddenData
              | 
              )
            & (UIlanguage.!LaNg) !hiddenData:?hiddenData
          | log$("failed to set language to " !arg)
      )
      "
/**
 * clean
 * 
 * Free all variables that shouldn't exist.
 * Such variables are normally undeclared 'local' variables.
 * (In proper coding, all such variables should be declared).
 *
 * Called from reloadScript.java
 */"
      ( clean
      =   c w sgn
        .   cat$:?c
          & :?sgn
          &   whl
            ' ( !c:%?w ?c
              & (     MLencoding
                      arg
                      c
                      cat
                      cos
                      fct
                      flt
                      jsn
                      nestML
                      out
                      sgn
                      sin
                      tay
                      toML
                      w
                      Functions
                      !Functions
                  : ? !w ?
                | !w !sgn:?sgn&tbl$(!w,0)
                )
              )
          & !sgn
      )
      ( trim
      =   a z
        .     whl
            ' ( @(!arg:?a \r ?z)
              & str$(!a !z):?arg
              )
          &   whl
            ' @(!arg:(" "|\n|\t) ?arg)
          &   whl
            ' @(!arg:?arg (" "|\n|\t))
          & !arg
      )
      ( hasTree
      =   2a 3a 1a 5a
        .     !arg:(?2a.?5a:(=?3a))
            & !2a:!3a
          |   !2a
            : ? (?.?,?1a&hasTree$(!1a.!5a)) ?
      )
      "
/**
 * getComponentRef
 *
 * Parse a resource's metadata.
 * (This function is very clarin.dk specific.)
 * Finds the item id, the value of the visibility property and the value of
 * the xlink:href attribute in the escidocComponents:component element with
 * mime-type text/xml, application/xml or text/plain
 * 
 * Input: the metadata of a resource (XML)
 *
 * No reference is made to any of the tables, so this function could just as
 * well have been implemented in Java+XPath. Here, we use Bracmat pattern 
 * matching in the XML-data.
 * Called from create.java when input is obtained from the clarin.dk
 * repository.
 */"
      ( getComponentRef
      =   visibility id ref mimetype
        .     "Input: metadata (XML)
               Returns something like dkclarin:111010/components/component/dkclarin:111009/content
               To get the thing itself, prepend https://infra.clarin.dk/ir/item/ to the ref."
            & put$(!arg,path$"item.xml",NEW)
            &   nestML$(get$(!arg,X,ML,TRM,MEM))
              :   ?
                  ( "escidocItem:item"
                  .   ?
                    ,   ?
                        ( "escidocComponents:components"
                        .   ?
                          ,   ?
                              ( "escidocComponents:component"
                              .     ?
                                    ( "xlink:href"
                                    .   ?ref
                                      & @(rev$!ref:?ref "/" ?)
                                      & rev$!ref:?ref
                                    )
                                    ?
                                ,     ?
                                      ( "escidocComponents:properties"
                                      .   ?
                                        ,     ?
                                              ( "prop:mime-type"
                                              .   ?
                                                ,   ( text/xml
                                                    | application/xml
                                                    | text/plain
                                                    )
                                                  : ?mimetype
                                              )
                                              ?
                                          : (   ?
                                                ( "prop:visibility"
                                                . ,?visibility
                                                )
                                                ?
                                            |   ?
                                              & :?visibility
                                            )
                                      )
                                      ?
                                  :   ?
                                      ( "escidocComponents:content"
                                      .     ?
                                            ( "xlink:href"
                                            . @(?:"/ir/item/" ?id)
                                            )
                                            ?
                                        , 
                                      )
                                      ?
                              )
                              ?
                        )
                        ?
                  )
                  ?
            & str$(!id.!visibility.!ref)
          | 
      )
      ( theResourceItself
      =   stagingName meta feats visibility
        .     !arg
            :   ?
                (?.? ("xlink:href".@(?:"/ir/item/" ?arg)) ?)
                ?
          & readTable$Uploads
          &   !Uploads
            :   ?
                (?.!arg.?.?stagingName.?meta.?feats.?visibility)
                ?
          & nestML$(get$(toolsdata$!stagingName,X,ML,TRM))
      )
      ( xmlidstyle
      =   xmlid
        .       hasTree
              $ ( theResourceItself$!arg
                . ( 
                  = ? (w.? ("xml:id".?xmlid) ?,?) ?
                  )
                )
            & ( @(!xmlid:i # "." #)&cst
              | @(!xmlid:? # "-" #)&dsl
              | @(!xmlid:? #)&nor
              | 1
              )
          | raw
      )
      ( getFacet
      =     spec facets type2facet type
          , teiHeader teiHeaderAtts YYY
        .   "<application ident=\"CstClarinDaTokeniser\" subtype=\"tokenizer\" type=\"automatic_annotation\" version=\"1.0\" xml:id=\"CstClarinDaTokeniser\">
                      <desc xml:lang=\"da\">Samler de atomare cbf-segmenter i tokens</desc>
        </application>"
          & NEWSPEC
          & 1:?spec
          &   !arg
            :   ?
                ( "escidocItem:item"
                .   ?
                  ,   ?
                      ( "escidocMetadataRecords:md-records"
                      .   ?
                        ,   ?
                            ( "escidocMetadataRecords:md-record"
                            .   ?
                              ,   ?
                                  (teiHeader.?teiHeaderAtts,?teiHeader)
                                  ?
                            )
                            ?
                      )
                      ?
                )
                ?
          & (     !teiHeaderAtts
                : ? (xmlns.?) ?
                : ? (type.text) ?
              & text:?arg
            |     !teiHeaderAtts
                : ? (xmlns.?) ?
                : ? (type.dictionary) ?
              & dictionary:?arg
            |     !teiHeaderAtts
                : ? (xmlns.?) ?
                : ? (type.annotation) ?
              &   !teiHeader
                :   ?
                    ( encodingDesc
                    .   
                      ,   ?
                          ( appInfo
                          .   
                            ,   ?
                                ( application
                                . ? (subtype.?arg) ?,?
                                )
                                ?
                          )
                          ?
                    )
                    ?
            |   !teiHeaderAtts:? (xmlns.?) ?
              & "Example: <teiHeader xmlns=\"http://www.tei-c.org/ns/1.0\"> 
                Assume its TEIP5, just text"
              & text:?arg
            |   "HACK if appInfo is empty, read content"
              &   hasTree
                $ ( theResourceItself$!arg
                  . ( 
                    = ? (?.? (type.?type) ?,?) ?
                    )
                  )
              &   !type
                : ( Sseg&s-splitter:?arg
                  | Pseg&p-splitter:?arg
                  )
            )
          & (   readTable$subtype2facet
              & !subtype2facet:? (!arg.?arg) ?
            |   readTable$type2facet
              & !type2facet:? (!arg.?arg) ?
            |   readTable$facets
              & !facets:? (!arg.?arg.?YYY) ?
            )
          & NEWSPEC
          & !arg^!spec
      )
      (getLanguage=.)
      ( getOlacLanguage
      =   language
        .   !arg:? (language.?,?language) ?
          & !language
      )
      ( getOlacTitle
      =   olacTitle
        .   !arg:? (title.?,?olacTitle) ?
          & str$!olacTitle
      )
      ( getBaseItem
      =   base href
        .   "xlink:href=\"/ir/item/dkclarin:152004\""
          &   !arg
            :   ?
                ( "escidocItem:item"
                .   ? ("xml:base".?base) ?
                  ,   ?
                      ( "relations:relations"
                      .   ?
                        ,   ?
                            ( "relations:relation"
                            .       ?
                                    (predicate.@(?:? "#isAnnotationOf"))
                                    ?
                                : ? ("xlink:href".?arg) ?
                              , 
                            )
                            ?
                      )
                      ?
                )
                ?
          & str$(!base !href)
      )
      ( getFormat
      =   fmt
        .     hasTree
            $ ( !arg
              . ( 
                =   ?
                    ( publicationStmt
                    .   ?
                      ,   ?
                          (idno.? (type.format) ?,?fmt)
                          ?
                    )
                    ?
                )
              )
          & (@(!fmt:? "/" ?fmt)|)
          & ( !fmt:"rdf+xml"&rdf
            | !fmt:csv&csv
            )
      )
      ( getOlacFormat
      =   fmt conforms2 format spec
        .   "<format>application/xml</format>"
          &   !arg
            :   ?
                (format.?,@(?:? "/" ?fmt)|?fmt)
                ?
          & !fmt:xml
          & (   !arg:? (conformsTo.?,?conforms2) ?
              & 1:?spec
              & NEWSPEC
              &   !conforms2
                : (   TEIP5DKCLARIN
                    & txtbasis:?format
                    & xmlidstyle$!arg:?spec
                  |   (TEIP5PLAIN|TEIP5)
                    & teip5:?format
                  |   "TEIP5DKCLARIN_ANNOTATION"
                    & txtann:?format
                  )
              & NEWSPEC
              & !format^!spec
            | xm
            )
      )
      "
/**
 * Check whether the Tools staging area already has a copy of a given
 * resource. In that case, the slow process of copying the resource from the
 * repo and the analysis of this resource can be skipped.
 * If there is a copy, its time stamp is refreshed so as to extend its right
 * to live.
 * Arguments: item id and current date.
 * Side effect: the table Uploads.table is updated if the resource is found.
 *
 * Called from create.java
 */"
      ( hasCopy
      =     item newdate A Z nr Path file
          , meta a z feats visibility
        .     !arg:(?item.?newdate)
            & (readTable$Uploads|:?Uploads)
            &   !Uploads
              :   ?A
                  (?nr.!item.?Path.?file.?meta.?feats.?visibility)
                  ?Z
            & !meta:?a (DATE.?) ?z
            & !a (DATE.!newdate) !z:?meta
            &     !A
                  (!nr.!item.!Path.!file.!meta.!feats.!visibility)
                  !Z
              : ?Uploads
            & saveTable$Uploads
            & !visibility
          | no
      )
      ( NCNameStartChar
      =   ~<A:~>Z
        | "_"
        | ~<a:~>z
        | ~<À:~>Ö
        | ~<Ø:~>ö
        | ~<ø:~>˿
        | ~<Ͱ:~>ͽ
        | ~<Ϳ:~>῿
        | ~<‌:~>‍
        | ~<⁰:~>↏
        | ~<Ⰰ:~>⿯
        | ~<、:~>퟿
        | ~<豈:~>﷏
        | ~<ﷰ:~>�
        | ~<𐀀:~>󯿿
      )
      ( NCNameChar
      =   !NCNameStartChar
        | "-"
        | "."
        | ~<0:~>9
        | ·
        | ~<̀:~>ͯ
        | ~<‿:~>⁀
      )
      (allowedChar=.utf$!sjt&!sjt:!(arg.))
      ( NCName
      = |allowedChar$('$NCNameChar) !NCName
      )
      ( checkParms
      =   parms parm table val abbr abbrs spec YYY
        .   !arg:(?parms.?parm.?table)
          & :?abbrs
          &   whl
            ' ( !parms:? (!parm.?val) ?parms
              & !hiddenData (!parm.!val):?hiddenData
              & NEWSPEC
              &   whl
                ' ( !val:%?abbr^?spec+?val
                  & !table:? (?.!abbr.?YYY) ?
                  & !abbrs !abbr:?abbrs
                  )
              )
          & !abbrs
      )
      ( lexan
      =   T A B op ops
        .   !arg:(?ops.?arg)
          & "safe alternative for get$(!arg,MEM). Ignores JBoss-life-threatening (closing) parentheses."
          & (   !arg:?A_?B
              & (lexan$(!ops.!A))_(lexan$(!ops.!B))
            |   !ops:%?op ?ops
              & NEWSPEC
              & (   @(!arg:?A !op ?B)
                  &   !op
                    : (   " "
                        &   lexan$(!ops.!A) lexan$(!op !ops.!B)
                          : ?T
                      |   "+"
                        &   lexan$(!ops.!A)+lexan$(!op !ops.!B)
                          : ?T
                      |   "*"
                        &   lexan$(!ops.!A)*lexan$(!op !ops.!B)
                          : ?T
                      |   "^"
                        &   lexan$(!ops.!A)^lexan$(!op !ops.!B)
                          : ?T
                      )
                  & !T
                | lexan$(!ops.!arg)
                )
            | !arg
            )
      )
      ( unpackIOparm
      =   A parms parm nparms val
        .   !arg:(?parms.?parm)
          & :?nparms
          &   whl
            ' ( !parms:?A (!parm.?val) ?parms
              & NEWSPEC
              & log$(unpackIOparm !val)
              & ( lexan$(" " "+" "*" "^".!val):?val
                | 
                )
              & log$(unpackIOparm2 !val)
              & !nparms !A (!parm.!val):?nparms
              )
          & !nparms !parms
      )
      ( checkParmsSimple
      =   parms parm abbr
        .   !arg:(?parms.?parm)
          & !parms:? (!parm.%?abbr) ?
          & !hiddenData (!parm.!abbr):?hiddenData
          & !abbr
      )
      ( heading
      =   n
        .   !arg:(?n.?arg)
          & (str$(h !n).,!arg) \r\n
      )
      (paragraph=.(p.,!arg) \r\n)
      ( fieldset
      =   legend content
        .   !arg:(?legend.?content)
          &   ( fieldset
              .   (style."padding: 10px; border-style: none;")
                ,   (!legend:|(legend.,!legend))
                    !content
              )
              \r\n
      )
      ( form
      =   action method
        .   !arg:(?action.?arg)
          & (   !arg
              : ( ?arg
                .   ( post
                    | POST
                    | get
                    | GET
                    )
                  : ?method
                )
            | GET:?method
            )
          & ( form
            .     ( ~&"20121024 Why wasn't there an enctype?"
                  |   !method:(POST|post)
                    & (enctype.multipart/form-data)
                  | "20121024 GET no enctype?"&
                  | (enctype.application/x-www-form-urlencoded)
                  )
                  (accept-charset.UTF-8)
                  (method.low$!method)
                  (action.!action)
              , (div.,!arg)
            )
      )
      ( makeCheckboxFormField
      =   text parm desc state disabled
        .     !arg
            : ( ?text
              . ?parm
              .   ( ? (val.?state) ?
                  | ?&:?state
                  )
                : ( ? (disabled.?disabled) ?
                  | ?&:?disabled
                  )
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
              )
          &   (span.,!text)
              \r\n
              ( input
              .     (type.checkbox)
                    (tabindex.1+!tabind:?tabind)
                    (name.!parm)
                    ( !state:
                    | ( checked
                      .   !state:on&checked
                        | 
                      )
                    )
                    (!disabled:|(disabled.!disabled))
                    (!desc:|(title.!desc))
                , 
              )
              \r\n
      )
      ( makeStaticTextFormField
      =   text val
        .   !arg:(?text.?val)
          & (label.,!text) \r\n !val \r\n
      )
      ( makeTextFormField
      =   text parm val desc readonly size required
        .     !arg
            : ( ?text
              . ?parm
              .   ? (val.?val) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (readonly.?readonly) ?
                  | ?&:?readonly
                  )
                : ( ? (size.?size) ?
                  | ?&:?size
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( label
              .   
                ,   !text
                    ( !required:
                    |   " "
                        ( span
                        .     (class.required)
                              (style."width: auto; line-height: normal;")
                          , !required
                        )
                    )
              )
              \r\n
              ( input
              .     (tabindex.1+!tabind:?tabind)
                    (type.text)
                    (name.!parm)
                    (!val:|(value.trim$!val))
                    (!desc:|(title.!desc))
                    ( !readonly:(|no)
                    | (disabled.disabled)
                    )
                    (!size:|(size.!size))
                , 
              )
              \r\n
      )
      ( makeTextAreaFormField
      =   text parm val required desc
        .     !arg
            : ( ?text
              . ?parm
              .   ? (val.?val) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( label
              .   
                ,   !text
                    ( !required:
                    |   " "
                        ( span
                        .     (class.required)
                              (style."width: auto; line-height: normal;")
                          , !required
                        )
                    )
              )
              \r\n
              ( textarea
              .     (tabindex.1+!tabind:?tabind)
                    (style."font-size: 9pt;")
                    (name.!parm)
                    (rows.2)
                    (cols.60)
                    (!desc:|(title.!desc))
                , trim$!val
              )
              \r\n
      )
      ( makeFileFormField
      =   text parm val
        .   !arg:(?text.?parm.?val)
          &   (span.,!text)
              \r\n
              ( input
              .     (type.file)
                    (name.!parm)
                    (value.)
                    (!val:|(accept.trim$!val))
                , 
              )
              \r\n
      )
      ( enumerateTools
      =   tool o i inp I,a b
        .     !arg:(?tool,(?o.?i.?inp))
            & ToolTitle$!tool:?tool
            &   (enumerateTools$!inp:?I)
                (!I:|" → ")
                !tool
          |   !arg:%?a*%?b
            & "(" enumerateTools$!a ∪ enumerateTools$!b ")"
          |   !arg:%?a+%?b
            & NEWSPEC
            & "(" enumerateTools$!a "|" enumerateTools$!b ")"
          | !arg:(?o.?inp)&enumerateTools$!inp
          | 
      )
      ( disam
      =     nextvar ding nextn nextvars wfs wflw N toolPlumbing
          , demul demultiply inmul inmultiply c2m
        .     0:?nextn
            & :?nextvars
            & ( nextvar
              =   bang quest var squest
                .   !nextn+1:?nextn
                  &   !nextvars (str$(a !nextn):?var)
                    : ?nextvars
                  & glf$('(`%?.$var)):?quest
                  & glf$('(!.$var)):?bang
                  & glf$('(?.$var)):?squest
                  & (!quest.!bang.!squest)
              )
            & ( ding
              =     bang bangA bangZ bangT featval o
                  , quest questA questZ questT bangIO questIO
                  , questionpattern-tio questiontemplate
                  , questiontemplate-lhs question
                  , questiontemplate-rhs
                  , replacement replacementtemplate
                  , replacementtemplate-lhs replacementtemplate-rhs
                  , rynaps synaps t wf1
                  , i w ws wf1 tmp REPLACE IO
                .     !arg
                    : ( ?wf1
                      . (=?questiontemplate)
                      . (=?replacementtemplate)
                      )
                  & "questiontemplate is macro '(...$synaps...)"
                  & (     (=?t.(?i.?o).?IO)
                        : (=?synaps)
                      &   !questiontemplate
                        : (=?questionpattern-tio)
                      & !wf1:!questionpattern-tio
                      &   nextvar$
                        : ((=?questT).(=?bangT).?)
                      &   nextvar$
                        : (?.(=?bangA).(=?questA))
                      &   nextvar$
                        : (?.(=?bangZ).(=?questZ))
                      &   nextvar$
                        : (?.(=?bang).(=?quest))
                      &   nextvar$
                        : (?.(=?bangIO).(=?questIO))
                      & "If a feature is shared by all workflows, remove it."
                      & ( REPLACE
                        =   !questiontemplate:(=?question)
                          & ( (,!toolPlumbing):!question
                            |   !wfs:?ws
                              &   whl
                                ' ( !ws:%?w ?tmp
                                  & !w:!question
                                  & !tmp:?ws
                                  )
                              & (   !ws:
                                  & !wfs:?ws
                                  & :?wfs
                                  &   whl
                                    ' ( !ws:%?w ?ws
                                      & !w:!question
                                      & !wfs !replacement:?wfs
                                      )
                                | 
                                )
                            )
                        )
                      &     
                          ' ( $bangT
                            . ($bangA ()$bangZ.$bang)
                            . $bangIO
                            )
                        : (=?rynaps)
                      & !replacementtemplate:(=?replacement)
                      &   whl
                        ' ( !i:%?featval ?i
                          &     
                              ' ( $questT
                                . ( $questA ()$featval ()$questZ
                                  . $quest
                                  )
                                . $questIO
                                )
                            : (=?synaps)
                          & !REPLACE
                          )
                      &     
                          ' ( $bangT
                            . ($bang.$bangA ()$bangZ)
                            . $bangIO
                            )
                        : (=?rynaps)
                      & !replacementtemplate:(=?replacement)
                      &   whl
                        ' ( !o:%?featval ?o
                          &     
                              ' ( $questT
                                . ( $quest
                                  . $questA ()$featval ()$questZ
                                  )
                                . $questIO
                                )
                            : (=?synaps)
                          & !REPLACE
                          )
                    |   (=%?_%?):(=?synaps)
                      & !questiontemplate:(=?question)
                      & !wf1:!question
                      &   nextvar$
                        : ((=?quest).(=?bang).?)
                      &   '$(%?:$($synaps))_($quest)
                        : (=?synaps)
                      &   !questiontemplate
                        : (=?questiontemplate-lhs)
                      &   '$($($rynaps))_($bang)
                        : (=?rynaps)
                      &   !replacementtemplate
                        : (=?replacementtemplate-lhs)
                      &   '$($quest)_(%?:$($synaps))
                        : (=?synaps)
                      &   !questiontemplate
                        : (=?questiontemplate-rhs)
                      &   '$($bang)_($($rynaps))
                        : (=?rynaps)
                      &   !replacementtemplate
                        : (=?replacementtemplate-rhs)
                      &   ding
                        $ ( !wf1
                          . '('$questiontemplate-lhs)
                          . '('$replacementtemplate-lhs)
                          )
                      &   ding
                        $ ( !wf1
                          . '('$questiontemplate-rhs)
                          . '('$replacementtemplate-rhs)
                          )
                    )
              )
            & "de/inmul(tiply) are used to replace (commutative) * operators
			   with (noncommutative) , operators. And back again. Reason:
			   During simplification factors can swap place, leading to
			   mismatch with the tool plumbing pattern."
            & ( demul
              =   a b
                .     !arg:%?a*%?b
                    & (demul$!a,demul$!b)
                  |   !arg:?a_?b
                    & (demul$!a)_(demul$!b)
                  | !arg
              )
            & ( demultiply
              =   wfs wf n
                .   :?wfs
                  &   whl
                    ' ( !arg:(?n,?wf) ?arg
                      & demul$!wf:?wf
                      & !wfs (!n,!wf):?wfs
                      )
                  & !wfs
              )
            & ( c2m
              =   x
                .   !arg:(?x,?arg)&!x*c2m$!arg
                  | !arg
              )
            & ( inmul
              =   a b
                .   !arg:(@?a,?b)&(!a,c2m$!b)
                  |   !arg:?a_?b
                    & (inmul$!a)_(inmul$!b)
                  | !arg
              )
            & ( inmultiply
              =   wfs wf n
                .   :?wfs
                  &   whl
                    ' ( !arg:(?n,?wf) ?arg
                      & inmul$!wf:?wf
                      & !wfs (!n,!wf):?wfs
                      )
                  & !wfs
              )
            & !arg:((=?toolPlumbing).?wfs)
            & demul$!toolPlumbing:?toolPlumbing
            & demultiply$!wfs:?wfs
            & !wfs:%?wflw ?
            & :?nextvars
            & 0:?nextn
            &   ding
              $ ( !wflw
                . (='(?N,$synaps))
                . (='(!N,$rynaps))
                )
            & tbl$(!nextvars,0)
            & inmultiply$!wfs:?wfs
            & !wfs
          | 
      )
      ( describefeature
      =     featvals table specificationTables featdesc
          , featval spec full stbl sps sp YYY
        .   !arg:(?featvals.?table.?specificationTables)
          & :?featdesc
          & NEWSPEC
          &   whl
            ' ( !featvals:%?featval^?spec*?featvals
              &     !featdesc
                    (!featdesc:|" & ")
                    (   !!table:? (?full.!featval.?YYY) ?
                      & localized$!full
                    | !featval
                    )
                    (   !spec:1
                      & NEWSPEC
                      & 
                    |   "["
                        (   !specificationTables
                          :   ?
                              (? (%@:!featval) ?.?stbl)
                              ?
                        & :?sps
                        & (!!stbl|readTable$!stbl)
                        &   whl
                          ' ( !spec:%?sp+?spec
                            & NEWSPEC
                            &     !sps
                                  (!sps:|"|")
                                  (     !!stbl
                                      : ? (?full.!sp.?YYY) ?
                                    & localized$!full
                                  | !sp
                                  )
                              : ?sps
                            )
                        & !sps
                        )
                        "]"
                    )
                : ?featdesc
              )
          & !featdesc
      )
      ( reorder
      =   reorderedworkflowlist nr pipe workflow weighted
        .   ( weighted
            =     deleteReference findUnvisitedWF n
                , insertNameInFirst isReferenced mul2com
                , removeWorkflowsPrecedingRefs renameReference replace
                , name newseqno newseqnos Ntools Nsteps
                , accumulateAbbreviations nr countTools
                , ref refs nrefs seq seqno struct wf abbrevs
                , toolInventory
              .   ( mul2com
                  =   a b n I O i o
                    .     !arg:%?a*%?b
                        & (mul2com$!a,mul2com$!b)
                      |   !arg:(?n.(?i.?o).?I.?O)
                        & (!n.!I.!O)^(!i.!o)*!abbrevs:?abbrevs
                        & (!n..!I.!O)
                      |   !arg:?a_?b
                        & (mul2com$!a)_(mul2com$!b)
                      | !arg
                  )
                & ( accumulateAbbreviations
                  =   A I O i o sum exp N list
                    .   1:?N
                      &   whl
                        ' ( !arg:%?A^%?exp*?arg
                          & :?I:?O
                          &   whl
                            ' ( !exp:?*(?i.?o)+?exp
                              & !I !i:?I
                              & !O !o:?O
                              )
                          & ( sum
                            =   S t
                              .   0:?S
                                &   whl
                                  ' ( !arg:%?t ?arg
                                    & NEWSPEC
                                    & !S+!t:?S
                                    )
                                & !S
                            )
                          & ( list
                            =   S t
                              .   :?S
                                &   whl
                                  ' ( !arg:#*((?,?):%?t)+?arg
                                    & !S !t:?S
                                    )
                                & !S
                            )
                          &   !A^(list$(sum$!I).list$(sum$!O))*!N
                            : ?N
                          )
                      & !N
                  )
                & ( findUnvisitedWF
                  =   a b
                    .     !arg:(%?a,%?b)
                        & ( findUnvisitedWF$!a
                          | findUnvisitedWF$!b
                          )
                      |   !arg:?a (?..?)
                        & findUnvisitedWF$!a
                      |   !arg:(? (?..?):?arg) ?
                        & !arg
                  )
                & ( replace
                  =   a b struct wf seqno n m
                    .   !arg:(?struct.?wf.?seqno)
                      & (   !struct:(%?a,%?b)
                          & ( replace$(!a.!wf.!seqno)
                            , replace$(!b.!wf.!seqno)
                            )
                        |   !struct:(!wf:?a (?n..?m)) ?b
                          & !a (.!seqno.!m) !b
                        |   !struct:?a (?n..?m)
                          & replace$(!a.!wf.!seqno) (!n..!m)
                        | !struct
                        )
                  )
                & ( insertNameInFirst
                  =   struct name seqno a b
                    .   !arg:(?struct.?name.?seqno)
                      & (   !struct:(%?a,%?b)
                          & (   insertNameInFirst$(!a.!name.!seqno)
                              : ?a
                            |   insertNameInFirst$(!b.!name.!seqno)
                              : ?b
                            )
                          & (!a,!b)
                        |   !struct:?a ((?.?.?):?b)
                          & insertNameInFirst$(!a.!name.!seqno):?a
                          & !a !b
                        |   !struct:?a (.!seqno.?b)
                          & !a (!name.!seqno.!b)
                        )
                  )
                & ( removeWorkflowsPrecedingRefs
                  =   a b
                    .     !arg:(%?a,%?b)
                        & ( removeWorkflowsPrecedingRefs$!a
                          , removeWorkflowsPrecedingRefs$!b
                          )
                      |   !arg:? ((.?.?):?b)
                        & !b
                      |   !arg:?a ((?.?.?):?b)
                        & removeWorkflowsPrecedingRefs$!a !b
                      | !arg
                  )
                & ( isReferenced
                  =   a b seqno struct
                    .     !arg:(?seqno.?struct)
                        & !struct:(%?a,%?b)
                        & ( isReferenced$(!seqno.!a)
                          | isReferenced$(!seqno.!b)
                          )
                      | !struct:? (.!seqno.?) ?
                      |   !struct:%?a %?b
                        & ( isReferenced$(!seqno.!a)
                          | isReferenced$(!seqno.!b)
                          )
                  )
                & ( deleteReference
                  =   a b struct seqno n m
                    .   !arg:(?seqno.?struct)
                      & (   !struct:(%?a,%?b)
                          & ( deleteReference$(!seqno.!a):?a
                            | deleteReference$(!seqno.!b):?b
                            )
                          & (!a,!b)
                        |   !struct:?a (?n.!seqno.?m) ?b
                          & !a (!n..!m) !b
                        |   !struct:%?a %?b
                          & ( deleteReference$(!seqno.!a):?a
                            | deleteReference$(!seqno.!b):?b
                            )
                          & !a !b
                        )
                  )
                & ( renameReference
                  =   a b struct seq n m seqno nseqno
                    .   !arg:(?seq.?struct)
                      & (   !struct:(%?a,%?b)
                          & ( renameReference$(!seq.!a)
                            , renameReference$(!seq.!b)
                            )
                        |   !struct:%?a %?b
                          &   renameReference$(!seq.!a)
                              renameReference$(!seq.!b)
                        |   !seq:(?seqno.?nseqno)
                          & !struct:(?n.!seqno.?m)
                          & (!n.!nseqno.!m)
                        | !struct
                        )
                  )
                & "Second arg is flattened structure, which we don't use anymore"
                & !arg:(?nr,(?.?struct))
                & 1:?abbrevs
                & mul2com$!struct:?struct
                & accumulateAbbreviations$!abbrevs:?abbrevs
                & 0:?seqno
                & :?refs
                &   whl
                  ' ( findUnvisitedWF$!struct:?wf
                    & 1+!seqno:?seqno
                    & !wf:? (?name.?)
                    & (!name.!seqno) !refs:?refs
                    & replace$(!struct.!wf.!seqno):?struct
                    )
                & :?nrefs
                &   whl
                  ' ( !refs:%?ref ?refs
                    & !ref !nrefs:?nrefs
                    & insertNameInFirst$(!struct.!ref):?struct
                    )
                & removeWorkflowsPrecedingRefs$!struct:?struct
                & :?newseqnos
                & (48|9311):?newseqno
                &   whl
                  ' ( !nrefs:(?.?seqno) ?nrefs
                    & 1+!newseqno:?newseqno
                    & (   isReferenced$(!seqno.!struct)
                        &   (!seqno.!newseqno) !newseqnos
                          : ?newseqnos
                      | deleteReference$(!seqno.!struct):?struct
                      )
                    )
                &   whl
                  ' ( !newseqnos:%?seq ?newseqnos
                    & renameReference$(!seq.!struct):?struct
                    )
                & 0:?Ntools:?Nsteps:?toolInventory
                & ( countTools
                  =   A B
                    .   !arg
                      : (   ((?A,?B)|%?A %?B)
                          & countTools$!A
                          & countTools$!B
                        |   (?A.?.?.?)
                          & ( !A:
                            | !A+!toolInventory:?toolInventory
                            )
                        )
                  )
                & countTools$!struct
                &   whl
                  ' ( !toolInventory:?n*%@?name+?toolInventory
                    & !n+!Nsteps:?Nsteps
                    & 1+!Ntools:?Ntools
                    )
                & ( (!Nsteps*!Ntools^-1.!Ntools.!nr)
                  , (!abbrevs.!struct)
                  )
            )
          & 0:?reorderedworkflowlist
          &   whl
            ' ( !arg:(?nr,(?pipe.?workflow))+?arg
              &   weighted$(!nr,(!pipe.!workflow))+!reorderedworkflowlist
                : ?reorderedworkflowlist
              )
          & !reorderedworkflowlist
      )
      ( SortList
      =   S L e
        .   0:?S
          & whl'(!arg:%?e ?arg&!e+!S:?S)
          & :?L
          & whl'(!S:%?e+?S&!L !e:?L)
          & !L
      )
      ( makeWorkflowRadioButtons
      =     i buttons nr goodness Ntools currGoodness
          , disambiguatedworkflowlist groupedworkflowlist n nth
          , o pat pipe pipes prev flatten sameToolDifferentRoles
          , toolPlumbing "*" simplify translateToHumanLanguage
          , wf wfs workflow workflowlist saveio toolPattern
          , enumerateToolsDetail
          , abbr reorderedworkflowlist struct weight
        .   !arg:?pipes
          & ( enumerateToolsDetail
            =   tool o i predecessors myfold,a b
              .       !arg
                    : ( ?tool
                      , ( ?o
                        . ?
                        .   (?i.?predecessors)
                          | ?i&:?predecessors
                        )
                      )
                  & ToolTitle$!tool:?tool
                  & ( myfold
                    =   a b A B F R v1 v2
                      .     !arg:%?a*%?b
                          & myfold$!b:?b
                          & (     !a
                                :   ?
                                    ( ?F
                                    ,   ?v1
                                      &   !b
                                        : ?A (!F,~!v1:?v2) ?B
                                      &   !A (!F,!v1*!v2) !B
                                        : ?R
                                    )
                                    ?
                              & !R
                            | 
                            )
                        | !arg
                    )
                  &   ( !predecessors:
                      | enumerateToolsDetail$!predecessors
                      )
                      (!tool.myfold$!i.!o)
                |   !arg:%?a*%?b
                  & enumerateToolsDetail$!a*enumerateToolsDetail$!b
                |   !arg:%?a+%?b
                  & NEWSPEC
                  & enumerateToolsDetail$!a+enumerateToolsDetail$!b
                |   !arg:(?o.?i)
                  & enumerateToolsDetail$!i
                | 1
            )
          & ( simplify
            =     WF S dun sortout n f i I
                , o feat val A Z O IO replace
              .   ( sortout
                  =   L R
                    .   !arg:(?.?)&!arg !S:?S
                      |   !arg:%?L_%?R
                        & sortout$!L
                        & sortout$!R
                  )
                & :?S
                & sortout$!arg
                & :?dun
                & ( replace
                  =   n r p L R WF
                    .   !arg:(?WF.?n.(=?p).(=?r))
                      & (   !WF:(=?.?)
                          & (   !WF:(=!n.!p)
                              & !r:?r
                              & '($n.$r)
                            | !WF
                            )
                        |   !WF:(=%?L_%?R)
                          &   
                            '   
                              $   ( 
                                  $ ( replace
                                    $ ('$L.!n.'$p.'$r)
                                    )
                                  )
                                _ ( 
                                  $ ( replace
                                    $ ('$R.!n.'$p.'$r)
                                    )
                                  )
                        )
                  )
                & '$arg:?WF
                &   whl
                  ' ( !S:(?n.?f) ?S
                    & ( !dun:? !n ?
                      |   !n !dun:?dun
                        & (   !S:? (!n.~!f) ?
                            & !f:((?i.?o).?IO)
                            &   whl
                              ' ( !i:(?feat,?val) ?i
                                & (   !S
                                    :   ?
                                        ( !n
                                        . (? (!feat,~!val) ?.?)
                                        . ?
                                        )
                                        ?
                                  |     replace
                                      $ ( !WF
                                        . !n
                                        .   
                                          ' ( (   ?A
                                                  ($feat,$val)
                                                  ?Z
                                              . ?O
                                              )
                                            . ?IO
                                            )
                                        . ( 
                                          = (!A ? !Z.!O).!IO
                                          )
                                        )
                                    : ?WF
                                  )
                                )
                            &   whl
                              ' ( !o:(?feat,?val) ?o
                                & (   !S
                                    :   ?
                                        ( !n
                                        . (?.? (!feat,~!val) ?)
                                        . ?
                                        )
                                  |     replace
                                      $ ( !WF
                                        . !n
                                        .   
                                          ' ( ( ?I
                                              .   ?A
                                                  ($feat,$val)
                                                  ?Z
                                              )
                                            . ?IO
                                            )
                                        . (=(!I.!A ? !Z).!IO)
                                        )
                                    : ?WF
                                  )
                                )
                          |   replace$(!WF.!n.(=?).(=?))
                            : ?WF
                          )
                      )
                    )
                & !WF
            )
          & ( toolPattern
            =   pat tool lhs rhs lpat rpat Wf feats
              .   :?pat
                & !arg:(=?Wf)
                &   whl
                  ' ( (   '$Wf:(=?Wf (?tool.?feats))
                        & (   '$feats:(=?feats.?)
                            & '($feats.?):(=?feats)
                          | 
                          )
                        & (   :!pat
                            & '($tool.$feats)
                          | '(($tool.$feats) ()$pat)
                          )
                      |   '$Wf:(=?Wf %?lhs*%?rhs)
                        & toolPattern$('$lhs):(=?lpat)
                        & toolPattern$('$rhs):(=?rpat)
                        & (   :!pat
                            & '($lpat*$rpat)
                          | '($lpat*$rpat ()$pat)
                          )
                      )
                    : (=?pat)
                    )
                & '$pat
            )
          & "Same code, but a bit faster because of short names. (intensively used code!)"
          & ( "*"
            =   "#" "%" "[" "]" "(" ")" "-" "="
              .   :?"#"
                & !arg:(=?"-")
                &   whl
                  ' ( (   '$"-":(=?"-" (?"%".?"="))
                        & (   '$"=":(=?"=".?)
                            & '($"=".?):(=?"=")
                          | 
                          )
                        & ( :!"#"&'($"%".$"=")
                          | '(($"%".?) ()$"#")
                          )
                      |   '$"-":(=?"-" %?"["*%?"]")
                        & "*"$('$"["):(=?"(")
                        & "*"$('$"]"):(=?")")
                        & ( :!"#"&'($"("*$")")
                          | '($"("*$")" ()$"#")
                          )
                      )
                    : (=?"#")
                    )
                & '$"#"
            )
          & ( translateToHumanLanguage
            =     circle Circle describe nice inoutdesc
                , description seqno struct abbrevs
              .   ( circle
                  =   
                    .   !arg:~#&!arg
                      | ( strong
                        .   
                          ,     !arg:<128
                              &   ":"
                                  ( !arg:~<48&!arg+-48
                                  | chr$!arg
                                  )
                            | chu$!arg
                        )
                  )
                & ( Circle
                  =   
                    .   !arg:~#&!arg
                      | ( strong
                        .   
                          ,     !arg:<128
                              & ( !arg:~<48&!arg+-48
                                | chr$!arg
                                )
                            | chu$!arg
                        )
                  )
                & ( inoutdesc
                  =     description featname featvals table
                      , specificationTables featdesc
                    .   :?description
                      &   whl
                        ' ( !arg:(?featname,?featvals) ?arg
                          &   !features
                            :   ?
                              + ( ( ? (name.? !featname ?) ?
                                  | ? (short.!featname) ?
                                  )
                                : ? (table.?table) ?
                                : (   ?
                                      (specificationTable.?specificationTables)
                                      ?
                                  |   ?
                                    & :?specificationTables
                                  )
                                )
                              + ?
                          &     describefeature
                              $ (!featvals.!table.!specificationTables)
                            : ?featdesc
                          &     !description
                                (!description:|", ")
                                !featdesc
                            : ?description
                          )
                      & !description
                  )
                & ( nice
                  =   i o
                    .   !arg:(?i.?o)
                      & inoutdesc$!i:?i
                      & inoutdesc$!o:?o
                      & ( :!i:!o
                        |   "("
                            !i
                            ( !i:
                            | !o:
                            | " ; "
                            )
                            !o
                            ")"
                        )
                  )
                & ( infoabout
                  =   Description
                    .     !tooladm
                        :   ?
                          + ( ? (Title.!arg) ?
                            : ? (Description.?Description) ?
                            )
                          + ?
                      & ( div
                        .   (class.tooltip)
                          ,   !arg
                              ( span
                              . (class.tooltiptext),!Description
                              )
                        )
                  )
                & ( describe
                  =   a b c m n
                    .     !arg:(?a,?b)
                        & (     !b
                              : ((?.?.?)|((?.?.?),?))
                            & describe$!a " + " describe$!b
                          |   !b:(?b,?c)
                            &   describe$!a
                                " + ["
                                describe$!b
                                "] + "
                                describe$!c
                          | describe$!a " + [" describe$!b "] "
                          )
                      |   !arg:%?a %?b
                        & describe$!a " → " describe$!b
                      |   !arg:(?m.?seqno.?n)
                        &   ( !m:&Circle$!seqno
                            | infoabout$!m circle$!seqno
                            )
                            ( !m:
                            |   !abbrevs:?*(!m.!n)^?n*?
                              & nice$!n
                            )
                      | !arg
                  )
                & !arg:(?abbrevs.?struct)
                & describe$!struct:?description
                & ( !description:~
                  |   localized
                    $ ( "It seems that the input already matches your goal. Or we haven't enough information about the input. Use the back button to change your choice."
                        "Det ser ud til at inputtet allerede opfylder dit mål. Eller vi har ikke fundet de nødvendige oplysninger om inputtet. Brug knappen \"Forrige\" for at ændre dine valg."
                      )
                  )
            )
          & ( sameToolDifferentRoles
            =     delta Delta replac I O
                , beast result simple tool tree
                , details flatlist updat
                , fx fy reps sx sy
              .   ( delta
                  =   this other L f v
                    .   !arg:(?this.?other)
                      & :?L
                      & (   !this
                          :   ?
                              ( (?f,?v)
                              & ( !other:? (!f,!v) ?
                                | (!f,!v) !L:?L
                                )
                              & ~
                              )
                              ?
                        | !L
                        )
                  )
                & ( Delta
                  =   AI AO BI BO
                    .   !arg:((?AI.?AO),(?BI.?BO))
                      & (delta$(!AI.!BI).delta$(!AO.!BO))
                  )
                & ( replac
                  =   t s r a b
                    .   !arg:(?t.?s,?r)
                      & ( !t:!s&!r
                        |   !t:%?a %?b
                          & replac$(!a.!s,!r) replac$(!b.!s,!r)
                        |   !t:(%?a,%?b)
                          & (replac$(!a.!s,!r),replac$(!b.!s,!r))
                        | !t
                        )
                  )
                & 0:?result
                & ( flatlist
                  =   p q
                    .     !arg
                        : ( @
                          . (?.?)
                          . (?,?) ?
                          . (?,?) ?
                          )
                      |   !arg:((?p,?q)|%?p %?q)
                        & flatlist$!p+flatlist$!q
                  )
                & ( updat
                  =     reps tool i o id
                      , od I O details A Z
                    .     !arg
                        : ( ?reps
                          . ?tool
                          . (?i.?o),(?id.?od)
                          . ?details
                          )
                      & (     !reps
                            : ?A (!tool.(?I.?O).!details) ?Z
                          &   !A
                              ( !tool
                              . (set$(!I !i !id).set$(!O !o !od))
                              . !details
                              )
                              !Z
                        |   ( !tool
                            . (set$(!i !id).set$(!o !od))
                            . !details
                            )
                            !reps
                        )
                  )
                &   whl
                  ' ( !arg:(?n,(?beast.?tree))+?arg
                    & :?reps
                    & (   flatlist$!beast
                        :   ?
                          + ?*(?tool.?sx.?fx)
                          + ?
                          + ?*(!tool.?sy.?fy)
                          + ( ?
                            &     updat
                                $ ( !reps
                                  . !tool
                                  . !sx,Delta$(!fx,!fy)
                                  . !fx
                                  )
                              : ?reps
                            &     updat
                                $ ( !reps
                                  . !tool
                                  . !sy,Delta$(!fy,!fx)
                                  . !fy
                                  )
                              : ?reps
                            & ~
                            )
                      |     whl
                          ' (   !reps
                              : (?tool.?simple.?details) ?reps
                            &     replac
                                $ ( !tree
                                  .   (!tool.?.!details)
                                    , (!tool.!simple.!details)
                                  )
                              : ?tree
                            )
                        & !result+(!n,(!beast.!tree)):?result
                      )
                    )
                & !result
            )
          & "pipes is a unnumbered list sorted on directly on full workflow tree."
          & :?workflowlist
          & 0:?n
          & log$enumerateToolsDetail
          &   whl
            ' ( 1+!n:?n:<1000000
              & !pipes:%?pipe+?pipes
              &   (!n.enumerateToolsDetail$!pipe) !workflowlist
                : ?workflowlist
              )
          & log$enumerateToolsDetailDONE
          & (   !n:<1000000
              & log$("while enumerateToolsDetail:" !n)
            |   log
              $ "while enumerateToolsDetail: MAX NUMBER OF WORKFLOW OPERATIONS REACHED (1000000)"
            )
          & "workflowlist is numbered list of workflows, with equal branches not merged yet."
          & ( saveio
            =   n i o x y
              .     !arg:(?n.?i.~(?.?):?o)
                  & (!n.(!i.!o).!i.!o)
                |   !arg:?x_?y
                  & (saveio$!x)_(saveio$!y)
                | !arg
            )
          & map$(saveio.!workflowlist):?workflowlist
          & "workflowlist is numbered list of workflows, with equal branches not merged yet, and with I/O duplicated."
          & :?groupedworkflowlist
          & :?toolPlumbing
          &   whl
            ' ( 1+!n:?n:<1000000
              & !workflowlist:(#?nr.?workflow) ?workflowlist
              & "*"$(simplify$!workflow):(=?toolPlumbing)
              & (!nr,!workflow):?wfs
              &   whl
                ' ( 1+!n:?:<1000000
                  &   !workflowlist
                    :   ?prev
                        (#?nr.!toolPlumbing:?wf)
                        ?workflowlist
                  & (!nr,!wf) !wfs:?wfs
                  & !prev !workflowlist:?workflowlist
                  )
              &   ('$toolPlumbing.!wfs) !groupedworkflowlist
                : ?groupedworkflowlist
              )
          & ( !n:<1000000
            |   log
              $ "while groupedworkflowlist: MAX NUMBER OF WORKFLOW OPERATIONS REACHED (1000000)"
            )
          & 0:?disambiguatedworkflowlist
          &   whl
            ' (   !groupedworkflowlist
                : (?toolPlumbing.?wfs) ?groupedworkflowlist
              & ( flatten
                =   a b N O flat
                  .     !arg:(#?N,?a) ?b
                      &   (!N,(flatten$!a.!a))
                        + (flatten$!b:~|0)
                    |   !arg:%?a*%?b
                      & flatten$!a flatten$!b
                    |   !arg:%?a^#%?N
                      & flatten$!a:?flat:?O
                      &   whl
                        ' ( -1+!N:>0:?N
                          & !flat !O:?O
                          )
                      & !O
                    |   !arg:%?a %?b
                      & flatten$!a flatten$!b
                    | !arg
                )
              &     flatten$(disam$(!toolPlumbing.!wfs))
                  + !disambiguatedworkflowlist
                : ?disambiguatedworkflowlist
              )
          &   sameToolDifferentRoles$!disambiguatedworkflowlist
            : ?disambiguatedworkflowlist
          & reorder$!disambiguatedworkflowlist:?reorderedworkflowlist
          & (   !disambiguatedworkflowlist:%+%
              & :?buttons
              & 1:?nth
              & (   !reorderedworkflowlist
                  : ((?currGoodness.?),?)+?
                | 1:?currGoodness
                )
              &   whl
                ' (   !reorderedworkflowlist
                    :   ( ?weight:(?goodness.?Ntools.?nr)
                        , (?abbr.?struct)
                        )
                      + ?reorderedworkflowlist
                  &     !buttons
                        (     !goodness
                            : >!currGoodness
                            : ?currGoodness
                          & (hr.,)
                        | 
                        )
                        !nth
                        ( input
                        .     (type.radio)
                              (name.nth)
                              (value.!nr)
                          , 
                        )
                        translateToHumanLanguage$(!abbr.!struct)
                        (br.,)
                        (br.,)
                    : ?buttons
                  & 1+!nth:?nth
                  )
            |     !reorderedworkflowlist
                :   (?weight:(?goodness.?Ntools.?nr),(?abbr.?struct))
                  + ?
              &   translateToHumanLanguage$(!abbr.!struct) (br.,)
                : ?buttons
            )
          & !buttons
      )
      ( makePasswordFormField
      =   text parm desc size required
        .     !arg
            : ( ?text
              . ?parm
              .   ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (size.?size) ?
                  | ?&:?size
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( !required:
              | (span.(class.required),!required)
              )
              (span.,!text)
              \r\n
              ( input
              .     (tabindex.1+!tabind:?tabind)
                    (type.password)
                    (name.!parm)
                    (value.)
                    (!desc:|(title.!desc))
                    (!size:|(size.!size))
                , 
              )
              \r\n
      )
      ( makeSelectFormField
      =   text parm options desc required
        .     !arg
            : ( ?text
              . ?parm
              .   ? (options.?options) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( !required:
              | (span.(class.required),!required)
              )
              (span.,!text)
              \r\n
          &   ( label
              .   
                ,   !text
                    ( !required:
                    |   " "
                        ( span
                        .     (class.required)
                              (style."width: auto; line-height: normal;")
                          , !required
                        )
                    )
              )
              \r\n
              ( select
              .     (tabindex.1+!tabind:?tabind)
                    (name.!parm)
                    (!desc:|(title.!desc))
                , \r\n !options
              )
              \r\n
      )
      ( submit
      =   button
        .   !arg:?button
          &   ( input
              .     (type.submit)
                    (tabindex.1+!tabind:?tabind)
                    (name.bsubmit)
                    (value.!button)
                , 
              )
              \r\n
      )
      ( ConstructUnionOfInputOutputParmsFromToolProp
      =     f fs i o name short tools pairs
          , iV oV TOOL out outs in ins
        .   !arg:?TOOL
          & :?i:?o
          & readTable$features
          & readTable$toolprop
          & !features:?fs
          &   whl
            ' ( !fs:%?f+?fs
              &   !f
                : ? (name.?name) ?
                : ? (short.?short) ?
              & 0:?iV:?oV
              & !toolprop:?tools
              & localized$!name:?name
              &   whl
                ' (   !tools
                    :   ?
                      + ( !TOOL
                        .   ? (!short,?pairs) ?
                          | ? (!name,?pairs) ?
                        )
                      + ?tools
                  &   whl
                    ' ( !pairs:(?ins.?outs)+?pairs
                      &   whl
                        ' ( !ins:%(%?in ?)+?ins
                          & ( !iV:?+!in+?
                            | !in+!iV:?iV
                            )
                          )
                      &   whl
                        ' ( !outs:%?out+?outs
                          & ( !oV:?+!out+?
                            | !out+!oV:?oV
                            )
                          )
                      )
                  )
              & ( !short:format
                | !iV:0
                | !i (str$(I !short).!iV):?i
                )
              & ( !oV:0
                | !o (str$(O !short).!oV):?o
                )
              )
          & (!i.!o)
      )
      ( style
      =   ( style
          .   (type.text/css)
            ,   \r\n
                ".bodycanvas {background: linear-gradient(rgb(254,254,254), rgba(0,210,255,0.2));background-repeat: no-repeat;}"
                \r\n
                "h1, h2, h3, span, p, td, input, legend, textarea {font-family: Comic"
                Sans
                "MS, cursive, sans-serif;}"
                \r\n
                "legend {border:none;color:black;background-color:rgba(154,186,206,0.6);text-align:left;display:block;margin:0;padding:10px;float:left;width:100%;position:relative;font-size:15px; }"
                \r\n
                ".required {color:red; font-size:90%;}"
                \r\n
                "/* Tooltip container */"
                \r\n
                ".tooltip {"
                \r\n
                "    position: relative;"
                \r\n
                "    display: inline-block;"
                \r\n
                "    border-bottom: 1px dotted black; /* If you want dots under the hoverable text */"
                \r\n
                "}"
                \r\n\r\n
                "/* Tooltip text */"
                \r\n
                ".tooltip .tooltiptext {"
                \r\n
                "    visibility: hidden;"
                \r\n
                "    width: 320px;"
                \r\n
                "    background-color: #555;"
                \r\n
                "    color: #fff;"
                \r\n
                "    text-align: left;"
                \r\n
                "    padding: 5px 0;"
                \r\n
                "    border-radius: 6px;"
                \r\n\r\n
                "    /* Position the tooltip text */"
                \r\n
                "    position: absolute;"
                \r\n
                "    z-index: 1;"
                \r\n
                "    bottom: 125%;"
                \r\n
                "    left: 50%;"
                \r\n
                "    margin-left: -60px;"
                \r\n\r\n
                "    /* Fade in tooltip */"
                \r\n
                "    opacity: 0;"
                \r\n
                "    transition: opacity 0.3s;"
                \r\n
                "}"
                \r\n\r\n
                "/* Tooltip arrow */"
                \r\n
                ".tooltip .tooltiptext::after {"
                \r\n
                "    content: ;"
                \r\n
                "    position: absolute;"
                \r\n
                "    top: 100%;"
                \r\n
                "    left: 50%;"
                \r\n
                "    margin-left: -5px;"
                \r\n
                "    border-width: 5px;"
                \r\n
                "    border-style: solid;"
                \r\n
                "    border-color: #555 transparent transparent transparent;"
                \r\n
                "}"
                \r\n\r\n
                "/* Show the tooltip text when you mouse over the tooltip container */"
                \r\n
                ".tooltip:hover .tooltiptext {"
                \r\n
                "    visibility: visible;"
                \r\n
                "    opacity: 1;"
                \r\n
                "}"
          )
          \r\n
      )
      ( HTMLbodyContainer
      =     @(!wwwServer:? clarin ?)
          & HTML5bodyContainer
        | log$noClarin&XHTMLbodyContainer
      )
      ( HTML5bodyContainer
      =   
        .   ("!DOCTYPE"." html")
            \r\n
            ( html
            .   
              ,   \r\n
                  ( head
                  .   
                    ,   \r\n
                        (meta.charset.UTF-8)
                        \r\n
                        ( link
                        .     (rel.stylesheet)
                              (type.text/css)
                              (href."/clarindk/css/clarin.css")
                          , 
                        )
                        ( style
                        .   (type.text/css)
                          , " legend {display: inline-block; padding: 0.2em 0.5em; border:1px solid green; color:green; font-size:90%; text-align:left; } .required {color:red; font-size:90%;}"
                        )
                        \r\n
                        ( link
                        .     (rel.stylesheet)
                              (type.text/css)
                              (href."/clarindk/css/colorbox.css")
                              (media.screen)
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/jquery.min.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/jquery-plugins/jquery.validate.min.js"
                              )
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/jquery-plugins/jquery-ui-custom.min.js"
                              )
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/clarin-scripts/menuToggle.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/clarin-scripts/basket.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/clarin-scripts/fulltext.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/jquery-plugins/jquery.colorbox.min.js"
                              )
                          , 
                        )
                        \r\n
                        ( "!--"
                        . "[if lt IE 9]> <script src=\"/clarindk/js/html5.js\" type=\"text/javascript\"></script> <link rel=\"stylesheet\" type=\"text/css\" href=\"/clarindk/css/clarin-ie.css\" /> <![endif]"
                        )
                        \r\n
                        ( "!--"
                        . "[if IE]> <style type=\"text/css\"> .clearfix { zoom: 1; /* triggers hasLayout */ display: block; /* resets display for IE/Win */ } /* Only IE can see inside the conditional comment and read this CSS rule. Don't ever use a normal HTML comment inside the CC or it will close prematurely. Kilde: http://www.positioniseverything.net/easyclearing.html */ </style> <![endif]"
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/clarin-scripts/clarin-deposit.js"
                              )
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/clarin-scripts/clarin-find.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/clarin-scripts/clarin-text-img.scroll.js"
                              )
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/clarin-scripts/clarin-tabs.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/clarin-scripts/colorbox-license.js"
                              )
                          , 
                        )
                        \r\n
                        (title.,!headerTitle)
                        \r\n
                  )
                  \r\n
                  ( body
                  .   
                    ,   \r\n
                        ( section
                        .   (class."header clearfix")
                          ,   \r\n
                              ( header
                              .   
                                ,   \r\n
                                    ( h1
                                    .   
                                      ,   \r\n
                                          ( a
                                          .     (href."/clarindk/forside.jsp")
                                                (rel.)
                                            , "Clarin.dk"
                                          )
                                          \r\n
                                    )
                                    \r\n
                                    ("!--"."LOGIN NAV")
                                    \r\n
                                    ( nav
                                    .   
                                      ,   \r\n
                                          ("!--"." FindQuick ")
                                          \r\n
                                          ( fieldset
                                          .   
                                            ,   \r\n
                                                ( form
                                                .     (name.myform)
                                                      (method.get)
                                                      ( action
                                                      . "/clarindk/item.jsp"
                                                      )
                                                  ,   \r\n
                                                      ( p
                                                      .   
                                                        ,   \r\n
                                                            ( input
                                                            .     (type.text)
                                                                  ( placeholder
                                                                  . "Ressource ID"
                                                                  )
                                                                  (name.id)
                                                              , 
                                                            )
                                                            \r\n
                                                            ( input
                                                            .     ( type
                                                                  . submit
                                                                  )
                                                                  (value.Ok)
                                                              , 
                                                            )
                                                            \r\n
                                                      )
                                                      \r\n
                                                )
                                                \r\n
                                          )
                                          \r\n
                                          ("!--"." FindQuick end ")
                                          \r\n
                                    )
                                    \r\n
                              )
                              \r\n
                        )
                        \r\n
                        ( "!--"
                        . " USER NAV **********************************************************************************************************"
                        )
                        \r\n
                        ( section
                        .   (class."userNavigation clearfix")
                          ,   \r\n
                              ( nav
                              .   (class.clearfix)
                                ,   \r\n
                                    ( a
                                    .   (href."/clarindk/find.jsp")
                                      , Find
                                    )
                                    \r\n
                                    ( a
                                    .   (href."/clarindk/tools.jsp")
                                      , Tools
                                    )
                                    \r\n
                                    ( a
                                    .   (href."/clarindk/deponer.jsp")
                                      , Deposit
                                    )
                                    \r\n
                                    ( a
                                    .     (href."/clarindk/basketList.jsp")
                                          (rel.)
                                          (class."basket basketEmpty")
                                      ,   "Show basket "
                                          (strong.(id.basketSize),0)
                                    )
                                    \r\n
                              )
                              \r\n
                        )
                        \r\n
                        (section.(class.content),!arg)
                        \r\n
                        ("!--"." Piwik ")
                        \r\n
                        ( script
                        .   (type.text/javascript)
                          ,   \r\n
                              "  var _paq = _paq || [];"
                              \r\n
                              "  _paq.push(['trackPageView']);"
                              \r\n
                              "  _paq.push(['enableLinkTracking']);"
                              \r\n
                              "  (function() {"
                              \r\n
                              "    var u=\"//clarin.dk/analytics/\";"
                              \r\n
                              "    _paq.push(['setTrackerUrl', u+'piwik.php']);"
                              \r\n
                              "    _paq.push(['setSiteId', 1]);"
                              \r\n
                              "    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];"
                              \r\n
                              "    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);"
                              \r\n
                              "  })();"
                              \r\n
                        )
                        \r\n
                        ( noscript
                        .   
                          , ( p
                            .   
                              , ( img
                                .     ( src
                                      . "//clarin.dk/analytics/piwik.php?idsite=1"
                                      )
                                      (style."border:0;")
                                      (alt.)
                                  , 
                                )
                            )
                        )
                        \r\n
                        ("!--"." End Piwik Code ")
                  )
            )
            \r\n
      )
      ( XHTMLbodyContainer
      =   
        .   "iso-8859-1 and not utf-8, because of problematic handling of UTF-8 by JNI
             (Or rather Java, which uses UTF-16 and converts surrogate pairs to 6 bytes of UTF-8 !)"
          &   ("?"."xml version=\"1.0\" encoding=\"iso-8859-1\"")
              \r\n
              ( "!DOCTYPE"
              . " html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\""
              )
              \r\n
              ( html
              .     (xmlns."http://www.w3.org/1999/xhtml")
                    ("xml:lang".da)
                    (lang.da)
                ,   \r\n
                    ( head
                    . ,\r\n (title.,!headerTitle) \r\n !style
                    )
                    \r\n
                    (body.(class.bodycanvas),!arg)
              )
              \r\n
      )
      ( refreshingXHTMLbodyContainer
      =   seconds body URL
        .   !arg:(%?seconds ?URL.?body)
          &   ("?"."xml version=\"1.0\" encoding=\"iso-8859-1\"")
              \r\n
              ( "!DOCTYPE"
              . " html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\""
              )
              \r\n
              ( html
              .     (xmlns."http://www.w3.org/1999/xhtml")
                    ("xml:lang".da)
                    (lang.da)
                ,   \r\n
                    ( head
                    .   
                      ,   \r\n
                          (title.,!headerTitle)
                          \r\n
                          ( meta
                          .     (http-equiv.refresh)
                                ( content
                                .   str
                                  $ ( !seconds
                                      (!URL:|"; " !URL)
                                    )
                                )
                            , 
                          )
                          \r\n
                          !style
                    )
                    \r\n
                    (body.(class.bodycanvas),!body)
              )
              \r\n
      )
      ( atts
      =   name value
        .     !arg:(?name,?value) ?arg
            & (!name.!value) atts$!arg
          | 
      )
      ( Table
      =   attributes heading content
        .   !arg:(?attributes.?heading.?content)
          &   ( table
              .   atts$!attributes
                , (thead.,!heading) \r\n (tbody.,!content)
              )
              \r\n
      )
      (row=.(tr.,!arg) \r\n)
      (cell=.td.,!arg)
      ( makeOptionList
      =   options table abbr full selected prefix YYY
        .     !arg
            : ( ?table
              .   (?selected.?prefix)
                | ?selected&:?prefix
              )
          &     ( option
                . (id.str$(b !tabind)) (value.),
                )
                \r\n
            : ?options
          &   whl
            ' (   !table
                : (?full.(?abbr.?YYY)|?abbr) ?table
              &     !options
                    ( option
                    .     ( id
                          .   str
                            $ ( ( @( !abbr
                                   :   %allowedChar$('$NCNameStartChar)
                                       !NCName
                                   )
                                | X
                                )
                                !tabind
                              )
                          )
                          (value.str$(!prefix !abbr))
                          (   !selected:!abbr
                            & (selected.selected)
                          | 
                          )
                      , localized$!full
                    )
                    \r\n
                : ?options
              )
          & !options
      )
      "
/**
 * uploadJobNr
 * 
 * Return the string preceding the hyphen in the input.
 *
 * Input: <jobNr>-<jobID>
 *
 * Called from upload.java
 */"
      ( uploadJobNr
      =   jobID jobNr
        .   "analyze the job parameter. It tells to which job the sent file belongs."
          & !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
          & !jobNr
      )
      ( uploadJobID
      =   jobID jobNr
        .   "analyze the job parameter. It tells to which job the sent file belongs."
          & !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
          & !jobID
      )
      "
/**
 * upload
 *
 * Make a waiting job non-waiting upon receipt of a result from an 
 * asynchronous tool.
 *
 * Analyze the job parameter. It tells to which job the sent file belongs.
 * The jobs table knows the file name and location for the uploaded file.
 *              (Last field)
 * Input:
 *      List of HTTP request parameters.
 *      One of the parameters must be (job.<jobNr>-<jobID>)
 *
 * Output:
 *      The file name that must be given to the received file when saved in
 *      the staging area.
 *
 * Status codes:
 *      200     ok
 *      400     'job' parameter does not contain hyphen '-' or
 *              'job' parameter missing altogether.
 *      404     Job is not expecting a result (job is not waiting)
 *              Job is unknown
 *      500     Job list could not be read
 *
 * Affected tables:
 *      jobs.table
 *
 * Called from upload.java
 */"
      ( upload
      =     jobNr jobID jobstatus JOB
          , A Z files toolURL parms file
        .     log$(upload !arg)
            & !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
            & (   readTable$jobs
                & (     !jobs
                      :   ?A
                          ( !jobNr
                          . !jobID ?jobstatus
                          . ?files
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                          ?Z
                    & (     !jobstatus
                          : (waiting|starting)
                        &     !A
                              ( !jobNr
                              . !jobID done
                              . !files
                              . !toolURL
                              . !parms
                              . !file
                              )
                              !Z
                          : ?jobs
                        & saveTable$jobs
                        & !file
                      |   str
                        $ ( "HTTP-status-code404upload$("
                            !arg
                            ") failed. Job "
                            !jobNr
                            "-"
                            !jobID
                            " is not expecting a result. Its current status is"
                            !jobstatus
                          )
                      )
                  |   str
                    $ ( "HTTP-status-code404upload$("
                        !arg
                        ") failed. Job "
                        !jobNr
                        "-"
                        !jobID
                        " not found in joblist."
                      )
                  )
              |   str
                $ ( "HTTP-status-code500upload$("
                    !arg
                    ") failed. Joblist could not be read"
                  )
              )
          |   str
            $ ( "HTTP-status-code400upload$("
                !arg
                ") failed. "
                (   !arg:? (job.?JOB) ?
                  & ( @(!JOB:% "-" %)
                    | "'job' parameter value must contain a hyphen '-'. "
                    )
                | "'job' parameter missing. "
                )
              )
      )
      "
/**
 * parseStatusCode
 *
 * Find the number greater than 100 immediately following the string 
 * 'HTTP-status-code'
 *
 * Called from upload.java
 */"
      ( parseStatusCode
      =   
        .   @(!arg:HTTP-status-code (#>100:?arg) ?)
          & !arg
      )
      "
/**
 * parsemessage
 *
 * Find the text following the number greater than 100 immediately following the string 
 * 'HTTP-status-code'
 *
 * Called from upload.java
 */"
      ( parsemessage
      = .@(!arg:HTTP-status-code #>100 ?arg)&!arg
      )
      ( getShort
      =   feat full abbr table YYY
        .   !arg:(?feat.?full)
          & (     !features
                :   ?
                  + ( ? (short.!feat) ?
                    : ? (table.?table) ?
                    )
                  + ?
              & readTable$!table
              & !!table:? (? !full ?.?abbr.?YYY) ?
              & !abbr
            | !full
            )
      )
      ( itemFeats
      =   feats
        .   !Uploads:? (?.!arg.?.?.?.?feats.?) ?
          & !feats
      )
      ( pickTool
      =     toolShort pairs Items fmt spec item formats nitems
          , sufficient
          , toolFull
        .   readTable$toolprop
          & readTable$tooladm
          & :?pairs
          & !arg:(?arg.?Items)
          & :?formats
          & 0:?nitems
          & (   !Items
              :   ?
                  ( Item&1+!nitems:?nitems
                  .   ( ? (format.%?fmt^?spec) ?
                      |   ?item
                        &   itemFeats$!item
                          : ? (format.%?fmt^?spec) ?
                      )
                    & ( !formats:? !fmt^!spec ?
                      | !formats !fmt^!spec:?formats
                      )
                    & ~
                  )
                  ?
            | 
            )
          & ( sufficient
            =   max n
              .     0:?max:?n
                  &   !sjt
                    :   ?
                        ( ?
                        ,   ?
                          + (     ?
                                + (   ?
                                    * ( (%@|%@^%)
                                      & 1+!n:?n
                                      )
                                    * (1|?&~)
                                  & ( !n:>!max:?max
                                    | 
                                    )
                                  & 0:?n
                                  & ~
                                  )
                                + ?
                                ?
                            . ?
                            )
                          + ?
                        )
                        ?
                | !arg:~<!max&?
            )
          & (   !toolprop
              :   ?
                + ( ( ?toolShort
                    .   sufficient$!nitems
                      :   ?
                          ( format
                          ,   ?
                            + ( ?+(!fmt^!spec|!fmt)+? ?
                              . ?
                              )
                            + ?
                          )
                          ?
                    )
                  & ( !pairs:? (?.!toolShort) ?
                    |   ToolTitle$!toolShort:?toolFull
                      & (!toolFull.!toolShort) !pairs:?pairs
                    )
                  & ~
                  )
                + ?
            | 
            )
          &   makeSelectFormField
            $ (Tool.TOOL.options.makeOptionList$(!pairs.))
      )
      ( makeHiddenFields
      =   ret par val
        .   :?ret
          &   whl
            ' ( !arg:(?par.?globval) ?arg
              & @(lst$(globval,MEM,LIN):"globval=" ?val ";\n")
              &     !ret
                    ( input
                    .     (type.hidden)
                          (name.!par)
                          (value.!val)
                      , 
                    )
                : ?ret
              )
          & !ret
      )
      ( makeHiddenFields
      =   ret par val
        .   :?ret
          &   whl
            ' ( !arg:(?par.?val) ?arg
              &     !ret
                    ( input
                    .     (type.hidden)
                          (name.!par)
                          (value.str$!val)
                      , 
                    )
                : ?ret
              )
          & !ret
      )
      "
/**
 * update
 *
 * Create an HTML form that allows a user to choose a tool from a pick list.
 * The user must also fill out a password.
 *
 * The input can either be an empty string or two fields: a message to be 
 * displayed above the form and the name of a tool, which will then be 
 * selected when the browser shows the pick list.
 *
 * Called from update.java
 */"
      ( update
      =     L ToolID Title msg selected
          , contactEmail handle
          , passwordAsHandle
        .     0:?tabind
            & readTable$tooladm
            &   
              : ?msg
              : ?selected
              : ?contactEmail
              : ?handle
            & (!arg:? (msg.?msg) ?|)
            & ( !arg:? (selected.?selected) ?
              | 
              )
            & 
            & (   !arg
                : ? (passwordAsHandle.?passwordAsHandle) ?
              | (.):?passwordAsHandle
              )
            & ( !arg:? (contactEmail.?contactEmail) ?
              | 
              )
            & (!arg:? (handle.?handle) ?|)
            & :?L
            &   !tooladm
              :   ?
                + (   ? (ToolID.?ToolID) ?
                    : ? (Title.?Title) ?
                  & !L (!Title.!ToolID):?L
                  )
                + 0
            &   toML
              $ ( !HTMLbodyContainer
                $ ( (!msg:|paragraph$!msg)
                      form
                    $ ( register
                      .     paragraph
                          $ ( makeSelectFormField
                            $ (   localized
                                $ ("Choose a tool" "Vælg et værktøj")
                              . name
                              .   (options.makeOptionList$(!L.!selected))
                                  (required."*")
                              )
                            )
                            paragraph
                          $ ( makePasswordFormField
                            $ (   localized
                                $ ( "Password (If you are not owner)"
                                    "Adgangskode (Hvis du ikke er \"ejer\")"
                                  )
                              . password
                              . desc
                              .   localized
                                $ ( "Use this field if you don't own the tool and the owner has given you the password. When you update the tool metadata, you become the new owner of the tool."
                                    "Brug feltet hvis du ikke er ejer af værktøjet og du har fået adgangskoden fra ejeren. Når du opdaterer værktøjsoplysningerne bliver du automatisk den nye ejer af værktøjet."
                                  )
                              )
                            )
                          submit$next
                            makeHiddenFields
                          $ ( (   !passwordAsHandle:(.)
                                & 
                              | (passwordAsHandle.!passwordAsHandle)
                              )
                              ( !contactEmail:
                              | (contactEmail.!contactEmail)
                              )
                              ( !handle:
                              | (handle.!handle)
                              )
                            )
                      . POST
                      )
                  )
                )
          | 
      )
      ( createMetaDataForDeposition
      =     ToolName ToolVersion FullToolName
          , ToolURL ToolPublisher ContentProvider
          , ToolCreator InfoAbout ToolDescription
          , ToolExternalURI ToolXMLparms
          , ToolPostData ToolInactive
          , languages values val
          , infacets outfacets
          , informats outformats
          , vals
        .   readTable$tooladm
          & readTable$toolprop
          & !arg:?ToolName
          &   !tooladm
            :   ?
              + ( ? (ToolID.!ToolName) ?
                : ? (Version.?ToolVersion) ?
                : ? (Title.?FullToolName) ?
                : ? (ServiceURL.?ToolURL) ?
                : ? (Publisher.?ToolPublisher) ?
                : ? (ContentProvider.?ContentProvider) ?
                : ? (Creator.?ToolCreator) ?
                : ? (InfoAbout.?InfoAbout) ?
                : ? (Description.?ToolDescription) ?
                : ? (ExternalURI.?ToolExternalURI) ?
                : ? (XMLparms.?ToolXMLparms) ?
                : ? (PostData.?ToolPostData) ?
                : ? (Inactive.?ToolInactive) ?
                )
              + ?
          & ( vals
            =   v
              .   !sjt
                :   ?
                      ?
                    +   ?
                      * (%@?v&!values+!v:?values)^?
                      * 1
                    + 0
                    ()
            )
          & 0:?values
          & (   !toolprop
              :   ?
                + ( !ToolName
                  .   ?
                      (lang,?+((vals$.vals$)&~)+?)
                      ?
                  )
                + 0
            | 
            )
          & :?languages
          &   whl
            ' ( !values:#*%@?val+?values
              & !languages (language.,!val):?languages
              )
          & 0:?values
          & (   !toolprop
              :   ?
                + ( !ToolName
                  .   ?
                      (facet,?+(vals$&~.?)+?)
                      ?
                  )
                + 0
            | 
            )
          & :?infacets
          &   whl
            ' ( !values:#*%@?val+?values
              &   (!infacets:|!infacets ", ") !val
                : ?infacets
              )
          & 0:?values
          & (   !toolprop
              :   ?
                + ( !ToolName
                  .   ?
                      (facet,?+(?.vals$&~)+?)
                      ?
                  )
                + 0
            | 
            )
          & :?outfacets
          &   whl
            ' ( !values:#*%@?val+?values
              &   (!outfacets:|!outfacets ", ") !val
                : ?outfacets
              )
          & 0:?values
          & (   !toolprop
              :   ?
                + ( !ToolName
                  .   ?
                      (format,?+(vals$&~.?)+?)
                      ?
                  )
                + 0
            | 
            )
          & :?informats
          &   whl
            ' ( !values:#*%@?val+?values
              &   (!informats:|!informats ", ") !val
                : ?informats
              )
          & 0:?values
          & (   !toolprop
              :   ?
                + ( !ToolName
                  .   ?
                      (format,?+(?.vals$&~)+?)
                      ?
                  )
                + 0
            | 
            )
          & :?outformats
          &   whl
            ' ( !values:#*%@?val+?values
              &     (!outformats:|!outformats ", ")
                    !val
                : ?outformats
              )
          &   ("?"."xml version=\"1.0\" encoding=\"UTF-8\"")
              \r\n
              ( CMD
              .     (xmlns."http://www.clarin.eu/cmd/")
                    ("xmlns:xsi"."http://www.w3.org/2001/XMLSchema-instance")
                    ( "xsi:schemaLocation"
                    . "http://www.clarin.eu/cmd http://infra.clarin.dk/schemas/cmd/DKCLARIN-tool-profile.xsd"
                    )
                    (CMDVersion."1.1")
                ,   \r\n
                    ( Header
                    .   
                      ,   \r\n
                          (MdCreator.,DK-CLARIN)
                          \r\n
                          (MdProfile.,"clarin.eu:cr1:p_1380106710826")
                          \r\n
                    )
                    \r\n
                    ( Resources
                    .   
                      ,   \r\n
                          (ResourceProxyList.,)
                          \r\n
                          (JournalFileProxyList.,)
                          \r\n
                          (ResourceRelationList.,)
                          \r\n
                    )
                    \r\n
                    ( Components
                    .   
                      ,   \r\n
                          ( DKCLARIN-tool-profile
                          .   
                            ,   \r\n
                                ( olac
                                .   
                                  ,   \r\n
                                      (conformsTo.,"DKCLARIN_TOOL")
                                      \r\n
                                      ( contributor
                                      . (olac-role.editor),n/a
                                      )
                                      \r\n
                                      ( contributor
                                      . (olac-role.sponsor),n/a
                                      )
                                      \r\n
                                      ( contributor
                                      .   (olac-role.depositor)
                                        , !ContentProvider
                                      )
                                      \r\n
                                      (created.,2011-03-16)
                                      \r\n
                                      (creator.,!ToolCreator)
                                      \r\n
                                      ( description
                                      .   ("xml:lang".da)
                                        , !ToolDescription
                                      )
                                      \r\n
                                      (format.,application)
                                      \r\n
                                      (issued.,2011-03-16)
                                      " !languages "
                                      (publisher.,!ToolPublisher)
                                      \r\n
                                      (source.,n/a)
                                      \r\n
                                      (subject.,n/a)
                                      \r\n
                                      ( title
                                      . ("xml:lang".da),!FullToolName
                                      )
                                      \r\n
                                      (type.,service)
                                      \r\n
                                )
                                \r\n
                                ( DKCLARIN-dkclarin
                                .   
                                  ,   \r\n
                                      (CPsId.,n/a)
                                      \r\n
                                      (creationDateCertainty.,n/a)
                                      \r\n
                                      (externalUri.,!ToolExternalURI)
                                      \r\n
                                      (fileName.,n/a)
                                      \r\n
                                      (infoAbout.,!InfoAbout)
                                      \r\n
                                )
                                \r\n
                                ( DKCLARIN-tool
                                .   
                                  ,   \r\n
                                      (toolId.,!ToolName)
                                      \r\n
                                      (version.,!ToolVersion)
                                      \r\n
                                      (serviceUrl.,!ToolURL)
                                      \r\n
                                      (facetsIn.,!infacets)
                                      \r\n
                                      (facetsOut.,!outfacets)
                                      \r\n
                                      (dataformatsIn.,!informats)
                                      \r\n
                                      (dataformatsOut.,!outformats)
                                      \r\n
                                )
                                \r\n
                          )
                          \r\n
                    )
                    \r\n
              )
              \r\n
      )
      ( denumerizeSum
      =   A M Z
        .     whl
            ' ( !arg:(?A+#%*?M+?Z|?A+?M^#%+?Z)
              & !A+!M+!Z:?arg
              )
          & !arg
      )
      ( removeNumFactors
      =   A M Z
        .     whl
            ' ( !arg:?A+#%*?M+?Z
              & !A+!M+!Z:?arg
              )
          & !arg
      )
      "
/**
  * register
  *
  * Register a tool - integrated or not.
  * Produces an initially empty html form that dynamically adapts to user's
  * need to register multiple values for the same feature.
  * The form consists of two parts: a part for general information, most of
  * which can be deposited in the repository in a later phase, and a part that
  * is mainly used for integrated tools. The second part collects very precise
  * and formalised information that enables the Tools module to compute
  * workflows with tools and resources that fit together. Only some of the
  * information from this part can be deposited in the repository: a condensed
  * list of supported languages, dataformats and facets, in both input and 
  * output. Missing in the deposited metadata are the restrictions on 
  * combinations of input and output features and between features. 
  * For example there is no formal way for the deposited metadata to express
  * that the input facet 'Part Of Speech' can be combined with input languages
  * Danish and English, but not with Russian as an input language. Nor can
  * deposited metadata formally express that input language Danish implies 
  * output language Danish, and input lnaguage Russian either output language
  * Russian or English. (Implying that the tool can translate from Russian to
  * English.) 
  * Such relations must be written in natural language in the description of
  * the tool.
  *
  * Affected tables: 
  *         tooladm.table   (general part), 
  *         toolprop.table  (for integrated tools)
  * Input: a list of HTTP-parameters converted to the form 
  *     (<parameter>.<value>) (<parameter>.<value>) (<parameter>.<value>) ...
  *
  * Output: a XHTML-form
  *
  * Input and output form a closed circuit: the form is generated by the 
  * register function and the input from the filled-out form is sent to the
  * register function.
  *
  * Called from register.java
  */"
      ( register
      =     Metadata featureListing staticFields
          , ToolName ToolVersion FullToolName PassWord password
          , ToolURL ToolPublisher ContentProvider passwordAsHandle
          , ToolCreator InfoAbout ToolDescription mail2
          , ToolExternalURI ToolXMLparms
          , ToolPostData ToolInactive
          , formFields storeTool handle
          , unfoldInputAndOutput foldInputAndOutput askFeature
          , nth AA ZZ feats windfw ContactEmail contactEmail
          , featjursPreexisting featjursURL feat error Submit
          , createBoilerPlate
          , validationComments
          , storeToolButton replaceToolButton
          , deleteToolButton UpdateButton PHPbutton
        .   log$(register !arg)
          & clean$
          & :?servicedSources:?servicedGoals
          &   localized$("Save metadata" "Gem oplysninger")
            : ?storeToolButton
          &   localized$("Replace metadata" "Erstat oplysninger")
            : ?replaceToolButton
          &   localized$("Delete metadata" "Slet oplysninger")
            : ?deleteToolButton
          &   localized$("Show more entry fields" "Vis flere inputfelter")
            : ?UpdateButton
          & localized$("PHP wrapper" PHP-kode):?PHPbutton
          & ( createBoilerPlate
            =     ToolName ToolVersion FullToolName
                , URL Publisher ContentProvider
                , Creator InfoAbout Description
                , ExternalURI XMLparms url-password
                , PostData Inactive pval toggles
                , liste a z urlparm var val like
                , PassWord url-ToolName
                , ContactEmail url-contactEmail
              .     ~(!arg:? (name.?) ?)
                  &   !arg
                    : ? (contactEmail.~:?url-contactEmail) ?
                  & "User hasn't specified a name yet, but email is known. This
                     generates a form independent of already registered tools."
                  & ( 
                    . 
                    . !url-contactEmail
                    . !arg (ml2.!url-contactEmail) (nctv.on)
                    )
                |   "Either the name http parameter is similar to an existing 
                     tool's name, or it is the name of a new tool."
                  & ( like
                    =   
                      .   sim$(trim$!sjt,trim$!arg):1
                        & ?
                    )
                  & log$(createBoilerPlate !arg)
                  & "TODO RESET ALL OF urlparm IF TOOL NOT FOUND"
                  & !arg:?urlparm
                  &   !urlparm
                    : ? (name.?url-ToolName) ?
                    : ( ? (password.~:?url-password) ?
                      | ?&:?url-password
                      )
                    : ? (contactEmail.~:?url-contactEmail) ?
                  & :?ContactEmail
                  & (     !tooladm
                        :   ?
                          + (   ?
                                ( ToolID
                                .   like$!url-ToolName
                                  : ?ToolName
                                  : ?url-ToolName
                                )
                                ?
                            : ( ? (PassWord.?PassWord) ?
                              | ?
                              )
                            : ( ? (ContactEmail.?ContactEmail) ?
                              | ?
                              )
                            : ? (Version.?ToolVersion) ?
                            : ? (Title.?FullToolName) ?
                            : ? (ServiceURL.?URL) ?
                            : ? (Publisher.?Publisher) ?
                            : ? (ContentProvider.?ContentProvider) ?
                            : ? (Creator.?Creator) ?
                            : ? (InfoAbout.?InfoAbout) ?
                            : ? (Description.?Description) ?
                            : ? (ExternalURI.?ExternalURI) ?
                            : ? (XMLparms.?XMLparms) ?
                            : ? (PostData.?PostData) ?
                            : ? (Inactive.?Inactive) ?
                            )
                          + ?
                      & !urlparm:?a (name.?) ?z
                      & !a (name.!url-ToolName) !z:?urlparm
                      & "The name http parameter was similar to an existing tool's name.
                         Use the existing tool's name instead and fetch all that is known
                         about this tool."
                    |   "The name http parameter is not seen before, so 
                         we create an empty form for an inactive tool."
                      & !url-ToolName:?ToolName
                      & !url-contactEmail:?ContactEmail
                      &   
                        : ?PassWord
                        : ?url-password
                        : ?ToolVersion
                        : ?FullToolName
                        : ?URL
                        : ?Publisher
                        : ?ContentProvider
                        : ?Creator
                        : ?InfoAbout
                        : ?Description
                        : ?ExternalURI
                        : ?XMLparms
                        : ?PostData
                      & on:?Inactive
                    )
                  & ( !url-contactEmail:!ContactEmail
                    |   ( !url-password:!PassWord:~
                        | !PassWord:!ContactEmail:
                        )
                      & !url-contactEmail:?ContactEmail
                    )
                  & "You only are allowed to edit a tool that
                        1) is yours (email) 
                     or 2) you know the password for
                     or 3) has empty password AND email fields (orphan tool)
                     
                     The password is reset and the tool becomes yours."
                  &     (psswrd.)
                        (ml2.!ContactEmail)
                        (vrsion.!ToolVersion)
                        (fllNm.!FullToolName)
                        (pblshr.!Publisher)
                        (cntPrvdr.!ContentProvider)
                        (crtr.!Creator)
                        (docuri.!InfoAbout)
                        (url.!URL)
                        (dscrptn.!Description)
                        (xuri.!ExternalURI)
                    : ?liste
                  &     (xmlprms.!XMLparms)
                        (pstdt.!PostData)
                        (|(nctv.!Inactive))
                    : ?toggles
                  &   (     !urlparm
                          : ? (handle.?handle) ?
                          : ? (nth.?) ?
                        & "When the user enters the form, the list of http
                           parameters is still short:
                                 handle,contactEmail,name,password,bsubmit
                           A good indication that the user hasn't toggled
                           anything is the absence of the 'nth' parameter.
                           User's input value of Inactive overrules
                           registered input."
                        & ( !urlparm:? (nctv.?) ?
                          | (nctv.) !urlparm
                          )
                      |   "Registered value of Inactive overrules user's input."
                        &   !urlparm
                          : ( ?a (nctv.?) ?z
                            | ?z&:?a
                            )
                        & (nctv.!Inactive) !a !z
                      )
                    : ?urlparm
                  & ( !urlparm:? (url.?) ?
                    |   whl
                      ' ( !toggles:(?var.?val) ?toggles
                        & ( !urlparm:? (!var.?) ?
                          | !urlparm (!var.trim$!val):?urlparm
                          )
                        )
                    )
                  &   whl
                    ' ( !liste:(?var.?val) ?liste
                      & trim$!val:?val
                      & (   !urlparm
                          :   ?a
                              (   (!var.) ?z
                                & "Replace empty value by non-empty value."
                                & !a (!var.!val) !z:?urlparm
                              |   (!var.?pval) ?z
                                &   !a (!var.trim$!pval) !z
                                  : ?urlparm
                              )
                        | !urlparm (!var.!val):?urlparm
                        )
                      )
                  & (!ToolName.!PassWord.!ContactEmail.!urlparm)
            )
          & ( staticFields
            =   staticField
              .   ( staticField
                  =     urlvars prompt urlvar
                      , internalvar fieldType attrs
                    .     !arg
                        : ( ?urlvars
                          . ?prompt
                          . ?urlvar
                          . ?internalvar
                          . ?fieldType
                          . ?attrs
                          )
                      &   ( checkParmsSimple$(!urlvars.!urlvar)
                          | 
                          )
                        : ?!internalvar
                      &   !fieldType
                        $ (!prompt.!urlvar.(val.!!internalvar) !attrs)
                  )
                &     fieldset
                    $ (   localized
                        $ ( Boilerplate
                            "Generelle oplysninger for alle værktøjer"
                          )
                      .     paragraph
                          $ (   staticField
                              $ ( !arg
                                . "ToolID:"
                                . name
                                . ToolName
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ("short unique name" "kort unikt navn")
                                    )
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "Title:"
                                . fllNm
                                . FullToolName
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "full name of the tool"
                                          "Værktøjets fulde navn"
                                        )
                                    )
                                    (size.40)
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "Version:"
                                . vrsion
                                . ToolVersion
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "may only contain ascii letters dots  and digits"
                                          "må kun indeholde ascii-bogstaver, punktum og cifre"
                                        )
                                    )
                                    (required."*")
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Publisher:"
                                . pblshr
                                . ToolPublisher
                                . makeTextFormField
                                . required
                                . "*"
                                )
                                staticField
                              $ ( !arg
                                . "Content provider:"
                                . cntPrvdr
                                . ContentProvider
                                . makeTextFormField
                                . required
                                . "*"
                                )
                                staticField
                              $ ( !arg
                                . "Creator:"
                                . crtr
                                . ToolCreator
                                . makeTextFormField
                                . (size.25) (required."*")
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Email:"
                                . ml2
                                . ContactEmail
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "protection against unauthorized update"
                                          "Beskyttelse mod uautoriseret redigering af oplysninger. Email adressen bliver ikke offentliggjort eller lagret i repositoriet ved deponering af værktøjets oplysninger og kan ændres ved at overdrage redigeringsrettigheden til en anden person. (Se forklaring på Password-feltet.)"
                                        )
                                    )
                                    (readonly.yes)
                                )
                                staticField
                              $ ( !arg
                                . "Password:"
                                . psswrd
                                . PassWord
                                . makeTextFormField
                                . desc
                                .   localized
                                  $ ( "If you want to transfer the edit right of the tool to somebody else, enter a one-time password that you share with the other person. The other person must be logged in via WAYF and enter the password to gain access and the edit right."
                                      "Hvis du vil overdrage redigeringsrettigheden til en anden person, skriv en engangsadgangskode og giv den til den anden person. For at modtage redigeringsrettigheden, skal den anden person logge sig på via WAYF og indtaste adgangskoden. Når hun eller han erstatter værktøjets oplysninger, bliver hans eller hendes email adresse noteret i Email-feltet og er hun eller han blevet den primære kontaktperson hvis der er spørgsmål eller problemer ang. værktøjet."
                                    )
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "InfoAbout:"
                                . docuri
                                . InfoAbout
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "URI of documentation"
                                          "Dokumentationens URI"
                                        )
                                    )
                                    (size.40)
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "External Service URL:"
                                . xuri
                                . ToolExternalURI
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "fill out if the tool (also) functions as a web service"
                                          "udfyld hvis værktøjet (også) fungerer som webservice"
                                        )
                                    )
                                    (size.40)
                                )
                            )
                            paragraph
                          $ ( staticField
                            $ ( !arg
                              . "Description:"
                              . dscrptn
                              . ToolDescription
                              . makeTextAreaFormField
                              . required
                              . "*"
                              )
                            )
                      )
                      fieldset
                    $ (   localized
                        $ ("Webservice metadata" Webserviceoplysninger)
                      .     paragraph
                          $ ( staticField
                            $ ( !arg
                              . "Service URL of the tool:"
                              . url
                              . ToolURL
                              . makeTextFormField
                              .   ( desc
                                  .   localized
                                    $ ( "Something like \"https://abc.foo/wordreverser\". Only needed for integrated tools. To wipe URL: replace with one or more blank characters."
                                        "Noget i stil med \"https://abc.foo/wordreverser\". Kun krævet for integrerede værktøjer. For at udviske URL: erstat med blanktegn."
                                      )
                                  )
                                  (size.40)
                              )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Requires HTTP POST method:"
                                . pstdt
                                . ToolPostData
                                . makeCheckboxFormField
                                . 
                                )
                                staticField
                              $ ( !arg
                                . "parameters as XML (if POST):"
                                . xmlprms
                                . ToolXMLparms
                                . makeCheckboxFormField
                                . desc
                                .   localized
                                  $ ( "Check if parameters must be sent in XML format"
                                      "Marker hvis parametre skal sendes i XML-format"
                                    )
                                )
                                staticField
                              $ ( !arg
                                . "Inactive:"
                                . nctv
                                . ToolInactive
                                . makeCheckboxFormField
                                .   ( desc
                                    .   localized
                                      $ ( "Check if the tool is not integrated. Also check this box if an integrated tool temporarily cannot be used. (You need to be logged in to toggle this swicth.)"
                                          "Marker hvis værktøjet er midlertidigt ude af drift eller slet ikke integreret. (Du skal være logget på før du kan ændre dette felt.)"
                                        )
                                    )
                                    (   !handle:
                                      & (disabled.disabled)
                                    | 
                                    )
                                )
                            )
                      )
            )
          & ( featureListing
            =   listing featname inouts in outp K listIO
              .   ( listIO
                  =   in io I S L M s opt addFeature
                    .   ( addFeature
                        =     in K L featname io
                            , I S listing M s optional
                          .     !arg
                              : ( ?in
                                . ?K
                                . ?L
                                . ?featname
                                . ?io
                                . ?I
                                . ?S
                                . ?listing
                                . ?optional
                                )
                            &     (str$(!featname !K "." !L !io).!I)
                                  ( !optional:
                                  | (   str
                                      $ (!featname !K "." !L !io !optional)
                                    . on
                                    )
                                  )
                                  (   !in:(1|)
                                    & 
                                  | ( str$(!featname !K "." !L !io More)
                                    . on
                                    )
                                  )
                                  !listing
                              : ?listing
                            & 0:?M
                            & ( !S:1
                              |   whl
                                ' ( !S:%?s+?S
                                  & NEWSPEC
                                  & 1+!M:?M
                                  &     (   str
                                          $ ( !featname
                                              !K
                                              "."
                                              !L
                                              "."
                                              !M
                                              !io
                                              Spc
                                            )
                                        . !s
                                        )
                                        ( !S:0&
                                        | (   str
                                            $ ( !featname
                                                !K
                                                "."
                                                !L
                                                "."
                                                !M
                                                !io
                                                Spc
                                                More
                                              )
                                          . on
                                          )
                                        )
                                        !listing
                                    : ?listing
                                  )
                              )
                            & !listing
                        )
                      & 0:?L
                      & !arg:(?in.?io)
                      & !in:(%?in ?opt|?opt)
                      &   whl
                        ' ( !in:%?I^?S*?in
                          & 1+!L:?L
                          & NEWSPEC
                          &     addFeature
                              $ ( !in
                                . !K
                                . !L
                                . !featname
                                . !io
                                . !I
                                . !S
                                . !listing
                                . 
                                )
                            : ?listing
                          )
                      & ( !opt:
                        |       (str$(!featname !K "." !L !io More).on)
                                !listing
                            : ?listing
                          & NEWSPEC
                          &   whl
                            ' ( !opt:%?I^?S ?opt
                              & 1+!L:?L
                              & NEWSPEC
                              &     addFeature
                                  $ ( !opt
                                    . !K
                                    . !L
                                    . !featname
                                    . !io
                                    . !I
                                    . !S
                                    . !listing
                                    . Optional
                                    )
                                : ?listing
                              )
                        )
                  )
                & :?listing
                &   whl
                  ' ( !arg:(?featname,?inouts) ?arg
                    & 0:?K
                    &   whl
                      ' ( !inouts:#*(?in.?outp)+?inouts
                        & 1+!K:?K
                        & listIO$(!in.Input)
                        & listIO$(!outp.Output)
                        & ( !inouts:0
                          |     (str$(!featname !K More).on)
                                !listing
                            : ?listing
                          )
                        )
                    )
                & !listing
            )
          & ( windfw
            =   nth Nth toolprop ZZ ToolName featjursPreexisting
              .   !arg:(?toolprop.?ToolName.?nth:?Nth)
                & !toolprop:?+(!ToolName.?featjursPreexisting)+?ZZ
                &   whl
                  ' ( !Nth:>0
                    & !ZZ:(!ToolName.?featjursPreexisting)+?ZZ
                    & !Nth+-1:?Nth
                    )
                & (!featjursPreexisting.!ZZ.!nth+-1*!Nth)
            )
          & ( unfoldInputAndOutput
            =   afeat feat apair a z II OO zpair zfeat
              .     whl
                  ' (   !arg
                      :   ?afeat
                          (?feat,?apair+#*(%?a+%?z.?OO)+?zpair)
                          ?zfeat
                    &     !afeat
                          (!feat,!apair+(!a.!OO)+(!z.!OO)+!zpair)
                          !zfeat
                      : ?arg
                    )
                &   whl
                  ' (   !arg
                      :   ?afeat
                          (?feat,?apair+#*(?II.%?a+%?z)+?zpair)
                          ?zfeat
                    &     !afeat
                          (!feat,!apair+(!II.!a)+(!II.!z)+!zpair)
                          !zfeat
                      : ?arg
                    )
                &   whl
                  ' (   !arg
                      :   ?afeat
                          (?feat,?apair+#*(^?.^?)+?zpair)
                          ?zfeat
                    &   !afeat (!feat,!apair+!zpair) !zfeat
                      : ?arg
                    )
                & !arg
            )
          & ( foldInputAndOutput
            =     afeat feat apair a b II OO zpair zfeat
                , mpair aval zval
              .     whl
                  ' (   !arg
                      :   ?afeat
                          (?feat,?apair+#%*(?II.?OO)+?zpair)
                          ?zfeat
                    &     !afeat
                          (!feat,!apair+(!II.!OO)+!zpair)
                          !zfeat
                      : ?arg
                    )
                &   whl
                  ' (   !arg
                      :   ?afeat
                          ( ?feat
                          , ?apair+#*(?a.?OO)+?mpair+#*(?b.!OO)+?zpair
                          )
                          ?zfeat
                    &     !afeat
                          ( !feat
                          ,   !apair
                            + (denumerizeSum$(!a+!b).!OO)
                            + !mpair
                            + !zpair
                          )
                          !zfeat
                      : ?arg
                    )
                &   whl
                  ' (   !arg
                      :   ?afeat
                          ( ?feat
                          , ?apair+#*(?II.?a)+?mpair+#*(!II.?b)+?zpair
                          )
                          ?zfeat
                    &     !afeat
                          ( !feat
                          ,   !apair
                            + (!II.denumerizeSum$(!a+!b))
                            + !mpair
                            + !zpair
                          )
                          !zfeat
                      : ?arg
                    )
                &   whl
                  ' (   !arg
                      :   ?afeat
                          (?feat,?apair+#*(^?.^?)+?zpair)
                          ?zfeat
                    &   !afeat (!feat,!apair+!zpair) !zfeat
                      : ?arg
                    )
                &   whl
                  ' (   !arg
                      :   ?afeat
                          (?feat,?apair+#*(?aval*^?*?zval.?OO)+?zpair)
                          ?zfeat
                    &     !afeat
                          ( !feat
                          ,   !apair
                            + (denumerizeSum$(!aval*!zval).!OO)
                            + !zpair
                          )
                          !zfeat
                      : ?arg
                    )
                &   whl
                  ' (   !arg
                      :   ?afeat
                          (?feat,?apair+#*(?II.?aval*^?*?zval)+?zpair)
                          ?zfeat
                    &     !afeat
                          ( !feat
                          ,   !apair
                            + (!II.denumerizeSum$(!aval*!zval))
                            + !zpair
                          )
                          !zfeat
                      : ?arg
                    )
                &   whl
                  ' (   !arg
                      :   ?afeat
                          (?feat,?apair+#*(1.?OO)+?zpair)
                          ?zfeat
                    &     !afeat
                          (!feat,!apair+(.!OO)+!zpair)
                          !zfeat
                      : ?arg
                    )
                &   whl
                  ' (   !arg
                      :   ?afeat
                          (?feat,?apair+#*(?II.1)+?zpair)
                          ?zfeat
                    &     !afeat
                          (!feat,!apair+(!II.)+!zpair)
                          !zfeat
                      : ?arg
                    )
                &   whl
                  ' ( !arg:?afeat (?feat,0) ?zfeat
                    & !afeat !zfeat:?arg
                    )
                & !arg
            )
          & ( askFeature
            =     inoutpairs feat urlparms formstuff
                , formFields Metadata featname
                , askFieldSet shortfeatname
                , featdescription feattable specificationTables
              .   ( askFieldSet
                  =     sameFeaturePairOnceMore NrInOutAlternative
                      , featname inout featurePair inoutpairs
                      , featurePairMore FieldSet optionalFeature ret
                      , NrRequiredAndOptional optionals requireds
                      , shouldIAskOptionalFeature
                      , urlparms feattable featdescription formstuff
                      , askOptional aFeature Input Output
                    .   ( sameFeaturePairOnceMore
                        = .!arg:(?arg.?)&(.!arg)
                        )
                      & ( askOptional
                        =   urlparms featinoutOptional
                          .   !arg:(?urlparms.?featinoutOptional)
                            &   (   checkParmsSimple
                                  $ (!urlparms.!featinoutOptional)
                                | 
                                )
                              : ?!featinoutOptional
                            &   makeCheckboxFormField
                              $ ( optional
                                . !featinoutOptional
                                . val
                                . !!featinoutOptional
                                )
                        )
                      & ( aFeature
                        =     NrRequiredAndOptional NrInOutAlternative
                            , NrSpecification featname
                            , inout featinout featinoutMore
                            , featinoutOptional urlparms
                            , feattable featdescription row
                            , specifications specificationTables
                            , sameFeatureOnceMore YYY
                            , sameSpecificationOnceMore full
                            , specificationTable aSpecification
                            , featinoutSpec featinoutOptMore ret
                          .   (sameFeatureOnceMore=.)
                            & ( aSpecification
                              =   :?sameSpecificationOnceMore
                                & 1+!NrSpecification:?NrSpecification
                                &     str
                                    $ ( !featname
                                        !NrInOutAlternative
                                        "."
                                        !NrRequiredAndOptional
                                        "."
                                        !NrSpecification
                                        !inout
                                        Spc
                                      )
                                  : ?featinoutSpec
                                &   str$(!featinoutSpec More)
                                  : ?featinoutOptMore
                                & (       checkParms
                                        $ ( !urlparms
                                          . !featinoutSpec
                                          .   !!specificationTable
                                            |   readTable$!specificationTable
                                              & !!specificationTable
                                          )
                                      : ?!featinoutSpec
                                    & NEWSPEC
                                    &     ( !!featinoutSpec:~:~1
                                          | 0
                                          )
                                        + !specifications
                                      : ?specifications
                                  | :?!featinoutSpec
                                  )
                                &     !row
                                        makeSelectFormField
                                      $ (   str
                                          $ ( (     !!feattable
                                                  :   ?
                                                      (?full.!!featinout.?YYY)
                                                      ?
                                                & localized$!full
                                              |   "featinout:"
                                                  !featinout
                                                  "=="
                                                  !!featinout
                                                  " and feattable "
                                                  !feattable
                                                  " looks like this:"
                                                  !!feattable
                                              )
                                              " style"
                                            )
                                        . !featinoutSpec
                                        . options
                                        .   makeOptionList
                                          $ (!!specificationTable.!!featinoutSpec)
                                        )
                                      (       checkParmsSimple
                                            $ (!urlparms.!featinoutOptMore)
                                          : ?!featinoutOptMore
                                        & (   !!featinoutOptMore:on
                                            &   '$aSpecification
                                              : ( 
                                                = ?sameSpecificationOnceMore
                                                )
                                            &   makeHiddenFields
                                              $ (!featinoutOptMore.on)
                                          | 
                                          )
                                      |   makeCheckboxFormField
                                        $ ( localized$(more mere)
                                          . !featinoutOptMore
                                          . 
                                          )
                                      )
                                  : ?row
                                & !sameSpecificationOnceMore
                              )
                            &   !arg
                              : ( ?NrRequiredAndOptional
                                . ?featname
                                . ?NrInOutAlternative
                                . ?inout
                                . ?urlparms
                                . ?feattable
                                . ?featdescription
                                . ?specificationTables
                                . ?requireds
                                . ?optionals
                                )
                            &   1+!NrRequiredAndOptional
                              : ?NrRequiredAndOptional
                            &     str
                                $ ( !featname
                                    !NrInOutAlternative
                                    "."
                                    !NrRequiredAndOptional
                                    !inout
                                  )
                              : ?featinout
                            & str$(!featinout More):?featinoutMore
                            &   str$(!featinout Optional)
                              : ?featinoutOptional
                            & :?!featinoutOptional
                            &   (   checkParms
                                  $ (!urlparms.!featinout.!!feattable)
                                | 
                                )
                              : ?!featinout
                            &       makeSelectFormField
                                  $ ( !inout
                                    . !featinout
                                    .   ( options
                                        .   makeOptionList
                                          $ (!!feattable.!!featinout)
                                        )
                                        (desc.!featdescription)
                                    )
                                    optionalFeature
                                  $ (!urlparms.!featinoutOptional)
                                  (       checkParmsSimple
                                        $ (!urlparms.!featinoutMore)
                                      : ?!featinoutMore
                                    & (   !!featinoutMore:on
                                        &   '$aFeature
                                          : (=?sameFeatureOnceMore)
                                        &   makeHiddenFields
                                          $ (!featinoutMore.on)
                                      | 
                                      )
                                  |   makeCheckboxFormField
                                    $ ( localized$(more mere)
                                      . !featinoutMore
                                      . 
                                      )
                                  )
                              : ?row
                            & 0:?specifications
                            & NEWSPEC
                            & (   !specificationTables
                                :   ?
                                    ( ? (%@:!!featinout) ?
                                    .   ?specificationTable
                                      & 0:?NrSpecification
                                      & !aSpecification
                                    )
                                    ?
                              | 
                              )
                            & NEWSPEC
                            &     !!featinout
                                ^ ( !specifications:~0:~
                                  | 1
                                  )
                              : ?!featinout
                            & ( (   !!featinoutOptional:
                                  & !requireds*!!featinout:?requireds
                                | !optionals !!featinout:?optionals
                                )
                              & 
                              )
                            & !FieldSet paragraph$!row:?FieldSet
                            &   '$shouldIAskOptionalFeature
                              : (=?optionalFeature)
                            &     sameFeatureOnceMore
                                $ ( !NrRequiredAndOptional
                                  . !featname
                                  . !NrInOutAlternative
                                  . !inout
                                  . !urlparms
                                  . !feattable
                                  . !featdescription
                                  . !specificationTables
                                  . !requireds
                                  . !optionals
                                  )
                              : ?ret
                            & tbl$(!featinoutMore,0)
                            & tbl$(!featinoutOptMore,0)
                            & tbl$(!featinoutOptional,0)
                            & tbl$(!featinout,0)
                            & tbl$(!featinoutSpec,0)
                            & !ret
                        )
                      &   !arg
                        : ( ?inoutpairs
                          . ?NrInOutAlternative
                          . ?featname
                          . ?urlparms
                          . ?feattable
                          . ?featdescription
                          )
                      & 1+!NrInOutAlternative:?NrInOutAlternative
                      &   str$(!featname !NrInOutAlternative)
                        : ?featurePair
                      & str$(!featurePair More):?featurePairMore
                      & :?FieldSet
                      & (optionalFeature=.)
                      &   '$askOptional
                        : (=?shouldIAskOptionalFeature)
                      & (   Input Output
                          :   ?
                              ( %@?inout
                              & :?optionals
                              & 1:?requireds
                              &   aFeature
                                $ ( 0
                                  . !featname
                                  . !NrInOutAlternative
                                  . !inout
                                  . !urlparms
                                  . !feattable
                                  . !featdescription
                                  . !specificationTables
                                  . !requireds
                                  . !optionals
                                  )
                              & !requireds !optionals:?!inout
                              & (shouldIAskOptionalFeature=.)
                              & (optionalFeature=.)
                              & ~
                              )
                              ?
                        | (!Input.!Output)+!inoutpairs:?inoutpairs
                        )
                      &     fieldset$(.!FieldSet)
                            (       checkParmsSimple
                                  $ (!urlparms.!featurePairMore)
                                : ?!featurePairMore
                              & (   !!featurePairMore:on
                                  &   '$askFieldSet
                                    : (=?sameFeaturePairOnceMore)
                                  & makeHiddenFields$(!featurePairMore.on)
                                | 
                                )
                            |   makeCheckboxFormField
                              $ (   localized
                                  $ ( "Add an input/output combination"
                                      "Tilføj en input/output-kombination"
                                    )
                                . !featurePairMore
                                . 
                                )
                            )
                            (     sameFeaturePairOnceMore
                                $ ( !inoutpairs
                                  . !NrInOutAlternative
                                  . !featname
                                  . !urlparms
                                  . !feattable
                                  . !featdescription
                                  )
                              : (?formstuff.?inoutpairs)
                            & !formstuff
                            )
                        : ?ret
                      & tbl$(!featurePairMore,0)
                      & tbl$(!featurePair,0)
                      & (!ret.!inoutpairs)
                  )
                & !arg:(?urlparms.?feat.?formFields.?Metadata)
                &   !feat
                  : ? (name.?featname) ?
                  : ? (short.?shortfeatname) ?
                  : ? (description.?featdescription) ?
                  : ? (table.?feattable) ?
                  : ( ? (specificationTable.?specificationTables) ?
                    | ?
                    )
                & 0:?inoutpairs
                & readTable$!feattable
                & (   !formFields
                        fieldset
                      $ ( localized$!featname
                        .       askFieldSet
                              $ ( !inoutpairs
                                . 0
                                .   !shortfeatname
                                  | localized$!featname
                                . !urlparms
                                . !feattable
                                . localized$!featdescription
                                )
                            : (?formstuff.?inoutpairs)
                          & !formstuff
                        )
                  . !Metadata (!shortfeatname,!inoutpairs)
                  )
            )
          & ( validationComments
            =     Submit otherName
                , ToolName ToolVersion FullToolName PassWord
                , ToolURL ToolPublisher ContentProvider
                , ToolCreator InfoAbout ToolDescription
                , ToolExternalURI ToolXMLparms mayNotBeEmpty
                , ToolPostData ToolInactive Nazn dNazn
              .     !arg
                  : ( ?ToolName
                    . ?PassWord
                    . ?ToolVersion
                    . ?FullToolName
                    . ?ToolURL
                    . ?ToolPublisher
                    . ?ContentProvider
                    . ?ToolCreator
                    . ?InfoAbout
                    . ?ToolDescription
                    . ?ToolExternalURI
                    . ?ToolXMLparms
                    . ?ToolPostData
                    . ?ToolInactive
                    . ?Submit
                    )
                & ( mayNotBeEmpty
                  =   
                    .   "'"
                        !arg
                        "' "
                        localized$("may not be empty" "må ikke være tom")
                        (br.,)
                  )
                & ( (   !ToolName:
                      & mayNotBeEmpty$ToolID
                    |   @( !ToolName
                         : allowedChar$('$NCNameStartChar) !NCName
                         )
                      & `~
                    |   str
                      $ ( "ToolID '"
                          !ToolName
                            localized
                          $ ( "' contains invalid characters. (Must be an xml:id)"
                              "' indeholder ugyldige karakterer. (Skal være et xml:id)"
                            )
                        )
                    )
                  | !ToolName:&mayNotBeEmpty$ToolID
                  |   !FullToolName:
                    & mayNotBeEmpty$Title
                  |   !ToolURL:
                    & !ToolInactive:
                    &     localized
                        $ ( "'Service URL' may not be empty if the tool is integrated and active. If the tool must be integrated in the infrastructure, but not just now, you must check the field 'Inactive'."
                            "'Service URL' må ikke være tom hvis værktøjet er et aktivt integreret værktøj. Hvis værktøjet ikke skal være integreret i infrastrukturen, skal du markere feltet 'Inactive'."
                          )
                        (br.,)
                  |     !tooladm
                      :   ?
                        + ( ? (ToolID.!ToolName) ?
                          : ? (Inactive.) ?
                          : ? (ServiceURL.<>!ToolURL) ?
                          )
                        + ?
                    & !Submit:!storeToolButton
                    &     str
                        $ (   localized
                            $ ( "There is already an integrated tool with the name '"
                                "Der findes et integreret værktøj med navn '"
                              )
                            !ToolName
                              localized
                            $ ( "' with another Service URL. If you are sure it is the same tool, you can change the Service URL by temporarily deactivating the tool. (Check the 'Inactive'-field, save, change the Service URL, uncheck 'Inactive', and save.)"
                                "' med en anden Service URL end den indtastede. Hvis du er sikker på at det er samme værktøj, kan du ændre Service URL ved først midlertigt at deaktivere værktøjet. (Klik 'Inactive'-feltet, gem, ændr Service URL og klik 'Inactive'-feltet igen, gem.)"
                              )
                          )
                        (br.,)
                  |   !ToolURL:~
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!ToolURL) ?
                          :   ?
                              (ToolID.?otherName:<>!ToolName)
                              ?
                          )
                        + ?
                    &     str
                        $ ( localized$("Cannot save '" "Kan ikke gemme '")
                            !ToolName
                              localized
                            $ ("' on Service URL \"" "' på Service URL \"")
                            !ToolURL
                              localized
                            $ ( "\" (already taken by the tool '"
                                "\" (allerede i brug af værktøjet '"
                              )
                            !otherName
                            "')."
                          )
                        (br.,)
                  |   ( Nazn
                      =   #
                          ( 
                          | ? (%@:~<a:~>z)
                          | `
                          )
                          (|#)
                      )
                    & '("." ()$Nazn):(=?dNazn)
                    & (   @( !ToolVersion
                           :   !Nazn
                               ( 
                               |   !dNazn
                                   ( 
                                   | !dNazn (|!dNazn)
                                   )
                               )
                           )
                        & `~
                      |   localized
                        $ ( "'Version' must match the regular expression [d]+[a-z]*[d]*(.[d]+[a-z]*[d]*){0,3}"
                            "'Version' skal matche det regulære udtryk [d]+[a-z]*[d]*(.[d]+[a-z]*[d]*){0,3}"
                          )
                      )
                  |   !ToolPublisher:
                    & mayNotBeEmpty$Publisher
                  |   !ContentProvider:
                    & mayNotBeEmpty$"Content provider"
                  |   !ToolCreator:
                    & mayNotBeEmpty$Creator
                  |   !InfoAbout:
                    &     localized
                        $ ( "'InfoAbout' (tool documentation): URL may not be empty"
                            "'InfoAbout' (værktøjets dokumentation): URL må ikke være tom"
                          )
                        (br.,)
                  |   !ToolDescription:
                    & mayNotBeEmpty$Description
                  |   !ToolPostData:
                    & !ToolXMLparms:on
                    &   ( "XMLparms ("
                          !ToolXMLparms
                            localized
                          $ ( ") must not be checked if 'POST' is not checked"
                              ") skal være umarkeret hvis 'POST' er umarkeret"
                            )
                        )
                        (br.,)
                  )
            )
          & ( storeTool
            =     A M Z Metadata admdata
                , ToolName ToolVersion FullToolName PassWord
                , ToolURL ToolPublisher ContentProvider
                , ToolCreator InfoAbout ToolDescription
                , ToolExternalURI ToolXMLparms removeEmptyValues
                , ToolPostData ToolInactive sortFacets
                , ContactEmail otherToolprop thisToolProp
              .     !arg
                  : ( ?Metadata
                    . ?ToolName
                    . ?PassWord
                    . ?ContactEmail
                    . ?ToolVersion
                    . ?FullToolName
                    . ?ToolURL
                    . ?ToolPublisher
                    . ?ContentProvider
                    . ?ToolCreator
                    . ?InfoAbout
                    . ?ToolDescription
                    . ?ToolExternalURI
                    . ?ToolXMLparms
                    . ?ToolPostData
                    . ?ToolInactive
                    . ?ZZ
                    )
                & (   ( !ToolInactive:on
                      | !handle:~
                      )
                    &   (   !ZZ:<0
                          & (   !toolprop:?+!Metadata+?
                              & "Tool already defined"
                              & !toolprop
                            | !Metadata+!toolprop
                            )
                        |   !toolprop:?AA+(?.?)+!ZZ
                          & ( !AA+!ZZ:?+!Metadata+?
                            | !AA+!Metadata+!ZZ
                            )
                        )
                      : ?toolprop
                    &   whl
                      ' ( !toolprop:?A+(?.)+?Z
                        & !A+!Z:?toolprop
                        )
                    & removeNumFactors$!toolprop:?toolprop
                    & ( removeEmptyValues
                      =   a b
                        .     !arg:?a_?b
                            &     (removeEmptyValues$!a)
                                _ (removeEmptyValues$!b)
                              : ?arg
                            & ( !arg:*?arg&!arg
                              | !arg:+?arg&!arg
                              | !arg:?a^&!a
                              | !arg:^?&
                              )
                          | !arg
                      )
                    & removeEmptyValues$!toolprop:?toolprop
                    & ( sortFacets
                      =   toolpropFacetsSorted Name facets
                        .   0:?toolpropFacetsSorted
                          &   whl
                            ' ( !arg:#*(?Name.?facets)+?arg
                              &     (!Name.sort$!facets)
                                  + !toolpropFacetsSorted
                                : ?toolpropFacetsSorted
                              )
                          & !toolpropFacetsSorted
                      )
                    & sortFacets$!toolprop:?toolprop
                    & removeNumFactors$!toolprop:?toolprop
                    & ( unfact
                      =     ToolName F A Z a z f
                          , O x m T y
                        .   !arg:(?ToolName.?F)
                          & (   !F:?A (?f,%?a+%?z) ?Z
                              &   unfact$(!ToolName.!A (!f,!a) !Z)
                                + unfact$(!ToolName.!A (!f,!z) !Z)
                            |   !F:?A (?f,(%?a+%?z.?O)) ?Z
                              &     unfact
                                  $ (!ToolName.!A (!f,(!a.!O)) !Z)
                                +   unfact
                                  $ (!ToolName.!A (!f,(!z.!O)) !Z)
                            |   !F:?A (?f,(?O.%?a+%?z)) ?Z
                              &     unfact
                                  $ (!ToolName.!A (!f,(!O.!a)) !Z)
                                +   unfact
                                  $ (!ToolName.!A (!f,(!O.!z)) !Z)
                            |     !F
                                :   ?A
                                    (?f,(?O.?x*?m^(%?a+%?z)*?y ?T))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!O.!x*!m^!a*!y !T))
                                        !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!O.!x*!m^!z*!y !T))
                                        !Z
                                    )
                            |     !F
                                :   ?A
                                    (?f,(?x*?m^(%?a+%?z)*?y ?T.?O))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x*!m^!a*!y !T.!O))
                                        !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x*!m^!z*!y !T.!O))
                                        !Z
                                    )
                            |     !F
                                :   ?A
                                    (?f,(%?x ?m^(%?a+%?z) ?T.?O))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x !m^!a !T.!O))
                                        !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x !m^!z !T.!O))
                                        !Z
                                    )
                            |     !F
                                :   ?A
                                    (?f,(?O.%?x ?m^(%?a+%?z) ?T))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    . !A (!f,(!O.!x !m^!a !T)) !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    . !A (!f,(!O.!x !m^!z !T)) !Z
                                    )
                            | !arg
                            )
                      )
                    & ( subset
                      =   toolprop ToolName Fe A fe subs
                        .   !arg:(?toolprop.?ToolName)
                          & !toolprop:?A+(!ToolName.?Fe)+?toolprop
                          & 0:?subs
                          &   !whl
                            ' ( !toolprop:(!ToolName.?fe)+?toolprop
                              & !subs+(!ToolName.!fe):?subs
                              )
                          & ((!ToolName.!Fe)+!subs.!A+!toolprop)
                      )
                    &   subset$(!toolprop.!ToolName)
                      : (?thisToolProp.?otherToolprop)
                    & ( unfactorize
                      =   A
                        .     !arg:%?A+?arg
                            & unfact$!A+unfactorize$!arg
                          | 0
                      )
                    & unfactorize$!thisToolProp:?thisToolProp
                    & removeNumFactors$!thisToolProp:?thisToolProp
                    & ( Combine
                      =     A M Z AA ZZ Name Facet val1
                          , Vals1 Vals2 Vals a m z i o i2 o2
                        .     whl
                            ' (   !arg
                                :   ?A
                                  + (?Name.?val1)
                                  + ?M
                                  + ( ?
                                    .   ?AA
                                        ( (?Facet,?Vals2) ?ZZ
                                        &   !val1
                                          : !AA (!Facet,?Vals1) !ZZ
                                        )
                                    )
                                  + ?Z
                              &     !A
                                  + ( !Name
                                    . !AA (!Facet,!Vals1+!Vals2) !ZZ
                                    )
                                  + !M
                                  + !Z
                                : ?arg
                              )
                          & !arg
                      )
                    & Combine$!thisToolProp:?thisToolProp
                    & ( Ocomb
                      =   a i1 i2 o m z
                        .     !arg:?a+(?i1.?o)+?m+(?i2.!o)+?z
                            & Ocomb$(!a+(!i1+!i2.!o)+!m+!z)
                          | !arg
                      )
                    & ( IOcomb
                      =   a i o1 o2 m z
                        .     !arg:?a+(?i.?o1)+?m+(!i.?o2)+?z
                            & IOcomb$(!a+(!i.!o1+!o2)+!m+!z)
                          | Ocomb$!arg
                      )
                    & ( IOFeatComb
                      =   F vs
                        .     !arg:(?F,?vs) ?arg
                            & (!F,IOcomb$!vs) IOFeatComb$!arg
                          | 
                      )
                    & ( IOcombine
                      =   Name facets
                        .     !arg:(?Name.?facets)+?arg
                            & (!Name.IOFeatComb$!facets)+IOcombine$!arg
                          | 0
                      )
                    & IOcombine$!thisToolProp:?thisToolProp
                    & ( ~&log$DOEHIERIETS
                      | !thisToolProp+!otherToolprop:?toolprop
                      )
                    & saveToolTable$toolprop
                    & (     !tooladm
                          : ?A+(? (ToolID.!ToolName) ?)+?Z
                        & !A+!Z:?tooladm
                      | 
                      )
                    &     !tooladm
                        + (   (ToolID.!ToolName)
                              (PassWord.!PassWord)
                              (ContactEmail.!ContactEmail)
                              (Version.!ToolVersion)
                              (Title.!FullToolName)
                              (ServiceURL.!ToolURL)
                              (Publisher.!ToolPublisher)
                              (ContentProvider.!ContentProvider)
                              (Creator.!ToolCreator)
                              (InfoAbout.!InfoAbout)
                              (Description.!ToolDescription)
                              (ExternalURI.!ToolExternalURI)
                              (XMLparms.!ToolXMLparms)
                              (PostData.!ToolPostData)
                              (Inactive.!ToolInactive)
                          : ?admdata
                          )
                      : ?tooladm
                    & saveToolTable$tooladm
                    & "O.k."
                  |   str
                    $ ( "You need to be logged in to save or replace an active tool. (handle=\""
                        !handle
                        "\")"
                      )
                  )
            )
          & "Body of Register starts here"
          & log$NEW
          & log$INGESTLOGJE
          & 0:?tabind
          & :?hiddenData:?formFields:?Metadata
          & readTable$facets
          & readTable$toolprop
          & readTable$tooladm
          & readTable$features
          & ( !arg:? (handle.?handle) ?
            | :?handle
            )
          & ( !arg:? (passwordAsHandle.?passwordAsHandle) ?
            | (.):?passwordAsHandle
            )
          & ( !arg:? (mail2.?mail2) ?
            | :?mail2
            )
          & (     createBoilerPlate$!arg
                : (?ToolName.?password.?contactEmail.?arg)
              & staticFields$!arg:?formFields
              &     ( h1
                    .   
                      ,     !ToolName:
                          &   localized
                            $ ("Register a new tool" "Registrer et nyt værktøj")
                        |   localized
                          $ ( "Update tool metadata"
                              "Opdater værktøjsoplysninger"
                            )
                    )
                    !formFields
                : ?formFields
              & "
            Decide in how far the features as received in the request string
            (the arg variable) or the features as defined in toolprop.table
            should be used in the ensuing process (storage as needed and
            creation of the form to be returned to the caller):
            One of the submit buttons pressed or tool not defined in 
            toolprop.table (i.e. tool is not integrated): use info from request
            string.
            Otherwise: use metadata from toolprop.table.
            "
              &   (     !arg
                      :   ?
                          ( bsubmit
                          . @(?:(prev|next) #?nth)
                          )
                          ?
                    & "
                  If user wants to navigate to the next or previous incarnation
                  wind to the requested incarnation of tool and read tools'
                  properties from toolprop.table. ZZ is the part of
                  toolprop.table coming after this incarnation of this tool.
                  This variable is later used to decide whether a 'next' button
                  is needed and also to locate the old version of the
                  incarnation if the user wants to remove or replace it.
                  "
                    &   windfw$(!toolprop.!ToolName.!nth)
                      : (?featjursPreexisting.?ZZ.?nth)
                    &   featureListing
                      $ (unfoldInputAndOutput$!featjursPreexisting)
                  |   !arg:? (nth.?nth) ?
                    & "
                  The cardinal number of the incarnation is known.
                  "
                    &   windfw$(!toolprop.!ToolName.!nth)
                      : (?featjursPreexisting.?ZZ.?nth)
                    & (   !arg:? (bsubmit.?) ?
                        & "
                      User presses one of the 'submit' buttons 
					  (!storeToolButton, !replaceToolButton,
					  !deleteToolButton, !UpdateButton, !PHPbutton).
                      The features as shown in the form should overrule the
                      properties as recorded in toolprop.table for this
                      incarnation of the tool, so ignore the preexisting
                      properties.
                      "
                        & !arg
                      |   featureListing
                        $ (unfoldInputAndOutput$!featjursPreexisting)
                      )
                  |     windfw$(!toolprop.!ToolName.0)
                      : (?featjursPreexisting.?ZZ.?nth)
                    & "
                  The cardinal number of the incarnation is not known.
                  Navigate to the first incarnation of the tool.
                  "
                    &   featureListing
                      $ (unfoldInputAndOutput$!featjursPreexisting)
                  |   -1:?nth
                    & "
                  The tool hasn't any features (yet).
                  "
                    & !arg
                  )
                : ?featjursURL
              & "
            Add 'previous' and 'next' buttons as needed.
            "
              & ( !nth:<0
                |   (   !nth:>0
                      &   !formFields submit$(str$(prev !nth+-1))
                        : ?formFields
                    | 
                    )
                  & (   !ZZ:(!ToolName.?)+?
                      &   !formFields submit$(str$(next !nth+1))
                        : ?formFields
                    | 
                    )
                )
              & !features:?feats
              & "
            Step through the (short) list of features (facet, format, language)
            For each feature, create an input field and collect in the
            formFields variable. The Metadata variable collects the same data
            in a format similar to the format in the toolprop.table.
            "
              &   whl
                ' ( !feats:%?feat+?feats
                  &     askFeature
                      $ (!featjursURL.!feat.!formFields.!Metadata)
                    : (?formFields.?Metadata)
                  )
              & log$foldInputAndOutput
              & foldInputAndOutput$!Metadata:?Metadata
              & (!ToolName.!Metadata):?Metadata
              & (   ( !arg:? (bsubmit.?Submit) ?
                    | :?Submit
                    )
                  & (   !Submit:!PHPbutton
                      & wrapper$(PHP.!ToolName)
                    |     (     !Submit
                              : ( !storeToolButton
                                | !replaceToolButton
                                )
                            & (   validationComments
                                $ ( !ToolName
                                  . !PassWord
                                  . !ToolVersion
                                  . !FullToolName
                                  . !ToolURL
                                  . !ToolPublisher
                                  . !ContentProvider
                                  . !ToolCreator
                                  . !InfoAbout
                                  . !ToolDescription
                                  . !ToolExternalURI
                                  . !ToolXMLparms
                                  . !ToolPostData
                                  . !ToolInactive
                                  . !Submit
                                  )
                              |   storeTool
                                $ ( !Metadata
                                  . !ToolName
                                  . !PassWord:?password
                                  . !ContactEmail:?contactEmail
                                  . !ToolVersion
                                  . !FullToolName
                                  . !ToolURL
                                  . !ToolPublisher
                                  . !ContentProvider
                                  . !ToolCreator
                                  . !InfoAbout
                                  . !ToolDescription
                                  . !ToolExternalURI
                                  . !ToolXMLparms
                                  . !ToolPostData
                                  . !ToolInactive
                                  .     !Submit:!storeToolButton
                                      & -1
                                    | !ZZ
                                  )
                              )
                          |   !Submit:!deleteToolButton
                            & (   !toolprop:?AA+(!ToolName.?)+!ZZ
                                & !AA+!ZZ:?toolprop
                                & saveToolTable$toolprop
                                &   str
                                  $ ( "Deleted current incarnation of tool "
                                      !ToolName
                                    )
                              |     !tooladm
                                  :   ?AA
                                    + (? (ToolID.!ToolName) ?)
                                    + ?ZZ
                                & !AA+!ZZ:?tooladm
                                & saveToolTable$tooladm
                                &   str
                                  $ ( "Deleted administrative metadata of tool "
                                      !ToolName
                                    )
                              )
                          | Updated
                          )
                        : ?error
                      & log$(error !error)
                      &   toML
                        $ ( !HTMLbodyContainer
                          $ ( ( !formFields:
                              |   form
                                $ ( register
                                  .   ( !handle:
                                      | makeHiddenFields$(handle.!handle)
                                      )
                                      !formFields
                                      submit$!storeToolButton
                                      ( !nth:<0&
                                      |   submit$!replaceToolButton
                                          makeHiddenFields$(nth.!nth)
                                      )
                                        makeHiddenFields
                                      $ ( (password.!password)
                                          (   !passwordAsHandle:(.)
                                            & 
                                          | ( passwordAsHandle
                                            . !passwordAsHandle
                                            )
                                          )
                                          ( !mail2:
                                          | (mail2.!mail2)
                                          )
                                          (contactEmail.!contactEmail)
                                        )
                                      submit$!deleteToolButton
                                      submit$!UpdateButton
                                      submit$!PHPbutton
                                  . POST
                                  )
                              )
                              (p.,!error (br.,))
                              (hr.,)
                            )
                          )
                    )
                | str$("unknown button: " !Submit)
                )
            |   !arg:? (name.?ToolName) ?
              &   update
                $ ( (msg."Forkert adgangskode!")
                    (selected.!ToolName)
                    (password.!password)
                    (contactEmail.!contactEmail)
                    (handle.!handle)
                  )
            |   toML
              $ ( !HTMLbodyContainer
                $ ( paragraph
                  $ ( str
                    $ (   localized
                        $ ( "Email address missing."
                            "Der mangler en email-adresse."
                          )
                        " ('mail2' HTTP parameter)"
                      )
                    )
                  )
                )
            )
      )
      "
/*
 * storeUpload
 *
 * Administrate the storage of a copy of a file from repositorium in a place 
 * where a webservice can fetch it - the staging area of the Tools service.
 *
 * Adds an entry to a seven-column table Uploads.table. 
 * The first column is unique number generated by adding 1 to the highest 
 * currently occupied number, second is the resource identifier of a 
 * resource that has been copied to a local place, where a webservice can GET
 * it. This resource identifier points at a resource's metadata, which also 
 * shows the way to the resource itself - the third field. The fourth field 
 * contains the name of the resource as the webservice perceives it. It is
 * a concatenation of a number based on current date and cpu-time and the
 * value in the first field. (If the file is uploaded, the name is the 
 * concatenation of 'Uploaded' and the number in the first field.)
 * The seventh field states whether the resource is public, academic or 
 * restricted.
 * E.g. 
 *      ( 9
 *      . dkclarin:59004
 *      . dkclarin:59004/components/component/dkclarin:59003/content
 *      . 19325730679
 *      . 
 *      .
 *      . public
 *      )
 * The resource identifier is going to be used in the new resource's metadata.
 * The missing fifth and sixth fields are later filled out.
 * If the user provides a file by file upload, the second and third column are the same.
 *
 * Input: 
 *      item id (like dkclarin:59004/components/component/dkclarin:59003/content)
 *      date
 *      fk (optional)
 *
 * Affected tables:
 *      Uploads.table
 *
 * Output:
 *      The local file name of the resource (= fourth field)
 *
 * Called from create.java
 */"
      ( storeUpload
      =   nr item fname visibility date enam txe ext
        .   1:?nr
          &   !arg
            : ( ?arg
              .   (?date.?visibility)
                | ?date&:?visibility
              )
          & (   @(!arg:?item "/components/component/" ?)
              & :?ext
            |   !arg:?item
              & (   @(rev$!item:?txe "." ?enam)
                  & (   @( !txe
                         :   ?
                             ( "/"
                             | "\\"
                             | ":"
                             | " "
                             | "?"
                             | "*"
                             | "["
                             | "]"
                             | ";"
                             | "|"
                             | "="
                             | ","
                             )
                             ?
                         )
                      & :?ext
                    |   rev$!enam:?item
                      & str$("." rev$!txe):?ext
                    )
                | :?ext
                )
            )
          & (readTable$Uploads|:?Uploads)
          & (   !Uploads:(?nr.?) ?
              & !nr+1:?nr
            | :?Uploads
            )
          & str$(removePercentEncodings$!item):?item
          & str$(!item "-" !nr):?fname
          &     str
              $ ( vap
                $ ( ( 
                    =   
                      .       !arg
                            : ( "/"
                              | "\\"
                              | ":"
                              | " "
                              | "?"
                              | "*"
                              | "["
                              | "]"
                              | ";"
                              | "|"
                              | "="
                              | ","
                              | "%"
                              | "&"
                              )
                          & "_"
                        | !arg
                    )
                  . !fname
                  )
                )
            : ?fname
          & !str$(!fname !ext):?fname
          &     (!nr.str$(!item !ext).!arg.!fname...!visibility)
                !Uploads
            : ?Uploads
          & saveTable$Uploads
          & !fname
      )
      " If something went wrong, e.g. an URL that could not be fetched, call unstore. Called from create.java "
      ( unstore
      =   A Z
        .   log$(unstore !arg)
          & readTable$Uploads
          & !Uploads:?A (?.?.?.!arg...) ?Z
          & !A !Z:?Uploads
          & saveTable$Uploads
      )
      ( removePercentEncodings
      =   A g h
        .   @( !arg
             :   ?A
                 "%"
                 ( %@
                 : ( ~<0:~>9
                   | ~<a:~>f
                   | ~<A:~>F
                   )
                 : ?g
                 )
                 ( %@
                 : ( ~<0:~>9
                   | ~<a:~>f
                   | ~<A:~>F
                   )
                 : ?h
                 )
                 ?arg
             )
          & !A chr$(x2d$(str$(!g !h))) removePercentEncodings$!arg
      )
      ( percentEncodeURL
      =   pEU
        .   ( pEU
            =   A h
              .   @(!arg:?A (%@:>"~":?h) ?arg)
                & d2x$(asc$!h):?h
                & !A "%" upp$!h pEU$!arg
            )
          & str$(pEU$!arg)
      )
      ( element
      =   name attr content
        .   !arg:(?name.?attr.?content)
          & \r\n (!name.atts$!attr,\r\n !content \r\n) \r\n
      )
      ( Field
      =   name content col A M N Z
        .   !arg:(?name.?.?content)
          & (     !content
                : ( ? (input.?) ?
                  | ? (fieldset.?) ?
                  | ? (span.?) ?
                  )
              & 255+-10*!indent:?col
              & ( fieldset
                .   ( style
                    .   "background-color:rgb("
                        255+-30*!indent
                        ","
                        255+-10*!indent
                        ","
                        255
                        ")"
                    )
                  , (legend.,!name) !content
                )
            | (span.,\r\n !content) \r\n
            )
      )
      ( select
      =   car cdr a z writeList
        .     ( writeList
              =   pat a z el
                .   !arg:(?pat.?el.?arg)
                  & (   !arg:!pat
                      &   element$(!el..select$!a)
                          writeList$(!pat.!el.!z)
                    | element$(!el..select$!arg)
                    )
              )
            & !arg:%+%
            & writeList$(%?a+%?z.or.!arg)
          | !arg:%*%&writeList$(%?a*%?z.and.!arg)
          |   !arg:%?car %?cdr
            & " " select$!car " " element$(opt..select$!cdr)
          |   !arg:%?car^%?cdr
            & NEWSPEC
            & " " select$!car " " element$(spec..select$!cdr)
          | !arg:(0|1)&
          | !arg
      )
      ( XMLdeclaration
      = ("?"."xml version=\"1.0\" encoding=\"UTF-8\"") \r\n
      )
      ( shared
      =   gspc isp ispc ispcs
        .   !arg:(?gspc.?ispcs)
          & 0:?ispc
          & NEWSPEC
          & (   !gspc+!ispcs
              :   ?
                + ( 2*%@?isp+?
                  & !isp+!ispc:?ispc
                  & ~
                  )
            | !ispc:~0
            | 1
            )
      )
      ( unify
      =     source goal gfield gvalue gopt sopt
          , A Z other gspc sspc gvalues svalues
          , uni R zgvalue asvalue zsvalue tail
        .   !arg:(?source.?goal)
          & ( !goal:&!source
            |   !goal:(?gfield,?gvalues) ?goal
              & (   ~(!source:? (!gfield,?) ?)
                  & unify$(!source.!goal):?other
                  & (!gfield,!gvalues) !other
                |   !source:?A (!gfield,?svalues) ?Z
                  & NEWSPEC
                  &   !gvalues
                    :     ?
                        + ( %(`%?gvalue^?gspc ?gopt)*?zgvalue
                          &   !svalues
                            :   ?
                              +   ?asvalue
                                * (!gvalue^?sspc ?sopt)
                                * ( ?zsvalue
                                  & ( !gopt:!sopt
                                    | !gopt:
                                    | !sopt:
                                    )
                                  & ( !gspc:1
                                    | !sspc:1
                                    |   shared$(!gspc.!sspc)
                                      : ~1
                                      : ?sspc
                                    )
                                  & ( uni
                                    =     ss gs g gp go
                                        , a sp so z tail
                                      .     !arg:(?ss.?gs)
                                          &   1
                                            : (!ss|!gs)
                                        |   !gs:%(%?g^?gp ?go)*?gs
                                          & NEWSPEC
                                          & (   ~(!ss:?*(!g^? ?)*?)
                                              & uni$(!ss.!gs):?tail
                                              & !g*!tail
                                            |     !ss
                                                : ?a*(!g^?sp ?so)*?z
                                              & ( !go:!so
                                                | !go:
                                                | !so:
                                                )
                                              & ( !gp:1
                                                | !sp:1
                                                |   shared$(!gp.!sp)
                                                  : ~1
                                                  : ?sp
                                                )
                                              &   uni$(!a*!z.!gs)
                                                : ?tail
                                              & (!g^!sp !so)*!tail
                                            )
                                    )
                                  &   uni$(!asvalue*!zsvalue.!zgvalue)
                                    : ?tail
                                  & NEWSPEC
                                  & (!gvalue^!sspc !sopt)*!tail:?R
                                  &   unify$(!A !Z.!goal)
                                    : ?other
                                  )
                              + ?
                          )
                        + ?
                        ?
                  & (!gfield,!R) !other
                )
            )
      )
      ( fold
      =   A M Z B a f v1 v2 z
        .       !arg
              :   ?A
                * ( `%?B*?Z
                  &   !B
                    :   ?a
                        (?f,?v1)
                        ( ?z
                        & !Z:?M*(!a (!f,?v2) !z)*?Z
                        )
                  )
            & fold$(!A*(!a (!f,!v1*!v2) !z)*!M*!Z)
          |     !arg
              : ?A*(?a (?f,?v1) ?M (!f,?v2) ?z)*?Z
            & fold$(!A*(!a (!f,!v1*!v2) !M !z)*!Z)
          | !arg
      )
      ( supplyMissingFields
      =     features x outfeat infeat childfeaturevalue
          , childfeaturevalues featurename featurevalue
          , nfeatures xs v getChildVal cleanExponent cleanSum
        .     !arg:(?outfeat.?infeat.?features)
            & :?nfeatures
            &   whl
              ' (   !features
                  : (?featurename,?featurevalue) ?features
                & ( !outfeat:? (!featurename,?) ?
                  |     !nfeatures
                        ( !featurename
                        ,   ( cleanSum
                            =   A M Z
                              .   (   !arg:#%+?arg
                                    & cleanSum$!arg
                                  |   !arg:?A+#%*?M+?Z
                                    & cleanSum$(!A+!M+!Z)
                                  )
                                | !arg
                            )
                          & ( cleanExponent
                            =   E n
                              .     !arg:%?n^%?E
                                  & NEWSPEC
                                  & !n^cleanSum$!E
                                | !arg
                            )
                          & ( getChildVal
                            =   val A v
                              .     !arg:(?val.?arg)
                                  & !arg:((?A.?)|?A)
                                  & fold$!A:?A
                                  & !A:? (!val,?v) ?
                                  & !v
                                | 0
                            )
                          &   getChildVal$(!featurename.!infeat)
                            : ?childfeaturevalues
                          & 0:?xs
                          &   whl
                            ' (   !childfeaturevalues
                                : %?childfeaturevalue^?+?childfeaturevalues
                              &   !featurevalue
                                :   ?
                                  + (?+!childfeaturevalue^?+? ?.?x)
                                  + ?
                              & ( !xs:?+!x+?
                                | !x+!xs:?xs
                                )
                              )
                          & !xs
                        )
                    : ?nfeatures
                  )
                )
            &   whl
              ' ( !nfeatures:?x (?,) ?xs
                & !x !xs:?nfeatures
                )
            & !nfeatures
          | !outfeat
      )
      ( differentOutput
      =     fields otherPath otherPaths otherFields
          , same other A Z apathfld apathflds
        .   !arg:(?fields.?otherPaths)
          & 0:?same:?other
          &   whl
            ' (   !otherPaths
                : ((?,(?otherFields.?)):?otherPath)+?otherPaths
              & !fields:?apathflds
              &   whl
                ' ( !apathflds:%?apathfld ?apathflds
                  & !otherFields:?A !apathfld ?Z
                  & !A !Z:?otherFields
                  )
              & (   !apathflds:
                  & !otherFields:
                  & !same+!otherPath:?same
                | !other+!otherPath:?other
                )
              )
          & !other:~0
          & (!same.!other)
      )
      ( unfoldIfDivertingOutputs
      =     tool ou apath A Z fields
          , pathsWithSameOutputAsApath pathsWithOtherOutputAsApath
          , goal inputprop
        .       !arg
              : ( ?tool
                , (?ou.?inputprop.((?,(?fields.?)):?apath)+?Z)
                )
            &   differentOutput$(!fields.!Z)
              : (?pathsWithSameOutputAsApath.?pathsWithOtherOutputAsApath)
            &   (!tool,(!ou.!inputprop.!apath+!pathsWithSameOutputAsApath))
              +   unfoldIfDivertingOutputs
                $ (!tool,(!ou.!inputprop.!pathsWithOtherOutputAsApath))
          |   !arg:(?goal.%?A+%?Z)
            &   (!goal.unfoldIfDivertingOutputs$!A)
              + (!goal.unfoldIfDivertingOutputs$!Z)
          | !arg
      )
      ( nofoldCount
      =   tool ou inputprop childstuff A Z goal inputprop
        .     !arg:%?A*%?Z
            & nofoldCount$!A*nofoldCount$!Z
          |   !arg:%?A+%?Z
            & nofoldCount$!A+nofoldCount$!Z
          |   !arg:(?goal.?childstuff)
            & nofoldCount$!childstuff
          |   !arg:(?tool,(?ou.?inputprop.?childstuff))
            & nofoldCount$!childstuff:?childstuff
          | 1
      )
      ( unfoldCount
      =     tool ou ou2 inputprop childstuff A Z goal
          , inputprop feature
        .     !arg:%?A*%?Z
            & unfoldCount$!A*unfoldCount$!Z
          |   !arg:%?A+%?Z
            & unfoldCount$!A+unfoldCount$!Z
          |   !arg:(?goal.?childstuff)
            & unfoldCount$!childstuff
          |     !arg
              : ( ?tool
                , ( ?A (?feature,%?ou+%?ou2) ?Z
                  . ?inputprop
                  . ?childstuff
                  )
                )
            &     unfoldCount
                $ ( !tool
                  , ( !A (!feature,!ou) !Z
                    . !inputprop
                    . !childstuff
                    )
                  )
              +   unfoldCount
                $ ( !tool
                  , ( !A (!feature,!ou2) !Z
                    . !inputprop
                    . !childstuff
                    )
                  )
          |   !arg:(?tool,(?ou.?inputprop.?childstuff))
            & unfoldCount$!childstuff:?childstuff
          | 1
      )
      ( graphCount
      =   ou parent siblings child A seen ret sibl
        .   !arg:(?parent.?siblings.?child)
          & (   !child:%*%:?seen
              & 1:?sibl
              &   whl
                ' ( !child:%?A*?arg
                  &   graphCount$(!parent !seen.!sibl.!A)
                    : (?sibl.?ret)
                  )
              & !seen
            |   !arg:%+%:?seen
              & 0:?ret
              &   whl
                ' ( !arg:%?A+?arg
                  & !ret+(!seen.!A.graphCount$!A):?ret
                  )
              & !ret
            | !arg:(?.?child)&graphCount$!child
            |   !arg:(?,(?ou.?.?child))
              & graphCount$!child:?seen
              & ( 
                |   whl
                  ' ( !ou:? ((?,%+%):?A) ?ou
                    & !seen*!A:?seen
                    )
                )
              & !seen
            | 1
            )
      )
      ( leaveFeat
      =   A
        .     !arg:%?A*%?arg
            & leaveFeat$!A*leaveFeat$!arg
          | !arg:(?,(?.?.?.?arg))&leaveFeat$!arg
          | !arg:(?,(?.?.?arg))&!arg
          |   !arg:(?.(?,?):?arg)
            & leaveFeat$!arg
          | !arg:(@,?) ?
      )
      ( subtract
      =   all org
        .   !arg:(?all.?org)
          &   map
            $ ( ( 
                =   f
                  .   !arg:(?f,?)
                    & ( !org:? (!f,?) ?&
                      | !arg
                      )
                )
              . !all
              )
      )
      ( compatibleFeatureSets
      =   A B C D F V
        .   ~(!arg:%*%)
          |   1:?B
            &   whl
              ' ( !arg:((?,?) ?:?A)^?*?arg
                & subtract$(!A.!sources)*!B:?B
                )
            & ~( !B
               :   %?C
                 * ( %?D
                   &   !C
                     :   ?
                         ( ?F
                         ,   ?V
                           & !D:?*(? (!F,~!V) ?)*?
                         )
                         ?
                   )
               )
      )
      ( selectCommonTracks
      =   sum spotSum eliminate OUT WAY TERM result term M
        .   ( spotSum
            =   a sum
              .     !arg:%*%
                  & (   !arg:?*(?,(?.?.?.%+%:?sum))*?
                      & !sum
                    |   !arg:%?a*%?arg
                      & (spotSum$!a|spotSum$!arg)
                    )
                | !arg:%+%:?sum&!sum
                |   !arg:(?,(?.?.?.?arg))
                  & spotSum$!arg
            )
          & ( eliminate
            =   term O R T o i W S J P F D s
              .   !arg:(?arg.?term)
                & (   !arg:(?O.?W)
                    & ( !O
                      .     !W:%*%:?S
                          & 1:?R
                          &   whl
                            ' ( !S:%?s*?S
                              &     !R
                                  * (   !s:(?T,(?o.?i.?J))
                                      & (!T,(!o.!i.eliminate$(!J.!term)))
                                    | !s
                                    )
                                : ?R
                              )
                          & !R
                        |   !W:%+%
                          & ( !W:?+!term+?&!term
                            |   !W:?S
                              & 0:?R
                              &   whl
                                ' ( !S:%?P+?S
                                  & 1:?D
                                  &   whl
                                    ' ( !P:%?F*?P
                                      &     !D
                                          * (   !F:(?T,(?o.?i.?J))
                                              & ( !T
                                                , ( !o
                                                  . !i
                                                  . eliminate$(!J.!term)
                                                  )
                                                )
                                            | !F
                                            )
                                        : ?D
                                      )
                                  & !R+!D:?R
                                  )
                              & !R
                            )
                        |   !W:(?T,(?o.?i.?J))
                          & (!T,(!o.!i.eliminate$(!J.!term)))
                        | !W
                      )
                  | !arg
                  )
            )
          & 0:?result
          &   whl
            ' ( !arg:#*(?OUT.?WAY)+?arg
              & (   spotSum$!WAY:?sum
                  & 0:?TERM
                  &   whl
                    ' ( !sum:%?term+?sum
                      &   !TERM+eliminate$((!OUT.!WAY).!term)
                        : ?TERM
                      )
                  & !TERM+!arg:?arg
                | !result+(!OUT.!WAY):?result
                )
              )
          & !result
      )
      ( unfoldTree
      =     tool ou ou2 inputprop childstuff A Z goal b
          , inputprop feature stop a ret As stp z sp
          , projectOnto rt af bf
        .   "Returns sum. Each term is a dot separated structure:
                 (<stop list> . <user provided output specs> . <sum of unambiguous trees>)
             The stop list is a product of (<key>.<value>) pairs, where the key is an (ambiguous) tree and the value
             is a disambiguated solution. The stop list is passed down to the leafs and also up again as part of the
             return value. In that way some consistency is assured and many inviable solutions are never attempted.
             The ambiguities (declared as terms in sums) in the original tree can be in feature values and in tool choices.
             
             The argument consists of a product of already found unfoldings and the (sub)tree to unfold, separated by a dot.
             Each factor in the product of already found unfoldings consists of the tree to unfold (the key) and the tree
             it was unfolded to (the value). Factors can have an exponent.
             
             Expects that the variable 'sources' is a list of input feature/value pairs. 
             (A single pair can contain more than one value. That is the case if there are more than one inputs.)"
          & !arg:(?stop.?arg)
          & 1+!calls:?calls:<56789
          & ( @(!calls:? 000)&log$(calls !calls)
            | 
            )
          & (   !arg:%?A*%?arg
              & "Multiply each term in unfolded first factor with each term in unfolded remaining factors."
              & 0:?ret
              & unfoldTree$(!stop.!A):(?stp.?a)
              & unfoldTree$(!stop*!stp.!arg):(?sp.?b)
              & leaveFeat$!a:?af^?
              & leaveFeat$!b:?bf^?
              & (   compatibleFeatureSets$(!af*!bf)
                  & !ret+(!sp.!a*!b):?ret
                | log$(NOTCOMPATIBLE !af AND !bf)
                )
              & !ret
            |   !calls:<56789
              & !arg:%+%
              & LOG$SUMDETECTED
              & (   !stop:?*(!arg.?projectOnto)^?*?
                  & "This removes perhaps some solutions that assume incompatible input specs."
                  & (!stop.!projectOnto)
                |   0:?ret
                  & !arg:?As
                  &   whl
                    ' ( !As:%?A+?As
                      & unfoldTree$(!stop.!A):?Z
                      & !calls:<56789
                      &   whl
                        ' ( !Z:(?stp.?a)+?Z
                          & !ret+((!arg.!a)*!stop.!a):?ret
                          )
                      )
                  & !ret
                )
            |   !calls:<56789
              & !arg:(?goal.?childstuff)
              & unfoldTree$(!stop.!childstuff):?Z
              & !calls:<56789
              & 0:?ret
              &   whl
                ' ( !Z:(?stp.?A)+?Z
                  & !ret+(!stp.!goal.!A):?ret
                  )
              & !ret
            |   !calls:<56789
              &   !arg
                : ( ?tool
                  , ( ?A (?feature,%+%:?ou) ?Z
                    . ?inputprop
                    . ?childstuff
                    )
                  )
              & (   !stop:?*(!ou.?projectOnto)*?
                  &   unfoldTree
                    $ ( !stop
                      .   !tool
                        , ( !A (!feature,!projectOnto) !Z
                          . !inputprop
                          . !childstuff
                          )
                      )
                |   !calls:<56789
                  & !ou:?ou2
                  & 0:?ret
                  &   whl
                    ' ( !ou2:%?a+?ou2
                      &     unfoldTree
                          $ ( !stop*(!ou.!a)
                            .   !tool
                              , ( !A (!feature,!a) !Z
                                . !inputprop
                                . !childstuff
                                )
                            )
                        : ?rt
                      & !ret+!rt:?ret
                      )
                  & !calls:<56789
                  & !ret
                )
            |   !calls:<56789
              & !arg:(?tool,(?ou.?inputprop.?childstuff))
              & unfoldTree$(!stop.!childstuff):?Z
              & 0:?ret
              &   whl
                ' ( !Z:(?stp.?A)+?Z
                  & !ret+(!stp.!tool,(!ou.!inputprop.!A)):?ret
                  )
              & !ret
            | !calls:<56789&(!stop.!arg)
            )
      )
      ( createNewGoal
      =   toolFeatures rfield rvals rins rin newGoal RI
        .   !arg:(?newGoal.?toolFeatures)
          &   whl
            ' ( !toolFeatures:(?rfield,?rvals) ?toolFeatures
              & 0:?rins
              &   whl
                ' ( !rvals:(?rin.?)+?rvals
                  &   whl
                    ' ( !rin:%?RI+?rin
                      & ( !rins:?+!RI+?
                        | !RI+!rins:?rins
                        )
                      )
                  )
              & (!rfield,!rins) !newGoal:?newGoal
              )
          & !newGoal
      )
      (NA=|"?"|0)
      ( product
      =   a
        .   !arg:%?a %?arg&!a*product$!arg
          | !arg
      )
      ( sort
      =   S L e
        .   0:?S
          & whl'(!arg:%?e ?arg&!e+!S:?S)
          & :?L
          & whl'(!S:%?e+?S&!L !e:?L)
          & !L
      )
      ( set
      =   S L e
        .   0:?S
          &   whl
            ' ( !arg:%?e ?arg
              & (!S:?+!e+?|!e+!S:?S)
              )
          & :?L
          & whl'(!S:%?e+?S&!L !e:?L)
          & !L
      )
      ( matchGoalWithFeatures
      =     goal toolFeatures
          , newGoal pathfields gfield gvaluesAlts ngoal
          , Ar Zr gvaluePoss gspc ispc
          , input A Z oinput gval gvalspc done
        .   !arg:(?goal.?toolFeatures)
          & :?newGoal
          & :?pathfields
          &   whl
            ' ( !goal:(?gfield,%?gvaluesAlts) ?ngoal
              & (   ~(!toolFeatures:? (!gfield,?) ?)
                  & "Assume that tool leaves field unchanged: percolate output requirement to input."
                  & !pathfields (!gfield,!gvaluesAlts):?pathfields
                  & !newGoal (!gfield,!gvaluesAlts):?newGoal
                |   !gvaluesAlts
                  :   ?
                    + ( %@?gvaluePoss^?gspc
                      & NEWSPEC
                      &   !toolFeatures
                        :   ?Ar
                            ( !gfield&0:?done
                            ,     ?
                                + ( ( ?input
                                    .   !NA&1:?ispc
                                      |   ?
                                        +   ?
                                          *   !gvaluePoss
                                            ^ (   ~1:?ispc
                                                & NEWSPEC
                                                &   shared$(!gspc.!ispc)
                                                  : ( ~1:?ispc
                                                    |   ?
                                                      & !gspc:1
                                                    )
                                              |   ?ispc
                                                : ( 1
                                                  |   ?
                                                    & !gspc:1
                                                  )
                                              )
                                          * ?
                                        + ?
                                    )
                                  &   (     !pathfields
                                          : ?A (!gfield,?gval) ?Z
                                        &   !A
                                            ( !gfield
                                            ,       !gval
                                                  : !gvaluePoss^?gvalspc
                                                & NEWSPEC
                                                &   !gvaluePoss
                                                  ^ ( !gvalspc:!ispc
                                                    | !gvalspc+!ispc
                                                    )
                                              | !gval+!gvaluePoss^!ispc
                                            )
                                            !Z
                                      |   !pathfields
                                          (!gfield,!gvaluePoss^!ispc)
                                      )
                                    : ?pathfields
                                  &   ( !input:!NA
                                      |     !newGoal
                                          : ?A (!gfield,?oinput) ?Z
                                        &   !A
                                            (!gfield,!oinput+!input)
                                            !Z
                                      | !newGoal (!gfield,!input)
                                      )
                                    : ?newGoal
                                  & 1+!done:?done
                                  & `~
                                  )
                                + ?
                              | ?&!done:>0
                            )
                            ?Zr
                      & !Ar !Zr:?toolFeatures
                      )
                    + ?
                )
              & !ngoal:?goal
              )
          & !goal:
          & createNewGoal$(!newGoal.!toolFeatures):?newGoal
          & (!pathfields.sort$!newGoal)
      )
      "
/**
 * Check that pipes having multiple tasks running in parallel have compatible features and feature specialisations.
 */"
      ( illegalSolution
      =     goal pipes toolA toolB outputA outputB inputA inputB
          , vA featA vB agree explicitlySanctioned
          , WRONGPIPES OKPIPES pipe
        .   !arg:(?goal.?pipes)
          & ( agree
            =   a ea b eb E
              .   !arg:(%?a^?ea.%?b^?eb)
                & !a:!b
                & NEWSPEC
                & ( !ea:1
                  | !eb:1
                  | !ea:?+(%@?E&!eb:?+!E+?)+?
                  )
            )
          & ( explicitlySanctioned
            =   feat v goal v2
              .   !arg:(?feat,?v.?goal)
                &   !goal
                  :   ?
                    * ( ?
                        (!feat,?v2&agree$(!v.!v2))
                        ?
                      )
                    * ?
            )
          & 0:?OKPIPES
          & 0:?WRONGPIPES
          &   whl
            ' ( !pipes:%?pipe+?pipes
              & (     !pipe
                    :   ?
                      * (?toolA,(?outputA.?inputA.?))
                      * ?
                      * ( ?toolB
                        ,   (?outputB.?inputB)
                          &   !outputA
                            :   ?
                                ( ?featA
                                ,   ?vA
                                  & !outputB:? (!featA,?vB) ?
                                  & ~(agree$(!vA.!vB))
                                  & ( ~( explicitlySanctioned
                                       $ (!featA,!vA.!goal)
                                       )
                                    | ~( explicitlySanctioned
                                       $ (!featA,!vB.!goal)
                                       )
                                    )
                                )
                                ?
                        )
                      * ?
                  &     ( !featA vA !vA vB !vB outputB !outputB
                        . !pipe
                        )
                      + !WRONGPIPES
                    : ?WRONGPIPES
                | !pipe+!OKPIPES:?OKPIPES
                )
              )
          & !WRONGPIPES:~0
          & (!WRONGPIPES.!OKPIPES)
      )
      ( removeUnspecifiedFeatures
      =   AA
        .     !arg:?AA (?,0|(!NA.!NA)) ?arg
            & !AA removeUnspecifiedFeatures$!arg
          | !arg
      )
      ( refold
      =     A M Z AM MM ZM AZ MZ ZZ ag zg feat
          , val valZ feats featsZ tool g gZ substitute
          , ZMM
        .   ( substitute
            =   a b s d
              .   !arg:(?arg.?s.?d)
                & ( !arg:!s&!d
                  |   !arg:?a_?b
                    & (substitute$(!a.!s.!d))_(substitute$(!b.!s.!d))
                  | !arg
                  )
            )
          &   whl
            ' (   !arg
                :   ?A
                  + `%?M
                  + ( ?Z
                    &   !Z
                      :   ?AZ
                        + ( `%?MZ
                          &   !M
                            :   ?AM
                              * `%?MM
                              * ( ?ZM
                                & !MZ:!AM*?ZMM*!ZM
                                & !MM:~!ZMM
                                & !MM:(?g.?tool,?feats)
                                & !ZMM:(?gZ.!tool,?featsZ)
                                &   !g
                                  :   ?ag
                                      (?feat,?val)
                                      ( ?zg
                                      &   !gZ
                                        : !ag (!feat,?valZ) !zg
                                      & !val:~!valZ
                                      &     substitute
                                          $ (!feats.!feat,!val.)
                                        :   substitute
                                          $ (!featsZ.!feat,!valZ.)
                                      )
                                )
                          )
                        + ?ZZ
                    )
              &     !A
                  +   !AM
                    *   substitute
                      $ (!MM.!feat,!val.!feat,!val+!valZ)
                    * !ZM
                  + !AZ
                  + !ZZ
                : ?arg
              )
          & !arg
      )
      "20111024 collect worked only if the first argument was output from a 
       previous step, not if it was the very first input."
      ( collect
      =     f v outp a featprod alts opts partOf V remainder
          , actualOptions A Z common partOfFunc vs strictPartOf
        .   !arg:(?arg.?f,?v.?vs)
          & ( partOf
            =   a z S Z spc
              .   !arg:(1.?a)&!a
                |     !arg
                    : ( %@?S^?spc*?Z
                      .   ?a
                        * `( !S
                           ^ ( !spc
                             | ?&1:!spc
                             | 1
                             )
                           )
                        * ?z
                      )
                  & partOf$(!Z.!a*!z)
            )
          & ( strictPartOf
            =   a z S Z
              .   !arg:(1.?a)&!a
                |   !arg:(%?S*?Z.?a*`!S*?z)
                  & strictPartOf$(!Z.!a*!z)
            )
          & (     fct$!vs
                :   ?
                  * %(%?V+!V^%&!v:? ?*!V^?*? ?)
                  * ?
              & '$strictPartOf:(=?partOfFunc)
            | '$partOf:(=?partOfFunc)
            )
          & ( actualOptions
            =   a z S Z spc spc2
              .   !arg:(1.?)&1
                |   !arg:(%@?S^?spc*?Z.?z)
                  & NEWSPEC
                  & (     !z
                        :   ?a
                            `( !S
                             ^ ( !spc
                               | ?spc2&1:!spc
                               )
                             )
                            ?z
                      & !S^!spc2*actualOptions$(!Z.!a !z)
                    | actualOptions$(!Z.!z)
                    )
            )
          & 0:?outp
          & (!v:%?v %?opts|1:?opts)
          & !arg:?alts
          &   whl
            ' ( !alts:%?a+?alts
              & (   !a:(?featprod.?)*?
                  & (     fold$!featprod
                        :   ?
                          * ( ?
                              ( !f
                              ,   ?
                                + ( `%?V
                                  & partOfFunc$(!v.!V):?remainder
                                  & partOf$(!remainder.!opts)
                                  )
                                + ?
                              )
                              ?
                            )
                          * ?
                      & !a+!outp:?outp
                    | 
                    )
                |   !a:?featprod
                  & (     fold$!featprod
                        :   ?A
                            ( !f
                            ,   ?V
                              & partOf$(!v.!V):?remainder
                              &   !v*actualOptions$(!remainder.!opts)
                                : ?common
                            )
                            ?Z
                      & (!A (!f,!common) !Z)+!outp:?outp
                    | 
                    )
                | !a+!outp:?outp
                )
              )
          & !outp
      )
      ( distribute
      =     Res prop input a f vs z aa v
          , incarnationInput
        .   !arg:(?prop.?input)
          & (   !prop:?a (?f,%+%:?vs) ?z
              & 0:?Res
              & !vs:?aa
              &   whl
                ' ( !aa:`%?v+?aa
                  &   collect$(!input.!f,!v.!vs)
                    : ?incarnationInput
                  &     ( !incarnationInput:0
                        |   distribute
                          $ (!a (!f,!v) !z.!incarnationInput)
                        )
                      + !Res
                    : ?Res
                  )
              & !Res
            | !arg
            )
      )
      (assert=.!arg)
      ( restrictOutputParms
      =     pathh toolFeatures outp tool ou prop in nou
          , v e es A f a b Z
        .   !arg:(?pathh.?toolFeatures)
          &   whl
            ' ( !pathh:(?tool,(?ou.?prop.?in))+?pathh
              &     map
                  $ ( ( 
                      =   f vs val nvs i v e
                        .       !arg
                              : ( ?f
                                ,   ( %+%:?vs
                                    |   ?v^(%+%:?es)
                                      & 0:?vs
                                      &   whl
                                        ' ( !es:%?e+?es
                                          & !v^!e+!vs:?vs
                                          )
                                    )
                                  &   !toolFeatures
                                    : ? (!f,?val) ?
                                )
                            & 0:?nvs
                            &   whl
                              ' ( !vs:%?v^?e+?vs
                                & (     !val
                                      : ( 0
                                        |   ?
                                          + ( (?i.?+?*!v^(?+!e+?)*?+?)
                                            &   !prop
                                              :   ?
                                                  (!f,?+?*!i^?*?+?)
                                                  ?
                                            )
                                          + ?
                                        )
                                    & !nvs+!v^!e:?nvs
                                  | 
                                  )
                                )
                            & (!f,!nvs)
                          | !arg
                      )
                    . !ou
                    )
                : ?nou
              & :?outp
              &   whl
                ' ( !nou:?A (?f,%?a+%?b) ?Z
                  &     !outp
                        (!tool,(!A (!f,!a) !Z.!prop.!in))
                    : ?outp
                  & !A (!f,!b) !Z:?nou
                  )
              & !outp (!tool,(!nou.!prop.!in)):?outp
              )
          & !outp
      )
      ( fp
      =     tool source goal restriction superset
          , fulfil memoizedSteps activeTools
          , isfulfilled hasfulfilled fulfilGoalProduct unfoldGoal
          , getActiveTools getGoals getImplicatedGoals
        .   ( isfulfilled
            =   source src goal gl tool pipe pipes
              .   !arg:(?source.?goal.?tool)
                & product$!source:?src
                & product$!goal:?gl
                & 0:?pipes
                & (   !memoizedSteps
                    :   ?
                      + ( !src
                        . !gl
                        .   ?
                          + ( (!tool,?):?pipe
                            & !pipe+!pipes:?pipes
                            & ~
                            )
                          + ?
                        )
                      + ?
                  | !pipes:~0&(!source.!goal.!pipes)
                  )
            )
          & ( hasfulfilled
            =   source src goal gl term a b m,pipe
              .   !arg:(?source.?goal.?pipe)
                &   ( product$!source:?src
                    . product$!goal:?gl
                    . !pipe
                    )
                  : ?term
                & ( !memoizedSteps:?+!term+?
                  |   !memoizedSteps:?a+(!src.!gl.?m)+?b
                    & ( !m:?+!pipe+?
                      | !a+(!src.!gl.!m+!pipe)+!b:?memoizedSteps
                      )
                  | !term+!memoizedSteps:?memoizedSteps
                  )
                & !arg
            )
          & ( fulfilGoalProduct
            =     goalterm tools forkk goaly
                , toolspath tool ltools path1
                , toolFeatures pathh pathfields newGoal infeat
                , GL feat val memopaths restriction
                , goal source I IO O Os
              .   "Check whether source and goal already have been connected by tool and stored as a step."
                & !arg:(?source.?goalterm.?tools.?restriction)
                & 1:?forkk
                &   whl
                  ' ( !goalterm:%?goaly*?goalterm
                    &     (       map
                                $ ( ( 
                                    =   feat val sp SP
                                      .     !arg:(?feat,?val^?sp)
                                          & ( ~( !source
                                               : ? (!feat,?) ?
                                               )
                                            |     !source
                                                :   ?
                                                    ( !feat
                                                    , ?+?*!val^?SP*?+? ?
                                                    )
                                                    ?
                                              & ( !SP:1
                                                |   !sp
                                                  : ( 1
                                                    | ?+!SP+?
                                                    )
                                                )
                                            )
                                          & 
                                        | !arg
                                    )
                                  . !goaly
                                  )
                              : 
                            & !source
                          |     (!restriction:~0|!tools)
                              : ?ltools
                            & 0:?toolspath
                            &   whl
                              ' ( !forkk:~0
                                & !ltools:(?tool.?)+?
                                & (     isfulfilled$(!source.!goaly.!tool)
                                      : (?source.?goal.?memopaths)
                                    &   whl
                                      ' (!ltools:(!tool.?)+?ltools)
                                    &     denumerizeSum
                                        $ (!toolspath+!memopaths)
                                      : ?toolspath
                                  |   0:?memopaths
                                    &   whl
                                      ' (   !ltools
                                          : (!tool.?toolFeatures)+?ltools
                                        & (       removeUnspecifiedFeatures
                                                $ !toolFeatures
                                              : ?toolFeatures
                                            & !toolFeatures:
                                          |       matchGoalWithFeatures
                                                $ (!goaly.!toolFeatures)
                                              : (?pathfields.?newGoal)
                                            & (       fulfil
                                                    $ ( !tools
                                                      . !source
                                                      . !newGoal
                                                      . !indent+1
                                                      . 0
                                                      )
                                                  : ?pathh
                                                &   removeNumFactors$!pathh
                                                  : ?infeat
                                                &     distribute
                                                    $ (!newGoal.!infeat)
                                                  : ?IO
                                                & 0:?memopaths
                                                &   whl
                                                  ' (   !IO
                                                      : (?I.?Os)+?IO
                                                    &   whl
                                                      ' ( !Os:%?O+?Os
                                                        &   ( !tool
                                                            , (   sort
                                                                $ ( !pathfields
                                                                      supplyMissingFields
                                                                    $ ( !pathfields
                                                                      . !O
                                                                      . !toolFeatures
                                                                      )
                                                                  )
                                                              . !I
                                                              . !O
                                                              )
                                                            )
                                                          : ?pathh
                                                        & (   assert
                                                            ' ( !pathh
                                                              : ~( ?
                                                                 + ( ?
                                                                   , (   ?
                                                                         ( ?
                                                                         ,     %
                                                                             + %
                                                                           |   %
                                                                             ^ ( %
                                                                               + %
                                                                               )
                                                                         )
                                                                         ?
                                                                     . ?
                                                                     . ?
                                                                     )
                                                                   )
                                                                 + ?
                                                                 )
                                                              )
                                                          |     restrictOutputParms
                                                              $ ( !pathh
                                                                . !toolFeatures
                                                                )
                                                            : ?pathh
                                                          )
                                                        &   whl
                                                          ' (   !pathh
                                                              : %?path1 ?pathh
                                                            & (   !toolspath
                                                                : ?+!path1+?
                                                              |       !toolspath
                                                                    + !path1
                                                                  : ?toolspath
                                                                &     !memopaths
                                                                    + !path1
                                                                  : ?memopaths
                                                              )
                                                            )
                                                        )
                                                    )
                                                &   hasfulfilled
                                                  $ ( !source
                                                    . !pathfields
                                                    . !memopaths
                                                    )
                                                & ( !goaly:!pathfields
                                                  |   hasfulfilled
                                                    $ ( !source
                                                      . !goaly
                                                      . !memopaths
                                                      )
                                                  )
                                              | 0:?pathh
                                              )
                                          | FAIL
                                          )
                                        )
                                  )
                                )
                            & "forkk will become zero if no tools can fulfil goaly!"
                            & !toolspath
                          | 1:?goalterm&0
                          )
                        * !forkk
                      : ?forkk
                    )
                & 1+!forkk+-1
            )
          & " unfoldGoal:
              Construct all 2^n combinations of n options,
              and unfold all alternatives.
              Output: a list of disambiguated goals."
          & ( unfoldGoal
            =     A Z AA ZZ AAA ZZZ M1 M2
                , gfield gopts convertOptionsToAlternatives
              .   ( convertOptionsToAlternatives
                  =   gopt gopts gvaluesAlts
                    .   !arg:%?gvaluesAlts ?gopts
                      &   whl
                        ' ( !gopts:%?gopt ?gopts
                          &   !gvaluesAlts+!gvaluesAlts*!gopt
                            : ?gvaluesAlts
                          )
                      & !gvaluesAlts
                  )
                &   whl
                  ' (   !arg
                      :   ?A
                        +   ?AA
                          * ( ?AAA
                              (?gfield,(% %|%+%):?M1)
                              ?ZZZ
                            )
                          * ?ZZ
                        + ?Z
                    & convertOptionsToAlternatives$!M1:?M1
                    & !A+!Z:?arg
                    &   whl
                      ' ( !M1:%?M2+?M1
                        &   !arg+!AA*(!AAA (!gfield,!M2) !ZZZ)*!ZZ
                          : ?arg
                        )
                    )
                &   whl
                  ' (   !arg
                      :   ?A
                        + ?AA*(?AAA (?gfield,%?M1*%?M2) ?ZZZ)*?ZZ
                        + ?Z
                    &     !A
                        +   !AA
                          * (!AAA (!gfield,!M1) !ZZZ)
                          * (!AAA (!gfield,!M2) !ZZZ)
                          * !ZZ
                        + !Z
                      : ?arg
                    )
                & !arg
            )
          & ( fulfil
            =     tools source goal sourcePlus forkk IO I O Os
                , goals goalterm nnnpathh indent accPipelines
                , Pipeline WRONGPIPES OKPIPES restriction
              .   !arg:(?tools.?source.?goal.?indent.?restriction)
                & "Restrict path length to max 20"
                & !indent:<20
                & 0:?accPipelines
                & unfoldGoal$!goal:?goals
                &   whl
                  ' ( !goals:%?goalterm+?goals
                    & (     (     unify$(!source.fold$!goalterm)
                                : ?sourcePlus
                              & sort$!sourcePlus
                            |       fulfilGoalProduct
                                  $ (!source.!goalterm.!tools.!restriction)
                                : ?forkk
                              &   (   !forkk:(0|1)
                                    & 0
                                  |     illegalSolution$(!goalterm.!forkk)
                                      : (?WRONGPIPES.?OKPIPES)
                                    & (!goalterm.!OKPIPES)
                                  | (!goalterm.!forkk)
                                  )
                                : ~0
                                : ?nnnpathh
                              & refold$!nnnpathh
                            )
                          : ?Pipeline
                        & !Pipeline+!accPipelines:?accPipelines
                      | 
                      )
                    )
                & !accPipelines:~0
            )
          & ( getActiveTools
            =   T F L
              .   0:?L
                & readTable$tooladm
                &   whl
                  ' ( !arg:(?T.?F)+?arg
                    & (     !tooladm
                          :   ?
                            + ( ? (ToolID.!T) ?
                              : ? (ServiceURL.~) ?
                              : ? (Inactive.) ?
                              )
                            + ?
                        & (!T.!F)+!L:?L
                      | 
                      )
                    )
                & !L
            )
          & ( getGoals
            =     AllFs Inca FS Ios allOs Os O
                , X A FN a b Y Z
              .   0:?AllFs
                &   whl
                  ' ( !arg:%?Inca+?arg
                    & :?FS
                    &   whl
                      ' ( !Inca:(?FN,?Ios) ?Inca
                        & 0:?allOs
                        &   whl
                          ' ( !Ios:(?.?Os)+?Ios
                            &   whl
                              ' ( !Os:%?O+?Os
                                & !O+!allOs:?allOs
                                )
                            & 
                            )
                        & !FS (!FN,!allOs):?FS
                        )
                    &   whl
                      ' ( !FS:?X+#*(?A (?FN,%?a+%?b) ?Z)+?Y
                        &     !X
                            + (!A (!FN,!a) !Z)
                            + (!A (!FN,!b) !Z)
                            + !Y
                          : ?FS
                        )
                    & !FS+!AllFs:?AllFs
                    )
                & removeNumFactors$!AllFs
            )
          & ( getImplicatedGoals
            =   allios tools,restriction ios restrictedTools
              .   !arg:(?tools.?restriction)
                & 0:?allios:?restrictedTools
                & (   !tools
                    :   ?
                      + ( !restriction
                        .   ?ios
                          & !ios+!allios:?allios
                          &   (!restriction.!ios)+!restrictedTools
                            : ?restrictedTools
                          & ~
                        )
                      + ?
                  | 
                  )
                & (getGoals$!allios.!restrictedTools)
            )
          & ( getSuperGoals
            =   SuperSets goal nwg
              .   !arg:?goal:?nwg
                &   ( facet
                    .   (pos.spo stp tlp stpl stplo stpd)
                        (ner.stn)
                        (lem.sl tl tlp stl stpl stplo)
                        (cls.stplo)
                        (stx.stpd)
                        (tok.seto stn)
                        (seg.seto)
                    )
                  : ?SuperSets
                &   map
                  $ ( ( 
                      =   feat vals A Z Val
                        .     !arg:(?feat.?vals)
                            & !goal:?A (!feat,?Val) ?Z
                            &   map
                              $ ( ( 
                                  =   val alts sp
                                    .   !arg:(?val.?alts)
                                      & (   !Val:!val^?sp
                                          &   map
                                            $ ( ( 
                                                =   
                                                  .         ( !A
                                                              (!feat,!arg^!sp)
                                                              !Z
                                                            )
                                                          + !nwg
                                                        : ?nwg
                                                      & 
                                                    | 
                                                )
                                              . !alts
                                              )
                                        | 
                                        )
                                  )
                                . !vals
                                )
                          | 
                      )
                    . !SuperSets
                    )
                & !nwg
            )
          & !arg:(?source.?goal.?restriction.?superset)
          & readTable$toolprop
          & getActiveTools$!toolprop:?activeTools
          & (   !goal:
              &   getImplicatedGoals$(!activeTools.!restriction)
                : (?goal.?restriction)
            | 0:?restriction
            )
          & ( !superset:
            | getSuperGoals$!goal:?goal
            )
          & 0:?memoizedSteps
          & fulfil$(!activeTools.!source.!goal.0.!restriction)
      )
      ( extractIOfeaturesFromHTTParg
      =   fs IorO f name short p A v Z feat spec io V
        .   "Collects features of the input(s) or of the output. Each feature
             is mentioned once. If there are more than one input, one feature
             will have more than one value. These values are the factors in a
             product."
          & !arg:(?fs.?IorO.?arg)
          & :?io
          &   whl
            ' ( !fs:%?f+?fs
              &   !f
                : ? (name.?name) ?
                : ? (short.?short) ?
              & localized$!name:?name
              & str$(!IorO !short):?p
              &   whl
                ' ( !arg:?A (!p.?v) ?Z
                  & !A !Z:?arg
                  & NEWSPEC
                  & ( !v:%?feat^%?spec
                    |   !v:@(?:?feat "^" ?spec)
                      & !feat^!spec:?v
                    | 
                    )
                  & ( !v:
                    |     !io
                        : ( ?A (!short,?V) ?Z
                          | ?A (!name,?V) ?Z
                          )
                      & ( !V:?*!v*?
                        |   ( !A (!short,!V*!v) !Z
                            | !A (!name,!V*!v) !Z
                            )
                          : ?io
                        )
                    |   ( (!short,!v) !io
                        | (!name,!v) !io
                        )
                      : ?io
                    )
                  )
              )
          & sort$!io
      )
      ( has
      =   rstr S
        .   !arg:(?arg.?rstr)
          & ( !arg:?*(!rstr,?)*?
            |   !arg:?*(?,(?.?.?.?S))*?arg
              & (has$(!S.!rstr)|has$(!arg.!rstr))
            )
      )
      ( filter
      =   pipes rstr desiredtool fpipes o pipe1
        .   !arg:(?pipes.?desiredtool)
          & 0:?fpipes
          &   whl
            ' ( !pipes:(?o.?pipe1)+?pipes
              & (   has$(!pipe1.!desiredtool)
                  & ( !fpipes:?+(?.!o.!pipe1)+?
                    | (!o.!pipe1)+!fpipes:?fpipes
                    )
                | 
                )
              )
          & !fpipes
      )
      ( haz
      =   rstr S F T notfound
        .   !arg:(?arg.?rstr)
          & :?notfound
          &   whl
            ' ( :!notfound
              & !arg:%?T+?arg
              &   whl
                ' ( :!notfound
                  & !T:%?F*?T
                  & (   ( !F:(!rstr,?)
                        |   !F:(?,(?.?.?.?S))
                          & haz$(!S.!rstr)
                        )
                      & false:?notfound
                    | 
                    )
                  )
              )
          & !notfound:false
      )
      ( Pipelines
      =   i o restriction FP fP superset userInput
        .   0:?indent
          & ( !arg:? (desiredtool.?restriction) ?
            | :?restriction
            )
          & ( !arg:? (superset.?superset) ?
            | :?superset
            )
          & readTable$features
          & extractIOfeaturesFromHTTParg$(!features.I.!arg):?i
          & extractIOfeaturesFromHTTParg$(!features.O.!arg):?o
          & (!i.!o.!restriction.!superset):?userInput
          & (   !recentTasks:? (!userInput.?FP) ?
              & (!i.!FP.withRestriction)
            |   fp$!userInput:?FP
              & ( !i
                .     ( !restriction:
                      |   !FP
                        :   ?
                          + (?.?fP&haz$(!fP.!restriction))
                          + ?
                      )
                    & prunePipes$(!FP.!arg):?FP
                    & ( !recentTasks:?recentTasks [3 ?
                      | 
                      )
                    &   (!userInput.!FP) !recentTasks
                      : ?recentTasks
                    & (!FP.withRestriction)
                  |   !FP:(?,?) ?
                    & (!FP.triviallyFulfilled)
                  | (!FP.onlyWithoutRestriction)
                )
            )
      )
      ( testPipelines
      =   
        .   log$NEW
          &   Pipelines
            $ ( (method.GET)
                (Olang.)
                (mail2."\"xxx@san.foo\"")
                (Item."\"dkclarin:168148\"")
                (Item."\"dkclarin:168234\"")
                (Iformat.txtann)
                (Iformat.txtann)
                (TOOL.)
                (Ofacet.lem)
                (Ifacet.tok)
                (Ifacet.seg)
                (Oformat.)
                (Ilang.da)
                (Ilang.da)
                (bsubmit.">")
              )
      )
      ( pipeSegmentXML
      =     XML tool output input xml spec A
          , values value feature
          , inputprop goal
        .   :?XML
          & (   !arg:%+%
              &   element
                $ ( pipes
                  . 
                  .     whl
                      ' ( !arg:%?A+?arg
                        & !XML pipeSegmentXML$!A:?XML
                        )
                    & !XML
                  )
            |   !arg:%*%
              &   element
                $ ( merge
                  . 
                  .     whl
                      ' ( !arg:%?A*?arg
                        & !XML pipeSegmentXML$!A:?XML
                        )
                    & !XML
                  )
            |   !arg:(?tool,(?output.?inputprop.?input))
              &     !XML
                      element
                    $ ( pipe
                      . 
                      .   element$(tool..!tool)
                          element$(output..pipeSegmentXML$!output)
                          element$(input..pipeSegmentXML$!input)
                      )
                : ?XML
            | !arg:(?goal.?arg)&pipeSegmentXML$!arg
            |   element
              $ ( features
                . 
                .     whl
                    ' ( !arg:(?feature,?values) ?arg
                      &     !XML
                              element
                            $ ( feature
                              . 
                              .   element$(name..!feature)
                                  ( :?xml
                                  &   whl
                                    ' ( !values:%?value^?spec+?values
                                      & NEWSPEC
                                      &     !xml
                                              element
                                            $ ( value
                                              . 
                                              .   !value
                                                  (   !spec:1
                                                    & NEWSPEC
                                                    & 
                                                  | element$(spec..!spec)
                                                  )
                                              )
                                        : ?xml
                                      )
                                  & !xml
                                  )
                              )
                        : ?XML
                      & 
                      )
                  & !XML
                )
            )
      )
      " convert2URLs receives a list of job steps, each step describing the 
step's tool, its output and its inputs. The inputs not only tell the type of
each input, but also which step produced that input. The first step's input is
taken from the Items list. Following steps can, but need not take an item in
the Items list as input. Step descriptions in the JobStack can look like this:
  ( step1                                 STEP
  . pdf2htmlEX                            TOOL
  .   (facet,txt^ocr)                     ------
      (format,html)                       
      (lang,da)                           INPUT
      (pres,nml)                          -----
  .   (facet,txt)                         ------
      (format,pdf)                        
      (lang,da)                           OUTPUT
      (pres,nml)                          ------
  )
...
  ( step8                                  STEP
  . CST-Lem                                TOOL
  .   (facet,lem)                          ------
      (format,flat)
      (lang,da)                            INPUT
      (pres,alf)                           ------
  .   (pres,nml)                           ------
      (lang,da)
      (format,txtann)                      OUTPUT
      (facet,(pos^Par.step7))
      (facet,(tok.step5))                  ------
  )
"
      ( convert2URLs
      =     requestString Items items file files newJobs feats
          , base post2 val vals JobStack Val item meta In
          , jobIDoffset A OffSet
          , extension ID forceFeed visibility jobNr jobID maxjobID
          , Short Long DiscerningFeature getDisFe
          , DATE Tool URL dep discerningFeature
          , feat in ou spec v nfiles fileTerm
          , inputs moreinputs firstinput other fh oh
          , compact compatible simpleInput someinputs
          , getDepsAndAddInputsToRequestString
        .   "getDisFe establishes the feature that the given tool has to look
             for among the input Items, if it needs an item from that list.
             It is not useful for steps that only take input from earlier
             steps."
          & log$convert2URLs
          & ( getDisFe
            =   f
              .     !arg:? (?f,?) ? (!f,?) ?
                  & (!f.n)
                | (.1)
            )
          & ( Short
            =   
              .   (   !features
                    :   ?
                      + ( ? (name.? !arg ?) ?
                        : ? (short.?arg) ?
                        )
                      + ?
                  | 
                  )
                & !arg
            )
          & ( Long
            =   
              .   (   !features
                    :   ?
                      + ( ? (short.!arg) ?
                        : ? (name.?arg) ?
                        )
                      + ?
                  | 
                  )
                & localized$!arg
            )
          & ( compact
            =   A B C D E x
              .       whl
                    ' ( !arg:?A+(#*%?x.?B)+?C+(#*!x.?D)+?E
                      & !A+(!x.!B+!D)+!C+!E:?arg
                      )
                  &   whl
                    ' ( !arg:?A+#%*%?x+?C
                      & !A+!x+!C:?arg
                      )
                  & 0:?E
                  &   whl
                    ' ( !arg:?A+(?B.?C)+?arg
                      & !E+!A+(!B.compact$!C):?E
                      )
                  & !arg+!E:?arg
                | FOUT
            )
          & ( OffSet
            =   ID
              .   !jobIDoffset:&!arg
                |   @(!arg:step #?ID)
                  & str$(step !ID+!jobIDoffset)
                | !arg
            )
          & ( simpleInput
            =   a b c d e,f g h i j k
              .     !arg
                  : (   ?
                      + (I.?.?.?+(F.?)+?)
                      + ?
                      + (I.?.?.?+(F.?)+?)
                      + ?
                    | ?+(F.?)+?
                    )
                |     !arg
                    :   ?a
                      + (I.?b+(?c.?d+(?e.?f+(F.?g)+?h)+?i)+?j)
                      + ?k
                  & !a+(F.!g)+(I.!b+(!c.!d+(!e.!f+!h)+!i)+!j)+!k
            )
          & ( forceFeed
            =   requestString item file
              .   0:?requestString
                & !arg:?items
                &   whl
                  ' ( !items:(Item.%?item ?) ?items
                    & !Uploads:? (?.!item.?.?file.?) ?
                    &     !requestString
                        + ( !files !file:?files
                          & (F.!file)
                          )
                      : ?requestString
                    )
                & !requestString
            )
          & ( notIncompatible
            =   feats In f
              .   !arg:(?feats.?In)
                & ~( !feats
                   :   ?
                       (?f.?v)
                       ( ?
                       & !In:? (!f,(!v^?.?)) ?
                       )
                   )
            )
          & ( compatible
            =   f r v stp rs fv
              .   !arg:(?.~(? (?,@) ?))
                |   !arg:(?f.? (?r,@?v) ?rs)
                  & ( ~(!f:? (!r.?fv) ?)
                    | !v:!fv
                    | !v:!fv^?
                    | !fv:!v^?
                    )
                  & compatible$(!f.!rs)
            )
          & ( addOutputsToRequestString
            =   ou requestString extension feat val spec
              .   !arg:(?ou.?requestString)
                & xml:?extension
                &   whl
                  ' ( !ou:(?feat,%@?val^?spec) ?ou
                    & NEWSPEC
                    &     !requestString
                        + ( O
                          . Short$!feat
                          . !val
                          .     !spec:1
                              & NEWSPEC
                              & 0
                            | !spec
                          )
                      : ?requestString
                    & (   !feat:(format|Format)
                        &   ( !val:flat&txt
                            |     !val
                                : ( xm
                                  | txtbasis
                                  | txtann
                                  | teip5
                                  )
                              & xml
                            | !val
                            )
                          : ?extension
                      | 
                      )
                    )
                & (!extension.!requestString)
            )
          & ( getDepsAndAddInputsToRequestString
            =   in nfiles requestString
              .   !arg:(?in.?nfiles.?requestString)
                &     map
                    $ ( ( 
                        =     feat vals Val spec file
                            , val dep FiLfeats fileitem
                          .   !arg:(?feat,?vals)
                            & :?dep
                            &   whl
                              ' ( !vals:%?Val*?vals
                                &   !Val
                                  : ( ( %@?val^?spec
                                      .     @?file
                                          & OffSet$!file:?file
                                          &   !dep (!file,pending)
                                            : ?dep
                                          &   ( F
                                              .   (   !newJobs
                                                    :   ?
                                                        ( !jobNr
                                                        . !file
                                                        . ?
                                                        . ?
                                                        . ?
                                                        . ?file
                                                        )
                                                        ?
                                                  |   log
                                                    $ ( OOPS
                                                        !jobNr
                                                        file
                                                        !file
                                                      )
                                                  )
                                                & !file
                                              )
                                            : ?fileTerm
                                        |   (FiL.?FiLfeats)
                                          &   !Items
                                            :   ?
                                                ( Item
                                                .   %?item ?feats
                                                  &   !Uploads
                                                    :   ?
                                                        ( ?
                                                        . !item
                                                        . ?
                                                        . ?fileitem
                                                        .   ?meta
                                                          :   ?
                                                              (DATE.?DATE)
                                                              ?
                                                        .   ?feats
                                                          &   compatible
                                                            $ (!feats.!FiLfeats)
                                                        . ?visibility
                                                        )
                                                        ?
                                                )
                                                ?
                                          & !dep !fileitem:?dep
                                          & (F.!fileitem):?fileTerm
                                      )
                                    |   %@?val^?spec
                                      & 0:?fileTerm
                                    )
                                & NEWSPEC
                                &     !requestString
                                    + (   !nfiles:1
                                        & !fileTerm
                                      | 0
                                      )
                                    + ( I
                                      . Short$!feat
                                      . !val
                                      .   (   !nfiles:n
                                            & !fileTerm
                                          | 0
                                          )
                                        + (   !spec:1
                                            & NEWSPEC
                                            & 0
                                          | (!spec.0)
                                          )
                                      )
                                  : ?requestString
                                )
                            & !dep
                        )
                      . !in
                      )
                  : ?dep
                & (!dep.!requestString)
            )
          & 0:?maxjobID
          & readTable$features
          & readTable$tooladm
          & readTable$toolprop
          &   !arg
            : (?jobNr.?jobIDoffset.?JobStack.?base.?post2.?Items)
          & readTable$Uploads
          & :?newJobs
          & (readTable$jobs|:?jobs)
          &   whl
            ' ( !JobStack:(?jobID.?Tool.?ou.?in) ?JobStack
              & OffSet$!jobID:?jobID
              & 1+!maxjobID:?maxjobID
              &   !tooladm
                :   ?
                  + ( ? (ToolID.!Tool) ?
                    : ? (ServiceURL.?URL) ?
                    )
                  + ?
              &     (base.!base)
                  + (post2.!post2)
                  + (job.str$(!jobNr "-" !jobID))
                : ?requestString
              & getDisFe$!in:(?discerningFeature.?nfiles)
              &   addOutputsToRequestString$(!ou.!requestString)
                : (?extension.?requestString)
              & !in:?In
              &     getDepsAndAddInputsToRequestString
                  $ (!in.!nfiles.!requestString)
                : (?dep.?requestString)
              &     !newJobs
                    ( !jobNr
                    . !jobID
                    .     !dep
                          ( :?files
                          & ( !requestString:?+(F.?)+?
                            |   !Items:?items
                              &   whl
                                ' (   !items
                                    : (Item.%?item ?feats) ?items
                                  &   !Uploads
                                    :   ?
                                        ( ?
                                        . !item
                                        . ?
                                        . ?file
                                        .   ?meta
                                          : ? (DATE.?DATE) ?
                                        . ?feats
                                        . ?visibility
                                        )
                                        ?
                                  &     !requestString
                                      + (   !discerningFeature:
                                          & !files !file:?files
                                          & (F.!file)
                                        |     !feats
                                            :   ?
                                                (!discerningFeature.?v)
                                                ?
                                          &     getShort
                                              $ (!discerningFeature.!v)
                                            : ?v
                                          &   Long$!discerningFeature
                                            : ?DiscerningFeature
                                          & notIncompatible$(!feats.!In)
                                          & compatible$(!feats.!In)
                                          &   !In
                                            :   ?
                                                (   !discerningFeature
                                                  | !DiscerningFeature
                                                ,   ?+?*!v^?*?+?
                                                  | (?+?*!v^?*?+?.?)
                                                  | ?+?*!v*?+?
                                                  | (?+?*!v*?+?.?)
                                                )
                                                ?
                                          & !v:%@?v^?
                                          & !files !file:?files
                                          & ( I
                                            . !discerningFeature
                                            . !v
                                            . F
                                            . !file
                                            )
                                        | 0
                                        )
                                    : ?requestString
                                  )
                            )
                          & (     !requestString
                                : (   ?
                                    + (I.?+(?.?+(?.?+(F.?)+?)+?)+?)
                                    + ?
                                  | ?+(F.?)+?
                                  )
                              &   simpleInput$!requestString
                                : ?requestString
                            |   !requestString+forceFeed$!Items
                              : ?requestString
                            )
                          & !files
                          )
                      : ?inputs
                    . !URL
                    . compact$!requestString:?requestString
                    .   "Output from tool:"
                      & @(!jobID:? #?ID)
                      &   str
                        $ ( (     !inputs
                                : ? (@(?:step ?),?) ?
                              &   !requestString
                                : (   ?
                                    + (F.@(?:?inputs "-step" #% ?))
                                    + ?
                                  |     ?
                                      + ( I
                                        .   ?
                                          + ( ?
                                            .   ?someinputs
                                              + ( ?
                                                .   ?
                                                  + ( F
                                                    . @( ?
                                                       :   ?firstinput
                                                           "-step"
                                                           #%
                                                           ?
                                                       )
                                                    )
                                                  + ?
                                                )
                                              + ?moreinputs
                                            )
                                          + ?
                                        )
                                      + ?
                                    & :?inputs
                                    &   !someinputs+!moreinputs
                                      : ?moreinputs
                                    &   whl
                                      ' (   !moreinputs
                                          :   ?
                                            + ( ?
                                              .   ?
                                                + ( F
                                                  . @( ?
                                                     : ( ?other "-step" #% ?
                                                       | ?other
                                                       )
                                                     )
                                                  )
                                                + ?
                                              )
                                            + ?moreinputs
                                        & @( !firstinput
                                           : ?fh [%@(!other:?oh !sjt)
                                           )
                                        &     str
                                            $ (   ( !fh:
                                                  | !oh:
                                                  |   @(!fh:!oh "-" #?)
                                                    & :?oh
                                                  )
                                                & (     !inputs
                                                      : ( 
                                                        | !firstinput
                                                        )
                                                    &   (   @( !firstinput
                                                             : ? !fh ?
                                                             )
                                                          & 
                                                        | !fh
                                                        )
                                                        (   @( !firstinput
                                                             : ? !oh ?
                                                             )
                                                          & 
                                                        | !oh
                                                        )
                                                        !firstinput
                                                  | !inputs "_" !other
                                                  )
                                              |   (   !inputs:
                                                    & !fh "_"
                                                  | 
                                                  )
                                                  !oh
                                              )
                                          : ?inputs
                                        )
                                  )
                              & !inputs
                            |   ( !inputs:@
                                |     2
                                    *   mod
                                      $ ( div$(!DATE*(1+clk$),1)
                                        , 4231764527
                                        )
                                  + !jobNr*100
                                  + !ID
                                )
                                "-"
                                !jobNr
                            )
                            "-"
                            !jobID
                            "."
                            !extension
                          )
                    )
                : ?newJobs
              )
          & !jobs !newJobs:?jobs
          & saveTable$jobs
          & !maxjobID
      )
      "
/**
 * getNextJobID
 *
 * Given the jobNr of a workflow, return the next job that is not pending 
 * (=waiting for an another job to produce some of its inputs).
 * Argument: jobNr
 * Returns: jobID (if job found in jobs.table)
 *          empty string (if job not found in jobs.table)
 * Called from create.java and workflow.java
 */"
      ( getNextJobID
      =   A Z jobID dep g test
        .     log$(getNextJobID !arg)
            & !arg:(?arg.?test)
            & @(!arg:? #?arg)
            & readTable$jobs
            &   !jobs
              :   ?A
                  (!arg.@?jobID.~(? (?,pending) ?):?dep.?g)
                  ?Z
            & ( !test:justtesting
              |     !A (!arg.!jobID starting.!dep.!g) !Z
                  : ?jobs
                & log$(starting !arg !jobID)
                & saveTable$jobs
              )
            & log$(getNextJobID !arg !jobID)
            & !jobID
          | 
      )
      "
/**
 * getJobArg
 *
 * Consults tables jobs.table and tooladm.table to answer several requests
 * Arguments: jobNr, jobID and one of the following requests:
 *      endpoint        the URL where the integrated tool lives
 *      filename        the name to be given to the output
 *      method          POST or GET
 *      requestString   the request string as HTTP-parameters or as XML
 *      isXML           y or n
 * Called from workflow.java
 */"
      ( getJobArg
      =     JobNr jobID jobby res A B Res makeList
          , req servurl xmlparms fmt spc
        .   str
          $ (   !arg:(@(?:? #?JobNr).?jobID.?arg)
              & (!jobs|readTable$jobs)
              & !jobs:? (!JobNr.!jobID ?.?jobby) ?
              &   !arg
                : ( endpoint&!jobby:(?.?arg.?)
                  |   method
                    & !jobby:(?.?arg.?)
                    & readTable$tooladm
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!arg) ?
                          : ? (PostData.?arg) ?
                          )
                        + ?
                    &   ( !arg:on&POST
                        | GET
                        )
                      : ?arg
                  |   requestString
                    & !jobby:(?.?servurl.?req.?)
                    & readTable$tooladm
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!servurl) ?
                          : ? (XMLparms.?xmlparms) ?
                          )
                        + ?
                    & (   !xmlparms:on
                        & ( makeList
                          =   X el sub res
                            .   :?res
                              &   whl
                                ' ( !arg:%?X+?arg
                                  &     !res
                                        (   !X:(?el.?sub)
                                          & (!el.,makeList$!sub)
                                        | !X
                                        )
                                    : ?res
                                  )
                              & !res
                          )
                        & makeList$(parms.!req):?res
                        & str$!res:?arg
                      |   ( makeList
                          =   A B prefix res
                            .   !arg:(?prefix.?arg)
                              & :?res
                              &   whl
                                ' ( !arg:%?A+?arg
                                  &     !res
                                        (   !A:(?A.?B)
                                          &   ( !prefix:
                                              | (!prefix,!A)
                                              )
                                                makeList
                                              $ (!prefix !A.!B)
                                        | !prefix:
                                        | (!prefix,!A)
                                        )
                                    : ?res
                                  )
                              & !res
                          )
                        & makeList$(.!req):?res
                        & !res:(?A,?B) ?res
                        & !A "=" !B:?Res
                        &   whl
                          ' ( !res:(?A,?B) ?res
                            & !Res "&" !A "=" !B:?Res
                            )
                        & str$!Res:?arg
                      )
                  | filename&!jobby:(?.?.?.?arg)
                  )
              & !arg
            | SOMETHINGWRONG
            )
      )
      "
/**
  * waitingJob
  *
  * Make a job 'waiting'.
  * 
  * Input: JobNr and jobID
  *
  * Affected tables:
  *     jobs.table
  *
  * Called from workflow.java
  */"
      ( waitingJob
      =   A Z JobNr jobID ZZ jobstatus
        .     readTable$jobs
            & log$("waitingJob " !arg)
            & !arg:(@(?:? #?JobNr).?jobID)
            &   whl
              ' (   !jobs
                  : ?A (!JobNr.!jobID ?jobstatus.?ZZ) ?Z
                & !jobstatus:(|starting)
                &   !A (!JobNr.!jobID waiting.!ZZ) !Z
                  : ?jobs
                )
            & saveTable$jobs
            & 
          | "Expecting (? #JobNr.jobID)"
      )
      ( tekstXML
      =     OLACTITLE DATE EMAIL TBA AVAILABILITY Description
          , OUTPUTFACET BASEITEM XMLID ITEMS TOOLURIS SPANGRP
          , ret linguae BODYCONTENT niceDate noColon
          , ToolID Title ToolContentProvider Version toolURL full
          , CTB LANGUAGE type appdesc YYY
        .     !arg
            : ( ?OLACTITLE
              . ?DATE
              . ?EMAIL
              . ?CTB
              . ?TBA
              . ?AVAILABILITY
              . ?OUTPUTFACET
              . ?BASEITEM
              . ?XMLID
              . ?ITEMS
              . ?TOOLURIS
              . ?SPANGRP
              . ?toolURL
              . ?LANGUAGE
              )
          & ( niceDate
            =   yyyy mm dd
              .     @( !arg
                     :   (% % % %:?yyyy)
                         (% %:?mm)
                         (% %:?dd)
                     )
                  & str$(!yyyy "-" !mm "-" !dd)
                | !arg
            )
          & ( noColon
            =   A Z
              .     whl
                  ' ( @(!arg:?A "::" ?Z)
                    & str$(!A "_" !Z):?arg
                    )
                &   whl
                  ' ( @(!arg:?A ":" ?Z)
                    & str$(!A "_" !Z):?arg
                    )
                & !arg
            )
          &   
            : ?Title
            : ?ToolContentProvider
            : ?Version
            : ?ToolID
            : ?Description
          & (   !SPANGRP
              : ? ("?".@(?:? xml ? version ?)) ?SPANGRP
            | 
            )
          & (     !SPANGRP
                :   ?
                    ( spanGrp
                    .   ? (ana.@(?:"#" ?XMLID)) ?
                      | ?
                    )
                    ?
              & :?BODYCONTENT
              & annotation:?type
            |   !SPANGRP:?BODYCONTENT
              & :?SPANGRP
              & text:?type
            )
          &     (   readTable$tooladm
                  &   !tooladm
                    :   ?
                      + ( ? (ServiceURL.!TOOLURIS) ?
                        : ? (ToolID.?ToolID) ?
                        : ? (Title.?Title) ?
                        : ? (ContentProvider.?ToolContentProvider) ?
                        : ? (Version.?Version) ?
                        : ? (Description.?Description) ?
                        )
                      + ?
                  & !Title
                | !toolURL
                )
                ". "
                !Description
            : ?appdesc
          &     ("?"."xml version=\"1.0\" encoding=\"UTF-8\"")
                \n
                ( TEI
                .     (xmlns."http://www.tei-c.org/ns/1.0")
                      ( "xmlns:schemaLocation"
                      .   "https://www.clarin.dk/schemas/tei/TEIDKCLARIN_ANNO/xml.xsd"
                        |   !type:text
                          & "http://www.clarin.eu/cmd http:/infra.clarin.dk/cmd/dkclarin-text-md-schema.xsd"
                        | "http://www.clarin.eu/cmd http://infra.clarin.dk/cmd/dkclarin-textann-md-schema.xsd"
                      )
                  ,   \n
                      ( teiHeader
                      .   (type.!type)
                        ,   ( fileDesc
                            .   
                              ,   ( titleStmt
                                  .   
                                    ,   (title.,!OLACTITLE ", TEI-format")
                                        (sponsor.,DK-CLARIN)
                                        ( respStmt
                                        .   
                                          ,   (resp.,"a_annotation")
                                              ( name
                                              .   
                                                ,   ( note
                                                    .   (type.method)
                                                      , !ToolID
                                                    )
                                                    ( date
                                                    .   (when.niceDate$!DATE)
                                                      , 
                                                    )
                                              )
                                        )
                                  )
                                  (   !type:text
                                    & ( extent
                                      . ,(num.(type.words),)
                                      )
                                  | 
                                  )
                                  ( publicationStmt
                                  .   
                                    ,   (distributor.,!EMAIL)
                                        (idno.(type.ctb),!CTB)
                                        ( availability
                                        .   (status.free)
                                          , (ab.(type.public),)
                                        )
                                  )
                                  (notesStmt.,(note.,!OUTPUTFACET))
                                  ( sourceDesc
                                  .   
                                    , ( biblStruct
                                      .   
                                        , ( monogr
                                          .   
                                            ,   ( title
                                                .   ("xml:lang".da)
                                                  , monogr
                                                )
                                                ( imprint
                                                .   
                                                  ,   ( publisher
                                                      .   (n.n/a)
                                                        , !ToolContentProvider
                                                      )
                                                      ( date
                                                      .   ( when
                                                          . niceDate$!DATE
                                                          )
                                                        , 
                                                      )
                                                )
                                          )
                                      )
                                  )
                            )
                            ( "!--"
                            .   toML
                              $ ( encodingDesc
                                .   
                                  ,   (samplingDecl.,(ab.,samplingDecl))
                                      (projectDesc.,(ab.,!TBA))
                                      ( !type:text&
                                      | ( appInfo
                                        .   
                                          , ( application
                                            .     ( ident
                                                  .   !ToolID
                                                      ( !Version:
                                                      | "_" !Version
                                                      )
                                                  )
                                                  (type."a_annotation")
                                                  (subtype.!OUTPUTFACET)
                                                  (version.!Version)
                                                  ("xml:id".!XMLID)
                                              ,   (desc.,!appdesc)
                                                  ( ptr
                                                  .   (target.noColon$!ITEMS)
                                                    , 
                                                  )
                                                  ( ref
                                                  .   (target.!TOOLURIS)
                                                    , 
                                                  )
                                            )
                                        )
                                      )
                                )
                            )
                            ( profileDesc
                            .   
                              ,   ( creation
                                  .   
                                    , ( date
                                      .     (cert.high)
                                            (when.niceDate$!DATE)
                                        , 
                                      )
                                  )
                                  ( !LANGUAGE:
                                  | ( langUsage
                                    .   
                                      , ( language
                                        .   (ident.!LANGUAGE)
                                          ,     readTable$linguae
                                              &   !linguae
                                                :   ?
                                                    (?full.!LANGUAGE.?YYY)
                                                    ?
                                              & localized$!full
                                            | 
                                        )
                                    )
                                  )
                                  ( textDesc
                                  .   
                                    ,   (channel.(mode.w),2)
                                        (constitution.,)
                                        (derivation.,)
                                        ( domain
                                        . (type.specific),general
                                        )
                                        (factuality.,)
                                        (interaction.,)
                                        (preparedness.,)
                                        (purpose.,)
                                  )
                                  (particDesc.,(person.,))
                            )
                            ( revisionDesc
                            .   
                              , ( change
                                .     (when.niceDate$!DATE)
                                      (who.!EMAIL)
                                  ,     !type:text
                                      & !appdesc
                                    | created
                                )
                            )
                      )
                      \n
                      ( text
                      .   
                        ,   ( body
                            .   
                              ,     !BODYCONTENT:~
                                  & (   !BODYCONTENT
                                      : (   ?
                                            ( text
                                            .   ?
                                              ,   ?
                                                  (body.?,?BODYCONTENT)
                                                  ?
                                            )
                                            ?
                                        | ? (body.?,?BODYCONTENT) ?
                                        |   ?
                                            (body.?)
                                            ?BODYCONTENT
                                            (.body.)
                                            ?
                                        )
                                    | 
                                    )
                                  & !BODYCONTENT
                                | ( ab
                                  .   
                                    ,     !SPANGRP:
                                        & "empty body/no text"
                                      | 
                                  )
                            )
                            \n
                            !SPANGRP
                      )
                )
            : ?ret
          & !ret
      )
      "
/**
 * relationFile
 *
 * Create a relation file ready for deposition together with an annotation.
 *
 * Input: JobNr and jobID
 * Output: String that can be saved as a semicolon separated file.
 * Consulted tables:
 *      relations.table     (for relation type, ctb and ctbid
 *      CTBs.table          (for ContentProvider and CTBID)
 *
 * Called from workflow.java
 */"
      ( relationFile
      =     A Z JobNr jobID
          , ContentProvider CTBID ctb ctbid rel reltype
        .     !arg:(@(?:? #?JobNr).?jobID)
            & readTable$relations
            & readTable$CTBs
            &   !CTBs
              : ? (!JobNr.!jobID.?ContentProvider.?CTBID) ?
            & :?rel
            &   whl
              ' (   !relations
                  : ?A (!JobNr.!jobID.?reltype.?ctb.?ctbid) ?Z
                & !A !Z:?relations
                &     !rel
                      !reltype
                      ";"
                      !ContentProvider
                      ";"
                      !CTBID
                      ";"
                      !ctb
                      ";"
                      !ctbid
                      ";;\n"
                  : ?rel
                )
            & (|saveTable$relations)
            & str$!rel
          | 
      )
      ( isTEIoutput
      =   format JobNr jobID
        .   log$isTEIoutput
          & readTable$jobs
          & !arg:(@(?:? #?JobNr).?jobID)
          & (@(!jobID:?jobID " " ?)|)
          & (     !jobs
                :   ?
                    ( !JobNr
                    . !jobID ?
                    . ?
                    . ?
                    .   ?
                      + ( O
                        .   ?
                          + ( format
                            .   ( txtann
                                | txtbasis
                                | teip5
                                )
                              : ?format
                            . ?
                            )
                          + ?
                        )
                      + ?
                    . ?
                    )
                    ?
              & log$(str$(isTEIoutput "[" !format "]"))
              & !format
            | log$isTEIoutputNiks&
            )
      )
      ( inject
      =     userProvidedMetadata autogenerated final recurse
          , Required/optional/automatic val Line tree
          , PlaceInHeader id addOrInsert remove Metadata
          , replaceOrInsert addOrInsertOneOrMoreNames metadataType
        .   ( remove
            =     PlaceInHeader tree subtree
                , place A Z a attval
              .   !arg:(?PlaceInHeader.?tree)
                & (   !PlaceInHeader:%?place ?PlaceInHeader
                    & (   !PlaceInHeader:
                        & (   !place:(?place,?attval)
                            &   whl
                              ' (   !tree
                                  :   ?A
                                      (!place.? !attval ?,?)
                                      ?Z
                                & !A !Z:?tree
                                )
                          |   whl
                            ' ( !tree:?A (!place.?,?) ?Z
                              & !A !Z:?tree
                              )
                          )
                        & !tree
                      |   (   !place:(?place,?attval)
                            &   !tree
                              :   ?A
                                  (!place.? !attval ?:?a,?subtree)
                                  ?Z
                          | !tree:?A (!place.?a,?subtree) ?Z
                          )
                        &   !A
                            (!place.!a,remove$(!PlaceInHeader.!subtree))
                            remove$(!place !PlaceInHeader.!Z)
                      )
                  | !tree
                  )
            )
          & ( replaceOrInsert
            =     PlaceInHeader val tree subtree
                , place plac at A E Z a z attval
              .   !arg:(?PlaceInHeader.?val.?tree)
                & (   !PlaceInHeader:%?place ?PlaceInHeader
                    & (   !place:(?place.?at)
                        & (     !tree
                              :   ?A
                                  (!place.?a (!at.?) ?z,?E)
                                  ?Z
                            &   !A
                                (!place.!a (!at.!val) !z,!E)
                                !Z
                          | !tree (!place.(!at.!val),)
                          )
                      |   !place:(?plac,?attval)
                        &   !tree
                          :   ?A
                              (!plac.? !attval ?:?a,?subtree)
                              ?Z
                        &   !A
                            ( !plac
                            .   !a
                              ,   replaceOrInsert
                                $ (!PlaceInHeader.!val.!subtree)
                            )
                            !Z
                      |   !tree:?A (!place.?a,?subtree) ?Z
                        &   !A
                            ( !place
                            .   !a
                              ,   replaceOrInsert
                                $ (!PlaceInHeader.!val.!subtree)
                            )
                            !Z
                      |   !tree
                          (   !place:(?plac,?attval)
                            & ( !plac
                              .   !attval
                                , replaceOrInsert$(!PlaceInHeader.!val.)
                              )
                          | ( !place
                            . ,replaceOrInsert$(!PlaceInHeader.!val.)
                            )
                          )
                      )
                  | !val
                  )
            )
          & ( recurse
            =   A Z a attval place subtree
              .   !PlaceInHeader:%?place ?PlaceInHeader
                & (   !place:(?place,?attval)
                    & (     !tree
                          :   ?A
                              (!place.? !attval ?:?a,?subtree)
                              ?Z
                        &   !A
                            (!place.!a,!arg$(!PlaceInHeader.!val.!subtree))
                            !Z
                      |   !tree
                          (!place.!attval,!arg$(!PlaceInHeader.!val.))
                      )
                  |   !tree:?A (!place.?a,?subtree) ?Z
                    &   !A
                        (!place.!a,!arg$(!PlaceInHeader.!val.!subtree))
                        !Z
                  | !tree (!place.,!arg$(!PlaceInHeader.!val.))
                  )
            )
          & ( final
            =   A Z a attval b
              .     !PlaceInHeader:@
                  & (     !tree
                        :   ?A
                            (!PlaceInHeader.?a,?b)
                            (~((!PlaceInHeader.?) ?):?Z)
                      &   !A
                          (!PlaceInHeader.!a,!b)
                          (!PlaceInHeader.!a,!val)
                          !Z
                    | !tree (!PlaceInHeader.,!val)
                    )
                |   !PlaceInHeader:(?PlaceInHeader,?attval)
                  & (     !tree
                        :   ?A
                            (!PlaceInHeader.? !attval ?:?a,?b)
                            ( ~( (!PlaceInHeader.? !attval ?,?)
                                 ?
                               )
                            : ?Z
                            )
                      &   !A
                          (!PlaceInHeader.!a,!b)
                          (!PlaceInHeader.!a,!val)
                          !Z
                    | !tree (!PlaceInHeader.!attval,!val)
                    )
            )
          & ( addOrInsert
            =   PlaceInHeader val tree
              .   !arg:(?PlaceInHeader.?val.?tree)
                & ( final$
                  | recurse$addOrInsert
                  | !val
                  )
            )
          & ( addOrInsertOneOrMoreNames
            =     PlaceInHeader val tree parnt
                , A Z a b c d e
              .   !arg:(?PlaceInHeader.?val.?tree)
                &   log
                  $ (addOrInsertOneOrMoreNames !PlaceInHeader val !val)
                & (   !PlaceInHeader:@?parnt name
                    & (     !tree
                          :   ?A
                              (!parnt.?a,?b (name.?c,?d) ?e)
                              (~((!parnt.?) ?):?Z)
                        &   !A
                            (!parnt.!a,!b (name.!c,!d) !e)
                            (!parnt.!a,!b (name.!c,!val) !e)
                            !Z
                      |   !tree:?A (!parnt.?a,?b) ?Z
                        &   !A
                            (!parnt.!a,(name.,!val) !b)
                            !Z
                      | !tree (!parnt.,(name.,!val))
                      )
                  | final$
                  | recurse$addOrInsertOneOrMoreNames
                  | !val
                  )
            )
          & !arg:(?userProvidedMetadata.?autogenerated.?metadataType)
          & log$inject
          & readTable$!metadataType:?Metadata
          &   whl
            ' (   !userProvidedMetadata
                : (?id.?val) ?userProvidedMetadata
              & trim$!val:?val
              & (     !Metadata
                    :   ?
                        ( ?
                        ,   ?
                            ( !id
                            . ?
                            . ?Required/optional/automatic
                            . ?
                            . ?PlaceInHeader
                            . ?
                            . ?
                            . ?
                            )
                            ?
                        )
                        ?
                  &   (     !Required/optional/automatic
                          : ( ? r ?
                            | ? o ?&!val:~
                            )
                        &   replaceOrInsert
                          $ (!PlaceInHeader.!val.!autogenerated)
                      |     !Required/optional/automatic
                          : (   ? (o|zeroOrMore) ?
                              : ~(? a ?)
                            & !val:
                            )
                        &   remove$(!PlaceInHeader.!autogenerated)
                          : ?autogenerated
                      |     !Required/optional/automatic
                          : ( ? oneOrMore ?
                            | ? zeroOrMore ?&!val:~
                            )
                        &   remove$(!PlaceInHeader.!autogenerated)
                          : ?autogenerated
                        &   whl
                          ' ( @( !val
                               : ( ?Line \n ?val
                                 | ?Line&:?val
                                 )
                               )
                            & trim$!Line:?Line
                            & ( !Line:
                              |     (     !Required/optional/automatic
                                        : ? oneOrMore ?
                                      & addOrInsertOneOrMoreNames
                                    | addOrInsert
                                    )
                                  $ (!PlaceInHeader.!Line.!autogenerated)
                                : ?autogenerated
                              )
                            & !val:~
                            )
                        & !autogenerated
                      |   !Required/optional/automatic:? a ?
                        &   replaceOrInsert
                          $ (!PlaceInHeader.!val.!autogenerated)
                      )
                    : ?autogenerated
                | 
                )
              )
          & !autogenerated
      )
      "
/**
 * doneJob
 *
 * Marks a job as 'done' in jobs.table
 * Constructs a CTBID from date, JobNr and jobID
 * Makes sure there is a row in table CTBs connecting
 *      JobNr, jobID, email and CTBID
 * Creates isDependentOf and isAnnotationOf relations
 * Affected tables:
 *      jobs.table
 *      CTBs.table
 *      relations.table
 * Arguments: jobNR, JobID, spangroup with annotation and date. 
 *
 * Called from workflow.java
 */"
      ( doneJob
      =     A Z JobNr jobID ZZ jobid2 a z files facet S
          , itemId feats prevTitle findOLACTITLEinPreviousSteps
          , ctb ctbid CTBID baseitem filename visibility fromwhere
          , toolURL parms file TITLE BASEITEM DATE meta domain
          , baseitem OLACTITLE DATE EMAIL TBA AVAILABILITY
          , OUTPUTFACET XMLID ITEMS SPANGRP ZZ LANGUAGE identifier
          , userProvidedMetadata autogenerated extent YYY
          , facets type2facet ensureRelation updateOLACTITLE
        .     log$doneJob
            & readTable$jobs
            &   
              : ?TITLE
              : ?BASEITEM
              : ?DATE
              : ?OLACTITLE
              : ?EMAIL
              : ?TBA
              : ?AVAILABILITY
              : ?OUTPUTFACET
              : ?BASEITEM
              : ?XMLID
              : ?ITEMS
              : ?SPANGRP
              : ?LANGUAGE
            &   !arg
              : (@(?:? #?JobNr).%@?jobID ?.?SPANGRP.?DATE)
            & str$(!DATE "-" !JobNr "-" !jobID):?CTBID
            & (readTable$CTBs|:?CTBs)
            & (mail2$!JobNr:?EMAIL|)
            & get$(!SPANGRP,MEM,X,ML):?SPANGRP
            & nestML$!SPANGRP:?SPANGRP
            & ( extent
              =   n recur
                .   0:?n
                  & ( recur
                    =   S
                      .     !arg:? (w.?) ?
                          &   whl
                            ' ( !arg:? (w.?) ?arg
                              & 1+!n:?n
                              )
                        |   whl
                          ' ( !arg:? (?.?,?S) ?arg
                            & recur$!S
                            )
                    )
                  & recur$!arg
                  & !n
              )
            & ( identifier
              =   jobs
                .     readTable$jobs
                    &   !jobs
                      :   ?
                          (!JobNr.!jobID ?.?.?.?.?filename)
                          ?
                    & !filename
                  | 
              )
            & readTable$Uploads
            & readTable$facets
            & (readTable$relations|:?relations)
            & ( ensureRelation
              =   
                .   !relations:? !arg ?
                  | !relations !arg:?relations
              )
            & ( updateOLACTITLE
              =   ELTIT TIT sam TITLE prevTitle OLACTITLE
                .   !arg:(?TITLE.?prevTitle.?OLACTITLE)
                  & (   rev$!TITLE:?ELTIT
                      & @( rev$!prevTitle
                         : ? (?sam&@(!ELTIT:?TIT !sam))
                         )
                      & ( !sam:
                        | !TIT::?TITLE
                        | str$("-" rev$!TIT):?TITLE
                        )
                    | 
                    )
                  & ( !TITLE
                    .   (!OLACTITLE:|!OLACTITLE " ")
                        !TITLE
                    )
              )
            & ( findOLACTITLEinPreviousSteps
              =     jobs Uploads JobNr jobID files
                  , file TITLE prevTitle OLACTITLE
                .     !arg
                    : (?jobs.?Uploads.?JobNr.?jobID.?prevTitle.?OLACTITLE)
                  & (     !jobs
                        : ? (!JobNr.!jobID ?.?files.?) ?
                      &   whl
                        ' ( !files:%?file ?files
                          & (     !Uploads
                                :   ?
                                    ( ?
                                    . ?
                                    . ?
                                    . !file
                                    . ? (TITLE.?TITLE) ?
                                    . ?
                                    )
                                    ?
                              &     updateOLACTITLE
                                  $ (!TITLE.!prevTitle.!OLACTITLE)
                                : (?prevTitle.?OLACTITLE)
                            |     findOLACTITLEinPreviousSteps
                                $ ( !jobs
                                  . !Uploads
                                  . !JobNr
                                  . !file
                                  . !prevTitle
                                  . !OLACTITLE
                                  )
                              : (?prevTitle.?OLACTITLE)
                            )
                          )
                    | 
                    )
                  & (!prevTitle.!OLACTITLE)
              )
            &   whl
              ' (   !jobs
                  :   ?A
                      ( !JobNr
                      .   !jobID
                          (|starting|waiting)
                      . ?ZZ:?files
                      . ?toolURL
                      . ?parms
                      . ?filename
                      )
                      ?Z
                &     !A
                      ( !JobNr
                      . !jobID done
                      . !files
                      . !toolURL
                      . !parms
                      . !filename
                      )
                      !Z
                  : ?jobs
                & ( !CTBs:? (!JobNr.!jobID.!EMAIL.!CTBID) ?
                  |     (!CTBs|)
                        (!JobNr.!jobID.!EMAIL.!CTBID)
                    : ?CTBs
                  )
                & :?prevTitle
                &   whl
                  ' ( !files:%?file ?files
                    & (     !Uploads
                          :   ?
                              (?.?itemId.?.!file.?meta.?feats.?visibility)
                              ?
                        &   (     !meta
                                :   ?
                                    (BASEITEM.@(?:? "dkclarin:" #))
                                    ?
                              & (DKCLARIN.!repoServiceUrl)
                            | (!EMAIL.str$(!EMAIL "::"))
                            )
                          : (?domain.?fromwhere)
                        & ( !ITEMS:? !itemId ?
                          |       !ITEMS
                                  (!ITEMS:|" ")
                                  !fromwhere
                                  !itemId
                              : ?ITEMS
                            &   ensureRelation
                              $ ( !JobNr
                                . !jobID
                                . isDependentOf
                                . !domain
                                . !itemId
                                )
                          )
                        & :?TITLE:?BASEITEM:?DATE
                        &   !meta
                          :   ?
                              ( BASEITEM
                              . @( ?BASEITEM
                                 : ? ("dkclarin:" #:?baseitem)
                                 )
                              )
                              ?
                          : ? (TITLE.?TITLE) ?
                          : ? (DATE.?DATE) ?
                        &   ensureRelation
                          $ ( !JobNr
                            . !jobID
                            . isAnnotationOf
                            . DKCLARIN
                            . !baseitem
                            )
                        &   updateOLACTITLE$(!TITLE.!prevTitle.!OLACTITLE)
                          : (?prevTitle.?OLACTITLE)
                      |       findOLACTITLEinPreviousSteps
                            $ ( !jobs
                              . !Uploads
                              . !JobNr
                              . !file
                              . !prevTitle
                              . !OLACTITLE
                              )
                          : (?prevTitle.?OLACTITLE)
                        & (     !CTBs
                              : ? (!JobNr.!file.?ctb.?ctbid) ?
                            &   ensureRelation
                              $ (!JobNr.!jobID.isDependentOf.!ctb.!ctbid)
                            & ( !ITEMS:? (!ctb.!ctbid) ?
                              |     !ITEMS
                                    (!ITEMS:|" ")
                                    !ctb
                                    "::"
                                    !ctbid
                                : ?ITEMS
                              )
                          | 
                          )
                      )
                    )
                & (   !parms:?+(O.?+(facet.?facet.?)+?)+?
                    & (   readTable$subtype2facet
                        &   !subtype2facet
                          : ? (?OUTPUTFACET.!facet) ?
                      |   readTable$type2facet
                        &   !type2facet
                          : ? (?OUTPUTFACET.!facet) ?
                      |   !facets
                        : ? (?OUTPUTFACET.!facet.?YYY) ?
                      )
                  | 
                  )
                & ( !parms:?+(O.?+(lang.?LANGUAGE.?)+?)+?
                  | 
                  )
                )
            &   whl
              ' (   !jobs
                  :   ?A
                      ( !JobNr
                      . %@?jobid2 ?S
                      . ?a (!jobID,pending) ?z
                      . ?ZZ
                      )
                      ?Z
                &     !A
                      (!JobNr.!jobid2 !S.!a !jobID !z.!ZZ)
                      !Z
                  : ?jobs
                )
            & saveTable$CTBs
            & saveTable$jobs
            & saveTable$relations
            &   ( !SPANGRP:? (TEI.?) ?
                |   tekstXML
                  $ ( !OLACTITLE|
                    . !DATE|
                    . !EMAIL
                    . !CTBID
                    . TBA
                    . AVAILABILITY
                    . !OUTPUTFACET
                    . !BASEITEM|
                    . XMLID
                    . str$!ITEMS
                    . !toolURL
                    . !SPANGRP|
                    . !toolURL
                    . !LANGUAGE
                    )
                )
              : ?autogenerated
            &   toML
              $ (   readTable$jobAbout
                  &   !jobAbout
                    :   ?
                        ( !JobNr
                        .   ?
                            (userProvidedMetadata.?userProvidedMetadata)
                            ?
                        )
                        ?
                  & ( "Code below is WRONG. fpi is CTB and already decided. We cannot just change it. The relations files must mention correct CTBs."
                    |   !userProvidedMetadata:?A (fpi.) ?Z
                      &   !A (fpi.identifier$) !Z
                        : ?userProvidedMetadata
                    | !userProvidedMetadata:? (fpi.?) ?
                    |   (fpi.identifier$) !userProvidedMetadata
                      : ?userProvidedMetadata
                    | 
                    )
                  & (   !userProvidedMetadata:?A (fpi.?) ?Z
                      & !A !Z:?userProvidedMetadata
                    | 
                    )
                  &   inject
                    $ (   (     !autogenerated
                              :   ?
                                  ( TEI
                                  .   ?
                                    ,   ?
                                        ( teiHeader
                                        . ? (type.text) ?,?
                                        )
                                        ?
                                  )
                                  ?
                            & (fen.extent$!SPANGRP)
                          | 
                          )
                          !userProvidedMetadata
                      . !autogenerated
                      . TEImetadata
                      )
                | !autogenerated
                )
          | 
      )
      ( inputResources
      =   
        .   readTable$Uploads
          &   map
            $ ( ( 
                =   item TITLE
                  .       !Uploads
                        :   ?
                            ( ?
                            . ?item
                            . ?
                            . !arg
                            . ? (TITLE.?TITLE) ?
                            . ?
                            . ?
                            )
                            ?
                      & (item.,(id.,!item) (title.,!TITLE))
                    | 
                )
              . !arg
              )
      )
      ( toolName
      =   
        .   readTable$tooladm
          &   !tooladm
            :   ?
              + ( ? (ServiceURL.!arg) ?
                : ? (Title.?arg) ?
                )
              + ?
          & !arg
      )
      ( ToolTitle
      =   
        .     readTable$tooladm
            & (     !tooladm
                  :   ?
                    + ( ? (ToolID.!arg) ?
                      : ? (Title.?arg) ?
                      )
                    + ?
                & !arg
              | str$("ToolTitle:" !arg " does not exist.")
              )
          | str$("ToolTitle:" !arg " tooladm cannot be read.")
      )
      "
/**
 * abortJob
 *
 * Aborts, given a JobNr and a jobID, the specified job and all
 * pending jobs that depend on the output from the (now aborted) job.
 * Rather than removing the aborted jobs from the jobs.table list, they are
 * marked 'aborted'.
 *
 * Called from workflow.java
 */"
      ( abortJob
      =   abort JobNr jobID makeXML todelete
        .   readTable$jobs
          & log$("abortJob " !arg)
          & !arg:(@(?:? #?JobNr).?jobID)
          & (!JobNr.!jobID):?todelete
          & ( abort
            =     JobNr jobID jobid2 A Z ZZ a z
                , URL tool items todelete
              .   !arg:(?JobNr.?jobID) ?todelete
                & log$(abort !arg)
                &   !jobs
                  :   ?A
                      ( !JobNr
                      . !jobID ~aborted
                      .   ?items
                        & inputResources$!items:?items
                      . ?URL&toolName$!URL:?tool
                      . ?ZZ
                      )
                      ?Z
                & log$(going to abort !JobNr !jobID)
                &     !A
                      (!JobNr.!jobID aborted.!items.!URL.!ZZ)
                      !Z
                  : ?jobs
                & log$(aborted !JobNr !jobID)
                &   whl
                  ' (   !jobs
                      :   ?A
                          ( !JobNr
                          . %?jobid2 ?
                          . ?a (!jobID,pending) ?z
                          . ?URL&toolName$!URL:?tool
                          . ?ZZ
                          )
                          ?Z
                    & log$(depending !JobNr !jobid2)
                    &     !A
                          (!JobNr.!jobid2.!a !jobID !z.!URL.!ZZ)
                          !Z
                      : ?jobs
                    & (!JobNr.!jobid2) !todelete:?todelete
                    & log$(todelete !todelete)
                    )
                & log$(delete !todelete)
                & !todelete
            )
          &   whl
            ' ( log$(iterDO !todelete)
              & abort$!todelete:?todelete
              )
          & saveTable$jobs
      )
      ( deleteDepending
      =   jobNr jobID a z
        .   !arg:(?jobNr.?jobID)
          &   whl
            ' ( !CTBs:?a (!jobNr.!jobID.?) ?z
              & !a !z:?CTBs
              )
          &   whl
            ' ( !relations:?a (!jobNr.!jobID.?) ?z
              & !a !z:?relations
              )
          &   whl
            ' ( !jobAbout:?a (!jobNr.?) ?z
              & !a !z:?jobAbout
              )
      )
      ( addurl
      =   URL
        .     !arg:(?arg.?URL)
            & !URL:
            & !arg
          |   ( @(!URL:http ?)
              | str$("http://" !URL):?URL
              )
            & (a.(href.!URL),!arg)
      )
      ( jobMetaData
      =     userProvidedMetadata Metadata Heading Fields
          , listOfFields Val XPath HTML workflow
          , ID TextInUI Required Control Place
          , Notes HelpText Pattern URL type
        .     readTable$jobAbout
            & log$(jobMetaData !arg)
            & (     !jobAbout
                  :   ?
                      ( !arg
                      .   ? (human.?workflow) ?
                        :   ?
                            (userProvidedMetadata.?userProvidedMetadata)
                            ?
                      )
                      ?
                & readTable$TEImetadata:?Metadata
                & log$TEImetadata-READ
                & TEI:?type
                & ( XPath
                  =   el at
                    .     !arg:%?el ?arg
                        & (   !el:(?el.?at)
                            & "/" !el "/@" !at
                          | "/" !el XPath$!arg
                          )
                      | 
                  )
                & ( listOfFields
                  =   List
                    .   :?List
                      &   whl
                        ' (   !arg
                            :   ( ?ID
                                . ?TextInUI
                                . ?Required
                                . ?Control
                                . ?Place
                                . ?Notes
                                . ?HelpText
                                . ?Pattern
                                . ?URL
                                )
                                ?arg
                          & (     !userProvidedMetadata
                                : ? (!ID.?Val) ?
                              &     !List
                                    ( dt
                                    . ,addurl$(localized$!TextInUI.!URL)
                                    )
                                    (dd.,"XPath: " XPath$!Place)
                                    ( dd
                                    .   
                                      ,   localized$(Value Værdi)
                                          ": "
                                          ( strong
                                          .   
                                            , !Val:~|" "
                                          )
                                    )
                                : ?List
                            | 
                            )
                          )
                      & !List
                  )
                & :?HTML
                &   whl
                  ' (   !Metadata
                      : ? (?Heading,?Fields) ?Metadata
                    &     !HTML
                          (h2.,localized$!Heading)
                          (dl.,listOfFields$!Fields)
                      : ?HTML
                    )
                & (!HTML.!type)
              | log$NOuserProvidedMetadata&(.)
              )
          | log$CannotReadjobAbout&(.)
      )
      ( doneAllJobSub
      =     A Z JobNr JobId filelist filename aborted done
          , letterData items URL tool
          , I O workflow
        .   readTable$jobs
          & log$("doneAllJobSub " !arg)
          & :?filelist
          & @(!arg:? #?JobNr)
          & readTable$CTBs
          & readTable$relations
          & readTable$jobAbout
          & (   !jobAbout
              : ? (!JobNr.? (human.?workflow) ?) ?
            | :?workflow
            )
          &   whl
            ' ( :?aborted:?done
              &   !jobs
                :   ?A
                    ( !JobNr
                    .   %@?JobId
                        (   aborted:?aborted
                          & :?done
                        |   done:?done
                          & :?aborted
                        |   ( 
                            | starting
                            | waiting
                            )
                          & :?aborted:?done
                        )
                    .   ?items
                      & inputResources$!items:?items
                    . ?URL&toolName$!URL:?tool
                    .   ?+(I.?I)+?:?+(O.?O)+?
                      | ?&:?I:?O
                    . ?filename
                    )
                    ?Z
              & !A !Z:?jobs
              & deleteDepending$(!JobNr.!JobId)
              &     !filelist
                    ( !JobNr
                    . !JobId
                    .   !aborted:aborted&fejl
                      | !filename
                    . !items
                    . !tool
                    . !I
                    . !O
                    .     ( !aborted:aborted
                          |   !Z
                            : ? (!JobNr.?.? !JobId ?.?) ?
                          )
                        & 
                      | LAST
                    )
                : ?filelist
              )
          & saveTable$jobs
          & saveTable$CTBs
          & saveTable$relations
          & saveTable$jobAbout
          & ( letterData
            =   Steps menneskesprog
              .   readTable$features
                & ( menneskesprog
                  =     desc featdesc feature featvals featname
                      , table specificationTables
                    .   :?desc
                      &   whl
                        ' ( !arg:(?feature.?featvals.?)+?arg
                          &   !features
                            :   ?
                              + ( ? (short.!feature) ?
                                : ? (name.?featname) ?
                                : ? (table.?table) ?
                                : (   ?
                                      (specificationTable.?specificationTables)
                                      ?
                                  |   ?
                                    & :?specificationTables
                                  )
                                )
                              + ?
                          &     describefeature
                              $ (!featvals.!table.!specificationTables)
                            : ?featdesc
                          & ( !featdesc:
                            |     !desc
                                  (!desc:|", ")
                                  localized$!featname
                                  "="
                                  !featdesc
                              : ?desc
                            )
                          )
                      & str$!desc
                  )
                & ( Steps
                  =     x items tool JobNr JobId
                      , format I O format stage
                    .       !arg
                          :   ( ?JobNr
                              . @(?:? #?JobId)
                              . ?x
                              . ?items
                              . ?tool
                              . ?I
                              . ?O
                              . ?stage
                              )
                              ?arg
                        &   ( step
                            .   
                              ,   (JobNr.,!JobNr)
                                  (JobId.,!JobId)
                                  (name.,!x)
                                  (tool.,!tool)
                                  (items.,!items)
                                  (input.,menneskesprog$!I)
                                  (output.,menneskesprog$!O)
                                  ( format
                                  .   
                                    ,       !O
                                          : ?+(format.?format.?)+?
                                        & !format
                                      | 
                                  )
                                  (stage.,!stage)
                            )
                            Steps$!arg
                      | 
                  )
                & (workflow.,!workflow) (steps.,Steps$!arg)
            )
          & letterData$!filelist
      )
      ( filenameWithoutXMLextension
      =   base
        .   @(!arg:?base "." ~(? "." ?))&!base
          | !arg
      )
      ( Filename
      = .str$(filenameWithoutXMLextension$!arg ".withmetadata.xml")
      )
      (FilenameNoMetadata=.!arg)
      ( FilenameRelations
      = .str$(filenameWithoutXMLextension$!arg ".relations.csv")
      )
      ( readme
      =     jobNr date yyyy mm dd letter File Files
          , inputs results
        .     !arg
            : ( ?jobNr
              . @( ?date
                 :   (% % % %:?yyyy)
                     (% %:?mm)
                     (% %:?dd)
                 )
              . ?letter
              )
          & readTable$Uploads
          & :?Files:?inputs:?results
          &   whl
            ' ( @(!letter:? "file:" ?File ";" ?letter)
              & (@(!File:? "*" ?File)|)
              &     !Files
                    "    "
                    !File
                    (   !Uploads:? (?.!File.?) ?
                      & !inputs !File ",\r\n  ":?inputs
                      & " (input)"
                    |   @(!File:? ".xml")
                      & !results !File ",\r\n  ":?results
                      & 
                    | 
                    )
                    \r\n
                : ?Files
              )
          &   str
            $ ( README
                \r\n
                !yyyy
                "."
                !mm
                "."
                !dd
                \r\n\r\n
                "job "
                !jobNr
                \r\n\r\n
                "zip-filen ("
                !jobNr
                ".zip) indeholder:"
                \r\n
                ( !inputs:
                |   "- "
                    !inputs
                    "som er "
                    ( !inputs:@ @&inputfilen
                    | inputfilerne
                    )
                    \r\n\r\n
                )
                ( !results:
                |   "- "
                    !results
                    "som er "
                    ( !results:@ @&resultatet
                    | resultater
                    )
                    ", dvs. "
                    ( !results:@ @&inputteksten
                    | inputtekst
                    )
                    " klargjort til deponering."
                    \r\n
                    "  "
                    ( !results:@ @&"Denne fil"
                    | "Disse filer"
                    )
                    " kan deponeres i CLARIN.DK’s repositorie eller bruges som input"
                    \r\n
                    "  til annotering vha. CLARIN.DK’s værktøjer."
                    \r\n\r\n
                )
                "- index.html som indeholder detaljer om klargøringsprocessen, herunder de"
                \r\n
                "  metadata der blev angivet i interfacet samt beskrivelser af de anvendte"
                \r\n
                "  værktøjer."
                \r\n\r\n
                (   !inputs:
                  &   "- CMDI.xml som er CMDI metadatafilen som kan uploades sammen med din dataresurse."
                      \r\n\r\n
                |   "- resten er filerne er mellemtrin som du kan se bort fra hvis processen er"
                    \r\n
                    "  forløbet korrekt. Hvis der er fejl i den klargjorte tekst, er det sikrest"
                    \r\n
                    "  at rette i et af mellemtrinnene og uploade denne fil til klargøring igen."
                    \r\n
                    "  Det er ikke tilrådeligt at rette i tekstdelen i "
                    ( !results:@ @&filen
                    | filerne
                    )
                    "\r\n  "
                    !results
                    "da hvert enkelt ord er unik nummereret hvilket er krævet i den videre"
                    \r\n
                    "  lingvistiske processering. Metadataene kan man dog rolig rette i."
                    \r\n\r\n
                    "  Filerne er genereret i følgende rækkefølge:"
                    \r\n
                    !Files
                )
                \r\n\r\n
                "Hvis du har brug for hjælp til at deponere dine data eller har andre spørgsmål"
                \r\n
                "er du velkommen til at henvende dig til info@clarin.dk"
                \r\n
              )
      )
      ( letter
      =     workflow steps resources files inps Steps html
          , metadata explain type shortletter
        .   ( inps
            =   a
              .     !arg:%?a ?arg
                  &   (a.(href.!a),!a)
                      (br.,)
                      inps$!arg
                | 
            )
          & ( explain
            =   explanation
              .     !fileFormats:? (?.!arg.?explanation) ?
                  & !explanation:~
                  & " (" localized$!explanation ") "
                | 
            )
          & ( Steps
            =     body JobNr JobId filename tool
                , items I O format id title fil
                , Href2 Href2nometa Href2relations
                , stage steps shortletter
              .   !arg:(?steps.?shortletter)
                &     map
                    $ ( ( 
                        =   
                          .     !arg
                              : ( step
                                .   
                                  ,   (JobNr.,?JobNr)
                                      (JobId.,?JobId)
                                      (name.,?filename)
                                      (tool.,?tool)
                                      (items.,?items)
                                      (input.,?I)
                                      (output.,?O)
                                      (format.,?format)
                                      (stage.,?stage)
                                )
                            &   whl
                              ' (   !items
                                  :   ( item
                                      .   
                                        ,   ? (id.,?id) ?
                                          : ? (title.,?title) ?
                                      )
                                      ?items
                                & ( !resources:? !title ?
                                  |   !resources !title:?resources
                                    & (     !Uploads
                                          :   ?
                                              (?.!title.?.?fil.?)
                                              ?
                                        & ( !shortletter:y
                                          |     !files
                                                "file:"
                                                !fil
                                                "*"
                                                !title
                                                ";"
                                            : ?files
                                          )
                                      | 
                                      )
                                  )
                                )
                            & (   @(!filename:fejl ?)
                                & log$fejl
                                &   ( h2
                                    .   
                                      ,   localized
                                        $ ( "The following step(s) failed:"
                                            "Følgende trin fejlede:"
                                          )
                                    )
                                    ( dl
                                    .   
                                      ,   ( dt
                                          .   
                                            , ( strong
                                              .   
                                                ,   str
                                                  $ (   localized
                                                      $ ("Step " "Trin ")
                                                      !JobId
                                                    )
                                              )
                                          )
                                          (dd.,!tool)
                                    )
                              |   ( !shortletter:~y
                                  | !stage:LAST
                                  )
                                & Filename$!filename:?Href2
                                &   FilenameNoMetadata$!filename
                                  : ?Href2nometa
                                &   FilenameRelations$!filename
                                  : ?Href2relations
                                &   ( dt
                                    .   
                                      , ( strong
                                        .   
                                          ,   str
                                            $ ( localized$("Step " "Trin ")
                                                !JobId
                                                (   !shortletter:y
                                                  & 
                                                |   !stage:LAST
                                                  &   localized
                                                    $ (" (last)" " (sidste)")
                                                | 
                                                )
                                              )
                                        )
                                    )
                                    ( dd
                                    .   
                                      ,     @(!O:? TEI ?)
                                          & (   !format:txtann
                                              &     !files
                                                    "file:"
                                                    !Href2
                                                    ";file:"
                                                    !Href2relations
                                                    ";file:"
                                                    !Href2nometa
                                                    ";"
                                                : ?files
                                              &   str$(!tool ": ")
                                                  ( a
                                                  .   (href.!Href2)
                                                    ,   localized
                                                      $ ( "including metadata"
                                                          "inklusiv metadata"
                                                        )
                                                  )
                                                  ","
                                                  ( a
                                                  .   (href.!Href2relations)
                                                    , !relationsfil
                                                  )
                                                  ", "
                                                  ( a
                                                  .   (href.!Href2nometa)
                                                    ,   localized
                                                      $ ( "without metadata"
                                                          "uden metadata"
                                                        )
                                                  )
                                            |       !files
                                                    "file:"
                                                    !Href2
                                                    "*"
                                                    !filename
                                                    ";"
                                                : ?files
                                              &   str$(!tool ": ")
                                                  ( a
                                                  .   (href.!filename)
                                                    , basistekst
                                                  )
                                                  explain$!format
                                            )
                                        |       !files
                                                "file:"
                                                !Href2nometa
                                                "*"
                                                !filename
                                                ";"
                                            : ?files
                                          &   str$(!tool ": ")
                                              ( a
                                              .   (href.!filename)
                                                , data
                                              )
                                              explain$!format
                                    )
                                    ( !I:!O:
                                    | ( dl
                                      .   
                                        ,   ( !I:
                                            |   (dt.,Input)
                                                (dd.,!I)
                                            )
                                            ( !O:
                                            |   (dt.,Output)
                                                (dd.,!O)
                                            )
                                      )
                                    )
                              )
                        )
                      . !steps
                      )
                  : ?body
                & (dl.,!body)
            )
          & !arg:(?arg.?shortletter)
          & "shortletter: y or n"
          &   ( 
              =   zippedresults zipfile
                .   ( readTable$zippedresults
                    | :?zippedresults
                    )
                  & str$(!arg ".zip"):?zipfile
                  & ( !zippedresults:? !zipfile ?
                    | !zipfile !zippedresults:?zippedresults
                    )
                  & saveTable$zippedresults
              )
            $ !arg
          & jobMetaData$!arg:(?metadata.?type)
          & readTable$fileFormats
          & readTable$Uploads
          &   doneAllJobSub$!arg
            : (workflow.,?workflow) (steps.,?steps)
          & lst$(steps,path$steps,NEW)
          & :?resources:?files
          &     toML
              $ ( html
                .   
                  ,   ( head
                      .   
                        ,   (meta.charset.UTF-8)
                            ( title
                            .   
                              ,   localized
                                $ ( "Results from CLARIN-DK tools"
                                    "Resultater fra Tools"
                                  )
                            )
                      )
                      ( body
                      .   (class.bodycanvas)
                        ,   (h1.,localized$(Results Resultater))
                            (h2.,Workflow)
                            (p.,!workflow)
                            (h2.,localized$(Steps Trin))
                            (dl.,Steps$(!steps.!shortletter))
                            ( !shortletter:y&
                            |   ( h2
                                .   
                                  ,   localized
                                    $ ( "Input to the workflow:"
                                        "Workflowets input:"
                                      )
                                )
                                (p.,inps$!resources)
                            )
                            !metadata
                      )
                )
            : ?html
          & str$(!files !html)
      )
      ( pipeSegmentFields
      =     XML tool output input xml spec A
          , values value feature vallist
          , goal inputprop indent limitedTable
          , featname
          , whlvalues
        .   ( limitedTable
            =     featname row rows abbs table abbr
                , feattable specificationTables YYY
              .   !arg:(?featname.?abbs)
                & readTable$features
                &   !features
                  :   ?
                    + ( ( ? (short.!featname) ?
                        | ? (name.? !featname ?) ?
                        )
                      : ? (table.?feattable) ?
                      : (   ?
                            (specificationTable.?specificationTables)
                            ?
                        | ?&:?specificationTables
                        )
                      )
                    + ?
                & readTable$!feattable
                & !!feattable:?table
                & :?rows
                & (   !table
                    :   ?
                        ( ( (?.?abbr.?YYY)
                          & !abbs:? !abbr ?
                          )
                        : (?row&!rows !row:?rows)
                        )
                        (?&~)
                  | !rows
                  )
            )
          & !arg:(?arg.?indent)
          & :?XML
          & ( whlvalues
            =     values spec xml opt opts
                , feature specificationTables table xm
                , term
                , getfullspec getfullvalue
              .   !arg:(%?values ?opts.?xml.?feature)
                & ( readTable$features
                  &   !features
                    :   ?
                      + ( ( ? (short.!feature) ?
                          | ? (name.? !feature ?) ?
                          )
                        : ? (table.?table) ?
                        )
                      + ?
                  & (   !features
                      :   ?
                        + ( ( ? (short.!feature) ?
                            | ? (name.? !feature ?) ?
                            )
                          :   ?
                              (specificationTable.?specificationTables)
                              ?
                          )
                        + ?
                    | :?specificationTables
                    )
                  )
                & readTable$!table
                & ( getfullvalue
                  =   full YYY
                    .     !!table:? (?full.!arg.?YYY) ?
                        & localized$!full
                      | !arg
                  )
                & ( getfullspec
                  =   table value spec full YYY
                    .   !arg:(?value.?spec)
                      & (   !spec:1
                          & NEWSPEC
                          & 
                        |     !specificationTables
                            :   ?
                                (? (%@:!value) ?.?table)
                                ?
                          & readTable$!table
                          & (     !!table
                                : ? (?full.!spec.?YYY) ?
                              & localized$!full
                            | !spec
                            )
                        | !spec
                        )
                  )
                &   whl
                  ' ( !values:%?term+?values
                    & :?xm
                    &   whl
                      ' ( !term:%?value^?spec*?term
                        & NEWSPEC
                        &     !xm
                              (!xm:|", ")
                              ( span
                              .   
                                ,   \r\n
                                    getfullvalue$!value
                                    (   !spec:1
                                      & NEWSPEC
                                      & 
                                    | "(" getfullspec$(!value.!spec) ")"
                                    )
                              )
                              \r\n
                          : ?xm
                        )
                    & !xml !xm:?xml
                    )
                &   whl
                  ' ( !opts:%?opt^?spec ?opts
                    & NEWSPEC
                    &     !xml
                            Field
                          $ ( optional
                            . 
                            .   !opt
                                (   !spec:1
                                  & NEWSPEC
                                  & 
                                |   Field
                                  $ (spec..getfullspec$(!opt.!spec))
                                )
                            )
                      : ?xml
                    )
                & !xml
            )
          & (   !arg:%+%
              &   Field
                $ ( pipes
                  . 
                  .     whl
                      ' ( !arg:%?A+?arg
                        &   !XML pipeSegmentFields$(!A.!indent+1)
                          : ?XML
                        )
                    & !XML
                  )
            |   !arg:%*%
              &   Field
                $ ( merge
                  . 
                  .     whl
                      ' ( !arg:%?A*?arg
                        &   !XML pipeSegmentFields$(!A.!indent+1)
                          : ?XML
                        )
                    & !XML
                  )
            |   !arg:(?tool,(?output.?inputprop.?input))
              & ToolTitle$!tool:?tool
              &     !XML
                      Field
                    $ ( pipe
                      . 
                      .   Field$(tool..!tool)
                            Field
                          $ ( output
                            . 
                            . pipeSegmentFields$(!output.!indent+1)
                            )
                            Field
                          $ ( input
                            . 
                            . pipeSegmentFields$(!input.!indent+1)
                            )
                      )
                : ?XML
            |   !arg:(?goal.?arg)
              & pipeSegmentFields$(!arg.!indent+1)
            |   Field
              $ ( features
                . 
                .     whl
                    ' ( !arg:(?feature,?values) ?arg
                      &   !features
                        :   ?
                          + ( ( ? (short.!feature) ?
                              | ? (name.? !feature ?) ?
                              )
                            : ? (name.?featname) ?
                            )
                          + ?
                      &     !XML
                              Field
                            $ ( localized$!featname
                              . 
                              .   :?xml
                                & (   !values:%+%
                                    & :?vallist
                                    &   whl
                                      ' ( !values:%?value^?+?values
                                        & !value !vallist:?vallist
                                        )
                                    &     !xml
                                            paragraph
                                          $ ( makeSelectFormField
                                            $ (     localized
                                                  $ ("Choose a " "Vælg et ")
                                                  !feature
                                              . IETS
                                              . options
                                              .   makeOptionList
                                                $ (   limitedTable
                                                    $ (!feature.!vallist)
                                                  . 
                                                  )
                                              )
                                            )
                                      : ?xml
                                  | whlvalues$(!values.!xml.!feature)
                                  )
                              )
                        : ?XML
                      & 
                      )
                  & !XML
                )
            )
      )
      (pipeAsXML=.str$(!XMLdeclaration pipeSegmentXML$!arg))
      ( Intersection
      =   x y f v I e g w V W h
        .   !arg:(?x.?y)
          & :?I
          &   (   !x
                :   ?
                    (?f,@?v^?e:?V)
                    ( ?
                    & (   !y:? (!f,@?w^?g:?W) ?
                        & ( !w:~!v
                          |   !e:~1
                            & !g:~1
                            & !e:~!g
                          |   (   (!e:~1|!g:~1)
                                & !e*!g:%?h^?
                              | 1:?h
                              )
                            & (!f,!v^!h) !I:?I
                          )
                      | (!f,!v^!e) !I:?I
                      )
                    & ~
                    )
              |   !y
                :   ?
                    ( ?f
                    ,   @?v^?e:?V
                      & ~(!I:? (!f,!V) ?)
                    )
                    ( ?
                    & (   !x:? (!f,@?w^?g:?W) ?
                        & ( !w:~!v
                          |   !e:~1
                            & !g:~1
                            & !e:~!g
                          |   (   (!e:~1|!g:~1)
                                & !e*!g:%?h^?
                              | 1:?h
                              )
                            & (!f,!v^!h):?V
                            & ( !I:? !V ?
                              | !V !I:?I
                              )
                          )
                      |   (!f,!v^!e):?V
                        & (!I:? !V ?|!V !I:?I)
                      )
                    & ~
                    )
              | !I
              )
            : ?I
          & sort$!I:?I
          & !I
      )
      ( supplement
      =   f v NF OF e A Z G
        .   !arg:(?NF.?OF)
          & (   !OF
              :   ?
                  (?f,%?v^?e)
                  ( ?
                  & (   ~(!NF:? (!f,?) ?)
                      & (!f,!v^!e) !NF:?NF
                    |   !e:~1
                      & !NF:?A (!f,!v^?G) ?Z
                      & (   !G:(1|!e)
                          & !A (!f,!v^!e) !Z:?NF
                        | 
                        | log$(COLLISIONsupplement !e and !G in !arg)
                        )
                    )
                  & ~
                  )
            | sort$!NF
            )
      )
      ( percolateForgottenFeatures
      =     pipes F updateOFwithNF NN
          , FeatureList Results pipe1 pipe2 pipe3
          , fromMethods fromResultMethod fromToolOrSource
          , toMethods toResultMethod toTool
          , UpdateResultsFromMethods oUts
          , validateInputsForEachTool
        .   ( updateOFwithNF
            =   OF NF f v A Z e E
              .   !arg:(?OF.?NF)
                & (   !NF
                    :   ?
                        (?f,@?v^?e)
                        ( ?
                        & (   !OF:?A (!f,!v^?E) ?Z
                            & ( (!e:!E|!E:~1)
                              | !A (!f,!v^!e) !Z:?OF
                              )
                          |   !OF:?A (!f,?) ?Z
                            & !A (!f,!v^!e) !Z:?OF
                          | (!f,!v^!e) !OF:?OF
                          )
                        & ~
                        )
                  | sort$!OF
                  )
            )
          & ( FeatureList
            =   OF NF
              .   !arg:((@?,~(?.?)) ?:?NF.?OF)
                & (supplement$(!NF.!OF).updateOFwithNF$(!OF.!NF))
            )
          & ( oUts
            =   R F
              .   1:?R
                &   whl
                  ' ( !arg:(?,(?F.?))*?arg
                    & !F*!R:?R
                    )
                & !R
            )
          & ( Results
            =   L R OF LF RF
              .     !arg:(%?L*%?R.?OF)
                  & Results$(!R.!OF):(?R.?RF)
                  & FeatureList$(!L.!OF):(?L.?LF)
                  & (!L*!R.Intersection$(!RF.!LF))
                | FeatureList$!arg
            )
          & ( fromToolOrSource
            =   OF LF RF tool meta output sub
              .     !arg:(?tool,(?output.?meta.?sub).?OF)
                  & fromResultMethod$(!sub.!OF):(?sub.?RF)
                  & FeatureList$(!output.!RF):(?output.?LF)
                  & ( !tool,(!output.supplement$(!meta.!RF).!sub)
                    . !LF
                    )
                | FeatureList$!arg
            )
          & ( fromMethods
            =   L R OF LF RF
              .   !arg:(?arg.?OF)
                & (   !arg:%?L*%?R
                    & fromMethods$(!R.!OF):(?R.?RF)
                    & fromToolOrSource$(!L.!OF):(?L.?LF)
                    & (!L*!R.Intersection$(!RF.!LF))
                  | fromToolOrSource$(!arg.!OF)
                  )
            )
          & ( UpdateResultsFromMethods
            =   results methods nres result
              .   !arg:(?results.?methods)
                & 1:?nres
                &   whl
                  ' ( !results:%?result*?results
                    &     (   !methods:?*!result*?
                            & !result
                          |   map
                            $ ( ( 
                                =   F v e E
                                  .   !arg:(?F,%@?v^?e)
                                    & (     !methods
                                          : ?*(? (!F,!v^?E) ?)*?
                                        & (   !e:1
                                            & (!F,!v^!E)
                                          | (!F,!v^!e)
                                          )
                                      | (!F,!v^!e)
                                      )
                                )
                              . !result
                              )
                          )
                        * !nres
                      : ?nres
                    )
                & !nres
            )
          & ( fromResultMethod
            =   results methods OF NF
              .     !arg:((?results.?methods).?OF)
                  & fromMethods$(!methods.!OF):(?methods.?NF)
                  & (   UpdateResultsFromMethods$(!results.oUts$!methods)
                      : ?results
                    | 
                    )
                  & ((!results.!methods).!NF)
                | Results$!arg
            )
          & ( toTool
            =   OF LF RF tool meta output sub
              .   !arg:(?arg.?OF)
                & (   !arg:(?tool,(?output.?meta.?sub))
                    & FeatureList$(!output.!OF):(?output.?LF)
                    & toResultMethod$(!sub.!LF):(?sub.?RF)
                    & ( !tool,(!output.supplement$(!meta.!LF).!sub)
                      . !RF
                      )
                  |   !arg:(|(?,?) ?)
                    & FeatureList$(!arg.!OF)
                  )
            )
          & ( toMethods
            =   L R OF LF RF
              .   !arg:(?arg.?OF)
                & (   !arg:%?L*%?R
                    & toMethods$(!R.!OF):(?R.?RF)
                    & toTool$(!L.!OF):(?L.?LF)
                    & (!L*!R.Intersection$(!RF.!LF))
                  | toTool$(!arg.!OF)
                  | !arg:(@,?)&(!arg.!OF)
                  )
            )
          & ( toResultMethod
            =   results methods OF NF
              .   !arg:(?arg.?OF)
                & (   !arg:(?results.?methods)
                    & Results$(!results.!OF):(?results.?NF)
                    & toMethods$(!methods.!NF):(?methods.?NF)
                    & ((!results.!methods).!NF)
                  | Results$(!arg.!OF)
                  )
            )
          & ( validateInputsForEachTool
            =   recr
              .   "Every input spec shall be identical to an output
                   spec of an immediately preceding tool."
                & ( recr
                  =   a b A aa t
                    .     !arg:%?a*%?b
                        & recr$!a
                        & recr$!b
                      | !arg:(?t,(?.?.(?,?) ?))
                      | !arg:(?,~(?.?)) ?
                      |   !arg:(?t,(?.?.?a:?aa.?b))
                        & recr$!b
                        &   whl
                          ' ( !a
                            :   ( %?A
                                &   !b
                                  : (?*(?,(!A.?))*?|?*!A*?)
                                )
                              * ?a
                            )
                        & ( !a:1
                          |   ( 
                              |   log
                                $ ( "In feature bundle"
                                    !A
                                    str$(\n "of tool")
                                    !t
                                    str$(\n "with input")
                                    !aa
                                      str
                                    $ ( \n
                                        "mismatch with outputs of preceding tools"
                                      )
                                    oUts$!b
                                    "arg (suppressed)"
                                  )
                              )
                            & ~
                          )
                  )
                & !arg:(?.?arg)
                & recr$!arg
            )
          & 0:?pipes
          & 0:?NN
          &   whl
            ' ( !arg:%?pipe1+?arg
              & 1+!NN:?NN
              & fromResultMethod$(!pipe1.):(?pipe2.?F)
              & toResultMethod$(!pipe2.!F):(?pipe3.?)
              & ( !pipe3:0
                |   (~|validateInputsForEachTool$!pipe3)
                  & (   !pipes:?+(?.!pipe3)+?
                      & log$"pipe3 already added"
                    | !pipe3+!pipes:?pipes
                    )
                | 
                )
              )
          & !pipes
      )
      ( prunePipes
      =     As Ax NNN Z ax incarnationpipes parms
          , newpipes pipe pipes pipesN restriction
        .   !arg:(?pipes.?parms)
          & 0:?newpipes
          &   whl
            ' ( !pipes:((?.?):?incarnationpipes)+?pipes
              & "incarnationpipes is (<(user or declared tool) provided output specs> . <sum of unambiguous trees>)"
              & log$"now unfoldTree"
              & "TODO 20190917: do not have workflows with two or more tools that do exactly the same thing.
                Strategy: 
                (1) search for a sum. 
                (2) Iterate over that sum. 
                (3) For each term, produce a (possibly still ambiguous) workflow by projecting each sum that contains that
                    term on that term. So if a sum contains the current term, ignore all terms but the current term.
                (4) Repeat this for each new workflow.
                (5) The result is a list of unambiguous workflows in which no task is performed by two different tools."
              & selectCommonTracks$!incarnationpipes:?As
              & 0:?pipesN
              &   whl
                ' ( !As:%?Ax+?As
                  & unfoldTree$(1.!Ax):?Z
                  &   whl
                    ' ( !Z:(?.?ax)+?Z
                      & !pipesN+!ax:?pipesN
                      )
                  )
              & "The 1 is the initial stop list, which is formed as a product."
              & log$"unfoldTree done"
              & "pipesN is (<user provided output specs> . <unfolded tree>) + ..."
              & !pipesN:?+[?NNN
              & (   !parms:? (desiredtool.?restriction) ?
                  & !restriction:~
                  & filter$(!pipesN.!restriction):?pipesN
                | 
                )
              & percolateForgottenFeatures$!pipesN:?pipesN
              & !pipesN:?+[?NNN
              &   whl
                ' ( !pipesN:%?pipe+?pipesN
                  & wantThis$!pipe:?pipe
                  & ( !pipe:0
                    | !newpipes:?+!pipe+?
                    | !pipe+!newpipes:?newpipes
                    )
                  )
              )
          & !newpipes
      )
      "
/**
 * create
 *
 * Prepare and run a workflow.
 * Functions as a wizard, taking input from various stages.
 * The function handles two scenarios:
 *      create a resource by choice of goal ('hairdresser')
 *      create a resource by choice of tool ('wizard')
 * Arguments:
 *      - http parameters
 *      - directedBy=  GoalChoice (default) 
 * http parameters:
 *      mail2=<address>
 *      action=batch | batch=on | batch=off
 *      TOOL=<toolname>
 *      bsubmit=nextStep|prev<N>|next<N>|Submit|View details
 *      (item=<itemid>)+
 *      (Item=<itemid>)+
 *      I<feature>=<featurevalue>
 *      O<feature>=<featurevalue>
 * itemid's are of the form dkclarin:188028
 * features are (currently): facet, format and lang
 * feature values are complex strings consisting of a feature value and,
 * optionally, a specialisation of the feature values, separated from the
 * former by a caret.
 *
 * Called from create.java
 */"
      ( create
      =     Tool item parms Items methodName
          , formFields val mail2 password ERR
          , Submit pipes pipe windFW reqs req descr
          , JobStack JobNr presels hid feats analyzeInput
          , TOOL errors batch checkMail desiredTools
          , jobIDoffset subjobs Sources sourcesAndGoals
          , directedBy nth unpackIOparms BodyContainer
          , nicify handle checkIOparms PIPE lookForLanguage
          , precooked-DASISH A wrkflw Z errmsg
          , analyseContentType makeJobStack NoNeedForMetadata
          , ApplyThePipelineToTheInput NoWay TooManyOrNone
          , ShowAllPipes ShowOnlyTheCurrentPipe AddMetadata
          , "We are at the start. Show an input form."
          , "We are past the first stage: the user has pressed a button"
          , errorInMetadata rstr
          , MetadataInParms canConsumeMetadata
          , NoValueConflicts Subst Tubst
          , adaptInputProfile containedBy
          , rememberMetadata
          , rpl signatures clashing unif copySpecs wantThis
          , computeWorkflow computeWorkflowDASISH
        .   ( analyseContentType
            =   R spec nofonts ct isDiplom input getInput
              .   !arg:(?arg.?nofonts)
                & log$(analyseContentType !arg nofonts !nofonts)
                & @( !arg
                   : ((%? "/" %?:?ct) ";" ?|?ct)
                   )
                & ( getInput
                  = .@(get$(str$(!DestinationDir !LocalFileName),STR))
                  )
                & ( isDiplom
                  =   N lang input
                    .   0:?lang
                      & !arg:?input
                      &     vap
                          $ ( ( 
                              =   N la
                                .     vap$((=.!arg).!arg."|")
                                    : ? [?N
                                    : (   (%@:@(?:? Language ?))
                                          ( %@
                                          : @( ?
                                             :   ?
                                                 (   ( dan
                                                     | lat
                                                     | mlg
                                                     | swe
                                                     )
                                                   : ?la
                                                 & !la+!lang:?lang
                                                 )
                                                 ?
                                             )
                                          )
                                      | ?
                                      )
                                  & !N
                              )
                            . !input
                            . \n
                            )
                        : ? (~<17:?N) !N !N ?
                      &   (app.unn)
                          (facet.tok)
                          (format.dipl)
                          (   !lang:#*%@?lang
                            & ( lang
                              .   !lang:lat&la
                                | !lang:dan&da
                                | !lang:mlg&gml
                                | !lang:swe&sv
                              )
                          | 
                          )
                          (period.c13)
                          (pres.nml)
                  )
                & ( isTabSeparated
                  =   L H e empty
                    .   :?e
                      & (   @(!arg:? \t ? \n ? \t ? \n ?)
                          & -1:?L:?H
                          &   vap
                            $ ( ( 
                                =   
                                  .     vap$((=..).!arg.\t)
                                      : ? [?K
                                    & (   !K:1
                                        & trim$!arg:
                                        & e:?e
                                      |   !e:?empty
                                        & (   !L:-1
                                            & !K:?L
                                          | !K:<!L:?L
                                          | 
                                          )
                                        & (   !H:-1
                                            & !K:?H
                                          | !K:>!H:?H
                                          | 
                                          )
                                      )
                                )
                              . !arg
                              . \n
                              )
                          & !L:!H
                          & (4:<!L:?L|)
                          & (format.str$(!L col !empty))
                        |     vap$((=.trim$!arg).!arg.\n)
                            : ~(? @(?:? " " ?) ?)
                          & (format.1col)
                        )
                  )
                &   !ct
                  : (   application/pdf
                      &     (   !nofonts:true
                              & (app.rom)
                            | (app.nrm)
                            )
                            (facet.txt)
                            ( format
                            .     !nofonts:true
                                & img^pdf
                              | pdf
                            )
                        : ?R
                    |   "application/vnd.ms-powerpoint"
                      &     (app.nrm)
                            (facet.txt)
                            (format.ppt)
                        : ?R
                    |   "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                      &     (app.nrm)
                            (facet.txt)
                            (format.pptx)
                        : ?R
                    |   "application/vnd.oasis.opendocument.presentation"
                      &     (app.nrm)
                            (facet.txt)
                            (format.odp)
                        : ?R
                    |   "application/vnd.ms-excel"
                      &     (app.nrm)
                            (facet.txt)
                            (format.xls)
                        : ?R
                    |   "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                      &     (app.nrm)
                            (facet.txt)
                            (format.xlsx)
                        : ?R
                    |   "application/vnd.oasis.opendocument.spreadsheet"
                      &     (app.nrm)
                            (facet.txt)
                            (format.ods)
                        : ?R
                    |   ( application/x-download
                        | application/octet-stream
                        )
                      & getInput$:?input
                      & ( @( !input
                           : ( ("%PDF" ?|"%pdf" ?)
                             &     (   !nofonts:true
                                     & (app.rom)
                                   | (app.nrm)
                                   )
                                   (facet.txt)
                                   ( format
                                   .     !nofonts:true
                                       & img^pdf
                                     | pdf
                                   )
                               : ?R
                             )
                           )
                        | isDiplom$!input:?R
                        | isTabSeparated$!input:?R
                        | :?R
                        )
                    |   application/msword
                      & @( get$(str$(!DestinationDir !LocalFileName),STR)
                         : (   ? rtf [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.rtf)
                               : ?R
                           |   ? xml [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.xml)
                               : ?R
                           |   PK ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.docx)
                               : ?R
                           |   ? [<9
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.doc)
                               : ?R
                           |   ?
                             & (app.nrm) (facet.txt):?R
                           )
                         )
                    |   "application/vnd.oasis.opendocument.text"
                      & @( get$(str$(!DestinationDir !LocalFileName),STR)
                         : (   PK ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.odt)
                               : ?R
                           |   ?
                             & (app.nrm) (facet.txt):?R
                           )
                         )
                    |   application/octet-stream
                      & @( get$(str$(!DestinationDir !LocalFileName),STR)
                         : (   ? rtf [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.rtf)
                               : ?R
                           |   ? xml [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.xml)
                               : ?R
                           |   ?
                             & (app.nrm) (facet.txt):?R
                           )
                         )
                    |   "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                      &     (app.nrm)
                            (facet.txt)
                            (format.docx)
                        : ?R
                    |   application/json
                      & (format.json) (app.drty):?R
                    |   text/html
                      &     (app.nrm)
                            (facet.txt)
                            (format.html)
                        : ?R
                    |   text/rtf
                      &     (app.nrm)
                            (facet.txt)
                            (format.rtf)
                        : ?R
                    |   text/plain
                      & getInput$:?input
                      &   ( isDiplom$!input
                          | isTabSeparated$!input
                          |   (app.nrm)
                              (facet.txt)
                              (format.flat)
                          )
                        : ?R
                    | text/x-conll&(format.flat):?R
                    |   @( ?
                         :   image/
                             (   ( gif
                                 | jpeg
                                 | pjpeg
                                 | png
                                 | tiff
                                 | "vnd.microsoft.icon"
                                 )
                               : ?spec
                             | "svg+xml"&svg:?spec
                             )
                         )
                      &     (app.rom)
                            (facet.txt)
                            (format.img^!spec)
                        : ?R
                    |   @( ?
                         :   audio/
                             ( ( basic
                               | L24
                               | mp4
                               | mpeg
                               | ogg
                               | vorbis
                               | "vnd.rn-realaudio"
                               | "vnd.wave"
                               | webm
                               )
                             : ?spec
                             )
                         )
                      & (format.snd^!spec):?R
                    |   @( ?
                         :   video/
                             ( ( mpeg
                               | mp4
                               | ogg
                               | quicktime
                               | webm
                               | x-matroska
                               | x-ms-wmv
                               | x-flv
                               )
                             : ?spec
                             )
                         )
                      & (format.vid^!spec):?R
                    |   text/xml
                      & (       get
                              $ ( str$(!DestinationDir !LocalFileName)
                                , X ML
                                , TRM
                                )
                            : ? (TEI.?) ?
                          &     (app.nrm)
                                (facet.txt)
                                (format.teip5)
                            : ?R
                        | (format.xm):?R
                        )
                    | :?R
                    )
                & (   !R
                    : ? (format.json|dipl) ?
                  | !R (ambig.una):?R
                  )
                & log$("analyseContentType returns:" !R)
                & !R
            )
          & ( lookForLanguage
            =     knownInputFeats AA ZZ LocalFileName language
                , YYY
              .     !arg:(?LocalFileName.?arg)
                  & (   !arg:?AA (language.?language) ?ZZ
                      & readTable$linguae
                      & !linguae:? (?.!language.?YYY) ?
                      & !language
                    . !AA !ZZ
                    )
                | (       !Uploads
                        :   ?
                            (?.?.?.!LocalFileName.?.?knownInputFeats.?)
                            ?
                      &   !knownInputFeats
                        : ? (lang.?language) ?
                      & !language
                    | 
                  . !arg
                  )
            )
          & ( analyzeInput
            =     item feats Items item
                , parms presels n val buildItemList
                , buildItemListFromForeignData
                , retrieveFeatures date
              .   "Consult the 'Uploads'-table to find out what we know
                     about the input(s)."
                & readTable$Uploads
                & !arg:?parms
                & log$(analyzeInput !arg)
                & ( !arg:? (DATE.?date) ?
                  | :?date
                  )
                & "First build a list of items."
                & ( buildItemList
                  =   Items
                    .   :?Items
                      &   whl
                        ' ( !arg
                          :   ?
                              ( (item|Item.?item)
                              & (@(!item:\" ?item \")|)
                              & !Items (Item.!item):?Items
                              )
                              ?arg
                          )
                      & !Items
                  )
                & buildItemList$!parms:?Items
                & ( buildItemListFromForeignData
                  =     A Z N name Items FieldName nofonts
                      , Name ContentType Size feats YYY
                      , DestinationDir LocalFileName
                      , language
                    .   :?Items
                      &   (   !arg:? (language.?language) ?
                            & readTable$linguae
                            &   !linguae
                              : ? (?.!language.?YYY) ?
                            & (lang.!language)
                          | 
                          )
                        : ?language
                      &   whl
                        ' ( !arg
                          :   ?
                              ( ( FieldName,?FieldName
                                . Name,?Name
                                . ContentType,%?ContentType ?nofonts
                                . Size,?Size
                                . DestinationDir,?DestinationDir
                                . LocalFileName,?LocalFileName
                                )
                              &   analyseContentType$(!ContentType.!nofonts)
                                : ?feats
                              &   !Uploads
                                :   ?A
                                    (?N.?name.?.!LocalFileName.?.?.?)
                                    ?Z
                              &     !A
                                    ( !N
                                    . !name
                                    . !name
                                    . !LocalFileName
                                    .   (TITLE.!name)
                                        (BASEITEM.)
                                        (DATE.!date)
                                    . !language !feats
                                    . public
                                    )
                                    !Z
                                : ?Uploads
                              &     !Items
                                    ( Item
                                    . str$(removePercentEncodings$!Name)
                                    )
                                : ?Items
                              )
                              ?arg
                          )
                      & saveTable$Uploads
                      & !Items
                  )
                & !Items buildItemListFromForeignData$!parms:?Items
                & readTable$features
                & ( retrieveFeatures
                  =   Items item feats n val presels
                    .   !arg:?Items
                      & :?presels
                      &   whl
                        ' (   !Items
                            : (Item.%?item ?feats) ?Items
                          & (   !feats:
                              & itemFeats$!item:?feats
                            |   !errors:
                              &     str
                                  $ ( 404~~~
                                        toML
                                      $ ( !BodyContainer
                                        $ ( paragraph
                                          $ (str$("Item " !item " not found"))
                                          )
                                        )
                                    )
                                : ?errors
                            | 
                            )
                          &   whl
                            ' ( !feats:(?n.?val) ?feats
                              & getShort$(!n.!val):?val
                              & !presels (!n.!val.!item):?presels
                              )
                          )
                      & !presels
                  )
                & retrieveFeatures$!Items:?presels
                & (!arg.!Items.!presels)
            )
          & ( Sources
            =     f fs picklists name short srcs flds
                , description itms itm Types preselvals
                , table presel L PR
                , preselvalsrows items item spec
              .   readTable$features
                & !features:?fs
                & :?preselvalsrows
                & :?items
                &   whl
                  ' ( !fs:%?f+?fs
                    &   !f
                      : ? (name.?name) ?
                      : ? (short.?short) ?
                      : ? (description.?description) ?
                      : ? (table.?table) ?
                    & readTable$!table
                    & :?preselvals
                    & !arg:?L
                    &   whl
                      ' ( !L:? (!short.?presel.?item) ?L
                        & ( !items:? !item ?
                          | !items !item:?items
                          )
                        & !preselvals (!presel.!item):?preselvals
                        )
                    &     !preselvalsrows
                          (!short.localized$!name.!!table.!preselvals)
                      : ?preselvalsrows
                    )
                & :?picklists
                & !preselvalsrows:?PR
                &   whl
                  ' (   !PR
                      : (?short.?name.?table.?preselvals) ?PR
                    &     !picklists
                            row
                          $ ( cell$!name
                              ( :?flds
                              & !items:?itms
                              &   whl
                                ' ( !itms:%?itm ?itms
                                  &     !flds
                                          cell
                                        $ (     !preselvals
                                              :   ?
                                                  (%?presel^?spec.!itm)
                                                  ?
                                            & (   !spec:1
                                                & NEWSPEC
                                                &   makeSelectFormField
                                                  $ ( 
                                                    . str$(I !short)
                                                    . options
                                                    .   makeOptionList
                                                      $ (!table.!presel)
                                                    )
                                              |   makeSelectFormField
                                                $ ( 
                                                  . str$(I !short)
                                                  . options
                                                  .   readTable$features
                                                    &   !features
                                                      :   ?
                                                        + (   ?
                                                              (short.!short)
                                                              ?
                                                          :   ?
                                                              ( specificationTable
                                                              .   ?
                                                                  (   ?
                                                                      ( %@
                                                                      : !presel
                                                                      )
                                                                      ?
                                                                  . ?Types
                                                                  )
                                                                  ?
                                                              )
                                                              ?
                                                          )
                                                        + ?
                                                    & readTable$!Types
                                                    &   makeOptionList
                                                      $ ( !!Types
                                                        . !spec
                                                        . str$(!presel "^")
                                                        )
                                                  )
                                              )
                                          | 
                                          )
                                    : ?flds
                                  )
                              & !flds
                              )
                            )
                      : ?picklists
                    )
                &   Table
                  $ ( (style,"display:none;") (id,inputs)
                    .   row
                      $ ( cell$()
                          ( !items:?itms
                          & :?srcs
                          &   whl
                            ' ( 
                              & !itms:%?itm ?itms
                              & !srcs cell$!itm:?srcs
                              )
                          & !srcs
                          )
                        )
                    . !picklists
                    )
            )
          & ( desiredTools
            =   L ToolID Title S
              .   readTable$tooladm
                & 0:?S
                & :?L
                & (   !tooladm
                    :   ?
                      + (   ~(? (Inactive.on) ?)
                          : ? (ToolID.?ToolID) ?
                          : ? (Title.?Title) ?
                        & !S+(low$!Title.!Title.!ToolID):?S
                        & ~
                        )
                      + ?
                  | 
                  )
                &   whl
                  ' ( !S:(?.?Title.?ToolID)+?S
                    & !L (!Title.!ToolID):?L
                    )
                &   fieldset
                  $ (     localized
                        $ ( "Restrict list of workflow candidates. (Optional if you specified your goal in the fields above.)"
                            "Indskrænk listen med kandiderende arbejdsgange. (Kan springes over hvis du har specificeret dit mål i rubrikken ovenover.)"
                          )
                        (br.,)
                          localized
                        $ ( "If you did not specify a goal (i.e. "
                            "Værktøjet er det sidste i arbejdsgangene hvis du "
                          )
                        (strong.,localized$(ALL INTET))
                          localized
                        $ ( " fields are empty), the WMS computes all workflows that have the selected tool as the last step."
                            " har specificeret i rubrikken ovenover."
                          )
                    .   paragraph
                      $ ( makeSelectFormField
                        $ (   localized
                            $ ( "Workflow must utilize the tool:"
                                "Arbejdsgang skal inkludere værktøjet:"
                              )
                          . desiredtool
                          . options
                          . makeOptionList$(!L.)
                          )
                        )
                    )
            )
          & ( sourcesAndGoals
            =     f fs picklists name short
                , servicedGoalsTable flds
                , servicedSourcesTable
                , description itms itm Types
                , table presel L PR selectServicedValues
                , preselvalsrows items item spec
                , goalpicklists preselvals presels
                , srcs fromRepo createArgs
              .   !arg:(?presels.?createArgs.?fromRepo)
                & readTable$features
                & !features:?fs
                & :?preselvalsrows
                & :?items
                &   whl
                  ' (   !createArgs
                      :   ?
                          (FieldName,?.Name,?item.?)
                          ?createArgs
                    & !items !item:?items
                    )
                &   whl
                  ' ( !fs:%?f+?fs
                    &   !f
                      : ? (name.?name) ?
                      : ? (short.?short) ?
                      : ? (description.?description) ?
                      : ? (table.?table) ?
                    & readTable$!table
                    & :?preselvals
                    & !presels:?L
                    &   whl
                      ' ( !L:? (!short.?presel.?item) ?L
                        & ( !items:? !item ?
                          | !items !item:?items
                          )
                        & !preselvals (!presel.!item):?preselvals
                        )
                    &     !preselvalsrows
                          (!short.localized$!name.!!table.!preselvals)
                      : ?preselvalsrows
                    )
                & ( selectServicedValues
                  =   short table pat
                    .     !arg:(?short.?table.(=?pat))
                        & readTable$toolprop
                        & readTable$tooladm
                        &   map
                          $ ( ( 
                              =   tool full abbr YYY
                                .   !arg:(?full.?abbr.?YYY)
                                  & (   !( 
                                         ' ( $toolprop
                                           :   ?
                                             + (   ?tool
                                                 &   $tooladm
                                                   :   ?
                                                     + (   ?
                                                           (ToolID.!tool)
                                                           ?
                                                       :   ?
                                                           (Inactive.)
                                                           ?
                                                       )
                                                     + ?
                                               .   ?
                                                   ($short,?+$pat+?)
                                                   ?
                                               )
                                             + ?
                                           )
                                         )
                                      & (!full.!abbr.!YYY)
                                    | 
                                    )
                              )
                            . !table
                            )
                      | !table
                  )
                & :?picklists:?goalpicklists
                & !preselvalsrows:?PR
                &   whl
                  ' (   !PR
                      : (?short.?name.?table.?preselvals) ?PR
                    & (   !servicedSources
                        : ? (!short.?servicedSourcesTable) ?
                      |       selectServicedValues
                            $ ( !short
                              . !table
                              . (=?+?*!abbr^?*?+? ?.?)
                              )
                          : ?servicedSourcesTable
                        &     (!short.!servicedSourcesTable)
                              !servicedSources
                          : ?servicedSources
                      )
                    & (   !servicedGoals
                        : ? (!short.?servicedGoalsTable) ?
                      |       selectServicedValues
                            $ ( !short
                              . !table
                              . (=?.?+?*!abbr^?*?+? ?)
                              )
                          : ?servicedGoalsTable
                        &     (!short.!servicedGoalsTable)
                              !servicedGoals
                          : ?servicedGoals
                      )
                    &     !picklists
                            row
                          $ ( cell$!name
                              ( :?flds
                              & !items:?itms
                              &   whl
                                ' ( !itms:%?itm ?itms
                                  &     !flds
                                          cell
                                        $ (     !preselvals
                                              :   ?
                                                  (%?presel^?spec.!itm)
                                                  ?
                                            & NEWSPEC
                                            & (   !spec:1
                                                & NEWSPEC
                                                &   makeSelectFormField
                                                  $ ( 
                                                    . str$(I !short)
                                                    . options
                                                    .   makeOptionList
                                                      $ ( !servicedSourcesTable
                                                        . !presel
                                                        )
                                                    )
                                              |   makeSelectFormField
                                                $ ( 
                                                  . str$(I !short)
                                                  . options
                                                  .   readTable$features
                                                    &   !features
                                                      :   ?
                                                        + (   ?
                                                              (short.!short)
                                                              ?
                                                          :   ?
                                                              ( specificationTable
                                                              .   ?
                                                                  (   ?
                                                                      ( %@
                                                                      : !presel
                                                                      )
                                                                      ?
                                                                  . ?Types
                                                                  )
                                                                  ?
                                                              )
                                                              ?
                                                          )
                                                        + ?
                                                    & readTable$!Types
                                                    &   makeOptionList
                                                      $ ( !!Types
                                                        . !spec
                                                        . str$(!presel "^")
                                                        )
                                                  )
                                              )
                                          |   makeSelectFormField
                                            $ ( 
                                              . str$(I !short)
                                              . options
                                              .   makeOptionList
                                                $ (!servicedSourcesTable.)
                                              )
                                          )
                                    : ?flds
                                  )
                              & !flds
                              )
                            )
                      : ?picklists
                    &     !goalpicklists
                            row
                          $ ( cell$(str$(!name ":"))
                                cell
                              $ ( makeSelectFormField
                                $ ( 
                                  . str$(O !short)
                                  . options
                                  . makeOptionList$(!servicedGoalsTable.)
                                  )
                                )
                            )
                      : ?goalpicklists
                    )
                & (   !fromRepo
                    &     Table
                        $ ( (style,"display:none;") (id,inputs)
                          .   row
                            $ ( cell$()
                                ( !items:?itms
                                & :?srcs
                                &   whl
                                  ' ( !itms:%?itm ?itms
                                    & !srcs cell$!itm:?srcs
                                    )
                                & !srcs
                                )
                              )
                          . !picklists
                          )
                          Table
                        $ ( id,goal
                          . row$(cell$() cell$)
                          . !goalpicklists
                          )
                  |     fieldset
                      $ (   localized
                          $ ( "Input(s). Do not change these fields if you are not sure."
                              "Input. Lav ikke om på værdierne hvis du ikke er sikker."
                            )
                        .   Table
                          $ ( id,inputs
                            .   row
                              $ ( cell$()
                                  ( !items:?itms
                                  & :?srcs
                                  &   whl
                                    ' ( !itms:%?itm ?itms
                                      & !srcs cell$!itm:?srcs
                                      )
                                  & !srcs
                                  )
                                )
                            . !picklists
                            )
                        )
                        fieldset
                      $ (   (strong.,localized$("Your goal" "Dit mål"))
                            (br.,)
                            localized$("Fill out only " "Udfyld ")
                            (strong.,localized$(two to))
                            localized$(" or " " eller ")
                            (strong.,localized$(three tre))
                              localized
                            $ ( " fields and leave the other fields "
                                " felter og lad de øvrige felter være "
                              )
                            (strong.,localized$(blank blank))
                              localized
                            $ ( ". In general, more filled out fields = fewer candidate workflows."
                                ". Generelt gælder: jo flere udfyldte feldter, desto færre foreslåede arbejdsgange."
                              )
                            (br.,)
                              localized
                            $ ( "You can skip these fields and choose a tool instead, see below. In that case, the tool will be the last in the workflow."
                                "Du kan lade felterne stå tomme, og i stedet vælge et værktøj i rubrikken forneden. I så fald er værktøjet det sidste i arbejdsgangen."
                              )
                        .     Table
                            $ ( id,goal
                              . row$(cell$() cell$)
                              . !goalpicklists
                              )
                              makeCheckboxFormField
                            $ (   localized
                                $ ( "Show workflows for similar goals"
                                    "Hvis arbejdsgange for lignende mål"
                                  )
                              . superset
                              .   (val.on)
                                  ( desc
                                  .   localized
                                    $ ( "Check this box if your requirements are MINIMAL requirements. For example, if your requirement is to have PoS tags, you may also want to see workflows that produce PoS tags AND lemmas, at the same time."
                                        "Marker hvis dit mål er minimal, fx hvis du udover PoS tags også godt vil se lemmaer, i kombination med PoS tags."
                                      )
                                  )
                              )
                        )
                  )
            )
          & ( checkIOparms
            =   f fs short table p
              .   readTable$features
                & !features:?fs
                &   whl
                  ' ( !fs:%?f+?fs
                    &   !f
                      : ? (short.?short) ?
                      : ? (table.?table) ?
                    & readTable$!table
                    & str$(I !short):?p
                    & (checkParms$(!arg.!p.!!table)|)
                    & str$(O !short):?p
                    & (checkParms$(!arg.!p.!!table)|)
                    )
            )
          & ( unpackIOparms
            =   f fs short p
              .   readTable$features
                & !features:?fs
                &   whl
                  ' ( !fs:%?f+?fs
                    & !f:? (short.?short) ?
                    & str$(I !short):?p
                    & (unpackIOparm$(!arg.!p):?arg|)
                    & str$(O !short):?p
                    & (unpackIOparm$(!arg.!p):?arg|)
                    )
                & !arg
            )
          & ( precooked-DASISH
            =     A Z AZ Name wrkflw Iformat
                , LocalFileName language langopt nofonts
                , ContentType knownInputFeats outputformat
              .   !arg:(?wrkflw.?AZ)
                &   !AZ
                  :   ?A
                      ( FieldName,input|text
                      . Name,?Name
                      . ContentType,%?ContentType ?nofonts
                      . Size,?
                      . DestinationDir,?
                      . LocalFileName,?LocalFileName
                      )
                      ?Z
                &   !Uploads
                  :   ?
                      (?.?.?.!LocalFileName.?.?knownInputFeats.?)
                      ?
                & !A !Z:?A (DATE.?) ?Z
                & !A !Z:?A (method.?) ?Z
                & !A !Z:?A (action.?) ?Z
                &   lookForLanguage$(!LocalFileName.!A !Z)
                  : (?language.?A ?Z)
                &   (Ilang.!language) (Olang.!language)
                  : ?langopt
                & (   !wrkflw:NER
                    & (     !knownInputFeats
                          : ? (format.flat) ?
                        & (   !A
                              !Z
                              (method.GET)
                              (Item.!Name)
                              (nth.1)
                              (batch.on)
                              (bsubmit.Submit)
                              (Ifacet.txt)
                              (Iformat.flat)
                              !langopt
                              (Ofacet.ner)
                              (Opres.)
                          . 
                          )
                      | ( !arg
                        .   str
                          $ ( "NER workflow requires ContentType:text/plain instead of "
                              !ContentType
                            )
                        )
                      )
                  |   !wrkflw:CLEANING
                    & (     !A !Z
                          : ?A (outputformat.?outputformat) ?Z
                        & (   !outputformat:TEI
                            & (     !knownInputFeats
                                  :   ?
                                      ( format
                                      .   ( flat
                                          | rtf
                                          | html
                                          | pdf
                                          | doc
                                          | docx
                                          | odt
                                          | odp
                                          | ods
                                          | ppt
                                          | pptx
                                          | xls
                                          | xlsx
                                          )
                                        : ?Iformat
                                      )
                                      ?
                                & (   !A
                                      !Z
                                      (method.GET)
                                      (Item.!Name)
                                      (nth.1)
                                      (batch.on)
                                      (bsubmit.Metadata)
                                      (Ifacet.txt)
                                      (Iformat.!Iformat)
                                      !langopt
                                      (Oformat.txtbasis)
                                      (Ofacet.txt)
                                      (Opres.)
                                  . 
                                  )
                              | ( !arg
                                .     !ContentType:application/pdf
                                    &   str
                                      $ (   localized
                                          $ ( "PDF-files that only consist of image data cannot be handled by this work flow."
                                              "PDF-filer som kun består af billeddata kan ikke håndteres af denne workflow."
                                            )
                                          "("
                                          !Name
                                          ")"
                                        )
                                  |   str
                                    $ (   localized
                                        $ ( "CLEANING producing TEI output requires input with ContentType:text/plain, application/msword (RTF), text/rtf, text/html, application/pdf (with text!) or application/x-download (PDF) instead of "
                                            "Input kan være flad tekst, officedokumenter eller PDF. Ikke "
                                          )
                                        !ContentType
                                      )
                                )
                              )
                          |   !outputformat:flat
                            & (     !knownInputFeats
                                  :   ?
                                      ( format
                                      .   ( flat
                                          | rtf
                                          | html
                                          | pdf
                                          )
                                        : ?Iformat
                                      )
                                      ?
                                & (   !A
                                      !Z
                                      (method.GET)
                                      (Item.!Name)
                                      (nth.1)
                                      (batch.on)
                                      (bsubmit.Submit)
                                      (Ifacet.txt)
                                      (Iformat.!Iformat)
                                      !langopt
                                      (Ofacet.tok)
                                      (Oformat.flat)
                                      (Opres.)
                                  . 
                                  )
                              | ( !arg
                                .   str
                                  $ ( "CLEANING producing tokenized output, one sentence per line, requires input with ContentType:text/plain, application/msword (RTF), text/rtf, text/html, application/pdf or application/x-download (PDF) instead of "
                                      !ContentType
                                    )
                                )
                              )
                          | ( !arg
                            . "outputformat parameter must be 'TEI' or 'flat'"
                            )
                          )
                      | ( !arg
                        . "CLEANING workflow requires outputformat parameter"
                        )
                      )
                  )
            )
          & ( checkMail
            =   parms mail2 password formFields hiddenData errors
              .   "Check that there is an email address to send the results to. If there is a password, that is saved as well."
                & !arg:(?parms.?formFields.?hiddenData.?errors)
                & (     !parms:? (mail2.?mail2) ?
                      & (@(!mail2:\" ?mail2 \")|)
                      & (   !mail2:
                          &     !formFields
                                  makeTextFormField
                                $ ("Your email address:".mail2.val.)
                            : ?formFields
                          & 
                        |   !hiddenData (mail2.!mail2):?hiddenData
                          & (     !parms
                                : ? (password.?password) ?
                              & ( @(!password:\" ?password \")
                                | 
                                )
                              &   !hiddenData (password.!password)
                                : ?hiddenData
                            | 
                            )
                          & !mail2
                        )
                    |   ( !hiddenData (mail2.):?hiddenData
                        |     !formFields
                              makeTextFormField$(.mail2.val.)
                          : ?formFields
                        )
                      & 
                  . !formFields
                  . !hiddenData
                  . !errors
                  )
            )
          & ( windFW
            =   nth ZZ pipes pipe
              .   !arg:(?pipes.?nth)
                & !pipes:?ZZ
                & UNKNOWNS!:?pipe
                &   whl
                  ' ( !nth:>0
                    & !ZZ:%?pipe+?ZZ
                    & !nth+-1:?nth
                    )
                & !pipe
            )
          & ( ShowAllPipes
            =   directedBy hiddenData pipes rstr
              .   !arg:(?directedBy.?hiddenData.?pipes)
                & ( !hiddenData:? (desiredtool.?rstr) ?
                  | :?rstr
                  )
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ (   !pipes:(?.?)+?
                            &   (   !pipes:%+%
                                  &   ( h3
                                      .   
                                        ,   localized
                                          $ (Workflows Arbejdsgange)
                                      )
                                      ( p
                                      .   
                                        ,     localized
                                            $ ( "These are the workflows that fulfil the goal set by you."
                                                "Dette er arbejdsgangene som løser din opgave."
                                              )
                                            (br.,)
                                              localized
                                            $ ( "Select one before pressing the submit button."
                                                "Vælg en og tryk på submit-knappen."
                                              )
                                            (br.,)
                                              localized
                                            $ ( "Move the mouse pointer over the tool names for a short explanation of what the tool does."
                                                "Du får en kort forklaring for hvert værktøj ved at flytte musepilen over værktøjets navn."
                                              )
                                      )
                                |   (h3.,Workflow)
                                    ( p
                                    .   
                                      ,   localized
                                        $ ( "This is the workflow that fulfils the goal set by you."
                                            "Dette er arbejdsgangen som løser din opgave."
                                          )
                                    )
                                )
                                  form
                                $ ( methodName$!directedBy
                                  .   submit$"View details"
                                      submit$Metadata
                                      submit$Submit
                                      (br.,)
                                      makeHiddenFields$!hiddenData
                                      makeWorkflowRadioButtons$!pipes
                                  )
                          |   ( h3
                              .   
                                ,   localized
                                  $ ("Nothing to do" "Der er intet at lave")
                              )
                              ( p
                              .   
                                ,     !rstr:
                                    &   localized
                                      $ ( "The goal is trivially fulfilled by the input. Go to the previous screen and specify your goal (or even the input) in more detail."
                                          "Inputtet opfylder allerede målet. Gå tilbage til forrige skærm og specificer dit mål (og eventuelt også inputtet) nærmere."
                                        )
                                  |     localized
                                      $ ( "The goal is trivially fulfilled by the input. Go to the previous screen and either specify your goal in more detail, or do not specify a goal at all. If you choose the second option, an implicit goal will be derived from the tool that you specified."
                                          "Inputtet opfylder allerede målet. Gå tilbage til forrige skærm og specificer dit mål nærmere, eller lad være med at specificere et mål. Hvis du vælger det sidste, bliver målet implicit bestemt af det værktøj du har valgt."
                                        )
                                      " ("
                                      ToolTitle$!rstr
                                      ")"
                              )
                          )
                        )
                    )
            )
          & ( methodName
            = .str$(create (!arg:|By) !arg)
            )
          & ( ShowOnlyTheCurrentPipe
            =   formFields nicify pipe nth directedBy
              .   !arg:(?pipe.?nth.?directedBy)
                & :?formFields
                & ( nicify
                  =   pipeAsFields
                    .     (pipeAsFields=.pipeSegmentFields$(!arg.0))
                        & pipeAsFields$!arg
                      | !arg
                  )
                & !formFields nicify$!pipe:?formFields
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ ( ( !nth:<1
                            |     (br.,)
                                  submit$Submit
                                  !formFields
                              : ?formFields
                            )
                          & ( !formFields:
                            |   "Workflow: Input → "
                                enumerateTools$!pipe
                                " → Output"
                                (br.,)
                                  form
                                $ ( methodName$!directedBy
                                  .   !formFields
                                      ( !nth:<1&
                                      |   makeHiddenFields
                                        $ ((nth.!nth) !hiddenData)
                                      )
                                  )
                            )
                          )
                        )
                    )
            )
          & ( AddMetadata
            =     formFields metadataForm nth val
                , directedBy Metadata parms ERR metadataType
              .   !arg:(?metadataType.?nth.?directedBy.?parms.?ERR)
                & readTable$!metadataType:?Metadata
                & :?formFields
                & ( metadataForm
                  =     formFields tekst inputs
                      , "Tekst i grænsefladen"
                      , "Required / optional  / automatic"
                      , "Placering i header" Noter Hjælpetekst id
                      , "line / lines / box / empty" URL
                      , inputFields table typeOfError
                    .   :?formFields
                      &   whl
                        ' ( !arg:? (?tekst,?inputs) ?arg
                          &     !formFields
                                  fieldset
                                $ ( localized$!tekst
                                  .   :?inputFields
                                    &   whl
                                      ' (   !inputs
                                          :   ( ?id
                                              . ?"Tekst i grænsefladen"
                                              . ?"Required / optional  / automatic"
                                              . ?"line / lines / box / empty"
                                              . ?"Placering i header"
                                              . ?Noter
                                              . ?Hjælpetekst
                                              . ?
                                              . ?URL
                                              )
                                              ?inputs
                                        & (     !"Required / optional  / automatic"
                                              :   ?
                                                  ( o
                                                  | r
                                                  | oneOrMore
                                                  | zeroOrMore
                                                  )
                                                  ?
                                            &     !inputFields
                                                  ( div
                                                  .   (class.row)
                                                    ,   (     !"line / lines / box / empty"
                                                            : select ?table
                                                          & readTable$!table
                                                          &   makeSelectFormField
                                                            $ (   addurl
                                                                $ (   localized
                                                                    $ !"Tekst i grænsefladen"
                                                                  . !URL
                                                                  )
                                                              . !id
                                                              .   ( options
                                                                  .   makeOptionList
                                                                    $ ( !!table
                                                                      .       !parms
                                                                            :   ?
                                                                                ( !id
                                                                                . ?val
                                                                                )
                                                                                ?
                                                                          & !val
                                                                        | 
                                                                      )
                                                                  )
                                                                  ( desc
                                                                  .   localized
                                                                    $ !Hjælpetekst
                                                                  )
                                                                  ( required
                                                                  .       !"Required / optional  / automatic"
                                                                        :   ?
                                                                            ( r
                                                                            | oneOrMore
                                                                            )
                                                                            ?
                                                                      & ( span
                                                                        .   ( style
                                                                            . "color:blue; width: auto; line-height: normal;"
                                                                            )
                                                                          , "*"
                                                                        )
                                                                    | 
                                                                  )
                                                              )
                                                        |   (     !"line / lines / box / empty"
                                                                : ( box
                                                                  | lines
                                                                  )
                                                              & makeTextAreaFormField
                                                            | makeTextFormField
                                                            )
                                                          $ (     addurl
                                                                $ (   localized
                                                                    $ !"Tekst i grænsefladen"
                                                                  . !URL
                                                                  )
                                                                (     !"Required / optional  / automatic"
                                                                    : ? a ?
                                                                  & ( span
                                                                    .   ( style
                                                                        . "font-style:italic; width:auto;"
                                                                        )
                                                                      ,   str
                                                                        $ ( " ("
                                                                              localized
                                                                            $ ( "autogenerated if left blank"
                                                                                "automatisk genereret hvis ikke udfyldt"
                                                                              )
                                                                            ") "
                                                                          )
                                                                    )
                                                                | 
                                                                )
                                                            . !id
                                                            .   ( val
                                                                .       !parms
                                                                      :   ?
                                                                          ( !id
                                                                          . ?val
                                                                          )
                                                                          ?
                                                                    & !val
                                                                  | 
                                                                )
                                                                ( desc
                                                                .   localized
                                                                  $ !Hjælpetekst
                                                                )
                                                                ( required
                                                                .       !"Required / optional  / automatic"
                                                                      :   ?
                                                                          ( r
                                                                          | oneOrMore
                                                                          )
                                                                          ?
                                                                    & ( span
                                                                      .   ( style
                                                                          . "color:blue; width: auto; line-height: normal;"
                                                                          )
                                                                        , "*"
                                                                      )
                                                                  | 
                                                                )
                                                            )
                                                        )
                                                        (     !ERR
                                                            : ( !id
                                                              . ?typeOfError
                                                              . ?
                                                              )
                                                          & ( span
                                                            .   ( style
                                                                . "color:red;"
                                                                )
                                                              , !typeOfError
                                                            )
                                                        | 
                                                        )
                                                  )
                                              : ?inputFields
                                          |     !"Required / optional  / automatic"
                                              : ? a ?
                                            & !"Tekst i grænsefladen":~
                                            &     !inputFields
                                                  ( div
                                                  .   (class.row)
                                                    ,   makeStaticTextFormField
                                                      $ (   localized
                                                          $ !"Tekst i grænsefladen"
                                                        . span
                                                        .   (class.autogen)
                                                          ,   str
                                                            $ ( " ("
                                                                  localized
                                                                $ ( autogenerated
                                                                    "automatisk genereret"
                                                                  )
                                                                ") "
                                                              )
                                                        )
                                                  )
                                              : ?inputFields
                                          | 
                                          )
                                        )
                                    & !inputFields
                                  )
                            : ?formFields
                          )
                      & !formFields
                  )
                & log$"Creating formFields"
                &     !formFields
                      ( style
                      .   (type.text/css)
                        , "div.row{display:table-row;} .row * {vertical-align: middle;} .row label{display: table-cell; text-align: right; padding: 5px;} span.autogen{font-style:italic; width:auto; display: table-cell; text-align: left; padding: 5px;} .row input{display: table-cell;} .row textarea{display: table-cell;} span.required{width: 20px;}"
                      )
                      metadataForm$!Metadata
                  : ?formFields
                & log$"formFields created"
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ ( !formFields:
                          |   ( h1
                              .   
                                ,   localized
                                  $ ("Add metadata" "Tilføj metadata")
                              )
                              (br.,)
                                form
                              $ ( methodName$!directedBy
                                .   !formFields
                                    ( !nth:<1&
                                    |     makeHiddenFields
                                        $ ((nth.!nth) !hiddenData)
                                        (br.,)
                                        submit$Submit
                                    )
                                )
                          )
                        )
                    )
            )
          & ( makeJobStack
            =     nr jobID jobnr tool ou in inputs list ins
                , AA A B C ZZ P Q blocks feat outfeats val
                , in NC makeJobs JobStack
              .   ( makeJobs
                  =     jobLst tool output input A
                      , inputprop goal makeJob
                    .   ( makeJob
                        =   X
                          .   str$(step (!nr+1:?nr)):?X
                            & (!X.!arg) !blocks:?blocks
                            & !X
                        )
                      & :?jobLst
                      & (   !arg:%*%
                          &   whl
                            ' ( !arg:%?A*?arg
                              & !jobLst makeJobs$!A:?jobLst
                              )
                          & !jobLst
                        |   !arg:(?tool,(?output.?inputprop.?input))
                          & (   !blocks:? (?A.!arg.?) ?
                              & !A
                            |   makeJob
                              $ ( !arg
                                . !tool
                                . !output
                                . !inputprop
                                . makeJobs$!input
                                )
                            )
                        |   !arg:(?goal.?arg)
                          & makeJobs$!arg
                        | (FiL.!arg)
                        )
                  )
                & ( outfeats
                  =   
                    .   ( !arg:(FiL.?arg)
                        | !blocks:? (!arg.?.?.?arg.?) ?
                        )
                      & !arg
                  )
                & :?JobStack
                & 0:?nr
                & :?blocks
                & makeJobs$!arg
                & !blocks:?list
                &   whl
                  ' (   !list
                      : (?jobnr.?.?tool.?ou.?in.?inputs) ?list
                    & "inputs is a mix of atoms and the features of the input
                       file, marked with FiL."
                    & :?ins
                    & (     !in
                          :   ?AA
                              ( ?feat
                              ,   (%(%?A*%?B) ?C|%(%?A*?B) %?C)
                                : ?in
                              )
                              ?ZZ
                        & "Multiple inputs"
                        &   whl
                          ' ( !in:%(%?A*?B) ?C
                            &   !inputs
                              :   ?P
                                  `%?jobID
                                  ( ?Q
                                  &   outfeats$!jobID
                                    :   ?
                                        ( !feat
                                        ,   %?val^?
                                          & !A:!val^?
                                          &     (!feat,(!A.!jobID))
                                                !ins
                                            : ?ins
                                          & !B !C:?in
                                          & !P !Q:?inputs
                                        )
                                        ?
                                  )
                            )
                        & "'in' has only optional inputs. 1 opt1 opt2 ..."
                        &   whl
                          ' ( !in:%?B %?NC ?C
                            & !B !C:?in
                            &   !inputs
                              :   ?P
                                * `%?jobID
                                * ( ?Q
                                  &   outfeats$!jobID
                                    :   ?
                                        ( !feat
                                        ,   %?val^?
                                          & (   !NC:!val^?
                                              &     (!feat,(!NC.!jobID))
                                                    !ins
                                                : ?ins
                                            | 
                                            )
                                          & !P !Q:?inputs
                                        )
                                        ?
                                  )
                            )
                        & ( !in:1
                          | log$(SOOMTHINGROOTEN !in)
                          )
                        & !AA (!feat,!in) !ZZ:?in
                      |   "Single input"
                        & (     !in
                              :   ?
                                  (?,%(%?A*%?B) ?C|%?A %?C)
                                  ?
                            & log$(SOMTINGROTS !in)
                          | 
                          )
                        &   whl
                          ' ( !in:?AA (?feat,%(%?A*?) ?) ?ZZ
                            &   !inputs
                              :   ?P
                                  `%?jobID
                                  ( ?Q
                                  &   outfeats$!jobID
                                    :   ?
                                        ( !feat
                                        ,   %?val^?
                                          & !A:!val^?
                                          &     (!feat,(!A.!jobID))
                                                !ins
                                            : ?ins
                                          &   !AA (!feat,1) !ZZ
                                            : ?in
                                          & !P !Q:?inputs
                                        )
                                        ?
                                  )
                            )
                      )
                    & ( !ins:&!inputs:?ins
                      |   whl
                        ' ( !in:? (?feat,~1:?val) ?in
                          & (!feat,!val) !ins:?ins
                          )
                      )
                    &   (!jobnr.!tool.!ou.!ins) !JobStack
                      : ?JobStack
                    )
                & !JobStack
            )
          & ( ApplyThePipelineToTheInput
            =     PIPE batch jobIDoffset parms Metadata
                , retrieveMetadataFromParms directedBy
                , Items item subjobs mail2 JobId metadataType
              .     !arg
                  : ( ?metadataType
                    . ?PIPE
                    . ?batch
                    . ?Items
                    . ?mail2
                    . ?parms
                    . ?directedBy
                    )
                & ( retrieveMetadataFromParms
                  =   metadataType parms
                    .   !arg:(?metadataType.?parms)
                      &   map
                        $ ( ( 
                            =   inputs
                              .     !arg:(?,?inputs)
                                  &   map
                                    $ ( ( 
                                        =   id V
                                          .   !arg:(?id.?)
                                            & (     !parms
                                                  : ? (!id.?V) ?
                                                & (!id.!V)
                                              | 
                                              )
                                        )
                                      . !inputs
                                      )
                                | 
                            )
                          . readTable$!metadataType
                          )
                  )
                & makeJobStack$!PIPE:?JobStack
                & ( readTable$jobNr
                  | 0:?jobNr&saveTable$jobNr
                  )
                & !jobNr+1:?jobNr:?JobNr
                & saveTable$jobNr
                & (   !batch:on
                    & 0:?jobIDoffset
                    &   whl
                      ' ( !Items:%?item ?Items
                        &     convert2URLs
                            $ ( !jobNr
                              . !jobIDoffset
                              . !JobStack
                              . toolsdataURL$
                              . toolsUploadURL$
                              . !item
                              )
                          : ?subjobs
                        & !subjobs+!jobIDoffset:?jobIDoffset
                        )
                  |   convert2URLs
                    $ ( !jobNr
                      . 
                      . !JobStack
                      . toolsdataURL$
                      . toolsUploadURL$
                      . !Items
                      )
                  )
                & (readTable$jobAbout|:?jobAbout)
                &     ( !JobNr
                      .   (mail2.!mail2)
                          (human.makeWorkflowRadioButtons$!PIPE)
                          ( userProvidedMetadata
                          . retrieveMetadataFromParms$(!metadataType.!parms)
                          )
                      )
                      !jobAbout
                  : ?jobAbout
                & saveTable$jobAbout
                & log$(getNextJobID JobNr !JobNr)
                & getNextJobID$(!JobNr.justtesting):?JobId
                & log$(JobId !JobId)
                &   str
                  $ ( 200
                      "~"
                      !JobNr
                      "~"
                      !JobId
                      "~"
                      (   !JobId:
                        &   toML
                          $ ( !BodyContainer
                            $ ( paragraph
                              $ ( localized
                                $ ( "There is nothing to do. The goal seems to be fulfilled already. Go back with the \"back\" button."
                                    "Der er intet at lave. Gå tilbage med knappen \"Forrige\"."
                                  )
                                )
                              )
                            )
                      | poll$(!JobNr.1)
                      )
                    )
            )
          & ( canConsumeMetadata
            =   a b
              .   !arg:(?,txtbasis^?|txtann^?)
                |   !arg:?a_?b
                  & ( canConsumeMetadata$!a
                    | canConsumeMetadata$!b
                    )
            )
          & ( NoNeedForMetadata
            =   
              .   str
                $ ( 200~~~
                      toML
                    $ ( !BodyContainer
                      $ ( paragraph
                        $ ( localized
                          $ ( "The chosen workflow does not produce resources that can be deposited and therefore you do not need to enter metadata."
                              "Den valgte workflow producerer ingen deponerbare resurser og du skal derfor ikke indtaste metadata."
                            )
                          )
                        )
                      )
                  )
            )
          & ( NoWay
            =   restriction restr calls
              .   !arg:(?restriction.?restr.?calls)
                &   log
                  $ (restriction !restriction restr !restr calls !calls)
                & (   !calls:<56789
                    & (   !restr:triviallyFulfilled
                        &   str
                          $ ( 404~~~
                                toML
                              $ ( !BodyContainer
                                $ (   paragraph
                                    $ ( localized
                                      $ ( "Your goal is trivially fulfilled. Go back to the previous screen and specify your goal in more detail."
                                          "Dit mål er allerede opfyldt i inputtet.  Gå tilbage til forrige skærm og specificer dit mål i flere detaljer."
                                        )
                                      )
                                    ( !restriction:
                                    |   paragraph
                                      $ (   localized
                                          $ ( "You can also choose to not specify your goal at all. In that case the goal will be implicitly defined by the tool that you chose "
                                              "Alternativt specificerer du dit mål slet ikke. Så bliver målet implicit bestemt af det værktøj du har valgt "
                                            )
                                          "("
                                          ToolTitle$!restriction
                                          ")."
                                        )
                                    )
                                  )
                                )
                            )
                      |   !restriction:
                        &   str
                          $ ( 404~~~
                                toML
                              $ ( !BodyContainer
                                $ ( paragraph
                                  $ ( localized
                                    $ ( "Your goal cannot be fulfilled with the currently integrated tools."
                                        "Dit mål kan ikke opfyldes med de værktøjer der p.t. er integreret i infrastrukturen."
                                      )
                                    )
                                  )
                                )
                            )
                      |   str
                        $ ( 404~~~
                              toML
                            $ ( !BodyContainer
                              $ ( paragraph
                                $ (   localized
                                    $ ( "None of the found workflows involves the tool '"
                                        "Ingen af de fundne arbejdsgange anvender værktøjet '"
                                      )
                                    ToolTitle$!restriction
                                    "'."
                                  )
                                )
                              )
                          )
                      )
                  |   str
                    $ ( 404~~~
                          toML
                        $ ( !BodyContainer
                          $ ( paragraph
                            $ ( localized
                              $ ( "The computation takes too much time. It may succeed if you narrow your goal."
                                  "Beregningen tager for lang tid. Måske vil det lykkes hvis du definerer dit mål lidt nærmere."
                                )
                              )
                            )
                          )
                      )
                  )
            )
          & ( TooManyOrNone
            =   calls pipes
              .   !arg:(?calls.?pipes)
                & (   !calls:>0
                    &   str
                      $ ( 404~~~
                            toML
                          $ ( !BodyContainer
                            $ ( paragraph
                              $ ( localized
                                $ ( "There are unmanageable many possible workflows leading to your goal. Try to specify more details for your goal."
                                    "Der er uoverskuelig mange mulige workflows der fører til dit mål. Prøv at specificere dit mål nærmere."
                                  )
                                )
                              )
                            )
                        )
                  |   !pipes:0
                    &   str
                      $ ( 404~~~
                            toML
                          $ ( !BodyContainer
                            $ ( paragraph
                              $ ( localized
                                $ ( "There are no workflows leading to your goal. You could try to slacken the specification of your goal."
                                    "Der er ingen workflows der fører til dit mål. Dan kan prøve at slække på kravene til dit mål."
                                  )
                                )
                              )
                            )
                        )
                  )
            )
          & ( "We are at the start. Show an input form."
            =   formFields presels,directedBy hiddenData Items
              .     !arg
                  : (?formFields.?presels.?directedBy.?hiddenData.?Items)
                & log$"We are at the start. Show an input form."
                & (   !Items:
                    &   str
                      $ ( 200~~~
                            toML
                          $ ( !BodyContainer
                            $ ( paragraph
                              $ ( localized
                                $ ( "No input is specified, or the input is not accessible."
                                    "Inputtet er ikke specificeret, eller inputtet er ikke tilgængeligt."
                                  )
                                )
                              )
                            )
                        )
                  |       !formFields
                            sourcesAndGoals
                          $ ( !presels
                            . !arg
                            .     !Items
                                :   ?
                                    (Item.@(?:"dkclarin:" ?))
                                    ?
                              & 
                            )
                          desiredTools$
                      : ?formFields
                    & log$sourcesAndGoalsDONE
                    &   str
                      $ ( 200~~~
                            toML
                          $ ( !BodyContainer
                            $ ( !formFields:
                              |   form
                                $ ( methodName$!directedBy
                                  .   makeHiddenFields$!hiddenData
                                      (     !directedBy
                                          : (GoalChoice|)
                                        & !formFields submit$"next step"
                                      |   Sources$!presels
                                            paragraph
                                          $ ( pickTool$(txt.!Items)
                                              submit$"next step"
                                            )
                                      )
                                  )
                              )
                            )
                        )
                  )
            )
          & ( errorInMetadata
            =     pattern metadataType
                , "Tekst i grænsefladen" id ERR val Metadata
              .   log$errorInMetadata
                & !arg:(?metadataType.?arg)
                & log$(metadataType !metadataType)
                & readTable$!metadataType:?Metadata
                & :?ERR
                &   !Metadata
                  :   ?
                      ( ?
                      ,   ?
                          ( ?id
                          . ?"Tekst i grænsefladen"
                          .     (r|oneOrMore)
                              &   !arg
                                : (   ?
                                      ( !id
                                      .   ?val
                                        & trim$!val:
                                      )
                                      ?
                                  | ~(? (!id.?) ?)
                                  )
                              &   ( !id
                                  . localized$(required krævet)
                                  . localized$!"Tekst i grænsefladen"
                                  )
                                : ?ERR
                            | ?
                          . ?
                          . ?
                          . ?
                          . ?
                          .     %?pattern ?
                              & !arg:? (!id.~:?val) ?
                              & ~(@(!val:!!pattern)&)
                              &   ( !id
                                  . localized$(format format)
                                  . localized$!"Tekst i grænsefladen"
                                  )
                                : ?ERR
                            | &!ERR:~
                          . ?
                          )
                          ?
                      )
                      ?
                & !ERR
            )
          & ( MetadataInParms
            =   id Metadata metadataType
              .   !arg:(?metadataType.?arg)
                & readTable$!metadataType:?Metadata
                &   !Metadata
                  :   ?
                      ( ?
                      ,   ?
                          (   ?id
                            & !arg:? (!id.?) ?
                          . ?
                          )
                          ?
                      )
                      ?
                & !arg
            )
          & ( rememberMetadata
            =   mail2 userProvidedMetadata metadataType
              .   !arg:(?metadataType.?arg)
                & ( MetadataInParms$(!metadataType.!arg)
                  |   (   !arg:? (mail2.?mail2) ?
                        & readTable$jobAbout
                        &   !jobAbout
                          :   ?
                              ( ?
                              .   ?
                                  (mail2.!mail2)
                                  ?
                                  (userProvidedMetadata.?userProvidedMetadata)
                                  ?
                              )
                              ?
                      | :?userProvidedMetadata
                      )
                    & !userProvidedMetadata !parms
                  )
            )
          & ( "We are past the first stage: the user has pressed a button"
            =     parms TOOL pipes Submit directedBy hiddenData
                , parms nth pipe batch Items mail2 ERR
                , NNN pipesN calls allpipes
                , Workflows incarnationpipes newpipes restr
                , restriction rstr sources
                , ConflictingSpecs noValueConflict
                , nittyGritty specConflict
                , unifySignatures updateUploads
              .     !arg
                  : ( ?parms
                    . ?TOOL
                    . ?Submit
                    . ?directedBy
                    . ?hiddenData
                    . ?parms
                    . ?batch
                    . ?Items
                    . ?mail2
                    )
                & ( updateUploads
                  =     A nr Item Path stagingName
                      , meta feats visibility Z parms
                    .   !arg:?parms:? (Item.?Item) ?
                      & readTable$Uploads:?Uploads
                      & readTable$features:?features
                      &   !Uploads
                        :   ?A
                            ( ?nr
                            . !Item
                            . ?Path
                            . ?stagingName
                            . ?meta
                            . ?feats
                            . ?visibility
                            )
                            ?Z
                      &     !A
                            ( !nr
                            . !Item
                            . !Path
                            . !stagingName
                            . !meta
                            .   map
                              $ ( ( 
                                  =   key val
                                    .       !arg
                                          : ( @(?:I ?key)
                                            . ~:?val
                                            )
                                        &   !features
                                          : ?+(? (short.!key) ?)+?
                                        & (!key.!val)
                                      | 
                                  )
                                . !parms
                                )
                            . !visibility
                            )
                            !Z
                        : ?Uploads
                      & saveTable$Uploads
                  )
                & ( signatures
                  =   A prog o i sub
                    .     !arg:(((?,?) ?)*?.?arg)
                        & signatures$!arg
                      |   !arg:%?A*%?arg
                        & signatures$!A*signatures$!arg
                      |   !arg:(%@?prog,(?o.?i.?sub))
                        & !prog^(!o.!i)*signatures$!sub
                      | 1
                  )
                & ( containedBy
                  =   A B a
                    .   !arg:(?A.?B)
                      & (     !A
                            : ? (`%?a&~(!B:? !a ?)) ?
                          & `~
                        | 
                        )
                  )
                & ( noValueConflict
                  =   A B f e g
                    .   !arg:(?A.?B)
                      & ( !A:!B
                        | ~( !A
                           :   ?
                               ( ?f
                               ,   %@?e^?
                                 & !B:? (!f,%@?g^?) ?
                                 & !e:~!g
                               )
                               ?
                           )
                        )
                  )
                & ( specConflict
                  =   A B f e x y
                    .   !arg:(?A.?B)
                      &   !A
                        :   ?
                            ( ?f
                            ,   %@?e^?x
                              & !B:? (!f,!e^?y) ?
                              & !x*!y:%*%
                            )
                            ?
                  )
                & ( NoValueConflicts
                  =   i I o O
                    .   !arg:((?o.?i),(?O.?I))
                      & noValueConflict$(!i.!I)
                      & noValueConflict$(!o.!O)
                  )
                & ( ConflictingSpecs
                  =   i I o O
                    .   NoValueConflicts$!arg
                      & !arg:((?o.?i),(?O.?I))
                      & ( specConflict$(!i.!I)
                        | specConflict$(!o.!O)
                        )
                  )
                & ( containedBy
                  =   short long fac val e E rem
                    .   !arg:(?short.?long)
                      & ( !short:
                        |   !short:(?fac,@?val^?e) ?short
                          & !long:? (!fac,!val^?E) ?
                          & (   !e:(1|!E)
                              & containedBy$(!short.!long):?rem
                              & (!fac,!val^!E) !rem
                            |   !E:1
                              & containedBy$(!short.!long):?rem
                              & (!fac,!val^!e) !rem
                            )
                        )
                  )
                & ( clashing
                  =   oi1 oi2
                    .   !sjt
                      :   ?
                        + #*((?.?):?oi1)
                        + ?
                        +   #
                          * ( (?.?):?oi2
                            & ConflictingSpecs$(!oi1,!oi2)
                            )
                        + ?
                  )
                & ( copySpecs
                  =   Ao Ai Bo Bi res
                    .   !arg:((?Ao.?Ai),(?Bo.?Bi))
                      & (supplement$(!Ao.!Bo).supplement$(!Ai.!Bi))
                  )
                & ( nittyGritty
                  =   oi1 oi2 A M Z OI
                    .       !arg
                          :   ?A
                            + #*((?.?):?oi1)
                            + ?M
                            +   #
                              * ( (?.?):?oi2
                                & NoValueConflicts$(!oi1,!oi2)
                                )
                            + ?Z
                        &   nittyGritty
                          $ ( !A
                            + copySpecs$(!oi2,copySpecs$(!oi1,!oi2))
                            + !M
                            + !Z
                            )
                      | !arg
                  )
                & ( unifySignatures
                  =   tool A sigs
                    .     !arg:?A*%@?tool^(%+%:?sigs)*?arg
                        &   !A
                          * !tool^nittyGritty$!sigs
                          * unifySignatures$!arg
                      | !arg
                  )
                & ( rpl
                  =   vals fac gold A B exp
                    .     !arg:(?vals.?fac.?gold)
                        & !vals:%?A*%?B
                        & rpl$(!A.!fac.!gold):?A
                        & rpl$(!B.!fac.!gold):?B
                        & !A*!B
                      |   !vals:%?A %?B
                        & rpl$(!A.!fac.!gold):?A
                        & (rpl$(!B.!fac.!gold):?B|)
                        & !A !B
                      |   !vals:@?A^?B
                        & (   !gold:?*(? (!fac,!vals) ?)*?
                            & !vals
                          |     !gold
                              : ?*(? (!fac,!A^?exp) ?)*?
                            &   ( !B:!exp
                                | !exp:1&!B
                                | !B:1&!exp
                                )
                              : ?B
                            & !A^!B
                          | !A^!B
                          )
                  )
                & ( adaptInputProfile
                  =   I subs fac gold nI vals
                    .     !arg:(?I.?subs)
                        &   !subs
                          : (((?,?) ?)*?:?gold.?)
                        & :?nI
                        &   whl
                          ' ( !I:(?fac,?vals) ?I
                            &   !nI (!fac,rpl$(!vals.!fac.!gold))
                              : ?nI
                            )
                        & !nI
                      | !I
                  )
                & ( Tubst
                  =     OI I A o i sub prog
                      , H h h1 H1 O
                    .   !arg:(?arg.?OI)
                      & (     !arg
                            : (((?,?) ?)*?:?H.?arg)
                          & Tubst$(!arg.!OI):?arg
                          & 1:?h
                          &   whl
                            ' ( !H:%?H1*?H
                              & (     !arg
                                    : (   ?
                                        * ( ?
                                          , (   ?O
                                              &   containedBy$(!H1.!O)
                                                : ?h1
                                            . ?
                                            )
                                          )
                                        * ?
                                      |   ?
                                        * ( `%?O
                                          & ~(!O:(?,(?.?)))
                                          & containedBy$(!H1.!O):?h1
                                          )
                                        * ?
                                      )
                                  & !h*!h1:?h
                                | !h*(!H1 problem !arg):?h
                                )
                              )
                          & (   !h:1&HA!
                              | !h
                            . !arg
                            )
                        |   !arg:%?A*%?arg
                          & Tubst$(!A.!OI)*Tubst$(!arg.!OI)
                        |   !arg:(%@?prog,(?o.?i.?sub))
                          &   !OI
                            :   ?
                              *   !prog
                                ^ ( ?
                                  +   #
                                    * ( ?O
                                      .   ?I
                                        & noValueConflict$(!O.!o)
                                        & noValueConflict$(!I.!i)
                                      )
                                  + ?
                                  )
                              * ?
                          & Subst$(!sub.!OI):?sub
                          & (!prog,(!O.adaptInputProfile$(!I.!sub).!sub))
                        | !arg
                        )
                  )
                & ( Subst
                  =   OI H h h1 H1 O
                    .   !arg:(?arg.?OI)
                      & (     !arg
                            : (((?,?) ?)*?:?H.?arg)
                          & Tubst$(!arg.!OI):?arg
                          & 1:?h
                          &   whl
                            ' ( !H:%?H1*?H
                              & (     !arg
                                    : (   ?
                                        * ( ?
                                          , (   ?O
                                              &   containedBy$(!H1.!O)
                                                : ?h1
                                            . ?
                                            )
                                          )
                                        * ?
                                      |   ?
                                        * ( `%?O
                                          & ~(!O:(?,(?.?)))
                                          & containedBy$(!H1.!O):?h1
                                          )
                                        * ?
                                      )
                                  & !h*!h1:?h
                                |     !h
                                    * ( !H1
                                        substproblem
                                        !arg
                                        endsubstproblem
                                      )
                                  : ?h
                                )
                              )
                          & (   !h:1&HA!
                              | !h
                            . !arg
                            )
                        | !arg
                        )
                  )
                & "wantThis either returns the argument (if it is wanted) or
                   zero (if it isn't). So it does not FAIL."
                & ( wantThis
                  =   sig nsig
                    .   signatures$!arg:?sig
                      & (   !sig:?*?^(%+%:clashing$)*?
                          & "Discard solutions that contain steps that are
                             equal (or at least compatible) at the un-
                             subspecified level, but clash at the spec level."
                          & 0
                        |   unifySignatures$!sig:?nsig
                          & Subst$(!arg.!nsig):?arg
                          & "Either each tool is used in exactly one way, or
                             the different ways ALL differ more than only at
                             the subspec level."
                          & !arg
                        )
                  )
                & updateUploads$!parms
                & 0:?calls:?allpipes
                & :?restr
                & (   (   !directedBy:GoalChoice
                        & !wrkflw:~
                        &   precooked-DASISH$(!wrkflw.!A !Z)
                          : (?arg:?parms.?errmsg)
                        & !errmsg:
                        & readTable$Workflows
                        &   !Workflows
                          :   ?
                              (   ?reqs
                                &   whl
                                  ' ( !reqs:%?req ?reqs
                                    & log$(req !req)
                                    & !parms:? !req ?
                                    )
                                & !reqs:
                              . ?pipes
                              . ?descr
                              )
                              ?
                        & log$FoundWorkflow
                      |   log$(ComputePipelines !parms)
                        & (     Pipelines$!parms
                              : ( ?sources
                                . ?pipes
                                .   ( withRestriction
                                    | onlyWithoutRestriction
                                    | triviallyFulfilled
                                    )
                                  : ?restr
                                )
                            & log$("Pipelines computed restr=[" !restr "]")
                          |   log$(ComputePipelines failed)
                            & ~
                          )
                        &   !restr
                          : ( withRestriction
                            | triviallyFulfilled
                            )
                      )
                    &   log
                      $ "We may have succeeded in computing one or more pipelines."
                    & "We may have succeeded in computing one or more pipelines."
                    & (   ( !pipes:#:?NNN
                          |   !pipes:?+[?NNN
                            & !NNN:>1000
                          )
                        & TooManyOrNone$(!calls.!NNN)
                      |   !Submit:"next step"
                        & log$"next step"
                        & ShowAllPipes$(!directedBy.!hiddenData.!pipes)
                      |     !parms
                          : (   ?
                                ( bsubmit
                                . @(?:(prev|next) #?nth)
                                )
                                ?
                            | ? (nth.?nth) ?
                            | ?&1:?nth
                            )
                        &   log
                          $ ( str
                            $ ( "Wind to the "
                                !nth
                                " pipeline. That is the one the user has chosen."
                              )
                            )
                        & "Wind to the nth pipeline. That is the one the user has chosen."
                        & windFW$(!pipes.!nth):?pipe
                        & log$(Submit !Submit)
                        & (     !Submit
                              : ( "View details"
                                | @(?:(prev|next) ?)
                                )
                            &   ShowOnlyTheCurrentPipe
                              $ (!pipe.!nth.!directedBy)
                          |   !Submit:Metadata
                            & (     !parms
                                  : ~( ?
                                       ( Iformat
                                       .   ( txtbasis
                                           | txtann
                                           | teip5
                                           )
                                         ^ ?
                                       )
                                       ?
                                     )
                                & canConsumeMetadata$!pipe
                                &   rememberMetadata$(TEImetadata.!parms)
                                  : ?parms
                                &   AddMetadata
                                  $ (TEImetadata.!nth.!directedBy.!parms.)
                              | NoNeedForMetadata$
                              )
                          |   !Submit:Submit
                            & (     !parms
                                  : ~( ?
                                       ( Iformat
                                       .   ( txtbasis
                                           | txtann
                                           | teip5
                                           )
                                         ^ ?
                                       )
                                       ?
                                     )
                                & canConsumeMetadata$!pipe
                                & (   MetadataInParms$(TEImetadata.!parms)
                                    &     errorInMetadata
                                        $ (TEImetadata.!parms)
                                      : ?ERR
                                  |   ~(MetadataInParms$(TEImetadata.!parms))
                                    &   !parms
                                      :   ?
                                          ( Oformat
                                          .   ( txtbasis
                                              | txtann
                                              | teip5
                                              )
                                            ^ ?
                                          )
                                          ?
                                    &     rememberMetadata
                                        $ (TEImetadata.!parms)
                                      : ?parms
                                  )
                                &   AddMetadata
                                  $ ( TEImetadata
                                    . !nth
                                    . !directedBy
                                    . !parms
                                    . !ERR
                                    )
                              |   ApplyThePipelineToTheInput
                                $ ( TEImetadata
                                  . !pipe
                                  . !batch
                                  . !Items
                                  . !mail2
                                  . !parms
                                  . !directedBy
                                  )
                              )
                          )
                      )
                  |     !restr
                      : ( onlyWithoutRestriction
                        | triviallyFulfilled
                        )
                    & !parms:? (desiredtool.?restriction) ?
                    & log$noway1
                    & NoWay$(!restriction.!restr.!calls)
                  | log$noway2&NoWay$(..!calls)
                  )
            )
          & ( computeWorkflow
            =     "Shall we treat all resources in one job (non-batch) or shall we
               send each input through a different (though similar) job?"
                &   (     !parms
                        : ( ? (action.batch) ?
                          | ? (batch.on) ?
                          |   ~(? (action.?) ?)
                            & ~(? (batch.?) ?)
                          )
                      & on
                    | off
                    )
                  : ?batch
                & log$(batch !batch)
                & !errors:
                & (   !arg:? (handle.?handle) ?
                    &   (handle.!handle) !hiddenData
                      : ?hiddenData
                  | 
                  )
                & !hiddenData (batch.!batch):?hiddenData
                & "Does the user want to decide which tool to use or does she want
                   to let the infrastructure work out a way to reach a set goal?"
                & (   !directedBy:GoalChoice
                    & :?TOOL
                  |     str
                      $ (400~~~ toML$(!BodyContainer$(paragraph$goal?)))
                    : ?errors
                  )
                & !errors:
                & !hiddenData !Items !hid:?hiddenData
                &     !hiddenData
                      (   !arg:? (desiredtool.?rstr) ?
                        & (desiredtool.!rstr)
                      | 
                      )
                      (   !arg:? (superset.?rstr) ?
                        & (superset.!rstr)
                      | 
                      )
                  : ?hiddenData
                & unpackIOparms$!parms:?parms
                & checkIOparms$!parms
                & readTable$tooladm
                & (   !parms:? (bsubmit.?Submit) ?
                    &   "We are past the first stage: the user has pressed a button"
                      $ ( !parms
                        . !TOOL
                        . !Submit
                        . !directedBy
                        . !hiddenData
                        . !parms
                        . !batch
                        . !Items
                        . !mail2
                        )
                  |   "We are at the start. Show an input form."
                    $ (!formFields.!presels.!directedBy.!hiddenData.!Items)
                  )
              | !errors
            )
          & ( computeWorkflowDASISH
            =     unpackIOparms$!parms:?parms
                & checkIOparms$!parms
                & readTable$tooladm
                &   "We are past the first stage: the user has pressed a button"
                  $ ( !parms
                    . 
                    . !Submit
                    . !directedBy
                    . !hiddenData
                    . !parms
                    . off
                    . !Items
                    . !mail2
                    )
              | !errors
            )
          &   
            : ?hid
            : ?errors
            : ?hiddenData
            : ?formFields
            : ?Items
            : ?PIPE
            : ?wrkflw
          & 0:?tabind
          & ?:?Tool
          & log$NEW
          & startclock$
          & log$CREATELOGJE
          & !arg:(?parms:?arg.?directedBy)
          & !HTMLbodyContainer:?BodyContainer
          & setLanguageNotPermanently$!arg
          & analyzeInput$!parms:(?parms.?Items.?presels)
          & log$analyzeInputDONE
          &   checkMail$(!parms.!formFields.!hiddenData.!errors)
            : (?mail2.?formFields.?hiddenData.?errors)
          & log$checkMailDONE
          & (   !arg:?A (wrkflw.?wrkflw) ?Z
              & (   !Items:
                  &   str
                    $ ( 200~~~
                          toML
                        $ ( !BodyContainer
                          $ (paragraph$"Select a file to convert to TEI.")
                          )
                      )
                |   !directedBy:GoalChoice
                  & (     precooked-DASISH$(!wrkflw.!A !Z)
                        : (?arg:?parms.?errmsg)
                      & !errmsg:
                      & log$computeWorkflow
                      & !computeWorkflow
                    |   str
                      $ (200~~~ toML$(!BodyContainer$(paragraph$!errmsg)))
                    )
                )
            | !computeWorkflow
            )
      )
      (createGoalChoice=.create$(!arg.GoalChoice))
      "
/**
 * getStatusCode
 *
 *  Given a HTTP status code and an informatory text, return an HTML-file
 * with a heading containing the status code and the official short description
 * of the status code, a paragraph containing the informatory text and a 
 * paragraph displaying a longer text explaining the code (From wikipedia).
 * 
 * This function could just as well have been written in Java.
 * 
 * Called from create.java, register.java,
 * stresstest.java, update.java, upload.java
 */"
      ( getStatusCode
      =   code tekst explanation
        .   readTable$HTTP-status-codes
          & !arg:(?code.?tekst)
          & !HTTP-status-codes:? (!code.?arg.?explanation) ?
          &   toML
            $ ( !HTMLbodyContainer
              $ ( heading$(1.!code " " !arg)
                  paragraph$!tekst
                  paragraph$!explanation
                )
              )
      )
      ( poll
      =     jobs n step secs steplinks links
          , serviceurl title tooladm
          , runningParagraphs JobNr
        .   ( steplinks
            =     links jobs file step outp ServiceURL JobNr
                , seenInputs
              .   !arg:(?JobNr.?jobs)
                &   !jobs
                  :   ?
                      (   (!JobNr.step1 ?.?file.?.?.?outp)
                          ?
                      : ?jobs
                      )
                & :?seenInputs
                &     map
                    $ ( ( 
                        =   files
                          .   !arg:(!JobNr.?.?files.?.?.?)
                            &   map
                              $ ( ( 
                                  =   
                                    .       !Uploads
                                          : ? (?.?.?.!arg.?) ?
                                        & (   !seenInputs:? !arg ?
                                            & 
                                          |     !arg !seenInputs
                                              : ?seenInputs
                                            &   paragraph
                                              $ ( "input:"
                                                  ( a
                                                  .   ( href
                                                      .   str
                                                        $ ( !wwwServer
                                                            "/texton/data/"
                                                            !arg
                                                          )
                                                      )
                                                    , !arg
                                                  )
                                                )
                                          )
                                      | 
                                  )
                                . !files
                                )
                        )
                      . !jobs
                      )
                  : ?links
                &   whl
                  ' (   !jobs
                      :   ?
                          (!JobNr.?step done.?.?ServiceURL.?.?file)
                          ?jobs
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!ServiceURL) ?
                          : ? (Title.?Title) ?
                          )
                        + ?
                    &     !links
                            paragraph
                          $ ( str$(!step ":")
                              ( a
                              .   ( href
                                  . str$(!wwwServer "/texton/data/" !file)
                                  )
                                , !file
                              )
                              " ("
                              !Title
                              ")"
                            )
                      : ?links
                    )
                & ( !links:% %
                  | !jobs:? (!JobNr.?) ?
                  |     !links
                          paragraph
                        $ ( "output:"
                            ( a
                            .   ( href
                                . str$(!wwwServer "/texton/data/" !file)
                                )
                              , !outp
                            )
                          )
                    : ?links
                  )
                & !links
            )
          & log$(poll !arg)
          & ( !arg:(?JobNr.?secs)
            | @(!arg:? #?JobNr)&10:?secs
            )
          & readTable$jobs
          & readTable$tooladm
          & readTable$Uploads
          & div$(!deleteAfterMillisec*86400000^-1*24.1):?hours
          &   toML
            $ (   steplinks$(!JobNr.!jobs):?links
                &     ( 
                      =   jobs n JobNr
                        .   0:?n
                          & !arg:(?jobs.?JobNr)
                          &   whl
                            ' ( !jobs:? (!JobNr.?) ?jobs
                              & 1+!n:?n
                              )
                          & !n
                      )
                    $ (!jobs.!JobNr)
                  : ?n
                &     map
                    $ ( ( 
                        =   serviceurl title step
                          .       !arg
                                : ( !JobNr
                                  .   %@?step
                                      ( 
                                      | starting
                                      | waiting
                                      )
                                  . ~(? (?,pending) ?)
                                  . ?serviceurl
                                  . ?
                                  . ?
                                  )
                              &   !tooladm
                                :   ?
                                  + ( ? (ServiceURL.!serviceurl) ?
                                    : ? (Title.?title) ?
                                    )
                                  + ?
                              &   paragraph
                                $ (   localized
                                    $ ( "Currently running "
                                        "I øjeblikket kører "
                                      )
                                    !step
                                    " "
                                    localized$(of af)
                                    " "
                                    !n
                                    " ("
                                    !title
                                    ")"
                                  )
                            | 
                        )
                      . !jobs
                      )
                  : ?runningParagraphs
                & (   !runningParagraphs:
                    &   !HTMLbodyContainer
                      $ ( !links
                            paragraph
                          $ ( localized$("Done! " "Færdig! ")
                              ( a
                              .   ( href
                                  .   !wwwServer
                                      "/texton/zipresults?JobNr="
                                      !JobNr
                                  )
                                ,   localized
                                  $ ( "Download input and all results"
                                      "Download input og alle resultater"
                                    )
                              )
                              localized$(" OR " " ELLER ")
                              ( a
                              .   ( href
                                  .   !wwwServer
                                      "/texton/zipresults?shortletter=y&amp;JobNr="
                                      !JobNr
                                  )
                                ,   localized
                                  $ ( "Download final results"
                                      "Download slutresultater"
                                    )
                              )
                              ". ("
                                localized
                              $ ( "Re-run the workflow if you want to download both"
                                  "Kør igen hvis du vil downloade begge"
                                )
                              ".)"
                            )
                        )
                  |   refreshingXHTMLbodyContainer
                    $ ( !secs str$(!wwwServer "/texton/mypoll?job=" !JobNr)
                      .   !links
                          !runningParagraphs
                            paragraph
                          $ ( str
                            $ (   localized
                                $ ( "Reload this page to track the status of your job. Or wait. This page auto-reloads after "
                                    "Genindlæs denne side hvis du vil følge status på arbejdsgangen. Eller vent. Siden genindlæses automatisk efter "
                                  )
                                !secs
                                localized$(" seconds." " sekunder.")
                              )
                            )
                      )
                  )
              |   !HTMLbodyContainer
                $ (     ( 
                        =   zippedresults zipfile
                          .   readTable$zippedresults
                            & str$(!arg ".zip"):?zipfile
                            & !zippedresults:? !zipfile ?
                        )
                      $ !JobNr
                    &   paragraph
                      $ ( ( a
                          .   ( href
                              . !wwwServer "/texton/zipresults?JobNr=" !JobNr
                              )
                            ,   localized
                              $ ("Download result. " "Download resultat. ")
                          )
                            localized
                          $ (   str
                              $ ( " The zipped results are kept for no more than "
                                  !hours
                                  " hours! "
                                )
                                str
                              $ ( " De zippede resultater bliver bevaret is højst "
                                  !hours
                                  " timer!"
                                )
                            )
                        )
                  |   paragraph
                    $ ( localized
                      $ (   str
                          $ ( "The results have been deleted after "
                              !hours
                              " hours. "
                            )
                            str
                          $ ( "Resultaterne er blevet slettet efter "
                              !hours
                              " timer. "
                            )
                        )
                      )
                  )
              )
      )
      ( WRAPUPbody
      =   workflow
        .   toML
          $ ( html
            .   
              , ( body
                .   
                  ,   ( p
                      .   
                        ,   localized
                          $ ( "We have received your request to create new data by means of integrated tools."
                              "Vi har modtaget dit ønske om at oprette ny data ved hjælp af integrerede værktøjer."
                            )
                      )
                      ( readTable$jobAbout
                      & (     !jobAbout
                            :   ?
                                (!arg.? (human.?workflow) ?)
                                ?
                          & ( dl
                            .   
                              ,   (dt.,"Workflow:")
                                  (dd.,!workflow)
                            )
                        |   :?workflow
                          & (p.,"Unknown job " !arg)
                        )
                      )
                      (br.,)
                      \n\n
                      ( p
                      .   
                        ,     localized
                            $ ( "The creation of new data went well. Double click the link below or copy the URL to your browser to fetch the result."
                                "Oprettelsen er gået godt. Dobbelklik linket eller kopier adressen til din browser."
                              )
                            (br.,)
                            (br.,)
                            \n\n
                            ( a
                            .   ( href
                                . !wwwServer "/texton/zipresults?JobNr=" !arg
                                )
                              ,   str
                                $ (!wwwServer "/texton/zipresults?JobNr=" !arg)
                            )
                            \n\n
                            (br.,)
                            (br.,)
                            localized$(Notice! Bemærk!)
                            (br.,)
                            \n
                              localized
                            $ ( "Results will be deleted from the server after a few days."
                                "Ikke-hentede resultaterne slettes efter et par dage."
                              )
                            (br.,)
                            (br.,)
                            \n\n
                              localized
                            $ ( "You cannot answer this email. If the above information is incorrect or if you have any questions, please contact us on email address admin@clarin.dk"
                                "Du kan ikke svare på denne email. Hvis ovenstående oplysninger ikke er rigtige, eller du har spørgsmål, kan du henvende dig på mail-adressen admin@clarin.dk"
                              )
                            (br.,)
                            (br.,)
                            \n\n
                            localized$("With kind regards," "Venlig hilsen")
                            (br.,)
                            \n
                            CLARIN-DK
                      )
                )
            )
      )
      "
/**
 * keep
 *
 * Check whether a result from a tool in the staging area can be deleted.
 *
 * Results that for some reason are needed by other tasks must be kept.
 * The function looks for outstanding jobs that take the argument as input.
 * Argument: file name, may be preceded by a slash
 *      /19231210291
 *
 * NOTICE: If the file need not be kept, the file's name is deleted from
 * several tables, so calling keep has side effects!
 * Affected tables:
 *      jobs.table
 *      Uploads.table
 *      CTBs.table
 *      relations.table
 *      jobAbout.table
 *
 * Called from data.java and cleanup.java
 */"
      ( keep
      =     jobNr jobID jobstatus files toolURL parms file
          , A Z find
        .     readTable$jobs
            & log$(keep !arg)
            & (@(!arg:? "/" ?arg)|)
            &   !jobs
              :   ?
                  ( ( ?jobNr
                    . %?jobID ?jobstatus
                    . ?files
                    . ?toolURL
                    . ?parms
                    . ?file
                    )
                  & ( !files:? !arg ?
                    | !file:!arg
                    |   !parms:?+(I.?parms)+?
                      & ( find
                        =   x T L R
                          .     !arg:(?x.?T)
                              & !x:!T
                            |   !T:?L_?R
                              & (find$(!x.!L)|find$(!x.!R))
                        )
                      & find$(!arg.!parms)
                    )
                  &   !jobstatus
                    : (|waiting|starting)
                  )
                  ?
            & yes
          |   readTable$Uploads
            & readTable$CTBs
            & readTable$relations
            & readTable$jobAbout
            &   whl
              ' ( !Uploads:?A (?.!arg.?) ?Z
                & !A !Z:?Uploads
                )
            &   whl
              ' (   !jobs
                  :   ?A
                      ( ( ?jobNr
                        . %?jobID ?jobstatus
                        . ?files
                        . ?toolURL
                        . ?parms
                        . ?file
                        )
                      & ( !files:? !arg ?
                        | !file:!arg
                        )
                      )
                      ?Z
                & !A !Z:?jobs
                & deleteDepending$(!jobNr.!jobID)
                )
            & saveTable$Uploads
            & saveTable$jobs
            & saveTable$CTBs
            & saveTable$relations
            & saveTable$jobAbout
            & no
      )
      "
/**
 * cleanup
 *
 * Delete all references to files that no longer exist.
 * Argument: a list of the files that still exist in the Staging area.
 * Affected tables:
 *      Uploads.table
 *      jobs.table
 *      CTBs.table
 *      relations.table
 *      jobAbout.table 
 *
 * Called from cleanup.java
 */"
      ( cleanup
      =     jobNr jobID jobstatus files toolURL parms file
          , A Z a z F deleteDependingJobs existingFiles
          , Path feats item meta nr stagingName visibility
        .   ( deleteDependingJobs
            =     A Z jobNr jobs
                , a file files jobID jobstatus parms toolURL z
              .   !arg:(?arg.?jobs)
                &   whl
                  ' (   !jobs
                      :   ?A
                          ( ?jobNr
                          . %?jobID ?jobstatus
                          . ? !arg ?
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                          ?Z
                    & deleteDepending$(!jobNr.!jobID)
                    &     map
                        $ ( ( 
                            =   
                              .       !arg
                                    : ( !jobNr
                                      . %?jobID ?jobstatus
                                      . ?files
                                      . ?toolURL
                                      . ?parms
                                      . ?file
                                      )
                                  & deleteDepending$(!jobNr.!jobID)
                                  & 
                                | !arg
                            )
                          . !A !Z
                          )
                      : ?jobs
                    )
                & !jobs
            )
          & log$(cleanup !arg)
          & readTable$Uploads
          & readTable$jobs
          & readTable$CTBs
          & readTable$relations
          & readTable$jobAbout
          & !arg:?existingFiles
          &   ( 
              =   existingFiles zippedresults
                .   !arg:?existingFiles
                  & readTable$zippedresults
                  &     map
                      $ ( ( 
                          =   
                            .     !existingFiles:? !arg ?
                                & !arg
                              | 
                          )
                        . !zippedresults
                        )
                    : ?zippedresults
                  & saveTable$zippedresults
              )
            $ !existingFiles
          &     map
              $ ( ( 
                  =   
                    .     !arg
                        : ( ?nr
                          . ?item
                          . ?Path
                          . ?stagingName
                          . ?meta
                          . ?feats
                          . ?visibility
                          )
                      & (   ~(!existingFiles:? !stagingName ?)
                          &   deleteDependingJobs$(!stagingName.!jobs)
                            : ?jobs
                          & 
                        | 
                        )
                  )
                . !Uploads
                )
            : ?Uploads
          &     map
              $ ( ( 
                  =   
                    .     !arg
                        : ( ?jobNr
                          . %?jobID ?jobstatus
                          . ?files
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                      & (   (   !files
                              :   ?
                                  ( %@?F
                                  & ~(!existingFiles:? !F ?)
                                  )
                                  ?
                            | ~(!existingFiles:? !file ?)
                            )
                          & deleteDepending$(!jobNr.!jobID)
                          & 
                        | !arg
                        )
                  )
                . !jobs
                )
            : ?jobs
          &   whl
            ' (   !CTBs
                :   ?a
                    ( (?jobNr.?jobID.?)
                    & ~(!jobs:? (!jobNr.!jobID ?.?) ?)
                    )
                    ?z
              & !a !z:?CTBs
              )
          &   whl
            ' (   !relations
                :   ?a
                    ( (?jobNr.?jobID.?)
                    & ~(!jobs:? (!jobNr.!jobID ?.?) ?)
                    )
                    ?z
              & !a !z:?relations
              )
          &   whl
            ' (   !jobAbout
                :   ?a
                    ( (?jobNr.?)
                    & ~(!jobs:? (!jobNr.?) ?)
                    )
                    ?z
              & !a !z:?jobAbout
              )
          & saveTable$Uploads
          & saveTable$jobs
          & saveTable$CTBs
          & saveTable$relations
          & saveTable$jobAbout
      )
      "
/*
 * stresstest
 *
 * Do a computation that occupies Bracmat for several seconds.
 * Usage: activate the stresstest from several browsers at
 * about the same time, so they have to queue up and wait for
 * the previous to finish.
 *
 * Purpose: check that the transition from Java's multiple threads
 * to the Bracmat JNI's single thread and back goes smooth.
 *
 * Input: a HTTP-parameter 'stress' with a numerical value > 0.
 *
 * The function computes the first 'stress' terms in the decimal 
 * approximation of π.
 *
 * Called from stresstest.java
 */"
      ( stresstest
      =   PI err pi
        .     ( pi
              =   s1,s2,isgn,isgn1,err1,err2,i,j
                .   0:?s1
                  & 1:?isgn
                  & 1:?i
                  &   whl
                    ' ( !i:~>!arg
                      & 2*!i+-1:?j
                      & !s1+!isgn*(!j*5^!j)^-1:?s1
                      & -1*!isgn:?isgn
                      & 1+!i:?i
                      )
                  & 16*((2*!arg+1)*5^(2*!arg+1))^-1:?err1
                  & !isgn:?isgn1
                  & 16*!s1:?s1
                  & 0:?s2
                  & 1:?isgn
                  & 1:?i
                  &   whl
                    ' ( 2*!i+-1:?j
                      & (!j*239^!j)^-1:?err2
                      & 4*!err2:>!err1
                      & !s2+!isgn*!err2:?s2
                      & -1*!isgn:?isgn
                      & 1+!i:?i
                      )
                  & flt$(!isgn1*(!err1+4*!err2),2):?err
                  & !s1+-4*!s2
              )
            &   !arg
              : ? (stress.~/#?arg:>0:<1001) ?
            & (readTable$pies|:?pies)
            & pi$!arg:?PI
            & !pies (!arg.!PI !err):?pies
            & saveTable$pies
            &   toML
              $ ( !HTMLbodyContainer
                $ ( paragraph
                  $ ( str
                    $ ( "Your number:"
                        !arg
                        " Your approximation of pi:"
                        flt$(!PI,!arg)
                        " error "
                        !err
                      )
                    )
                  )
                )
          |   toML
            $ ( !HTMLbodyContainer
              $ (paragraph$(str$("Not understood:" !arg)))
              )
      )
      "
/*
 * wrapper
 *
 * Generate a web service wrapper from tool metadata.
 * Usage: wrapper$(PHP.<toolID>)
 * (Other languages may be supported in the future.)
 */"
      ( wrapper
      =     combineFeats combineToolIncarnations getBoilerPlate
          , getFeatName getFeatSpecTable getFeatTable listAlts
          , makeName DATA DATATEXT FEATURES FEATURETEXT Features
          , IO Iopt Oopt STYLES STYLETEXT basejobpost2 boilerPlate
          , boolfunc boolvar data declarations ech featname fname
          , fname1 fname2 fval helperFunctions httpparm iolist
          , lastWord mainfunc name o sptable stringfunc stringvar
          , toolParameters toolParmTests toolprop value values var
          , voidfunc i tooladm features svalues
          , getFeatValues toolid output TUPTUO reverselist
          , annotationStyles basistextStyles facets fileFormats
          , flatFileTypes imageStyles linguae presentations sndStyles
          , tagSets textStyles tokenisationStyles
        .     !arg
            : ( (?arg.?toolid)
              | ?&:?toolid
              )
          & :?TUPTUO
          & (output=.str$!arg !TUPTUO:?TUPTUO)
          & ( reverselist
            =   L E
              .   :?L
                &   whl
                  ' (!arg:%?E ?arg&!E !L:?L)
                & str$!L
            )
          & (   !arg:PHP
              &   "function "
                : ?stringfunc
                : ?boolfunc
                : ?voidfunc
              & "$":?stringvar:?boolvar:?var
              &     "<?php
header(\"Content-type:text/plain; charset=UTF-8\");
/*
 * This "
                    !arg
                    " script is generated by CLARIN-DK's tool registration form 
 * (https://clarin.dk/texton/register). It should, with no or few adaptations
 * work out of the box as a dummy for your web service. The output returned
 * to the CLARIN-DK workflow manager is just a listing of the HTTP parameters
 * received by this web service from the CLARIN-DK workflow manager, and not
 * the output proper. For that you have to add your code to this script and
 * deactivate the dummy functionality. (The comments near the end of this
 * script explain how that is done.)
 *
 * Places in this script that require your attention are marked 'TODO'.
 */
"
                : ?boilerPlate
              &   "    }
catch (SystemExit $e) 
    { 
    header ('An error occurred.' . $ERROR, true , 404 );
    logit('An error occurred' . $ERROR);
    echo $ERROR;
    }

?>
"
                : ?lastWord
            |   !arg:java
              & "public String ":?stringfunc
              & "public bool ":?boolfunc
              & "public void ":?voidfunc
              & "String ":?stringvar
              & "bool ":?boolvar
              & :?var
              & :?boilerPlate:?lastWord
            )
          & ( listAlts
            =   alt featF opts rsr rsrc stl style alts
              .   !arg:(?alts.?IO.?featname)
                &   whl
                  ' ( !alts:%(%?alt ?opts)+?alts
                    & (   !alt:%*%
                        & ( featF
                          = (!IO.!featname.!rsr.F)+!DATA:?DATA
                          )
                      |   !opts:% ?
                        & ( featF
                          = (!IO.!featname.!rsr.F)+!DATA:?DATA
                          )
                      | (featF=)
                      )
                    &   whl
                      ' ( !alt:%?rsrc*?alt
                        & (   !rsrc:?rsr^%?style
                            &   whl
                              ' ( !style:%?stl+?style
                                &   (!IO.!featname.!rsr)\L!stl+!STYLES
                                  : ?STYLES
                                )
                          | !rsrc:?rsr
                          )
                        & (!IO.!featname)\L!rsr+!FEATURES:?FEATURES
                        & !featF
                        )
                    &   whl
                      ' ( !opts:%?rsrc ?opts
                        & (   !rsrc:?rsr^%?style
                            &   whl
                              ' ( !style:%?stl+?style
                                &   (!IO.!featname.!rsr)\L!stl+!STYLES
                                  : ?STYLES
                                )
                          | !rsrc:?rsr
                          )
                        & (!IO.!featname)\L!rsr+!FEATURES:?FEATURES
                        & (!IO.!featname.!rsr.F)+!DATA:?DATA
                        )
                    )
                & 
            )
          & ( makeName
            =   name camel c
              .   :?name
                & (camel=.!arg)
                &   whl
                  ' ( @(!arg:%?c ?arg)
                    &     (     !c
                              : ( ~<0:~>9
                                | "_"
                                | ~<a:~>z
                                | ~<A:~>Z
                                )
                            & camel$!c:?c
                            & (camel=.!arg)
                            & !c
                          | (camel=.upp$!arg)&
                          )
                          !name
                      : ?name
                    )
                & rev$(str$!name)
            )
          & readTable$toolprop
          & readTable$tooladm
          & readTable$fileFormats
          & readTable$facets
          & readTable$presentations
          & readTable$linguae
          & readTable$features
          & readTable$periods
          & readTable$tagSets
          & ( getBoilerPlate
            =   id field val
              .   !arg:(?id.?field)
                &   !tooladm
                  :   ?
                    + ( ? (ToolID.!id) ?
                      : ? (!field.?val) ?
                      )
                    + ?
                & !val
            )
          & ( getFeatName
            =   fname
              .     !features
                  :   ?
                    + ( ? (short.!arg) ?
                      : ? (name.?fname) ?
                      )
                    + ?
                & localized$!fname
            )
          & ( getFeatTable
            =   table
              .     !features
                  :   ?
                    + ( ? (short.!arg) ?
                      : ? (table.?table) ?
                      )
                    + ?
                & !table
            )
          & ( getFeatValues
            =   featname value fval fvalAlt
              .   !arg:(?featname.?value)
                &   !(getFeatTable$!featname)
                  : ? (%?fval ? @?fvalAlt.!value.?) ?
                & !fval (!fvalAlt:|" (" !fvalAlt ")")
            )
          & ( getFeatSpecTable
            =   table val
              .   !arg:(?arg.?val)
                &   !features
                  :   ?
                    + ( ? (short.!arg) ?
                      :   ?
                          ( specificationTable
                          . ? (? !val ?.?table) ?
                          )
                          ?
                      )
                    + ?
                & !table
            )
          & ( combineFeats
            =   A B M Z b c
              .     whl
                  ' ( !arg:?A (?B,?b) ?M (!B,?c) ?Z
                    & !A (!B,!b+!c) !M !Z:?arg
                    )
                & !arg
            )
          & ( combineToolIncarnations
            =   A Z name featK featL Tools feats
              .     whl
                  ' ( !arg:?A+(?name.?featK)+(!name.?featL)+?Z
                    & !A+(!name.!featK !featL)+!Z:?arg
                    )
                & 0:?Tools
                &   whl
                  ' ( !arg:(?name.?feats)+?arg
                    & !Tools+(!name.combineFeats$!feats):?Tools
                    )
                & !Tools
            )
          & combineToolIncarnations$!toolprop:?toolprop
          &   whl
            ' ( !toolprop:(?name.?Features)+?toolprop
              & (   !toolid:(|!name)
                  & (     !Features
                        :   ?
                            (?fname1,?+#*(?+(%?*%? ?)+?.?)+?)
                            ?
                            (?fname2,?+#*(?+(%?*%? ?)+?.?)+?)
                            ?
                      &   log
                        $ ( str
                          $ ( "Tool "
                              !name
                              ": inputs differ on two features: "
                              !fname1
                              " and "
                              !fname2
                              ". This is currently not supported."
                            )
                          )
                    |     !Features
                        :   ?
                            (?fname1,?+#*(?.?+(%*% ?)+?)+?)
                            ?
                            (?fname2,?+#*(?.?+(%*% ?)+?)+?)
                            ?
                      &   log
                        $ ( str
                          $ ( "Tool "
                              !name
                              ": outputs differ on two features: "
                              !fname1
                              " and "
                              !fname2
                              ". This is currently not supported."
                            )
                          )
                    | 
                    )
                  & :?Iopt:?Oopt
                  & 0:?DATA
                  & 0:?FEATURES
                  & 0:?STYLES
                  & (     !Features
                        : (   ?
                              (?,?+#*(?+(%*% ?)+?.?)+?:?fval)
                              ?
                          |   ?
                              (?,?+#*(?+(% %)+?.?)+?:?fval)
                              ?
                          )
                      & (   !fval:?+#*(?+%@^?+?.?)+?
                          & "IF in some cases, IfeatvalF in other cases"
                          & " (1/2)":?Iopt
                          & (I...F)+!DATA:?DATA
                        | "Never IF, always IfeatvalF"
                        )
                    |   "Always IF, never IfeatvalF"
                      & (I...F)+!DATA:?DATA
                    )
                  & (     !Features
                        : (   ?
                              (?,?+#*(?.?+(%*% ?)+?)+?:?fval)
                              ?
                          |   ?
                              (?,?+#*(?.?+(% %)+?)+?:?fval)
                              ?
                          )
                      & (   !fval:?+#*(?.?+%@^?+?)+?
                          & "OF in some cases, OfeatvalF in other cases"
                          & " (1/2)":?Oopt
                          & (O...F)+!DATA:?DATA
                        | "Never OF, always OfeatvalF"
                        )
                    |   "Always OF, never OfeatvalF"
                      & (O...F)+!DATA:?DATA
                    )
                  &   whl
                    ' ( !Features:(?fname,?iolist) ?Features
                      &   whl
                        ' ( !iolist:#*(?i.?o)+?iolist
                          & listAlts$(!i.I.!fname)
                          & listAlts$(!o.O.!fname)
                          )
                      )
                  &     "/*
ToolID         : "
                        !name
                        "
PassWord       : "
                        getBoilerPlate$(!name.PassWord)
                        "
Version        : "
                        getBoilerPlate$(!name.Version)
                        "
Title          : "
                        getBoilerPlate$(!name.Title)
                        "
ServiceURL     : "
                        getBoilerPlate$(!name.ServiceURL)
                        \t
                        "*** TODO make sure your web service listens on this address and that this script is readable for the webserver. ***
Publisher      : "
                        getBoilerPlate$(!name.Publisher)
                        "
ContentProvider: "
                        getBoilerPlate$(!name.ContentProvider)
                        "
Creator        : "
                        getBoilerPlate$(!name.Creator)
                        "
InfoAbout      : "
                        getBoilerPlate$(!name.InfoAbout)
                        "
Description    : "
                        getBoilerPlate$(!name.Description)
                        "
ExternalURI    : "
                        getBoilerPlate$(!name.ExternalURI)
                        "
XMLparms       : "
                        getBoilerPlate$(!name.XMLparms)
                        "
PostData       : "
                        getBoilerPlate$(!name.PostData)
                        "
Inactive       : "
                        getBoilerPlate$(!name.Inactive)
                        "
*/

/*******************
* helper functions *
*******************/
$toollog = '/var/log/tool/"
                        makeName$!name
                        ".log'; /* Used by the logit() function. TODO make sure the folder exists and is writable. Adapt if needed */
                
/*  TODO Set $dodelete to false if temporary files in /tmp should not be deleted before returning. */
$dodelete = true;
$tobedeleted = array();


function loginit()  /* Wipes the contents of the log file! TODO Change this behaviour if needed. */
    {
    global $toollog,$ftemp;
    $ftemp = fopen($toollog,'w');
    if($ftemp)
        {
        fwrite($ftemp,$toollog . \"\\n\");
        fclose($ftemp);
        }
    }
    
function logit($str) /* TODO You can use this function to write strings to the log file. */
    {
    global $toollog,$ftemp;
    $ftemp = fopen($toollog,'a');
    if($ftemp)
        {
        fwrite($ftemp,$str . \"\\n\");
        fclose($ftemp);
        }
    }
    
class SystemExit extends Exception {}
try {
    "
                        !boolfunc
                        "hasArgument ("
                        !stringvar
                        "parameterName)
        {
        return isset($_REQUEST[\""
                        !stringvar
                        "parameterName\"]);
        }

    "
                        !stringfunc
                        "getArgument ("
                        !stringvar
                        "parameterName)
        {
        return isset($_REQUEST[\""
                        !stringvar
                        "parameterName\"]) ? $_REQUEST[\""
                        !stringvar
                        "parameterName\"] : \"\";
        }

    "
                        !boolfunc
                        "existsArgumentWithValue ("
                        !stringvar
                        "parameterName, "
                        !stringvar
                        "parameterValue)
        {
        /* Check whether there is an argument <parameterName> that has value 
           <parameterValue>. 
           There may be any number of arguments with name <parameterName> !
        */
        $query  = explode('&', $_SERVER['QUERY_STRING']);

        foreach( $query as $param )
            {
            list($name, $value) = explode('=', $param);
            if("
                        !stringvar
                        "parameterName == urldecode($name) && "
                        !stringvar
                        "parameterValue == urldecode($value))
                return true;
            }
        return false;
        }

    function tempFileName($suff) /* TODO Use this to create temporary files, if needed. */
        {
        global $dodelete;
        global $tobedeleted;
        $tmpno = tempnam('/tmp', $suff);
        if($dodelete)
            $tobedeleted[$tmpno] = true;
        return $tmpno;
        }
        
    function requestFile($requestParm) // e.g. \"IfacettokF\"
        {
        logit(\"requestFile(\" . $requestParm . \")\");

        if(isset($_REQUEST[$requestParm]))
            {
            $urlbase = isset($_REQUEST[\"base\"]) ? $_REQUEST[\"base\"] : \""
                        !baseUrlTools
                        "/toolsdata/\";

            $item = $_REQUEST[$requestParm];
            $url = $urlbase . $item;
            logit(\"requestParm:$requestParm\");
            logit(\"urlbase:$urlbase\");
            logit(\"item:$item\");
            logit(\"url[$url]\");

            $handle = fopen($url, \"r\");
            if($handle == false)
                {
                logit(\"Cannot open url[$url]\");
                return \"\";
                }
            else
                {
                $tempfilename = tempFileName(\""
                        makeName$!name
                        "_$requestParm_\");
                $temp_fh = fopen($tempfilename, 'w');
                if($temp_fh == false)
                    {
                    fclose($handle);
                    logit(\"handle closed. Cannot open $tempfilename\");
                    return \"\";
                    }
                else
                    {
                    while (!feof($handle)) 
                        {
                        $read = fread($handle, 8192);
                        fwrite($temp_fh, $read);    
                        }
                    fclose($temp_fh);
                    fclose($handle);
                    return $tempfilename;
                    }
                }
            }
        logit(\"empty\");
        return \"\";
        }    
"
                    : ?helperFunctions
                  &     "
/***************
* declarations *
***************/

/*
 * TODO Use the variables defined below to configure your tool for the right 
 * input files and the right settings.
 * The input files are local files that your tool can open and close like any
 * other file.
 * If your tool needs to create temporary files, use the tempFileName() 
 * function. It can mark the temporary files for deletion when the webservice
 * is done. (See the global dodelete variable.)
 */
        "
                        !stringvar
                        "base = \"\";"
                        \t
                        "/* URL from where this web service downloads input. The generated script takes care of that, so you can ignore this variable. */
        "
                        !stringvar
                        "job = \"\";"
                        \t
                        "/* Only used if this web service returns 201 and POSTs result later. In that case the uploaded file must have the name of the job. */
        "
                        !stringvar
                        "post2 = \"\";"
                        \t
                        "/* Only used if this web service returns 201 and POSTs result later. In that case the uploaded file must be posted to this URL. */
        "
                        !stringvar
                        "echos = \"\";"
                        \t
                        "/* List arguments and their actual values. For sanity check of this generated script. All references to this variable can be removed once your web service is working as intended. */
"
                    : ?declarations
                  & :?toolParmTests
                  &     "
        if( hasArgument(\"base\") )
            {
            "
                        !var
                        "base = getArgument(\"base\");
            }
        if( hasArgument(\"job\") )
            {
            "
                        !var
                        "job = getArgument(\"job\");
            }
        if( hasArgument(\"post2\") )
            {
            "
                        !var
                        "post2 = getArgument(\"post2\");
            }
        "
                        !var
                        "echos = \"base=$base job=$job post2=$post2 \";
"
                    : ?basejobpost2
                  & "
/*********
* input  *
*********/
":?DATATEXT
                  &   whl
                    ' ( !DATA:#*(?IO.?featname.?value.F)+?DATA
                      & "Restriction: There is exactly one output file."
                      &     (!featname:|I)
                            !featname
                            !value
                            F
                        : ?httpparm
                      & (   !IO:I
                          &     !declarations
                                "        "
                                !stringvar
                                !httpparm
                                " = \"\";"
                                \t
                                "/* "
                                ( Input
                                  (   !featname:
                                    & " (ONLY used if there is exactly ONE input to this workflow step)"
                                  |   " with "
                                      low$(getFeatName$!featname)
                                      " "
                                      getFeatValues$(!featname.!value)
                                  )
                                )
                                " */\n"
                            : ?declarations
                          &   !toolParameters ", " !stringvar !httpparm
                            : ?toolParameters
                          &     !DATATEXT
                                "        if( hasArgument(\""
                                !httpparm
                                "\") )
            {        
            "
                                !var
                                !httpparm
                                " = requestFile(\""
                                !httpparm
                                "\");
            if("
                                !var
                                !httpparm
                                " == '')
                {
                header(\"HTTP/1.0 404 Input "
                                ( !featname:
                                |   "with "
                                    low$(getFeatName$!featname)
                                    " '"
                                    getFeatValues$(!featname.!value)
                                    "' "
                                )
                                "not found ("
                                !httpparm
                                " parameter). \");
                return;
                }
            "
                                !var
                                "echos = "
                                !var
                                "echos . \""
                                !httpparm
                                "="
                                !var
                                !httpparm
                                " \";
            }
"
                            : ?DATATEXT
                        | 
                        )
                      )
                  &   "
/************************
* input/output features *
************************/
"
                    : ?FEATURETEXT
                  &   whl
                    ' ( !FEATURES:#*(?IO.?data)\L?svalues+?FEATURES
                      & ( 
                        |     !declarations
                              "    "
                              !stringvar
                              !IO
                              !data
                              " = \"\";\n"
                          : ?declarations
                        )
                      &     !FEATURETEXT
                            "        if( hasArgument(\""
                            !IO
                            !data
                            "\") )
            {
"
                        : ?FEATURETEXT
                      & :?ech
                      &   whl
                        ' ( !svalues:%?values+?svalues
                          &   whl
                            ' ( !values:%@?value^?*?values
                              &     !declarations
                                    "        "
                                    !stringvar
                                    !IO
                                    !data
                                    !value
                                    " = false;"
                                    \t
                                    "/* "
                                    ( getFeatName$!data
                                      " in "
                                      ( !IO:I&input
                                      | output
                                      )
                                      " is "
                                      getFeatValues$(!data.!value)
                                    )
                                    " if true */
"
                                : ?declarations
                              &     !ech
                                    " . \""
                                    !IO
                                    !data
                                    !value
                                    "="
                                    !var
                                    !IO
                                    !data
                                    !value
                                    " \""
                                : ?ech
                              &     !FEATURETEXT
                                    "            "
                                    !var
                                    !IO
                                    !data
                                    !value
                                    " = existsArgumentWithValue(\""
                                    !IO
                                    !data
                                    "\", \""
                                    !value
                                    "\");\n"
                                : ?FEATURETEXT
                              )
                          )
                      &     !FEATURETEXT
                            "            "
                            !var
                            "echos = "
                            !var
                            echos
                            !ech
                            ";
            }
"
                        : ?FEATURETEXT
                      )
                  &   "
/*******************************
* input/output features styles *
*******************************/
"
                    : ?STYLETEXT
                  &   whl
                    ' (   !STYLES
                        : #*(?IO.?featname.?data)\L?svalues+?STYLES
                      & ( 
                        |     !declarations
                              "        "
                              !stringvar
                              !IO
                              !featname
                              !data
                              " = \"\";\n"
                          : ?declarations
                        )
                      &     !STYLETEXT
                            "        if( hasArgument(\""
                            !IO
                            !featname
                            !data
                            "\") )
            {
"
                        : ?STYLETEXT
                      & :?ech
                      &   whl
                        ' ( !svalues:%?values+?svalues
                          &   whl
                            ' ( !values:%@?value^?*?values
                              &     !declarations
                                    "        "
                                    !stringvar
                                    !IO
                                    !featname
                                    !data
                                    !value
                                    " = false;"
                                    \t
                                    "/* Style of "
                                    low$(getFeatName$!featname)
                                    " "
                                    getFeatValues$(!featname.!data)
                                    " in "
                                    ( !IO:I&input
                                    | output
                                    )
                                    " is "
                                    (   getFeatSpecTable$(!featname.!data)
                                      : ?sptable
                                    &   ( !!sptable
                                        |   readTable$!sptable
                                          & !!sptable
                                        )
                                      : ? (?fval.!value) ?
                                    & !fval
                                    )
                                    " if true */
"
                                : ?declarations
                              &     !ech
                                    " . \""
                                    !IO
                                    !featname
                                    !data
                                    !value
                                    "="
                                    !var
                                    !IO
                                    !featname
                                    !data
                                    !value
                                    " \""
                                : ?ech
                              &     !STYLETEXT
                                    "            "
                                    !stringvar
                                    !IO
                                    !featname
                                    !data
                                    !value
                                    " = existsArgumentWithValue(\""
                                    !IO
                                    !featname
                                    !data
                                    "\", \""
                                    !value
                                    "\");\n"
                                : ?STYLETEXT
                              )
                          )
                      &     !STYLETEXT
                            "            "
                            !var
                            "echos = "
                            !var
                            echos
                            !ech
                            ";
            }
"
                        : ?STYLETEXT
                      )
                  &   output
                    $ ( !boilerPlate
                        !helperFunctions
                        "\n    "
                        !voidfunc
                        (str$("do_" makeName$!name):?mainfunc)
                        "()
        {
        global $dodelete;
        global $tobedeleted;"
                        !declarations
                        !basejobpost2
                        !DATATEXT
                        !FEATURETEXT
                        !STYLETEXT
                        \n
                        "//* DUMMY CODE TO SANITY CHECK GENERATED SCRIPT (TODO Remove one of the two solidi from the beginning of this line to activate your own code)"
                        "\n        "
                        !stringvar
                        makeName$!name
                        "file = tempFileName(\""
                        makeName$!name
                        "-results\");
        $command = \"echo $echos >> "
                        !stringvar
                        makeName$!name
                        "file\";
        logit($command);

        if(($cmd = popen($command, \"r\")) == NULL)
            {
            throw new SystemExit(); // instead of exit()
            }

        while($read = fgets($cmd))
            {
            }

        pclose($cmd);
/*/
// YOUR CODE STARTS HERE.
//        TODO your code!
// YOUR CODE ENDS HERE. OUTPUT EXPECTED IN "
                        !var
                        makeName$!name
                        "file
//*/
        $tmpf = fopen("
                        !var
                        makeName$!name
                        "file,'r');

        if($tmpf)
            {
            logit('output from "
                        makeName$!name
                        ":');
            while($line = fgets($tmpf))
                {
                logit($line);
                print $line;
                }
            fclose($tmpf);
            }

        if($dodelete)
            {
            foreach ($tobedeleted as $filename => $dot) 
                {
                if($dot)
                    unlink($filename);
                }
            unset($tobedeleted);
            }
        }
    loginit();
    "
                        !mainfunc
                        "();\n"
                        !lastWord
                      )
                | 
                )
              )
          & reverselist$!TUPTUO
      )
      ( setLanguage
      =   A Z
        .     !arg:? (UIlanguage.?arg) ?
            & (   readTable$UIlanguage
                & (   !UIlanguage:?A !arg ?Z
                    & !arg !A !Z:?UIlanguage
                    & saveTable$UIlanguage
                    & setLang$!arg:?arg
                    &   toML
                      $ ( !HTMLbodyContainer
                        $ (paragraph$(str$("Sprog er nu sat til " !arg)))
                        )
                  |   toML
                    $ ( !HTMLbodyContainer
                      $ (paragraph$(str$("Det forstod jeg ikke:" !arg)))
                      )
                  )
              |   toML
                $ ( !HTMLbodyContainer
                  $ ( paragraph
                    $ "Table UIlanguage listing ISO codes of supported UI languages could not be read."
                    )
                  )
              )
          |   toML
            $ ( !HTMLbodyContainer
              $ (paragraph$"Expected parameter 'UIlanguage'")
              )
      )
      ( setLanguageNotPermanently
      =   
        .   ( !arg:? (UIlanguage.?arg) ?
            |   "reset to default"
              & readTable$UIlanguage:%?arg ?
            )
          & setLang$!arg
      )
      ( countGraphNodes
      =   count tools feats feat i o cnt tcnt fcnt tool
        .   "Unfold toolprop. Each subspecification doubles count due to specification.
             Counts 360 tools that are active (not 'inactive') 20130424"
          & readTable$toolprop
          & readTable$tooladm
          & !toolprop:?tools
          & NEWSPEC
          & ( count
            =   ret term spcno factor spcs
              .   0:?ret
                &   whl
                  ' ( !arg:%?term+?arg
                    & 1:?spcno
                    &   whl
                      ' ( !term
                        :   ?
                          * ( %?factor %?spcs*?term
                            &   whl
                              ' ( !spcs:% ?spcs
                                & !spcno+!spcno:?spcno
                                )
                            )
                        )
                    & !ret+!spcno:?ret
                    )
                & !ret
            )
          & 0:?cnt
          &   whl
            ' (   !tools
                :   ?
                  + (   ?tool
                      & ( ~&"15 nodes are inactive 20130424"
                        |   !tooladm
                          :   ?
                            + ( ? (ToolID.!tool) ?
                              : ? (Inactive.) ?
                              )
                            + ?
                        )
                    . ?feats
                    )
                  + ?tools
              & 1:?tcnt
              &   whl
                ' ( !feats:(?,?feat) ?feats
                  & 0:?fcnt
                  &   whl
                    ' ( !feat:(?i.?o)+?feat
                      & !fcnt+count$!i*count$!o:?fcnt
                      )
                  & !tcnt*!fcnt:?tcnt
                  )
              & !cnt+!tcnt:?cnt
              )
          & !cnt
      )
      ( countGraphNodesTool
      =   count tools feats feat i o cnt tcnt fcnt tool
        .   "Unfold toolprop. Each subspecification doubles count due to specification.
             Counts 360 tools that are active (not 'inactive') 20130424"
          & !arg:?tools
          & NEWSPEC
          & ( count
            =     ret term spcno factor spcs fix opt
                , Nspc Nopt
              .   0:?ret
                &   whl
                  ' ( !arg:%?term+?arg
                    & !term:%?fix ?opt
                    & 1:?spcno
                    &   whl
                      ' ( !fix
                        :     %?
                            ^ ( ?+[?Nspc
                              &   !spcno*(!Nspc:~0|1)
                                : ?spcno
                              )
                          * ?fix
                        )
                    & 0:?Nopt
                    &   whl
                      ' ( !opt:%?^(?+[?Nspc) ?opt
                        &   (!Nspc:~0|1)+!Nopt
                          : ?Nopt
                        )
                    & !ret+!spcno*2^!Nopt:?ret
                    )
                & !ret
            )
          & 0:?cnt
          &   whl
            ' ( !tools:#?*(?tool.?feats)+?tools
              & 1:?tcnt
              &   whl
                ' ( !feats:(?,?feat) ?feats
                  & 0:?fcnt
                  &   whl
                    ' ( !feat:(?i.?o)+?feat
                      & !fcnt+count$!i*count$!o:?fcnt
                      )
                  & !tcnt*!fcnt:?tcnt
                  )
              & !cnt+!tcnt:?cnt
              )
          & !cnt
      )
      ( testsub
      =   pipeno in ou successcomment failurecomment res
        .   !arg:(?pipeno.?in.?ou.?successcomment.?failurecomment)
          & log$(">>>>>>PIPE" !pipeno)
          & (   fp$(!in.!ou.):?res
              &   log
                $ ("======PIPE" !pipeno "======" !successcomment \n !res)
              & ( 
                |   put
                  $ ( str$(pipeAsXML$!res)
                    , str$(PIPE !pipeno ".xml")
                    , NEW
                    )
                )
            | log$("~~~~~~PIPE" !pipeno "~~~~~~" !failurecomment)
            )
      )
      ( testcreate
      =   
        .   log$NEW
          & 0:?indent
          &   create
            $ (   (method.GET)
                  (goal.lem)
                  (Language.)
                  (nth.1)
                  (source.txt)
                  (bsubmit.Submit)
                  (mail2."a@bc.foo")
              . GoalChoice
              )
      )
      ( testDutch
      =   
        .   0:?indent
          &   create
            $ (   (method.GET)
                  (DATE.20171123)
                  (UIlanguage.en)
                  (batch.on)
                  (Item.text)
                  (Ifacet.txt^hq)
                  (Ipres.)
                  (Iformat.flat)
                  (Ilang.nl)
                  (Iperiod.)
                  (Iapp.)
                  (Ofacet.lem)
                  (Opres.)
                  (Oformat.flat)
                  (Olang.)
                  (Operiod.)
                  (Oapp.)
                  (bsubmit."next step")
              . GoalChoice
              )
      )
      ( imgtest
      =   
        .   log$NEW
          &   testsub
            $ ( 1871
              . format,img^jpeg
              . facet,lem
              . OK
              . WRONG
              )
      )
      ( conlltest
      =   
        .   log$NEW
          &   testsub
            $ ( 3871
              .   (facet,tok)
                  (facet,lem)
                  (format,txtann)
              . (format,conll) (lang,da)
              . OK
              . WRONG
              )
          & ( ~
            |     testsub
                $ ( 3872
                  .   (facet,tok)
                      (facet,pos)
                      (format,txtann)
                  . (format,conll) (lang,da)
                  . OK
                  . WRONG
                  )
              &   testsub
                $ ( 3873
                  .   (facet,tok)
                      (facet,pos)
                      (facet,lem)
                      (format,txtann)
                  . (format,conll) (lang,da)
                  . OK
                  . WRONG
                  )
              &   testsub
                $ ( 3874
                  . (facet,tok) (format,txtann)
                  . (format,conll) (lang,da)
                  . OK
                  . WRONG
                  )
            )
      )
      ( ltest
      =   
        .   log$NEW
          &   testsub
            $ ( 801
              .   (facet,txt)
                  (format,txtbasis^cst)
                  (lang,da)
              . facet,lem
              . OK
              . WRONG
              )
      )
      ( rtest
      =   
        .   log$NEW
          & NEWSPEC
          &   testsub
            $ ( 101
              .   (facet,txt^(hq+ocr))
                  (format,rtf)
                  (lang,da)
              . (facet,seg) (format,flat) (lang,da)
              . OK
              . WRONG
              )
          &   testsub
            $ ( 102
              .   (facet,txt^ocr)
                  (format,rtf)
                  (lang,da)
              . (facet,seg) (format,flat) (lang,da)
              . OK
              . WRONG
              )
          &   testsub
            $ ( 103
              .   (facet,txt^hq)
                  (format,rtf)
                  (lang,da)
              . (facet,seg) (format,flat) (lang,da)
              . WRONG
              . OK
              )
          &   testsub
            $ ( 104
              . format,img
              . (format,flat) (lang,da)
              . OK
              . WRONG
              )
          &   testsub
            $ ( 105
              . (facet,txt) (format,img)
              . (format,flat) (lang,da)
              . OK
              . WRONG
              )
          &   testsub
            $ ( 106
              . (facet,txt) (format,img)
              . (facet,seg) (format,flat) (lang,da)
              . OK
              . WRONG
              )
          &   testsub
            $ ( 107
              . format,img^gif
              . (facet,txt) (format,rtf) (lang,da)
              . OK
              . WRONG
              )
      )
      ( mtest
      =   
        .   log$NEW
          &   testsub
            $ ( 871
              . (facet,tok) (format,txtann) (lang,da)
              . format,flat
              . OK
              . WRONG
              )
      )
      ( ntest
      =   
        .   log$NEW
          & (   ~
              &   testsub
                $ ( 123
                  .   (facet,seg*tok)
                      (format,xm)
                      (lang,en)
                  . (facet,lem) (format,xm) (lang,en)
                  . OK
                  . WRONG
                  )
            |   testsub
              $ ( 123
                .   (facet,pos*tok)
                    (format,txtann)
                    (lang,da)
                . facet,lem
                . OK
                . WRONG
                )
            )
      )
      ( test
      =   
        .   log$NEW
          & 0:?indent
          & NEWSPEC
          & (     illegalSolution
                $ (   ( (facet,flat)
                        (facet,seg)
                        (lang,en)
                      )
                    * ( (format,flat)
                        (facet,tok^PT)
                        (lang,en)
                      )
                  .   ( CST-RTFread
                      , (   (facet,seg)
                            (format,flat^latin1)
                            (lang,en)
                        .   (facet,txt)
                            (format,rtf+flat^(latin1+utf8))
                            (lang,en)
                        )
                      )
                    * ( CST-RTFread
                      , (   (facet,tok^PT)
                            (format,flat^utf8)
                            (lang,en)
                        .   (facet,txt)
                            (format,flat+rtf)
                            (lang,en)
                        )
                      )
                  )
              & log$illegalSolution
            | log$OKSolution
            )
          & NEWSPEC
          & (     illegalSolution
                $ (   ((format,flat) (facet,seg))
                    * ((format,flat) (facet,tok^PT))
                  .   ( CST-RTFread
                      , (   (facet,seg)
                            (format,flat^(latin1+utf8))
                            (lang,en)
                        .   (facet,txt)
                            (format,rtf+flat^(latin1+utf8))
                            (lang,en)
                        )
                      )
                    * ( CST-RTFread
                      , (   (facet,tok)
                            (format,flat)
                            (lang,xh)
                        .   (facet,txt)
                            (format,flat+rtf)
                            (lang,en)
                        )
                      )
                  )
              & log$illegalSolution
            | log$OKSolution
            )
          & (   ~
              &   testsub
                $ ( 23
                  . (facet,tok) (format,xm)
                  . (pres,alf) (format,flat) (lang,da)
                  . OK
                  . WRONG
                  )
            |   
              &   testsub
                $ ( 22
                  . format,txtann
                  .   (facet,lem)
                      (format,flat+xm)
                      (lang,pl+ru+sl+sv)
                      (pres,alf+frq)
                  . OK
                  . WRONG
                  )
            |   ( ~
                |     testsub
                    $ ( 1a
                      . facet,txt
                      .   (facet,lem)
                          (lang,en+da)
                          (pres,alf+frq)
                      . OK
                      . WRONG
                      )
                  &   testsub
                    $ ( 1
                      . facet,txt
                      . (facet,lem) (lang,en)
                      . OK
                      . WRONG
                      )
                  &   testsub
                    $ (2.facet,txt.facet,key.OK.fails)
                  &   testsub
                    $ ( 3
                      . facet,txt
                      . (facet,key) (lang,da)
                      . OK
                      . WRONG
                      )
                  &   testsub
                    $ ( 4
                      . facet,txt
                      . (facet,key) (lang,en)
                      . "WRONG: keywords not implemented for english"
                      . OK
                      )
                  &   testsub
                    $ ( 5
                      . (facet,txt) (lang,xh)
                      . facet,lem
                      . "WRONG XHOSA not supported by lemmatiser"
                      . OK
                      )
                  &   testsub
                    $ ( 6
                      . facet,txt
                      . (facet,lem) (lang,xh)
                      . "WRONG XHOSA not supported by lemmatiser"
                      . OK
                      )
                  &   testsub
                    $ ( 7
                      . (facet,txt) (lang,xh)
                      . (facet,txt) (lang,xh)
                      . OK
                      . WRONG
                      )
                  &   testsub
                    $ ( 8
                      . (facet,txt) (lang,en)
                      . (facet,txt) (lang,da)
                      . "WRONG cannot translate from en to da"
                      . OK
                      )
                  &   testsub
                    $ ( 9
                      . (facet,txt) (lang,en)
                      . (facet,txt) (lang,da)
                      . "WRONG cannot translate from en to da"
                      . OK
                      )
                  &   testsub
                    $ ( 10
                      . (facet,txt) (lang,da)
                      . (facet,tok) (lang,da)
                      . OK
                      . WRONG
                      )
                  &   testsub
                    $ ( 11
                      . facet,txt
                      . facet,lem
                      . OK
                      . WRONG
                      )
                  &   testsub
                    $ ( 12
                      . (facet,txt) (lang,en)
                      . facet,npr
                      . WRONG
                      . OK
                      )
                  &   testsub
                    $ ( 13
                      . (facet,txt) (lang,en)
                      . facet,mwu
                      . WRONG
                      . OK
                      )
                  &   testsub
                    $ ( 14
                      . facet,txt
                      . facet,npr
                      . OK
                      . WRONG
                      )
                  &   testsub
                    $ ( 15
                      . facet,txt
                      . (facet,lem) (lang,fr)
                      . OK
                      . WRONG
                      )
                )
              &   testsub
                $ ( 16
                  . (facet,tok) (lang,en)
                  . facet,lem
                  . OK
                  . WRONG
                  )
              &   testsub
                $ ( 17
                  . (facet,tok) (lang,fr)
                  . facet,lem
                  . OK
                  . WRONG
                  )
              &   testsub
                $ ( 18
                  . (facet,txt) (lang,da)
                  . facet,pos
                  . OK
                  . WRONG
                  )
              &   testsub
                $ ( 19
                  . facet,txt
                  . (facet,pos) (lang,da)
                  . OK
                  . WRONG
                  )
              &   testsub
                $ ( 20
                  . (facet,txt) (lang,en)
                  . facet,rep
                  . OK
                  . WRONG
                  )
              &   testsub
                $ ( 21
                  . facet,txt
                  . (facet,rep) (lang,da)
                  . OK
                  . WRONG
                  )
            )
      )
      (Uploads=)
  : ?Functions;

r=
  get'"toolsProg.bra"
& rmv$"toolsProg.bak"
& ren$("toolsProg.bra"."toolsProg.bak")
&   put
  $ ( "{toolsProg.bra


    Copyright 2014, Bart Jongejan
    This file is part of the DK-ClarinTools.

    DK-ClarinTools is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    DK-ClarinTools is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with DK-ClarinTools.  If not, see <http://www.gnu.org/licenses/>.





Source code for DK-Clarin tools webservice 

To neatly re-format this source code, load the file in a running instance of
Bracmat:

    get$\"toolsprog.bra\"
    
Now, after you have made changes to the source code in a text editor, reload
the source code in Bracmat using the command:

    !r

This command re-reads the file, renames the previous version from toolsprog.bra
to toolsprog.bak and then saves the source code. Some editors will notice that
the text has changed on disk and offer you to reload the source code.

To change the comment near the start of this file, you need to go to the bottom
of the file and find the text there. A change made to that text takes effect
after saving once and pressing !r two times. Remember to escape quotes \" with
a backslash \\. Comments elsewhere (i.e. text enclosed by braces { and } is NOT
saved. Use string expressions if you want a comment somewhere.

The following commands can be issued by sending an 'expression' HTTP parameter
to the 'bracmatevaluator' servlet.

To get started from a file containing all tables called 'alltablesxxx' (replace
xxx with actual characters in the file name), e.g., alltables.GPL:

importTables$\"alltables.GPL\"

This reads the named file and stores each table in a separate file in a folder
structure
work/
    job/
    meta/
        feature/
        style/

(This folder structure must already exist.) Finally, the same file is
rewritten, so all lay-out is normalized (Bracmat style).

After changes have been made to the single table files, for example because
new tools are registered, the 'alltablesxxx' file is made up to date with

exportTables$

This command reads all single file tables from the folder structure and saves
them to 'alltablesxxx'. The command knows the actual name of the file to write
to because that name is stored in the variable AAA, which is itself stored
alongside all tables, and is therefore known after the last time 
importTables$alltablesxxx was called. It is possible to change context by
reading an 'alltablesyyy' that is different from 'alltablesxxx'.

To export all tables to a different file, do

exportTables$\"alltableszzz\"

where alltableszzz must be a valid file name that starts with 'alltables'.

To do a clean up, removing almost all that is not defined in this file from 
Bracmat's memory, call the clean function

    clean$
    
Changes made to table files take immediately effect. It is advised to use the
admin page to register new tools. Some changes cannot be made using the admin
page, such as adding a new feature or feature value.
    
Server:
Add following line to /etc/httpd/conf.d/proxy_ajp.conf:
    ProxyPass /toolsdata !
(Restart Apache sudo /etc/init.d/httpd restart)
    
Make sure bracmat is in JBoss's or Tomcat PATH:
    /usr/lib/libbracmat.so -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1 -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1.0

The conf/properties.xml file has an entry \"toolsHome\". The value of this entry
is the location of this file, toolsprog.bra.
}

"
    , "toolsProg.bra"
    , NEW BIN
    )
& lst'(toolsProg,"toolsProg.bra",APP BIN)
& put'(\n,"toolsProg.bra",APP BIN)
& lst'(r,"toolsProg.bra",APP BIN);
