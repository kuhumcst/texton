{toolsProg.bra


    Copyright 2014, Bart Jongejan
    This file is part of the DK-ClarinTools.

    DK-ClarinTools is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    DK-ClarinTools is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with DK-ClarinTools.  If not, see <http://www.gnu.org/licenses/>.





Source code for DK-Clarin tools webservice 

To neatly re-format this source code, load the file in a running instance of
Bracmat:

    get$"toolsprog.bra"
    
Now, after you have made changes to the source code in a text editor, reload
the source code in Bracmat using the command:

    !r

This command re-reads the file, renames the previous version from toolsprog.bra
to toolsprog.bak and then saves the source code. Some editors will notice that
the text has changed on disk and offer you to reload the source code.

To change the comment near the start of this file, you need to go to the bottom
of the file and find the text there. A change made to that text takes effect
after saving once and pressing !r two times. Remember to escape quotes " with
a backslash \. Comments elsewhere (i.e. text enclosed by braces { and } is NOT
saved. Use string expressions if you want a comment somewhere.

The following commands can be issued by sending an 'expression' HTTP parameter
to the 'bracmatevaluator' servlet.

To get started from a file containing all tables called 'alltablesxxx' (replace
xxx with actual characters in the file name), e.g., alltables.GPL:

importTables$"alltables.GPL"

This reads the named file and stores each table in a separate file in a folder
structure
work/
    job/
    meta/
        feature/
        style/

(This folder structure must already exist.) Finally, the same file is
rewritten, so all lay-out is normalized (Bracmat style).
This command reads all single file tables from the folder structure and saves
them to 'alltablesxxx'. The command knows the actual name of the file to write
to because that name is stored in the variable AAA, which is itself stored
alongside all tables, and is therefore known after the last time 
importTables$alltablesxxx was called. It is possible to change context by
reading an 'alltablesyyy' that is different from 'alltablesxxx'.

If <prod> is the empty string "", then the table tooladm is anonymized by 
changing all domains in service URLs "http:\localhost" and by changing all
contact emails to "x@x.xxx".

To export all tables to a different file, do

exportTables$(<prod>."alltableszzz")

where alltableszzz must be a valid file name that starts with 'alltables'.



To do a clean up, removing almost all that is not defined in this file from 
Bracmat's memory, call the clean function

    clean$
    
Changes made to table files take immediately effect. It is advised to use the
admin page to register new tools. Some changes cannot be made using the admin
page, such as adding a new feature or feature value.
    
Server:
Add following line to /etc/httpd/conf.d/proxy_ajp.conf:
    ProxyPass /toolsdata !
(Restart Apache sudo /etc/init.d/httpd restart)
    
Make sure bracmat is in JBoss's or Tomcat PATH:
    /usr/lib/libbracmat.so -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1 -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1.0

The conf/properties.xml file has an entry "toolsHome". The value of this entry
is the location of this file, toolsprog.bra.
}

toolsProg=
      " Replaced:

        pmls-------  lem*mrf*pos*stx
        spo--------  cls*pos*seg
        stp--------  pos*seg*tok
        stpd-------  pos*seg*stx*tok
        stlp-------  lem*pos*seg*tok
        stopl------  cls*lem*pos*seg*tok
        stpld------  lem*pos*seg*stx*tok
        stpmld-----  lem*mrf*pos*seg*stx*tok
        stpmldn----  lem*mrf*ner*pos*seg*stx*tok
        tlp--------  lem*pos*tok
        tlpm-------  lem*mrf*pos*tok
        tlpmn------  lem*mrf*ner*pos*tok
        stl--------  lem*seg*tok
        sl---------  lem*seg
        tl---------  lem*tok
        stn--------  ner*seg*tok
        seto-------  seg*tok
            
        Still used with some formats:
        tp
        tlp
        seto"
      (indent=0)
      (logno=0)
      (tabind=0)
      (globval=)
      (runningThreads=0)
      (maxRunningThreads=0)
      ( headerTitle
      = "Text Tonsorium - Natural Language Processing workflows automatically composed, scheduled and enacted"
      )
      (hiddenData=)
      ( "Set from boot"
        (toolshome=)
        (documentRoot=)
        (wwwServer=)
        (deleteAfterMillisec=)
        86400000
        (stagingArea=)
        (repoServiceUrl=)
        (baseUrlTools=)
        (path=)
      )
      (servicedSources=)
      (servicedGoals=)
      (StartClk=)
      (startclock=.-1*clk$:?StartClk)
      ( clock
      =   
        .   ( !StartClk:&startclock$
            | 
            )
          & str$("[" jsn$(clk$+!StartClk) "]")
      )
      (path=.str$(!toolshome !arg))
      ( log
      =   c spc i logfile
        .   path$"log.txt":?logfile
          & (   !arg:NEW
              & put$(,!logfile,NEW)
              & startclock$
              & 0:?logno
            |   (!logno|0:?logno)
              &     ( :?spc
                    & NEWSPEC
                    & 1+!logno:?logno
                    & !indent:?i
                    &   whl
                      ' ( !i+-1:>0:?i
                        & " " !spc:?spc
                        )
                    & str$("[" !indent "] " !logno !spc)
                    )
                    !arg
                : ?arg
              & put$(clock$,!logfile,APP)
              &   whl
                ' ( !arg:%?c ?arg
                  & put$(!c " ",!logfile,APP)
                  )
              & put$(\n,!logfile,APP)
            )
      )
      ( readTable
      =   folder
        .     !arg:%@
            & (   !arg:(AAA|where)
                & (get$(path$!arg):?!arg|`~)
              |   ( !where:(?.?) ?
                  | readTable$where
                  )
                & !where:? (? !arg ?.?folder) ?
                & get$(path$(!folder !arg)):?!arg
              )
          | log$("Cannot read " !arg)&~
      )
      ( saveTable
      =   tab saved folder
        .     !arg:
            & :?saved
            & (   !where
                :   ?
                    ( ?Tables
                    .   ?folder
                      &   whl
                        ' ( !Tables
                          :   ( %?tab
                              & saveTable$(!folder.!tab)
                              & !saved !tab:?saved
                              )
                              ?Tables
                          )
                      & ~
                    )
                    ?
              | Saved !saved
              )
          |   !arg:(?folder.?tab)
            & lst$(!tab,path$(!folder !tab),NEW,RAW)
          |     whl
              ' ( !arg:%?tab ?arg
                & (   !where:? (? !tab ?.?folder) ?
                    & lst$(!tab,path$(!folder !tab),NEW,RAW)
                  | 
                  )
                )
            & 
      )
      ( saveTable
      =   tab saved folder
        .     !arg:
            & :?saved
            & (   !where
                :   ?
                    ( ?Tables
                    .   ?folder
                      &   whl
                        ' ( !Tables
                          :   ( %?tab
                              & saveTable$(!folder.!tab)
                              & !saved !tab:?saved
                              )
                              ?Tables
                          )
                      & ~
                    )
                    ?
              | Saved !saved
              )
          |   !arg:(?folder.?tab)
            & lst$(!tab,path$(!folder !tab),NEW,RAW)
          |     whl
              ' ( !arg:%?tab ?arg
                & (   !where:? (? !tab ?.?folder) ?
                    & lst$(!tab,path$(!folder !tab),NEW,RAW)
                  | 
                  )
                )
            & 
      )
      ( localized
      =   
        .   ( !LaNg:da&!arg:%@ %@?arg
            | !arg:%?arg ?
            )
          & !arg
      )
      "Reusable patterns in errorInMetadata function"
      ( ISO639
      = [%( readTable$linguae
          & log$(ISO639 !sjt "?")
          & !( 
             ' ( $linguae
               : ( ? (?.$sjt.?) ?
                 | ? (? ()$sjt ?.?.?) ?
                 )
               )
             )
          & log$(ISO639 !sjt "!!!")
          )
      )
      ( DATE
      =   (   #%@?y1 #%@?y2 #%@?y3 #%@?y4 "-" #%@?m1 #%@?m2 "-" #%@?d1 #%@?d2
            & 10*!m1+!m2:~<1:~>12
            & 10*!d1+!d2:~<1:~>31
          | #%@?y1 #%@?y2 #%@?y3 #%@?y4
          )
        & 1000*!y1+100*!y2+10*!y3+!y4:<2100
      )
      ( MEDIATYPE
      =   ( application
          | audio
          | example
          | image
          | message
          | model
          | multipart
          | text
          | video
          | chemical
          )
          "/"
            ( 
            =   sub parms suf name
              .   @(!sjt:(?sub ";" ?parms|?sub))
                & whl'@(!sub:?sub " ")
                & @( !sub
                   : ( (vnd|prs|x) "." ?name
                     | ?name
                     )
                   )
                & (   @(!name:? "+" ?suf)
                    & (   !suf
                        : ( xml
                          | json
                          | ber
                          | der
                          | fastinfoset
                          | wbxml
                          | zip
                          | cbor
                          | binary
                          | vrml
                          )
                      | `~
                      )
                  | 
                  )
                & ?
            )
          $ 
      )
      "
/**
 * toolsdata
 *
 * Return the full file system path to Tool's staging area.
 * The input can be a file name: this name is appended to the returned value.
 *
 * Called from workflow.java
 */"
      ( toolsdata
      = .str$(!documentRoot (|!stagingArea) !arg)
      )
      "
/**
 * toolsdataURL
 *
 * Return the full URL to Tool's staging area.
 * The input can be a file name: this name is appended to the returned value.
 *
 * Called from workflow.java
 */"
      (toolsdataURL=.str$(!baseUrlTools !stagingArea !arg))
      (toolsUploadURL=.str$(!baseUrlTools "/texton/upload" !arg))
      ( read
      = .get$(path$((!arg:~|all) ".bra"))
      )
      ( prodtables
      =   CTBs
          jobAbout
          jobNr
          jobs
          relations
          Uploads
          zippedresults
          tooladm
          jobNr
          toolprop
          ItemGroupsCache
          footer
          recentTasks
          wrkflws
      )
      ( saveAllTables
      =   tab saved folder
        .   !arg:
          & :?saved
          & (   !where
              :   ?
                  ( ?Tables
                  .   ?folder
                    &   whl
                      ' ( !Tables
                        :   ( %?tab
                            & saveTable$(!folder.!tab)
                            & !saved !tab:?saved
                            )
                            ?Tables
                        )
                    & ~
                  )
                  ?
            | Saved !saved
            )
      )
      ( importTables
      =     prod missingToolprop prodtoolprop productionTables tdata
          , tid
        .     log$(importTables !arg)
            & !arg:(?prod.?arg)
            & @(!arg:alltables ?)
            & ( (   !prod:
                  &     map
                      $ ((=.!arg.readTable$!arg).!prodtables)
                    : ?productionTables
                  & get$(path$!arg)
                  & saveAllTables$
                  & readTable$tooladm
                  & readTable$toolprop
                  & :?missingToolprop
                  &   map
                    $ ( ( 
                        =     name productioncontent
                            , anotool ToolID prodtool mergedtooladm
                          .   !arg:(?name.?productioncontent)
                            & (   !name:tooladm
                                & "Use the imported non-production tooladm, but inject ContactEmail ServiceURL from current production tooladm"
                                & 0:?mergedtooladm
                                &   whl
                                  ' (   !tooladm
                                      :   ( ? (ToolID.?ToolID) ?
                                          : ?anotool
                                          )
                                        + ?tooladm
                                    & (     !productioncontent
                                          :   ?
                                            + ( ? (ToolID.!ToolID) ?
                                              : ?prodtool
                                              )
                                            + ?
                                        &   map
                                          $ ( ( 
                                              =   a z anoval prodval
                                                .     !anotool
                                                    :   ?a
                                                        (!arg.?anoval)
                                                        ?z
                                                  &   !prodtool
                                                    :   ?
                                                        (!arg.?prodval)
                                                        ?
                                                  & ( !anoval:!prodval
                                                    |     !a
                                                          (!arg.!prodval)
                                                          !z
                                                      : ?anotool
                                                    )
                                              )
                                            . ContactEmail ServiceURL
                                            )
                                      | 
                                      )
                                    &   !mergedtooladm+!anotool
                                      : ?mergedtooladm
                                    )
                                & log$OUTLIERS
                                &   whl
                                  ' (   !productioncontent
                                      :   ( ? (ToolID.?ToolID) ?
                                          : ?prodtool
                                          )
                                        + ?productioncontent
                                    & (   !mergedtooladm
                                        :   ?
                                          + (? (ToolID.!ToolID) ?)
                                          + ?
                                      |     !prodtool+!mergedtooladm
                                          : ?mergedtooladm
                                        &   !ToolID !missingToolprop
                                          : ?missingToolprop
                                      )
                                    )
                                & !mergedtooladm:?productioncontent
                              | 
                              )
                            & ( !name:toolprop
                              |     !productioncontent
                                  : ?(&!name)
                                & log$(saving !name)
                                & saveTable$!name
                                & log$(!name saved)
                              )
                        )
                      . !productionTables
                      )
                  & (   !missingToolprop:
                      & log$NOTHINGMISSING
                    |     !productionTables
                        : ? (toolprop.?prodtoolprop) ?
                      & log$HAVETOINSERT
                      & readTable$toolprop
                      &   whl
                        ' (   !prodtoolprop
                            :   ?
                              + (   ?tid
                                  & !missingToolprop:? !tid ?
                                  & log$(tid !tid is missing)
                                . ?tdata
                                )
                              + ?prodtoolprop
                          & log$(ADD !tdata)
                          & (!tid.!tdata)+!toolprop:?toolprop
                          )
                      & saveTable$toolprop
                    )
                  & "Imported file, but kept local production data."
                |   get$(path$!arg)
                  & saveAllTables$
                  & "Initialized all tables from imported file."
                )
              | str$("Cannot read " !arg)&~
              )
          |   str
            $ "Usage: importTables$\"<file name>\" .  <file name> must start with 'alltables'."
      )
      ( readTableFromFolder
      =   folder file
        .     !arg:(?folder.?file)
            & get$(path$(!folder !file)):?!file
          | str$("Cannot read " !arg)&~
      )
      ( exportTables
      =   tabs tab Tables folder error prod mssg
        .     ( !where:(?.?) ?
              | readTable$where
              )
            & log$(exportTables !arg)
            & !arg:(?prod.?arg)
            & (   @(!arg:(|alltables ?))
                & 0:?tabs
                & :?error
                & (   !where
                    :   ?
                        ( ?Tables
                        .   ?folder
                          &   whl
                            ' ( !Tables
                              :   ( %@?tab
                                  & (   readTableFromFolder$(!folder.!tab)
                                      & !tab+!tabs:?tabs
                                    |   log
                                      $ ( str
                                        $ ( " Cannot read ["
                                            !tab
                                            "] in ["
                                            !folder
                                            "]."
                                          )
                                        )
                                    )
                                  )
                                  ?Tables
                              )
                          & ~
                        )
                        ?
                  |   ( !tabs:?+where+?
                      | where+!tabs:?tabs
                      )
                    & (   @(!arg:alltables ?)
                        & !arg:?AAA
                      | 
                      )
                    & (   !prod:
                        &   map
                          $ ( (=.:?(&!arg))
                            . !prodtables
                            )
                        & 0:?jobNr
                        & readTable$toolprop
                        & readTable$tooladm
                        &     ( 
                              =     anotooladm A Z a z
                                  , ContactEmail ServiceURL
                                .   0:?anotooladm
                                  &   whl
                                    ' (   !arg
                                        :   ( ?A
                                              (ContactEmail.?ContactEmail)
                                              ?Z
                                            )
                                          + ?arg
                                      &     !A
                                            (ContactEmail."x@x.xxx")
                                            !Z
                                        :   ?A
                                            (ServiceURL.?ServiceURL)
                                            ?Z
                                      & (   @( !ServiceURL
                                             : ? "://" ? "/" ?z
                                             )
                                          &   str$("http://localhost/" !z)
                                            : ?ServiceURL
                                        | 
                                        )
                                      &     !anotooladm
                                          + ( !A
                                              (ServiceURL.!ServiceURL)
                                              !Z
                                            )
                                        : ?anotooladm
                                      )
                                  & !anotooladm
                              )
                            $ !tooladm
                          : ?tooladm
                      | 
                      )
                    &   (   lst$(!tabs,path$!AAA,NEW)
                          &   str
                            $ ("Saved all tables in '" path$!AAA "'. " !error)
                        |   str
                          $ ( "Cannot write to ["
                              path$!AAA
                              "]. Check file access rights for JBoss/Tomcat."
                            )
                        )
                      : ?mssg
                    & (   !prod:
                        & map$((=.readTable$!arg).!prodtables)
                        & readTable$jobNr
                        & readTable$tooladm
                      | 
                      )
                    & !mssg
                  )
              |   str
                $ "'exportTables$' must be called without argument or with the name of a file that must start with 'alltables'."
              )
          | str$"Cannot read table 'where'"&~
      )
      ( saveToolTable
      =   
        .   saveTable$!arg
          & :?recentTasks
          & saveTable$recentTasks
      )
      ( setLang
      =   full A Z
        .       (   @(low$!arg:d (a|k) ?)
                  & da
                | en
                )
              : ?LaNg
            & readTable$linguae
            & !linguae:? (?full.!LaNg.?) ?
            & localized$!full
            & (   !hiddenData:?A (UIlanguage.?) ?Z
                & !A !Z:?hiddenData
              | 
              )
            & (UIlanguage.!LaNg) !hiddenData:?hiddenData
          | log$("failed to set language to " !arg)&~
      )
      ( setTypeFace
      =   A Z
        .   !arg:?TyPeFaCe
          & log$(setTypeFace !TyPeFaCe)
          & (   !hiddenData:?A (TyPeFaCe.?) ?Z
              & !A !Z:?hiddenData
            | 
            )
          & (TyPeFaCe.!TyPeFaCe) !hiddenData:?hiddenData
      )
      "
/**
 * clean
 * 
 * Free all variables that shouldn't exist.
 * Such variables are normally undeclared 'local' variables.
 * (In proper coding, all such variables should be declared).
 *
 * Called from reloadScript.java
 */"
      ( clean
      =   
        .   map
          $ ( ( 
              =   
                .         MLencoding
                          abs
                          arg
                          c
                          cat
                          cos
                          fct
                          flt
                          jsn
                          nestML
                          out
                          sgn
                          sin
                          sub
                          tay
                          toML
                          v
                          w
                          Globals
                          !Globals
                      : ? !arg ?
                    & 
                  | tbl$(!arg,0)&!arg
              )
            . cat$
            )
      )
      ( trim
      =   a z
        .     whl
            ' ( @(!arg:?a \r ?z)
              & str$(!a !z):?arg
              )
          &   whl
            ' @(!arg:(" "|\n|\t) ?arg)
          &   whl
            ' @(!arg:?arg (" "|\n|\t))
          & !arg
      )
      ( hasTree
      =   2a 3a 1a 5a
        .     !arg:(?2a.?5a:(=?3a))
            & !2a:!3a
          |   !2a
            : ? (?.?,?1a&hasTree$(!1a.!5a)) ?
      )
      "
/**
 * Check whether the Tools staging area already has a copy of a given
 * resource. In that case, the slow process of copying the resource from the
 * repo and the analysis of this resource can be skipped.
 * If there is a copy, its time stamp is refreshed so as to extend its right
 * to live.
 * Arguments: item id and current date.
 * Side effect: the table Uploads.table is updated if the resource is found.
 *
 * Called from create.java
 */"
      ( hasCopy
      =   item newdate A Z nr file,meta a z feats
        .     !arg:(?item.?newdate)
            & (readTable$Uploads|:?Uploads)
            &   !Uploads
              : ?A (?nr.!item.?file.?meta.?feats) ?Z
            & !meta:?a (DATE.?) ?z
            & !a (DATE.!newdate) !z:?meta
            &   !A (!nr.!item.!file.!meta.!feats) !Z
              : ?Uploads
            & saveTable$Uploads
            & public
          | no
      )
      ( NCNameStartChar
      =   ~<A:~>Z
        | "_"
        | ~<a:~>z
        | ~<À:~>Ö
        | ~<Ø:~>ö
        | ~<ø:~>˿
        | ~<Ͱ:~>ͽ
        | ~<Ϳ:~>῿
        | ~<‌:~>‍
        | ~<⁰:~>↏
        | ~<Ⰰ:~>⿯
        | ~<、:~>퟿
        | ~<豈:~>﷏
        | ~<ﷰ:~>�
        | ~<𐀀:~>󯿿
      )
      ( NCNameChar
      =   !NCNameStartChar
        | "-"
        | "."
        | ~<0:~>9
        | ·
        | ~<̀:~>ͯ
        | ~<‿:~>⁀
      )
      (allowedChar=.utf$!sjt&!sjt:!(arg.))
      ( NCName
      = |allowedChar$('$NCNameChar) !NCName
      )
      ( checkParms
      =   parms parm table val abBr abbrs spec
        .   !arg:(?parms.?parm.?table)
          & :?abbrs
          &   whl
            ' ( !parms:? (!parm.?val) ?parms
              & !hiddenData (!parm.!val):?hiddenData
              & NEWSPEC
              &   whl
                ' ( !val:%?abBr^?spec+?val
                  & !table:? (?.!abBr.?) ?
                  & !abbrs !abBr:?abbrs
                  )
              )
          & !abbrs
      )
      ( lexan
      =   T A B op ops
        .   !arg:(?ops.?arg)
          & "safe alternative for get$(!arg,MEM). Ignores JBoss-life-threatening (closing) parentheses."
          & (   !arg:?A_?B
              & (lexan$(!ops.!A))_(lexan$(!ops.!B))
            |   !ops:%?op ?ops
              & NEWSPEC
              & (   @(!arg:?A !op ?B)
                  &   !op
                    : (   " "
                        &   lexan$(!ops.!A) lexan$(!op !ops.!B)
                          : ?T
                      |   "+"
                        &   lexan$(!ops.!A)+lexan$(!op !ops.!B)
                          : ?T
                      |   "*"
                        &   lexan$(!ops.!A)*lexan$(!op !ops.!B)
                          : ?T
                      |   "^"
                        &   lexan$(!ops.!A)^lexan$(!op !ops.!B)
                          : ?T
                      )
                  & !T
                | lexan$(!ops.!arg)
                )
            | !arg
            )
      )
      ( unpackIOparm
      =   A parms parm nparms val
        .   !arg:(?parms.?parm)
          & :?nparms
          &   whl
            ' ( !parms:?A (!parm.?val) ?parms
              & NEWSPEC
              & ( lexan$(" " "+" "*" "^".!val):?val
                | 
                )
              & !nparms !A (!parm.!val):?nparms
              )
          & !nparms !parms
      )
      ( unpackIOparms
      =   f fs short p
        .   readTable$features
          & !features:?fs
          &   whl
            ' ( !fs:%?f+?fs
              & !f:? (short.?short) ?
              & str$(I !short):?p
              & (unpackIOparm$(!arg.!p):?arg|)
              & str$(O !short):?p
              & (unpackIOparm$(!arg.!p):?arg|)
              )
          & !arg
      )
      ( checkParmsSimple
      =   parms parm aBbr
        .   !arg:(?parms.?parm)
          & !parms:? (!parm.%?aBbr) ?
          & !hiddenData (!parm.!aBbr):?hiddenData
          & !aBbr
      )
      ( checkIOparms
      =   f fs short table p
        .   readTable$features
          & !features:?fs
          &   whl
            ' ( !fs:%?f+?fs
              &   !f
                : ? (short.?short) ?
                : ? (table.?table) ?
              & readTable$!table
              & str$(I !short):?p
              & (checkParms$(!arg.!p.!!table)|)
              & str$(O !short):?p
              & (checkParms$(!arg.!p.!!table)|)
              )
      )
      ( heading
      =   n
        .   !arg:(?n.?arg)
          & (str$(h !n).,!arg) \r\n
      )
      (paragraph=.(p.,!arg) \r\n)
      ( fieldset
      =   legend content
        .   !arg:(?legend.?content)
          &   ( fieldset
              .   (style."padding: 10px; border-style: none;")
                ,   (!legend:|(legend.,!legend))
                    !content
              )
              \r\n
      )
      ( form
      =   action method
        .   !arg:(?action.?arg)
          & (   !arg
              : ( ?arg
                .   ( post
                    | POST
                    | get
                    | GET
                    )
                  : ?method
                )
            | GET:?method
            )
          & ( form
            .     ( ~&"20121024 Why wasn't there an enctype?"
                  |   !method:(POST|post)
                    & (enctype.multipart/form-data)
                  | "20121024 GET no enctype?"&
                  | (enctype.application/x-www-form-urlencoded)
                  )
                  (accept-charset.UTF-8)
                  (method.low$!method)
                  (action.!action)
                  (class.formRounded)
              , (div.,!arg)
            )
      )
      ( makeCheckboxFormField
      =   text parm desc state disabled
        .     !arg
            : ( ?text
              . ?parm
              .   ( ? (val.?state) ?
                  | ?&:?state
                  )
                : ( ? (disabled.?disabled) ?
                  | ?&:?disabled
                  )
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
              )
          &   (span.,!text)
              \r\n
              ( input
              .     (type.checkbox)
                    (tabindex.1+!tabind:?tabind)
                    (name.!parm)
                    ( !state:
                    | ( checked
                      .   !state:on&checked
                        | 
                      )
                    )
                    (!disabled:|(disabled.!disabled))
                    (!desc:|(title.!desc))
                , 
              )
              \r\n
      )
      ( makeStaticTextFormField
      =   text val
        .   !arg:(?text.?val)
          & (label.,!text) \r\n !val \r\n
      )
      ( makeTextFormField
      =   text parm val desc readonly size required
        .     !arg
            : ( ?text
              . ?parm
              .   ? (val.?val) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (readonly.?readonly) ?
                  | ?&:?readonly
                  )
                : ( ? (size.?size) ?
                  | ?&:?size
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( label
              .   
                ,   !text
                    ( !required:
                    |   " "
                        ( span
                        .     (class.required)
                              (style."width: auto; line-height: normal;")
                          , !required
                        )
                    )
              )
              \r\n
              ( input
              .     (tabindex.1+!tabind:?tabind)
                    (type.text)
                    (name.!parm)
                    (!val:|(value.trim$!val))
                    (!desc:|(title.!desc))
                    ( !readonly:(|no)
                    | (disabled.disabled)
                    )
                    (!size:|(size.!size))
                , 
              )
              \r\n
      )
      ( makeTextAreaFormField
      =   text parm val required desc
        .     !arg
            : ( ?text
              . ?parm
              .   ? (val.?val) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( label
              .   
                ,   !text
                    ( !required:
                    |   " "
                        ( span
                        .     (class.required)
                              (style."width: auto; line-height: normal;")
                          , !required
                        )
                    )
              )
              \r\n
              ( textarea
              .     (tabindex.1+!tabind:?tabind)
                    (style."font-size: 9pt;")
                    (name.!parm)
                    (rows.2)
                    (cols.60)
                    (!desc:|(title.!desc))
                , trim$!val
              )
              \r\n
      )
      ( makeFileFormField
      =   text parm val
        .   !arg:(?text.?parm.?val)
          &   (span.,!text)
              \r\n
              ( input
              .     (type.file)
                    (name.!parm)
                    (value.)
                    (!val:|(accept.trim$!val))
                , 
              )
              \r\n
      )
      ( ToolTitle
      =   
        .     readTable$tooladm
            & (     !tooladm
                  :   ?
                    + ( ? (ToolID.!arg) ?
                      : ? (Title.?arg) ?
                      )
                    + ?
                & !arg
              | str$("ToolTitle:" !arg " does not exist.")
              )
          | str$("ToolTitle:" !arg " tooladm cannot be read.")
      )
      ( toolID2title
      =   
        .   readTable$tooladm
          &   map
            $ ( ( 
                =   tit
                  .   (   !tooladm
                        :   ?
                          + ( ? (ToolID.!arg) ?
                            : ? (Title.?tit) ?
                            )
                          + ?
                      | 
                      )
                    & (!arg.!tit)
                )
              . !arg
              )
      )
      ( enumerateTools
      =   tool o i inp I,a b
        .     !arg:(?tool,(?o.?i.?inp))
            & ToolTitle$!tool:?tool
            &   (enumerateTools$!inp:?I)
                (!I:|" → ")
                !tool
          |   !arg:%?a*%?b
            & "(" enumerateTools$!a ∪ enumerateTools$!b ")"
          |   !arg:%?a+%?b
            & NEWSPEC
            & "(" enumerateTools$!a "|" enumerateTools$!b ")"
          | !arg:(?o.?inp)&enumerateTools$!inp
          | 
      )
      ( disam
      =     nextvar ding nextn nextvars wfs wflw N toolPlumbing
          , demul demultiply inmul inmultiply c2m
        .     0:?nextn
            & :?nextvars
            & ( nextvar
              =   bang quest var squest
                .   !nextn+1:?nextn
                  &   !nextvars (str$(a !nextn):?var)
                    : ?nextvars
                  & glf$('(`%?.$var)):?quest
                  & glf$('(!.$var)):?bang
                  & glf$('(?.$var)):?squest
                  & (!quest.!bang.!squest)
              )
            & ( ding
              =     bang bangA bangZ bangT featval o
                  , quest questA questZ questT bangIO questIO
                  , questionpattern-tio questiontemplate
                  , questiontemplate-lhs question
                  , questiontemplate-rhs
                  , replacement replacementtemplate
                  , replacementtemplate-lhs replacementtemplate-rhs
                  , rynaps synaps wf1
                  , i w ws wf1 tmp REPLACE IO
                .     !arg
                    : ( ?wf1
                      . (=?questiontemplate)
                      . (=?replacementtemplate)
                      )
                  & "questiontemplate is macro '(...$synaps...)"
                  & (     (=?t.(?i.?o).?IO)
                        : (=?synaps)
                      &   !questiontemplate
                        : (=?questionpattern-tio)
                      & !wf1:!questionpattern-tio
                      &   nextvar$
                        : ((=?questT).(=?bangT).?)
                      &   nextvar$
                        : (?.(=?bangA).(=?questA))
                      &   nextvar$
                        : (?.(=?bangZ).(=?questZ))
                      &   nextvar$
                        : (?.(=?bang).(=?quest))
                      &   nextvar$
                        : (?.(=?bangIO).(=?questIO))
                      & "If a feature is shared by all workflows, remove it."
                      & ( REPLACE
                        =   !questiontemplate:(=?question)
                          & ( (,!toolPlumbing):!question
                            |   !wfs:?ws
                              &   whl
                                ' ( !ws:%?w ?tmp
                                  & !w:!question
                                  & !tmp:?ws
                                  )
                              & (   !ws:
                                  & !wfs:?ws
                                  & :?wfs
                                  &   whl
                                    ' ( !ws:%?w ?ws
                                      & !w:!question
                                      & !wfs !replacement:?wfs
                                      )
                                | 
                                )
                            )
                        )
                      &     
                          ' ( $bangT
                            . ($bangA ()$bangZ.$bang)
                            . $bangIO
                            )
                        : (=?rynaps)
                      & !replacementtemplate:(=?replacement)
                      &   whl
                        ' ( !i:%?featval ?i
                          &     
                              ' ( $questT
                                . ( $questA ()$featval ()$questZ
                                  . $quest
                                  )
                                . $questIO
                                )
                            : (=?synaps)
                          & !REPLACE
                          )
                      &     
                          ' ( $bangT
                            . ($bang.$bangA ()$bangZ)
                            . $bangIO
                            )
                        : (=?rynaps)
                      & !replacementtemplate:(=?replacement)
                      &   whl
                        ' ( !o:%?featval ?o
                          &     
                              ' ( $questT
                                . ( $quest
                                  . $questA ()$featval ()$questZ
                                  )
                                . $questIO
                                )
                            : (=?synaps)
                          & !REPLACE
                          )
                    |   (=%?_%?):(=?synaps)
                      & !questiontemplate:(=?question)
                      & !wf1:!question
                      &   nextvar$
                        : ((=?quest).(=?bang).?)
                      &   '$(%?:$($synaps))_($quest)
                        : (=?synaps)
                      &   !questiontemplate
                        : (=?questiontemplate-lhs)
                      &   '$($($rynaps))_($bang)
                        : (=?rynaps)
                      &   !replacementtemplate
                        : (=?replacementtemplate-lhs)
                      &   '$($quest)_(%?:$($synaps))
                        : (=?synaps)
                      &   !questiontemplate
                        : (=?questiontemplate-rhs)
                      &   '$($bang)_($($rynaps))
                        : (=?rynaps)
                      &   !replacementtemplate
                        : (=?replacementtemplate-rhs)
                      &   ding
                        $ ( !wf1
                          . '('$questiontemplate-lhs)
                          . '('$replacementtemplate-lhs)
                          )
                      &   ding
                        $ ( !wf1
                          . '('$questiontemplate-rhs)
                          . '('$replacementtemplate-rhs)
                          )
                    )
              )
            & "de/inmul(tiply) are used to replace (commutative) * operators
			   with (noncommutative) , operators. And back again. Reason:
			   During simplification factors can swap place, leading to
			   mismatch with the tool plumbing pattern."
            & ( demul
              =   a b
                .     !arg:%?a*%?b
                    & demul$!a:?a
                    & demul$!b:?b
                    & !(glf$('($arg.$a,$b)))
                  |   !arg:?a_?b
                    & (demul$!a)_(demul$!b)
                  | !arg
              )
            & ( demultiply
              =   wf n
                .   map
                  $ ( ( 
                      =   
                        .   !arg:(?n,?wf)
                          & (!n,demul$!wf)
                      )
                    . !arg
                    )
              )
            & ( c2m
              =   x
                .   !arg:(?x,?arg)&!x*c2m$!arg
                  | !arg
              )
            & ( inmul
              =   a b
                .     !arg:(@?a,?b)
                    & ( !a
                      ,   c2m$!b:?a
                        & !(glf$('($b.$a)))
                      )
                  |   !arg:?a_?b
                    & (inmul$!a)_(inmul$!b)
                  | !arg
              )
            & ( inmultiply
              =   wf n
                .   map
                  $ ( ( 
                      =   
                        .   !arg:(?n,?wf)
                          & (!n,inmul$!wf)
                      )
                    . !arg
                    )
              )
            & !arg:((=?toolPlumbing).?wfs)
            & demul$!toolPlumbing:?toolPlumbing
            & demultiply$!wfs:?wfs
            & !wfs:%?wflw ?
            & :?nextvars
            & 0:?nextn
            & "ding changes wfs !!"
            &   ding
              $ ( !wflw
                . (='(?N,$synaps))
                . (='(!N,$rynaps))
                )
            & tbl$(!nextvars,0)
            & inmultiply$!wfs:?wfs
            & !wfs
          | 
      )
      ( describefeature
      =     featvals table specificationTables featdesc
          , featval spec full stbl sps sp
        .   !arg:(?featvals.?table.?specificationTables)
          & :?featdesc
          & NEWSPEC
          &   whl
            ' ( !featvals:%?featval^?spec*?featvals
              &     !featdesc
                    (!featdesc:|" & ")
                    (   !!table:? (?full.!featval.?) ?
                      & localized$!full
                    | !featval
                    )
                    (   !spec:1
                      & NEWSPEC
                      & 
                    |   "["
                        (   !specificationTables
                          :   ?
                              (? (%@:!featval) ?.?stbl)
                              ?
                        & :?sps
                        & (!!stbl|readTable$!stbl)
                        &   whl
                          ' ( !spec:%?sp+?spec
                            & NEWSPEC
                            &     !sps
                                  (!sps:|"|")
                                  (     !!stbl
                                      : ? (?full.!sp.?) ?
                                    & localized$!full
                                  | !sp
                                  )
                              : ?sps
                            )
                        & !sps
                        )
                        "]"
                    )
                : ?featdesc
              )
          & !featdesc
      )
      ( inoutdesc
      =   description
        .         map
                $ ( ( 
                    =     featname featvals table
                        , specificationTables
                      .     !arg:(?featname,?featvals)
                          &   !features
                            :   ?
                              + ( ? (short.!featname) ?
                                : ? (table.?table) ?
                                : (   ?
                                      (specificationTable.?specificationTables)
                                      ?
                                  |   ?
                                    & :?specificationTables
                                  )
                                )
                              + ?
                          &   ", "
                                describefeature
                              $ (!featvals.!table.!specificationTables)
                        | 
                    )
                  . !arg
                  )
              : ", " ?description
            & !description
          | 
      )
      ( fullinoutdesc
      =   description
        .         map
                $ ( ( 
                    =     featname featvals table
                        , specificationTables name
                      .     !arg:(?featname,?featvals)
                          &   !features
                            :   ?
                              + ( ? (short.!featname) ?
                                : ? (table.?table) ?
                                : ? (name.?name) ?
                                : (   ?
                                      (specificationTable.?specificationTables)
                                      ?
                                  |   ?
                                    & :?specificationTables
                                  )
                                )
                              + ?
                          &   ", "
                              localized$!name
                              ":"
                                describefeature
                              $ (!featvals.!table.!specificationTables)
                        | 
                    )
                  . !arg
                  )
              : ", " ?description
            & !description
          | 
      )
      ( fullinoutdescTable
      =   
        .   !arg:
          | ( table
            .   
              ,   map
                $ ( ( 
                    =     featname featvals table
                        , specificationTables name
                      .   !arg:(?featname,?featvals)
                        &   !features
                          :   ?
                            + ( ? (short.!featname) ?
                              : ? (table.?table) ?
                              : ? (name.?name) ?
                              : (   ?
                                    (specificationTable.?specificationTables)
                                    ?
                                |   ?
                                  & :?specificationTables
                                )
                              )
                            + ?
                        & ( tr
                          .   
                            ,   ( td
                                .   (style."font-size:small")
                                  , localized$!name
                                )
                                ( td
                                .   (style."font-size:small")
                                  ,   describefeature
                                    $ (!featvals.!table.!specificationTables)
                                )
                          )
                    )
                  . !arg
                  )
            )
      )
      ( reorder
      =     reorderedworkflowlist nr
          , workflow weighted presentable
        .   ( presentable
            =     mul2com accumulateAbbreviations findUnvisitedWF
                , replace insertNameInFirst
                , removeWorkflowsPrecedingRefs isReferenced
                , deleteReference renameReference
                , abbrevs name newseqno newseqnos nrefs ref
                , refs seq seqno struct wf
              .   ( mul2com
                  =   a b n I O i o
                    .     !arg:%?a*%?b
                        & (mul2com$!a,mul2com$!b)
                      |   !arg:(?n.(?i.?o).?I.?O)
                        & (!n.!I.!O)^(!i.!o)*!abbrevs:?abbrevs
                        & (!n..!I.!O)
                      |   !arg:?a_?b
                        & (mul2com$!a)_(mul2com$!b)
                      | !arg
                  )
                & ( accumulateAbbreviations
                  =   A I O i o exp N list sum
                    .   1:?N
                      & ( sum
                        =   S t
                          .   0:?S
                            &   whl
                              ' ( !arg:%?t ?arg
                                & NEWSPEC
                                & !S+!t:?S
                                )
                            & !S
                        )
                      & ( list
                        =   S t
                          .   :?S
                            &   whl
                              ' ( !arg:#*((?,?):%?t)+?arg
                                & !S !t:?S
                                )
                            & !S
                        )
                      &   whl
                        ' ( !arg:%?A^%?exp*?arg
                          & 0:?I:?O
                          &   whl
                            ' ( !exp:?*(?i.?o)+?exp
                              & !I+sum$!i:?I
                              & !O+sum$!o:?O
                              )
                          & !A^(list$!I.list$!O)*!N:?N
                          )
                      & !N
                  )
                & ( findUnvisitedWF
                  =   a b
                    .     !arg:(%?a,%?b)
                        & ( findUnvisitedWF$!a
                          | findUnvisitedWF$!b
                          )
                      |   !arg:?a (?..?)
                        & findUnvisitedWF$!a
                      |   !arg:(? (?..?):?arg) ?
                        & !arg
                  )
                & ( replace
                  =   a b struct wf seqno n m
                    .   !arg:(?struct.?wf.?seqno)
                      & (   !struct:(%?a,%?b)
                          & ( replace$(!a.!wf.!seqno)
                            , replace$(!b.!wf.!seqno)
                            )
                        |   !struct:(!wf:?a (?n..?m)) ?b
                          & !a (.!seqno.!m) !b
                        |   !struct:?a (?n..?m)
                          & replace$(!a.!wf.!seqno) (!n..!m)
                        | !struct
                        )
                  )
                & ( insertNameInFirst
                  =   struct name seqno a b
                    .   !arg:(?struct.?name.?seqno)
                      & (   !struct:(%?a,%?b)
                          & (   insertNameInFirst$(!a.!name.!seqno)
                              : ?a
                            |   insertNameInFirst$(!b.!name.!seqno)
                              : ?b
                            )
                          & (!a,!b)
                        |   !struct:?a ((?.?.?):?b)
                          & insertNameInFirst$(!a.!name.!seqno):?a
                          & !a !b
                        |   !struct:?a (.!seqno.?b)
                          & !a (!name.!seqno.!b)
                        )
                  )
                & ( removeWorkflowsPrecedingRefs
                  =   a b
                    .     !arg:(%?a,%?b)
                        & ( removeWorkflowsPrecedingRefs$!a
                          , removeWorkflowsPrecedingRefs$!b
                          )
                      |   !arg:? ((.?.?):?b)
                        & !b
                      |   !arg:?a ((?.?.?):?b)
                        & removeWorkflowsPrecedingRefs$!a !b
                      | !arg
                  )
                & ( isReferenced
                  =   a b seqno struct
                    .     !arg:(?seqno.?struct)
                        & !struct:(%?a,%?b)
                        & ( isReferenced$(!seqno.!a)
                          | isReferenced$(!seqno.!b)
                          )
                      | !struct:? (.!seqno.?) ?
                      |   !struct:%?a %?b
                        & ( isReferenced$(!seqno.!a)
                          | isReferenced$(!seqno.!b)
                          )
                  )
                & ( deleteReference
                  =   a b struct seqno n m
                    .   !arg:(?seqno.?struct)
                      & (   !struct:(%?a,%?b)
                          & ( deleteReference$(!seqno.!a):?a
                            | deleteReference$(!seqno.!b):?b
                            )
                          & (!a,!b)
                        |   !struct:?a (?n.!seqno.?m) ?b
                          & !a (!n..!m) !b
                        |   !struct:%?a %?b
                          & ( deleteReference$(!seqno.!a):?a
                            | deleteReference$(!seqno.!b):?b
                            )
                          & !a !b
                        )
                  )
                & ( renameReference
                  =   a b struct seq n m seqno nseqno
                    .   !arg:(?seq.?struct)
                      & (   !struct:(%?a,%?b)
                          & ( renameReference$(!seq.!a)
                            , renameReference$(!seq.!b)
                            )
                        |   !struct:%?a %?b
                          &   renameReference$(!seq.!a)
                              renameReference$(!seq.!b)
                        |   !seq:(?seqno.?nseqno)
                          & !struct:(?n.!seqno.?m)
                          & (!n.!nseqno.!m)
                        | !struct
                        )
                  )
                & 1:?abbrevs
                & "Replace * by , and collect abbrevs (side effect)"
                & mul2com$!arg:?struct
                & accumulateAbbreviations$!abbrevs:?abbrevs
                & 0:?seqno
                & :?refs
                &   whl
                  ' ( findUnvisitedWF$!struct:?wf
                    & 1+!seqno:?seqno
                    & !wf:? (?name.?)
                    & (!name.!seqno) !refs:?refs
                    & replace$(!struct.!wf.!seqno):?struct
                    )
                & :?nrefs
                &   whl
                  ' ( !refs:%?ref ?refs
                    & !ref !nrefs:?nrefs
                    & insertNameInFirst$(!struct.!ref):?struct
                    )
                & removeWorkflowsPrecedingRefs$!struct:?struct
                & :?newseqnos
                & (48|9311):?newseqno
                &   whl
                  ' ( !nrefs:(?.?seqno) ?nrefs
                    & 1+!newseqno:?newseqno
                    & (   isReferenced$(!seqno.!struct)
                        &   (!seqno.!newseqno) !newseqnos
                          : ?newseqnos
                      | deleteReference$(!seqno.!struct):?struct
                      )
                    )
                &   whl
                  ' ( !newseqnos:%?seq ?newseqnos
                    & renameReference$(!seq.!struct):?struct
                    )
                & (!struct.!abbrevs)
            )
          & ( weighted
            =     name Ntools Nsteps n nr countTools
                , A B T C usedTools struct abbrevs
                , toolInventory toolsUsed plumbing
              .   ( plumbing
                  =   a b
                    .     !arg:%?a %?b
                        & plumbing$!a plumbing$!b
                      |   !arg:(%?a,%?b)
                        & (plumbing$!a,plumbing$!b)
                      | !arg:(?a.?b.?)&(!a.!b)
                  )
                & !arg:(?nr,(?struct.?abbrevs))
                & 0:?Ntools:?Nsteps:?toolInventory
                & ( countTools
                  =   A B
                    .     !arg:((?A,?B)|%?A %?B)
                        & countTools$!A+countTools$!B
                      | !arg:(~:?A.?.?.?)&!A
                      | 0
                  )
                & countTools$!struct:?toolInventory
                & ( usedTools
                  =   A B
                    .     !arg:((?A,?B)|%?A %?B)
                        & usedTools$!A usedTools$!B
                      | !arg:(?A.?.?.?)&!A
                      | 
                  )
                & usedTools$!struct:?toolsUsed
                &   whl
                  ' ( !toolsUsed:?A %@?T ?B %@!T ?C
                    & !A !T !B !C:?toolsUsed
                    )
                &   whl
                  ' ( !toolInventory:?n*%@?name+?toolInventory
                    & !n+!Nsteps:?Nsteps
                    & 1+!Ntools:?Ntools
                    )
                & ( (!Ntools.!toolsUsed.!Nsteps.plumbing$!struct.!nr)
                  , (!abbrevs.!struct)
                  )
            )
          & 0:?reorderedworkflowlist
          &   map
            $ ( ( 
                =   nr workflow
                  .   whl
                    ' ( !arg:(?nr,?workflow) ?arg
                      &     weighted$(!nr,presentable$!workflow)
                          + !reorderedworkflowlist
                        : ?reorderedworkflowlist
                      )
                )
              . !arg
              )
          &   ( 
              =   L p n a b c d e B
                .   :?L
                  & :?p
                  & 0:?n
                  &   whl
                    ' ( !arg:((?a.?b.?c.?d.?e),?B)+?arg
                      & (   !d:~!p:?p
                          & 1+!n:?n
                        | 
                        )
                      & ((!a.!b.!c.!n.!e),!B) !L:?L
                      )
                  & 0:?arg
                  &   whl
                    ' (!L:%?a ?L&!a+!arg:?arg)
                  & !arg
              )
            $ !reorderedworkflowlist
      )
      ( topologicalOrder
      =     edges workflow A Z
          , 2p Kahn edg pr
          , pairs
        .   ( edg
            =   a b
              .   !arg:%?a %?b&edg$!b edg$!a
                | !arg:(?a,?b)&edg$!a+edg$!b
                | !arg:(?a.?b)&!a
            )
          & ( pr
            =   nxt a b c
              .     !arg:(?nxt.%?a+%?b)
                  & pr$(!nxt.!a)+pr$(!nxt.!b)
                | !arg:(?nxt.#%*%?a)&pr$(!nxt.!a)
                |   !arg:(?nxt.%?a %?b)
                  &   ( !nxt:&0
                      | (!a.!nxt)
                      )
                    + (   !b:%@?b ?c
                        & (!b.!a)+pr$(!b.!c)
                      | pr$(!a.!b)
                      )
                |   !arg:(?nxt.%@?a ?)
                  & (!nxt:&0|(!a.!nxt))
                | 0
            )
          & 0:?edges
          &   map
            $ ( ( 
                =   
                  .   whl
                    ' ( !arg:(?,?workflow) ?arg
                      & edg$!workflow+!edges:?edges
                      )
                )
              . !arg
              )
          & pr$(.!edges):?pairs
          & ( 2p
            =   a b
              .     !arg:%@?a %@?b ?arg
                  & (!a.!b)+2p$(!b !arg)
                | 0
            )
          & ( Kahn
            =   pairs A Z i S L m n
              .   "create topological ordering"
                & !arg:?pairs
                & :?S:?L
                & (   !pairs
                    :   ?
                      +   #
                        * (   ?i
                            & ~(!pairs:?+#*(?.!i)+?)
                            & ~(!S:? !i ?)
                            & !i !S:?S
                            & ~
                          . ?
                          )
                      + ?
                  | 
                  )
                &   whl
                  ' ( !S:%?n ?S
                    & !L !n:?L
                    &   whl
                      ' ( !pairs:?A+#*(!n.?m)+?Z
                        & !A+!Z:?pairs
                        & ( !pairs:?+#*(?.!m)+?
                          | !m !S:?S
                          )
                        )
                    )
                & ( !pairs:0
                  | log$"graph has at least one cycle"
                  )
                & !L
            )
          & Kahn$!pairs
      )
      ( set
      =   S L e
        .   0:?S
          &   whl
            ' ( !arg:%?e ?arg
              & (!S:?+!e+?|!e+!S:?S)
              )
          & :?L
          & whl'(!S:%?e+?S&!L !e:?L)
          & !L
      )
      ( makeWorkflowsSequential
      =     i nr enumerateToolsDetail
          , disambiguatedworkflowlist groupedworkflowlist n
          , o pat pipe pipes sameToolDifferentRoles
          , toolPlumbing "*" simplify
          , wf wfs workflow workflowlist saveio toolPattern
        .   ( enumerateToolsDetail
            =   tool o i predecessors myfold,a b
              .       !arg
                    : ( ?tool
                      , ( ?o
                        . ?
                        .   (?i.?predecessors)
                          | ?i&:?predecessors
                        )
                      )
                  & (|ToolTitle$!tool:?tool)
                  & ( myfold
                    =   a b A B F R v1 v2
                      .     !arg:%?a*%?b
                          & :!(glf$('($arg.?))) ?
                          & myfold$!b:?b
                          & (     !a
                                :   ?
                                    ( ?F
                                    ,   ?v1
                                      &   !b
                                        : ?A (!F,~!v1:?v2) ?B
                                      &   !A (!F,!v1*!v2) !B
                                        : ?R
                                    )
                                    ?
                              & !R
                            | 
                            )
                        |   !arg:?A (?F,%*%:?v1) ?B
                          & !A (!F,!(glf$('(%.$v1)))) !B
                        | !arg
                    )
                  &   ( !predecessors:
                      | enumerateToolsDetail$!predecessors
                      )
                      (!tool.myfold$!i.!o)
                |   !arg:%?a*%?b
                  & enumerateToolsDetail$!a*enumerateToolsDetail$!b
                |   !arg:%?a+%?b
                  & NEWSPEC
                  & enumerateToolsDetail$!a+enumerateToolsDetail$!b
                |   !arg:(?o.?i)
                  & enumerateToolsDetail$!i
                | 1
            )
          & ( simplify
            =     WF S dun sortout n f i I
                , o feat val A Z O IO replace
              .   ( sortout
                  =   L R
                    .   !arg:(?.?)&!arg !S:?S
                      |   !arg:%?L_%?R
                        & sortout$!L
                        & sortout$!R
                  )
                & :?S
                & sortout$!arg
                & :?dun
                & ( replace
                  =   n r p L R WF
                    .   !arg:(?WF.?n.(=?p).(=?r))
                      & (   !WF:(=?.?)
                          & (   !WF:(=!n.!p)
                              & !r:?r
                              & '($n.$r)
                            | !WF
                            )
                        |   !WF:(=%?L_%?R)
                          &   
                            '   
                              $   ( 
                                  $ ( replace
                                    $ ('$L.!n.'$p.'$r)
                                    )
                                  )
                                _ ( 
                                  $ ( replace
                                    $ ('$R.!n.'$p.'$r)
                                    )
                                  )
                        )
                  )
                & '$arg:?WF
                &   whl
                  ' ( !S:(?n.?f) ?S
                    & ( !dun:? !n ?
                      |   !n !dun:?dun
                        & (   !S:? (!n.~!f) ?
                            & !f:((?i.?o).?IO)
                            &   whl
                              ' ( !i:(?feat,?val) ?i
                                & (   !S
                                    :   ?
                                        ( !n
                                        . (? (!feat,~!val) ?.?)
                                        . ?
                                        )
                                        ?
                                  |     replace
                                      $ ( !WF
                                        . !n
                                        .   
                                          ' ( (   ?A
                                                  ($feat,$val)
                                                  ?Z
                                              . ?O
                                              )
                                            . ?IO
                                            )
                                        . ( 
                                          = (!A ? !Z.!O).!IO
                                          )
                                        )
                                    : ?WF
                                  )
                                )
                            &   whl
                              ' ( !o:(?feat,?val) ?o
                                & (   !S
                                    :   ?
                                        ( !n
                                        . (?.? (!feat,~!val) ?)
                                        . ?
                                        )
                                  |     replace
                                      $ ( !WF
                                        . !n
                                        .   
                                          ' ( ( ?I
                                              .   ?A
                                                  ($feat,$val)
                                                  ?Z
                                              )
                                            . ?IO
                                            )
                                        . (=(!I.!A ? !Z).!IO)
                                        )
                                    : ?WF
                                  )
                                )
                          |   replace$(!WF.!n.(=?).(=?))
                            : ?WF
                          )
                      )
                    )
                & !WF
            )
          & ( toolPattern
            =   pat tool lhs rhs lpat rpat Wf feats
              .   :?pat
                & !arg:(=?Wf)
                &   whl
                  ' ( (   '$Wf:(=?Wf (?tool.?feats))
                        & (   '$feats:(=?feats.?)
                            & '($feats.?):(=?feats)
                          | 
                          )
                        & (   :!pat
                            & '($tool.$feats)
                          | '(($tool.$feats) ()$pat)
                          )
                      |   '$Wf:(=?Wf %?lhs*%?rhs)
                        & toolPattern$('$lhs):(=?lpat)
                        & toolPattern$('$rhs):(=?rpat)
                        & (   :!pat
                            & '($lpat*$rpat)
                          | '($lpat*$rpat ()$pat)
                          )
                      )
                    : (=?pat)
                    )
                & '$pat
            )
          & "Same code, but a bit faster because of short names. (intensively used code!)"
          & ( "*"
            =   "#" "%" "[" "]" "(" ")" "-" "="
              .   :?"#"
                & !arg:(=?"-")
                &   whl
                  ' ( (   '$"-":(=?"-" (?"%".?"="))
                        & (   '$"=":(=?"=".?)
                            & '($"=".?):(=?"=")
                          | 
                          )
                        & ( :!"#"&'($"%".$"=")
                          | '(($"%".?) ()$"#")
                          )
                      |   '$"-":(=?"-" %?"["*%?"]")
                        & "*"$('$"["):(=?"(")
                        & "*"$('$"]"):(=?")")
                        & ( :!"#"&'($"("*$")")
                          | '($"("*$")" ()$"#")
                          )
                      )
                    : (=?"#")
                    )
                & '$"#"
            )
          & ( sameToolDifferentRoles
            =     delta Delta replac I O
                , simple tool tree
                , details flatlist updat
                , fx fy reps sx sy
              .   ( delta
                  =   this other L f v
                    .   !arg:(?this.?other)
                      & :?L
                      & (   !this
                          :   ?
                              ( (?f,?v)
                              & ( !other:? (!f,!v) ?
                                | (!f,!v) !L:?L
                                )
                              & ~
                              )
                              ?
                        | !L
                        )
                  )
                & ( Delta
                  =   AI AO BI BO
                    .   !arg:((?AI.?AO),(?BI.?BO))
                      & (delta$(!AI.!BI).delta$(!AO.!BO))
                  )
                & ( replac
                  =   t s r a b
                    .   !arg:(?t.?s,?r)
                      & ( !t:!s&!r
                        |   !t:%?a %?b
                          & replac$(!a.!s,!r) replac$(!b.!s,!r)
                        |   !t:(%?a,%?b)
                          & (replac$(!a.!s,!r),replac$(!b.!s,!r))
                        | !t
                        )
                  )
                & ( flatlist
                  =   p q
                    .     !arg
                        : ( @
                          . (?.?)
                          . (?,?) ?
                          . (?,?) ?
                          )
                      |   !arg:((?p,?q)|%?p %?q)
                        & flatlist$!p+flatlist$!q
                  )
                & ( updat
                  =     reps tool i o id
                      , od I O details A Z
                    .     !arg
                        : ( ?reps
                          . ?tool
                          . (?i.?o),(?id.?od)
                          . ?details
                          )
                      & (     !reps
                            : ?A (!tool.(?I.?O).!details) ?Z
                          &   !A
                              ( !tool
                              . (set$(!I !i !id).set$(!O !o !od))
                              . !details
                              )
                              !Z
                        |   ( !tool
                            . (set$(!i !id).set$(!o !od))
                            . !details
                            )
                            !reps
                        )
                  )
                &   map
                  $ ( ( 
                      =   
                        .   !arg:(?n,?tree)
                          & :?reps
                          & (   flatlist$!tree
                              :   ?
                                + ?*(?tool.?sx.?fx)
                                + ?
                                + ?*(!tool.?sy.?fy)
                                + ( ?
                                  &     updat
                                      $ ( !reps
                                        . !tool
                                        . !sx,Delta$(!fx,!fy)
                                        . !fx
                                        )
                                    : ?reps
                                  &     updat
                                      $ ( !reps
                                        . !tool
                                        . !sy,Delta$(!fy,!fx)
                                        . !fy
                                        )
                                    : ?reps
                                  & ~
                                  )
                            |     whl
                                ' (   !reps
                                    : (?tool.?simple.?details) ?reps
                                  &     replac
                                      $ ( !tree
                                        .   (!tool.?.!details)
                                          , (!tool.!simple.!details)
                                        )
                                    : ?tree
                                  )
                              & (!n,!tree)
                            )
                      )
                    . !arg
                    )
            )
          & ( saveio
            =   n i o x y
              .     !arg:(?n.?i.~(?.?):?o)
                  & (!n.(!i.!o).!i.!o)
                |   !arg:%?x*%?y
                  & (   :!(glf$('($arg.?))) ?
                      & saveio$!x*saveio$!y
                    | !arg
                    )
                |   !arg:?x_?y
                  & (saveio$!x)_(saveio$!y)
                | !arg
            )
          & !arg:?pipes
          & "pipes is an unnumbered list sorted on directly on full workflow tree."
          & :?workflowlist
          & 0:?n
          &   whl
            ' ( 1+!n:?n:<1000000
              & !pipes:%?pipe+?pipes
              &   saveio$(!n.enumerateToolsDetail$!pipe) !workflowlist
                : ?workflowlist
              )
          & (   !n:<1000000
              & log$("while enumerateToolsDetail:" !n)
            |   log
              $ "while enumerateToolsDetail: MAX NUMBER OF WORKFLOW OPERATIONS REACHED (1000000)"
            )
          & "workflowlist is numbered list of workflows, with equal branches not merged yet, and with I/O duplicated."
          & :?groupedworkflowlist
          & :?toolPlumbing
          & 0:?disambiguatedworkflowlist
          &   whl
            ' ( 1+!n:?n:<1000000
              & !workflowlist:(#?nr.?workflow) ?workflowlist
              & "*"$(simplify$!workflow):(=?toolPlumbing)
              & (!nr,!workflow):?wfs
              &     map
                  $ ( ( 
                      =   
                        .     !arg:(#?nr.!toolPlumbing:?wf)
                            & 1+!n:?n:<1000000
                            & (!nr,!wf) !wfs:?wfs
                            & 
                          | !arg
                      )
                    . !workflowlist
                    )
                : ?workflowlist
              & '$toolPlumbing:?toolPlumbing
              & "The function disam spots the differences between workflows 
                 that have the same tools in the same structure: the 'smaller'
                 differences. For example, in the example below, (.app,nrm)
                 indicates that the workflow differs from another workflow as
                 to the appearance of the output, which is 'normalized', while
                 another workflow has e.g. 'unnormalized' output. The field
                 left of the dot is empty, which tells us that there is no
                 difference in the input.
                      ( JSON to ORG-mode converter
                      . (.app,nrm)
                      .   (ambig,pru)
                          (app,drty)
                          (facet,stlp^Menotas)
                          (format,json^xid)
                          (lang,da)
                          (period,c21)
                          (pres,nml)
                      .   (ambig,pru)
                          (app,nrm)
                          (facet,tlp^Menotas)
                          (format,dipl)
                          (lang,da)
                          (period,c21)
                          (pres,nml)
                      )"
              & "'sameToolDifferentRoles' does something similar to 'disam'.
                 Whereas 'disam' looks at different uses of the same tool in
                 different workflows, 'sameToolDifferentRoles' looks at
                 different uses of the same tool in the same workflow."
              &     sameToolDifferentRoles$(disam$(!toolPlumbing.!wfs))
                    !disambiguatedworkflowlist
                : ?disambiguatedworkflowlist
              )
          & ( !n:<1000000
            |   log
              $ "while groupedworkflowlist: MAX NUMBER OF WORKFLOW OPERATIONS REACHED (1000000)"
            )
          & ( reorder$!disambiguatedworkflowlist
            . topologicalOrder$!disambiguatedworkflowlist
            )
      )
      ( Circle
      =   
        .   !arg:~#&!arg
          | ( strong
            .   
              ,     !arg:<128
                  & ( !arg:~<48&!arg+-48
                    | chr$!arg
                    )
                | chu$!arg
            )
      )
      ( SpotInput
      =   spotInput subt diff
        .   ( subt
            =   plus A f v a x y z
              .   !arg:(?plus.?A)
                &   whl
                  ' ( !A:(?f,?v) ?A
                    & !plus:?a (!f,?x*!v*?y) ?z
                    & ( !x*!y:1
                      | !a (!f,!x*!y) !z:?plus
                      )
                    )
                & !plus
            )
          & ( diff
            =   plus minus A refs
              .   !arg:(?plus.?refs.?minus)
                & ( !minus:
                  |     whl
                      ' ( !minus:(? (?.?.?.?A),?minus)
                        & subt$(!plus.!A):?plus
                        )
                    & !minus:? (?.?.?.?A)
                    & subt$(!plus.!A):?plus
                  )
                & ( !refs:
                  |     whl
                      ' ( !refs:(? (?.?.?.?A),?refs)
                        & subt$(!plus.!A):?plus
                        )
                    & !refs:? (?.?.?.?A)
                    & subt$(!plus.!A):?plus
                  )
                & !plus
            )
          & ( spotInput
            =     max nrefs N A B spotting
                , refs inputs name P a N DATA
              .   !arg:?spotting
                & (     !arg
                      :   ?A
                          ((?name.?refs [?nrefs.?inputs.?):?B)
                    &   ( !name:&spotInput$!A
                        |   0:?nrefs
                          & 1:?max
                          & (     !inputs
                                : ? (?,%*%:?P) ?
                              & ~(:!(glf$('($P.?))) ?)
                              & "There is a % preceding the product. That means: single file input."
                            |   !inputs
                              :   ?
                                  ( ?
                                  ,   ?
                                    * ( [?P
                                      & !P:>!max:?max
                                      )
                                  )
                                  (?&~)
                            | 
                            )
                          & !A:?a
                          & 0:?N
                          & ( !a:
                            |   -1:?N
                              &   whl
                                ' ( !a:(?,?a)
                                  & !N+-1:?N
                                  )
                            )
                          & (   !max+!N+!nrefs:0
                              & spotInput$!A
                            |   diff$(!inputs..!A):?DATA
                              & (   !A:
                                  & (.∵..!DATA)
                                | (spotInput$!A,(.∵..!DATA))
                                )
                            )
                        )
                        !B
                  |   !arg:(?A,?B)
                    & (spotInput$!A,spotInput$!B)
                  | !arg
                  )
            )
          & spotInput$!arg
      )
      ( makeWorkflowRadioButtons
      =     i Nsteps Ntools n o
          , toolPlumbing translateManyToHumanLanguage
          , abbR reorderedworkflowlist struct
          , toolsUsed topologicalOrderedTools candidateList
        .   ( candidateList
            =     reorderedworkflowlist nsteps ntools
                , theUsedTools infoAboutTool toolRows transpose
                , currNsteps currNtools currToolPlumbing currToolsUsed2
                , hyperlinks nth thead toolSetID buttons
                , toolTable toolUsageList topologicalOrderedTools
              .   ( nsteps
                  =   
                    . p
                    .   
                      ,   "("
                          !arg
                          " "
                            localized
                          $ ( ( !arg:1&step
                              | steps
                              )
                              trin
                            )
                          ")"
                  )
                & ( ntools
                  =   below
                    .   !arg:(?arg.?below)
                      & ( p
                        .   !below:|(id.below)
                          , ( strong
                            .   
                              ,   (🗱|💈)
                                  " "
                                  !arg
                                  " "
                                    localized
                                  $ (   !arg:1
                                      & tool værktøj
                                    | tools værktøjer
                                    )
                            )
                        )
                  )
                & ( theUsedTools
                  =   ID
                    .       !toolUsageList
                            (   str$(T (1+!toolSetID:?toolSetID))
                              : ?ID
                            . !arg
                            )
                        : ?toolUsageList
                      & (     map
                            $ ( ( 
                                =   
                                  .   !arg:(?.?arg)
                                    & ", " !arg
                                )
                              . !arg
                              )
                          : ", " ?arg
                        | 
                        )
                      & (p.(id.!ID),(strong.,!arg))
                  )
                & ( infoAboutTool
                  =   Description Title
                    .   !arg:(?arg.?Title)
                      &   !tooladm
                        :   ?
                          + ( ? (ToolID.!arg) ?
                            : ? (Description.?Description) ?
                            )
                          + ?
                      & ( div
                        .   (class.tooltip)
                          ,   !Title
                              ( span
                              . (class.tooltiptext),!Description
                              )
                        )
                  )
                & ( toolRows
                  =   tool tools row rows
                    .       !arg
                          : (%?tool ?tools.(?.?row) ?rows)
                        &   ( tr
                            .   
                              ,   (td.,infoAboutTool$!tool)
                                  map$((=.td.,!arg).!row)
                            )
                            toolRows$(!tools.!rows)
                      | 
                  )
                & ( transpose
                  =   L ID a
                    .   !arg:(?.) ?&
                      |       map
                            $ ( ( 
                                =   ID a
                                  .   !arg:(?ID.%?a ?arg)
                                    & (!a.!ID.!arg)
                                )
                              . !arg
                              )
                          : ?L
                        &   ( 
                            .   map
                              $ ( ( 
                                  =   
                                    .   !arg:(?arg.?)
                                      & !arg
                                  )
                                . !L
                                )
                            )
                              transpose
                            $ ( map
                              $ ( ( 
                                  =   
                                    .   !arg:(?.?arg)
                                      & !arg
                                  )
                                . !L
                                )
                              )
                  )
                &   !arg
                  : (?reorderedworkflowlist.?topologicalOrderedTools)
                & 0:?nth
                & (   !reorderedworkflowlist
                    : ((?currNsteps.?),?)+?
                  | 1:?currNsteps
                  )
                & :?currToolPlumbing:?currToolsUsed2
                & 0:?currNtools
                & :?toolUsageList
                & 0:?toolSetID
                &   sum2list$!reorderedworkflowlist
                  : ?reorderedworkflowlist
                &       map
                      $ ( ( 
                          =     Nsteps Ntools abbR nr
                              , struct toolPlumbing toolsUsed toolsUsed2
                            .     !arg
                                : ( 
                                  .   ( ?Ntools
                                      . ?toolsUsed
                                      . ?Nsteps
                                      . ?toolPlumbing
                                      . ?nr
                                      )
                                    , (?abbR.?struct)
                                  )
                              & toolID2title$!toolsUsed:?toolsUsed2
                              & 1+!nth:?nth
                              &   (   !nth:1
                                    & !Ntools:?currNtools
                                    & !toolsUsed2:?currToolsUsed2
                                    & !Nsteps:?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    &   (hr.,)
                                        (hr.,)
                                        ntools$(!Ntools.below)
                                        theUsedTools$!toolsUsed2
                                        nsteps$!Nsteps
                                  |     !Ntools
                                      : ~!currNtools
                                      : ?currNtools
                                    & !toolsUsed2:?currToolsUsed2
                                    & !Nsteps:?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    &   (hr.,)
                                        (hr.,)
                                        ntools$(!Ntools.)
                                        theUsedTools$!toolsUsed2
                                        nsteps$!Nsteps
                                  |     !toolsUsed2
                                      : ~!currToolsUsed2
                                      : ?currToolsUsed2
                                    & !Nsteps:?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    &   (hr.,)
                                        theUsedTools$!toolsUsed2
                                        nsteps$!Nsteps
                                  |     !Nsteps
                                      : ~!currNsteps
                                      : ?currNsteps
                                    & !toolPlumbing:?currToolPlumbing
                                    & nsteps$!Nsteps
                                  |     !toolPlumbing
                                      : ~!currToolPlumbing
                                      : ?currToolPlumbing
                                    & 
                                  | 
                                  )
                                  !nth
                                  \r\n
                                  ( input
                                  .     (type.submit)
                                        (name.str$(bview- !nth))
                                        (value.🔍)
                                    , 
                                  )
                                  \r\n
                                  ( input
                                  .     (type.submit)
                                        (name.str$(bsubmit- !nth))
                                        (value.►)
                                    , 
                                  )
                                  \r\n
                                    translateManyToHumanLanguage
                                  $ (!abbR.!struct)
                                  (br.,)
                                  (br.,)
                          )
                        . !reorderedworkflowlist
                        )
                      (br.,)
                  : ?buttons
                &   (   (|!toolUsageList:? [>1)
                      &     map
                          $ ( ( 
                              =   ID cur
                                .   !arg:(?ID.?cur)
                                  & ( !ID
                                    .   map
                                      $ ( ( 
                                          =   
                                            .     !cur:? !arg ?
                                                & (◼|■)
                                              | " "
                                          )
                                        . !topologicalOrderedTools
                                        )
                                    )
                              )
                            . !toolUsageList
                            )
                        : ?toolTable
                      & (   !toolUsageList:? [>1
                          &   ( thead
                              .   
                                , ( tr
                                  .   
                                    ,   ( th
                                        .   
                                          ,     localized
                                              $ (tools værktøjer)
                                              🠓
                                              ( 
                                              |   " ⧹ "
                                                  localized$hyperlinks
                                                  🠒
                                              )
                                        )
                                        (     map
                                            $ ( ( 
                                                =   ID
                                                  .   !arg:(?ID.?)
                                                    & ( th
                                                      .   
                                                        , ( a
                                                          .   ( href
                                                              . str$("#" !ID)
                                                              )
                                                            , ⬇
                                                          )
                                                      )
                                                )
                                              . !toolTable
                                              )
                                          : ?hyperlinks
                                        & 
                                        )
                                  )
                              )
                            : ?thead
                        | 
                        )
                      & transpose$!toolTable:?toolTable
                      &   ( table
                          .   (id.t01)
                            ,   (   !toolUsageList:? [>1
                                  & !thead
                                | 
                                )
                                ( tbody
                                .   
                                  ,   toolRows
                                    $ (!topologicalOrderedTools.!toolTable)
                                )
                                (   !toolUsageList:? [>1
                                  & ( thead
                                    .   
                                      , ( tr
                                        .   
                                          ,   ( th
                                              .   
                                                ,   ( 
                                                    |     localized
                                                        $ (tools værktøjer)
                                                        🠑
                                                        " ⧸ "
                                                    )
                                                    localized$hyperlinks
                                                    🠒
                                              )
                                              !hyperlinks
                                        )
                                    )
                                | 
                                )
                          )
                          ( p
                          .   
                            ,   (br.,)
                                  localized
                                $ ( "Move the mouse pointer over the tool names for a short explanation of what the tool does."
                                    "Du får en kort forklaring for hvert værktøj ved at flytte musepilen over værktøjets navn."
                                  )
                                (br.,)
                                  localized
                                $ ( "Click on the hyperlink for the preferred tools, and find all workflows that can be generated by the tools."
                                    "Klik på hyperlinket for de værktøjer som du foretrækker, og se alle arbejdgange med disse værktøjer."
                                  )
                                (br.,)
                                  localized
                                $ ( "Select a workflow by pressing a 🔍 (View details) or ► (Submit) button."
                                    "Vælg en arbejdsgang ved at trykke på 🔍 (Se detaljer) eller ► (Submit)."
                                  )
                          )
                    | 
                    )
                    !buttons
            )
          & ( translateManyToHumanLanguage
            =     description seqno struct abbrevs o
                , describeShort
              .   ( describeShort
                  =   describe circle nice arrow
                    .   ( circle
                        =   
                          .   !arg:~#&!arg
                            | ( strong
                              .   
                                ,     !arg:<128
                                    &   ":"
                                        (   !arg:~<48
                                          & !arg+-48
                                        | chr$!arg
                                        )
                                  | chu$!arg
                              )
                        )
                      & ( nice
                        =   i o
                          .   !arg:(?i.?o)
                            & inoutdesc$!i:?i
                            & inoutdesc$!o:?o
                            & ( :!i:!o
                              |   "("
                                  !i
                                  ( !i:
                                  | !o:
                                  | " ; "
                                  )
                                  !o
                                  ")"
                              )
                        )
                      & ( arrow
                        =   b i
                          .   !arg:(?arg.?b)
                            & !b:(?.?.?i.?) ?
                            & ( div
                              .   (class.tooltip)
                                ,   ( !arg:1&" → "
                                    | !arg:2&" ⇒ "
                                    | !arg:3&" ⇛ "
                                    | " ⭆ "
                                    )
                                    ( span
                                    .   (class.tooltiptext)
                                      , fullinoutdesc$!i
                                    )
                              )
                        )
                      & ( describe
                        =   a b c m n an bn cn h L tit
                          .   !arg:(?h.?arg)
                            & (   !arg:(?a,?b)
                                & describe$(.!a):(?L.?an)
                                &   whl
                                  ' ( !b:(?c,?b)
                                    &     !L
                                          "+"
                                          (   describe$(h.!c)
                                            : (?c.?cn)
                                          & !c
                                          )
                                      : ?L
                                    & !an+!cn:?an
                                    )
                                &     !L
                                      "+"
                                      ( describe$(h.!b):(?b.?bn)
                                      & !b
                                      )
                                  : ?L
                                & !an+!bn:?an
                                & (!L.!an)
                              |   !arg:%?a %?b
                                & describe$(.!a):(?a.?an)
                                & (       !a
                                          (   !a:(div.?,∵ ?)
                                            & 
                                          | arrow$(!an.!b)
                                          )
                                          (   describe$(.!b)
                                            : (?b.?bn)
                                          & !b
                                          )
                                      : ?c
                                    & ( !h:&!c
                                      | "[" !c "]"
                                      )
                                  . !bn
                                  )
                              |   !arg:(?m.?seqno.?n)
                                & ( !m::?tit
                                  |   !tooladm
                                    :   ?
                                      + ( ? (ToolID.!m) ?
                                        : ? (Title.?tit) ?
                                        )
                                      + ?
                                  )
                                & (   (   !tit:
                                        & (   !seqno:∵
                                            & 
                                          | Circle$!seqno
                                          )
                                      | !tit circle$!seqno
                                      )
                                      (   !tit:
                                        & (   !seqno:∵
                                            & !n:(?.?c)
                                            & ( !c:
                                              | ( div
                                                .   (class.tooltip)
                                                  ,   ∵
                                                      ( span
                                                      .   (class.tooltiptext)
                                                        , fullinoutdesc$!c
                                                      )
                                                )
                                              )
                                          | 
                                          )
                                      |   !abbrevs:?*(!m.!n)^?n*?
                                        & nice$!n
                                      )
                                  . 1
                                  )
                              )
                        )
                      & describe$(.!arg):(?arg.?)
                      & !arg
                  )
                & !arg:(?abbrevs.?struct)
                & SpotInput$!struct:?struct
                & describeShort$!struct:?description
                & (   !description:~
                    & !struct:? (?.?.?.?o)
                    &   !description
                        ( div
                        .   (class.tooltip)
                          ,   ∴
                              ( span
                              . (class.tooltiptextL),inoutdesc$!o
                              )
                        )
                  |   localized
                    $ ( "It seems that the input already matches your goal. Or we haven't enough information about the input. Use the back button to change your choice."
                        "Det ser ud til at inputtet allerede opfylder dit mål. Eller vi har ikke fundet de nødvendige oplysninger om inputtet. Brug knappen \"Forrige\" for at ændre dine valg."
                      )
                  )
            )
          & !arg:(?reorderedworkflowlist.?topologicalOrderedTools)
          &   toolID2title$!topologicalOrderedTools
            : ?topologicalOrderedTools
          & candidateList$(!reorderedworkflowlist.!topologicalOrderedTools)
      )
      ( makeWorkflowVisualisation
      =   n o struct translateOneToHumanLanguage
        .   ( translateOneToHumanLanguage
            =     description seqno struct abbrevs o
                , describeLong
              .   ( describeLong
                  =   describe simplearrow
                    .   ( simplearrow
                        =   b i
                          .   !arg:(?arg.?b)
                            & !b:(?.?.?i.?) ?
                            & ( !arg:1&" → "
                              | !arg:2&" ⇒ "
                              | !arg:3&" ⇛ "
                              | " ⭆ "
                              )
                        )
                      & ( describe
                        =   a b c m n an bn cn h L tit
                          .   !arg:(?h.?arg)
                            & (   !arg:(?a,?b)
                                & describe$(.!a):(?L.?an)
                                &   whl
                                  ' ( !b:(?c,?b)
                                    &     !L
                                          (dt.,"+")
                                          (   describe$(h.!c)
                                            : (?c.?cn)
                                          & !c
                                          )
                                      : ?L
                                    & !an+!cn:?an
                                    )
                                &     !L
                                      (dt.,"+")
                                      ( describe$(h.!b):(?b.?bn)
                                      & !b
                                      )
                                  : ?L
                                & !an+!bn:?an
                                & (!L.!an)
                              |   !arg:%?a %?b
                                & describe$(.!a):(?a.?an)
                                & (       (dd.,(dl.,!a))
                                          (dt.,simplearrow$(!an.!b))
                                          (   describe$(.!b)
                                            : (?b.?bn)
                                          & !b
                                          )
                                      : ?c
                                    & ( !h:&!c
                                      | (dt.,"[") !c (dt.,"]")
                                      )
                                  . !bn
                                  )
                              |   !arg:(?m.?seqno.?n)
                                & ( !m::?tit
                                  |   !tooladm
                                    :   ?
                                      + ( ? (ToolID.!m) ?
                                        : ? (Title.?tit) ?
                                        )
                                      + ?
                                  )
                                & (   ( dt
                                      .   
                                        ,   (   Circle$!seqno
                                              : ?c
                                              : 
                                            |   !c
                                                ( !tit:
                                                | "-"
                                                )
                                            )
                                            !tit
                                      )
                                      (   !seqno:~∵
                                        & !tit:
                                      |   !n:(?.?c)
                                        & ( !c:
                                          | (dd.,fullinoutdescTable$!c)
                                          )
                                      )
                                  . 1
                                  )
                              )
                        )
                      & describe$(.!arg):(?arg.?)
                      & (dl.,!arg)
                  )
                & !arg:?struct
                & SpotInput$!struct:?struct
                & describeLong$!struct:?description
                & (   !description:~
                    &   !struct
                      : ( ? (?.?.?.?o)
                        | (? (?.?.?.?o),?)
                        )
                    & !description
                  |   localized
                    $ ( "It seems that the input already matches your goal. Or we haven't enough information about the input. Use the back button to change your choice."
                        "Det ser ud til at inputtet allerede opfylder dit mål. Eller vi har ikke fundet de nødvendige oplysninger om inputtet. Brug knappen \"Forrige\" for at ændre dine valg."
                      )
                  )
            )
          & translateOneToHumanLanguage$!arg (br.,)
      )
      ( makePasswordFormField
      =   text parm desc size required
        .     !arg
            : ( ?text
              . ?parm
              .   ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (size.?size) ?
                  | ?&:?size
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( !required:
              | (span.(class.required),!required)
              )
              (span.,!text)
              \r\n
              ( input
              .     (tabindex.1+!tabind:?tabind)
                    (type.password)
                    (name.!parm)
                    (value.)
                    (!desc:|(title.!desc))
                    (!size:|(size.!size))
                , 
              )
              \r\n
      )
      ( makeSelectFormField
      =   text parm options desc required
        .     !arg
            : ( ?text
              . ?parm
              .   ? (options.?options) ?
                : ( ? (desc.?desc) ?
                  | ?&:?desc
                  )
                : ( ? (required.?required) ?
                  | ?&:?required
                  )
              )
          &   ( !required:
              | (span.(class.required),!required)
              )
              (span.,!text)
              \r\n
          &   ( label
              .   
                ,   !text
                    ( !required:
                    |   " "
                        ( span
                        .     (class.required)
                              (style."width: auto; line-height: normal;")
                          , !required
                        )
                    )
              )
              \r\n
              ( select
              .     (tabindex.1+!tabind:?tabind)
                    (name.!parm)
                    (!desc:|(title.!desc))
                , \r\n !options
              )
              \r\n
      )
      ( submit
      =   button
        .   !arg:?button
          &   ( input
              .     (type.submit)
                    (tabindex.1+!tabind:?tabind)
                    (name.bsubmit)
                    (value.!button)
                , 
              )
              \r\n
      )
      ( style
      =   ( style
          .   
            ,   \r\n
                ".bodycanvas {background: linear-gradient(rgb(254,254,254), rgba(0,210,255,0.2));background-repeat: no-repeat;}"
                \r\n
                "a, dd, dt, h1, h2, h3, span, p, td, input, legend, textarea {font-family:"
                (   !TyPeFaCe:sans-serif
                  & "sans-serif, Comic Sans MS"
                | "Comic Sans MS, sans-serif"
                )
                ";}"
                \r\n
                "legend {border:none;color:black;background-color:rgba(154,186,206,0.6);text-align:left;display:block;margin:0;padding:10px;float:left;width:100%;position:relative;font-size:15px; }"
                \r\n
                ".required {color:red; font-size:90%;}"
                \r\n
                "/* Tooltip container */"
                \r\n
                ".tooltip {"
                \r\n
                "    position: relative;"
                \r\n
                "    display: inline-block;"
                \r\n
                "    border-bottom: 1px dotted black; /* If you want dots under the hoverable text */"
                \r\n
                "}"
                \r\n\r\n
                "/* Tooltip text */"
                \r\n
                ".tooltip .tooltiptext {"
                \r\n
                "    visibility: hidden;"
                \r\n
                "    width: 330px;"
                \r\n
                "    background-color: #555;"
                \r\n
                "    color: #fff;"
                \r\n
                "    text-align: left;"
                \r\n
                "    padding: 5px 10px;"
                \r\n
                "    border-radius: 6px;"
                \r\n\r\n
                "    /* Position the tooltip text */"
                \r\n
                "    position: absolute;"
                \r\n
                "    z-index: 1;"
                \r\n
                "    bottom: 125%;"
                \r\n
                "    left: 0%;"
                \r\n
                "    margin-left: 0px;"
                \r\n\r\n
                "    /* Fade in tooltip */"
                \r\n
                "    opacity: 0;"
                \r\n
                "    transition: opacity 0.3s;"
                \r\n
                "}"
                \r\n\r\n
                ".tooltip .tooltiptextL {"
                \r\n
                "    visibility: hidden;"
                \r\n
                "    width: 220px;"
                \r\n
                "    background-color: #555;"
                \r\n
                "    color: #fff;"
                \r\n
                "    text-align: left;"
                \r\n
                "    padding: 5px 10px;"
                \r\n
                "    border-radius: 6px;"
                \r\n\r\n
                "    /* Position the tooltip text */"
                \r\n
                "    position: absolute;"
                \r\n
                "    z-index: 1;"
                \r\n
                "    bottom: 125%;"
                \r\n
                "    right: 0%;"
                \r\n
                "    margin-left: 0px;"
                \r\n\r\n
                "    /* Fade in tooltip */"
                \r\n
                "    opacity: 0;"
                \r\n
                "    transition: opacity 0.3s;"
                \r\n
                "}"
                \r\n\r\n
                "/* Tooltip arrow */"
                \r\n
                ".tooltip .tooltiptext::after, .tooltip .tooltiptextL::after {"
                \r\n
                "    position: absolute;"
                \r\n
                "    top: 100%;"
                \r\n
                "    left: 50%;"
                \r\n
                "    margin-left: -5px;"
                \r\n
                "    border-width: 5px;"
                \r\n
                "    border-style: solid;"
                \r\n
                "    border-color: #555 transparent transparent transparent;"
                \r\n
                "}"
                \r\n\r\n
                "/* Show the tooltip text when you mouse over the tooltip container */"
                \r\n
                ".tooltip:hover .tooltiptext,.tooltip:hover .tooltiptextL {"
                \r\n
                "    visibility: visible;"
                \r\n
                "    opacity: 1;"
                \r\n
                "}"
                \r\n
                "#t01 tr:nth-child(2n+0) {"
                \r\n
                "    background-color: #eee;"
                \r\n
                "}"
                \r\n
                "*:target {background: yellow;}"
                \r\n
                ".formRounded input[type=\"submit\"] {"
                \r\n
                "color:#FFFFFF;"
                \r\n
                "background-color:#5d9cec;"
                \r\n
                "border-color:#68A9fb;"
                \r\n
                "text-align:center;"
                \r\n
                "vertical-align:middle;"
                \r\n
                "cursor:pointer;"
                \r\n
                "border:1px solid black;"
                \r\n
                "padding:6px 6px;"
                \r\n
                "font-size:14px;"
                \r\n
                "border-radius:4px;"
                \r\n
                "}"
          )
          \r\n
      )
      ( HTMLbodyContainer
      =     @(!wwwServer:? clarin ?)
          & HTML5bodyContainer
        | log$noClarin&XHTMLbodyContainer
      )
      ( HTML5bodyContainer
      =   
        .   ("!DOCTYPE"." html")
            \r\n
            ( html
            .   
              ,   \r\n
                  ( head
                  .   
                    ,   \r\n
                        (meta.charset.UTF-8)
                        \r\n
                        ( link
                        .     (rel.stylesheet)
                              (type.text/css)
                              (href."/clarindk/css/clarin.css")
                          , 
                        )
                        ( style
                        .   (type.text/css)
                          , " legend {display: inline-block; padding: 0.2em 0.5em; border:1px solid green; color:green; font-size:90%; text-align:left; } .required {color:red; font-size:90%;}"
                        )
                        \r\n
                        ( link
                        .     (rel.stylesheet)
                              (type.text/css)
                              (href."/clarindk/css/colorbox.css")
                              (media.screen)
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/jquery.min.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/jquery-plugins/jquery.validate.min.js"
                              )
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/jquery-plugins/jquery-ui-custom.min.js"
                              )
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/clarin-scripts/menuToggle.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/clarin-scripts/basket.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/clarin-scripts/fulltext.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/jquery-plugins/jquery.colorbox.min.js"
                              )
                          , 
                        )
                        \r\n
                        ( "!--"
                        . "[if lt IE 9]> <script src=\"/clarindk/js/html5.js\" type=\"text/javascript\"></script> <link rel=\"stylesheet\" type=\"text/css\" href=\"/clarindk/css/clarin-ie.css\" /> <![endif]"
                        )
                        \r\n
                        ( "!--"
                        . "[if IE]> <style type=\"text/css\"> .clearfix { zoom: 1; /* triggers hasLayout */ display: block; /* resets display for IE/Win */ } /* Only IE can see inside the conditional comment and read this CSS rule. Don't ever use a normal HTML comment inside the CC or it will close prematurely. Kilde: http://www.positioniseverything.net/easyclearing.html */ </style> <![endif]"
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/clarin-scripts/clarin-deposit.js"
                              )
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/clarin-scripts/clarin-find.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/clarin-scripts/clarin-text-img.scroll.js"
                              )
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              (src."/clarindk/js/clarin-scripts/clarin-tabs.js")
                          , 
                        )
                        \r\n
                        ( script
                        .     (type.text/javascript)
                              ( src
                              . "/clarindk/js/clarin-scripts/colorbox-license.js"
                              )
                          , 
                        )
                        \r\n
                        (title.,!headerTitle)
                        \r\n
                  )
                  \r\n
                  ( body
                  .   
                    ,   \r\n
                        ( section
                        .   (class."header clearfix")
                          ,   \r\n
                              ( header
                              .   
                                ,   \r\n
                                    ( h1
                                    .   
                                      ,   \r\n
                                          ( a
                                          .     (href."/clarindk/forside.jsp")
                                                (rel.)
                                            , "Clarin.dk"
                                          )
                                          \r\n
                                    )
                                    \r\n
                                    ("!--"."LOGIN NAV")
                                    \r\n
                                    ( nav
                                    .   
                                      ,   \r\n
                                          ("!--"." FindQuick ")
                                          \r\n
                                          ( fieldset
                                          .   
                                            ,   \r\n
                                                ( form
                                                .     (name.myform)
                                                      (method.get)
                                                      ( action
                                                      . "/clarindk/item.jsp"
                                                      )
                                                  ,   \r\n
                                                      ( p
                                                      .   
                                                        ,   \r\n
                                                            ( input
                                                            .     (type.text)
                                                                  ( placeholder
                                                                  . "Ressource ID"
                                                                  )
                                                                  (name.id)
                                                              , 
                                                            )
                                                            \r\n
                                                            ( input
                                                            .     ( type
                                                                  . submit
                                                                  )
                                                                  (value.Ok)
                                                              , 
                                                            )
                                                            \r\n
                                                      )
                                                      \r\n
                                                )
                                                \r\n
                                          )
                                          \r\n
                                          ("!--"." FindQuick end ")
                                          \r\n
                                    )
                                    \r\n
                              )
                              \r\n
                        )
                        \r\n
                        ( "!--"
                        . " USER NAV **********************************************************************************************************"
                        )
                        \r\n
                        ( section
                        .   (class."userNavigation clearfix")
                          ,   \r\n
                              ( nav
                              .   (class.clearfix)
                                ,   \r\n
                                    ( a
                                    .   (href."/clarindk/find.jsp")
                                      , Find
                                    )
                                    \r\n
                                    ( a
                                    .   (href."/clarindk/tools.jsp")
                                      , Tools
                                    )
                                    \r\n
                                    ( a
                                    .   (href."/clarindk/deponer.jsp")
                                      , Deposit
                                    )
                                    \r\n
                                    ( a
                                    .     (href."/clarindk/basketList.jsp")
                                          (rel.)
                                          (class."basket basketEmpty")
                                      ,   "Show basket "
                                          (strong.(id.basketSize),0)
                                    )
                                    \r\n
                              )
                              \r\n
                        )
                        \r\n
                        (section.(class.content),!arg)
                        \r\n
                        ("!--"." Piwik ")
                        \r\n
                        ( script
                        .   (type.text/javascript)
                          ,   \r\n
                              "  var _paq = _paq || [];"
                              \r\n
                              "  _paq.push(['trackPageView']);"
                              \r\n
                              "  _paq.push(['enableLinkTracking']);"
                              \r\n
                              "  (function() {"
                              \r\n
                              "    var u=\"//clarin.dk/analytics/\";"
                              \r\n
                              "    _paq.push(['setTrackerUrl', u+'piwik.php']);"
                              \r\n
                              "    _paq.push(['setSiteId', 1]);"
                              \r\n
                              "    var d=document, g=d.createElement('script'), s=d.getElementsByTagName('script')[0];"
                              \r\n
                              "    g.type='text/javascript'; g.async=true; g.defer=true; g.src=u+'piwik.js'; s.parentNode.insertBefore(g,s);"
                              \r\n
                              "  })();"
                              \r\n
                        )
                        \r\n
                        ( noscript
                        .   
                          , ( p
                            .   
                              , ( img
                                .     ( src
                                      . "//clarin.dk/analytics/piwik.php?idsite=1"
                                      )
                                      (style."border:0;")
                                      (alt.)
                                  , 
                                )
                            )
                        )
                        \r\n
                        ("!--"." End Piwik Code ")
                  )
            )
            \r\n
      )
      ( XHTMLbodyContainer
      =   
        .   "iso-8859-1 and not utf-8, because of problematic handling of UTF-8 by JNI
             (Or rather Java, which uses UTF-16 and converts surrogate pairs to 6 bytes of UTF-8 !)"
          &   ("?"."xml version=\"1.0\" encoding=\"iso-8859-1\"")
              \r\n
              ( "!DOCTYPE"
              . " html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\""
              )
              \r\n
              ( html
              .     (xmlns."http://www.w3.org/1999/xhtml")
                    ("xml:lang".da)
                    (lang.da)
                ,   \r\n
                    ( head
                    . ,\r\n (title.,!headerTitle) \r\n !style
                    )
                    \r\n
                    (body.(class.bodycanvas),!arg)
              )
              \r\n
      )
      ( refreshingXHTMLbodyContainer
      =   seconds body URL
        .   !arg:(%?seconds ?URL.?body)
          &   ("?"."xml version=\"1.0\" encoding=\"iso-8859-1\"")
              \r\n
              ( "!DOCTYPE"
              . " html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\""
              )
              \r\n
              ( html
              .     (xmlns."http://www.w3.org/1999/xhtml")
                    ("xml:lang".da)
                    (lang.da)
                ,   \r\n
                    ( head
                    .   
                      ,   \r\n
                          (title.,!headerTitle)
                          \r\n
                          ( meta
                          .     (http-equiv.refresh)
                                ( content
                                .   str
                                  $ ( !seconds
                                      (!URL:|"; " !URL)
                                    )
                                )
                            , 
                          )
                          \r\n
                          !style
                    )
                    \r\n
                    (body.(class.bodycanvas),!body)
              )
              \r\n
      )
      ( atts
      =   name value
        .     !arg:(?name,?value) ?arg
            & (!name.!value) atts$!arg
          | 
      )
      ( Table
      =   attributes heading content
        .   !arg:(?attributes.?heading.?content)
          &   ( table
              .   atts$!attributes
                , (thead.,!heading) \r\n (tbody.,!content)
              )
              \r\n
      )
      (row=.(tr.,!arg) \r\n)
      (cell=.td.,!arg)
      ( xml-id
      =   car cdr
        .   str
          $ ( ( @(!arg:%@?car ?cdr)
              &   str
                $ ( (!car:!NCNameStartChar|A !car)
                      vap
                    $ ( (=.!arg:!NCName|"_")
                      . !cdr
                      )
                  )
              )
              !tabind
            )
      )
      ( makeOptionList
      =     table aBbR full selected prefix startchar
          , name stable
        .     !arg
            : ( ?table
              .   (?selected.?prefix)
                | ?selected&:?prefix
              )
          &     map
              $ ( ( 
                  =   f a
                    .   !arg:(?f.(?a.?)|?a)
                      & (low$(localized$!f:?f).!f.!a)
                  )
                . !table
                )
            : ?stable
          & ( !stable:? [<5
            | sort$!stable:?stable
            )
          &   ( option
              .   (id.str$(b !tabind)) (value.)
                , chu$8239
              )
              \r\n
                map
              $ ( ( 
                  =   
                    .   !arg:(?.?full.?aBbR)
                      &   ( option
                          .     (id.xml-id$!aBbR)
                                (value.str$(!prefix !aBbR))
                                (   !selected:!aBbR
                                  & (selected.selected)
                                | 
                                )
                            , !full
                          )
                          \r\n
                  )
                . !stable
                )
      )
      ( listToThreeColumnTable
      = .map$((=.low$!arg.!arg.xml-id$!arg).!arg)
      )
      ( makeOptionListSimple
      =   idval full name stable prefix
        .   !arg:(?stable.?prefix)
          & ( !stable:? [<5
            | sort$!stable:?stable
            )
          & log$(stable !stable)
          &   ( option
              .   (id.str$(b !tabind)) (value.)
                , chu$8239
              )
              \r\n
                map
              $ ( ( 
                  =   
                    .   !arg:(?.?full.?idval)
                      &   ( option
                          . (id.!idval) (value.!full),!full
                          )
                          \r\n
                  )
                . !stable
                )
      )
      "
/**
 * uploadJobNr
 * 
 * Return the string preceding the hyphen in the input.
 *
 * Input: <jobNr>-<jobID>
 *
 * Called from upload.java
 */"
      ( uploadJobNr
      =   jobID jobNr
        .   "analyze the job parameter. It tells to which job the sent file belongs."
          & !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
          & !jobNr
      )
      ( uploadJobID
      =   jobID jobNr
        .   "analyze the job parameter. It tells to which job the sent file belongs."
          & !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
          & !jobID
      )
      "
/**
 * upload
 *
 * Make a waiting job non-waiting upon receipt of a result from an 
 * asynchronous tool.
 *
 * Analyze the job parameter. It tells to which job the sent file belongs.
 * The jobs table knows the file name and location for the uploaded file.
 *              (Last field)
 * Input:
 *      List of HTTP request parameters.
 *      One of the parameters must be (job.<jobNr>-<jobID>)
 *
 * Output:
 *      The file name that must be given to the received file when saved in
 *      the staging area.
 *
 * Status codes:
 *      200     ok
 *      400     'job' parameter does not contain hyphen '-' or
 *              'job' parameter missing altogether.
 *      404     Job is not expecting a result (job is not waiting)
 *              Job is unknown
 *      500     Job list could not be read
 *
 * Affected tables:
 *      jobs.table
 *
 * Called from upload.java
 */"
      ( upload
      =     jobNr jobID jobstatus JOB
          , A Z files toolURL parms file
        .     log$(upload !arg)
            & !arg:? (job.@(?:?jobNr "-" ?jobID)) ?
            & (   readTable$jobs
                & (     !jobs
                      :   ?A
                          ( !jobNr
                          . !jobID ?jobstatus
                          . ?files
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                          ?Z
                    & (     !jobstatus
                          : (waiting|starting)
                        &     !A
                              ( !jobNr
                              . !jobID done
                              . !files
                              . !toolURL
                              . !parms
                              . !file
                              )
                              !Z
                          : ?jobs
                        & saveTable$jobs
                        & !file
                      |   str
                        $ ( "HTTP-status-code404upload$("
                            !arg
                            ") failed. Job "
                            !jobNr
                            "-"
                            !jobID
                            " is not expecting a result. Its current status is '"
                            !jobstatus
                            "'."
                          )
                      )
                  |   str
                    $ ( "HTTP-status-code404upload$("
                        !arg
                        ") failed. Job "
                        !jobNr
                        "-"
                        !jobID
                        " not found in joblist."
                      )
                  )
              |   str
                $ ( "HTTP-status-code500upload$("
                    !arg
                    ") failed. Joblist could not be read"
                  )
              )
          |   str
            $ ( "HTTP-status-code400upload$("
                !arg
                ") failed. "
                (   !arg:? (job.?JOB) ?
                  & ( @(!JOB:% "-" %)
                    | "'job' parameter value must contain a hyphen '-'. "
                    )
                | "'job' parameter missing. "
                )
              )
      )
      "
/**
 * parseStatusCode
 *
 * Find the number greater than 100 immediately following the string 
 * 'HTTP-status-code'
 *
 * Called from upload.java
 */"
      ( parseStatusCode
      =   
        .   @(!arg:HTTP-status-code (#>100:?arg) ?)
          & !arg
      )
      "
/**
 * parsemessage
 *
 * Find the text following the number greater than 100 immediately following the string 
 * 'HTTP-status-code'
 *
 * Called from upload.java
 */"
      ( parsemessage
      = .@(!arg:HTTP-status-code #>100 ?arg)&!arg
      )
      ( getShort
      =   feat full ABBR table
        .   !arg:(?feat.?full)
          & (     !features
                :   ?
                  + ( ? (short.!feat) ?
                    : ? (table.?table) ?
                    )
                  + ?
              & readTable$!table
              & !!table:? (? !full ?.?ABBR.?) ?
              & !ABBR
            | !full
            )
      )
      ( itemFeats
      =   feats
        .   !Uploads:? (?.!arg.?.?.?feats) ?
          & !feats
      )
      ( pickTool
      =     toolShort pairs Items fmt spec item formats nitems
          , sufficient
          , toolFull
        .   readTable$toolprop
          & readTable$tooladm
          & :?pairs
          & !arg:(?arg.?Items)
          & :?formats
          & 0:?nitems
          & (   !Items
              :   ?
                  ( Item&1+!nitems:?nitems
                  .   ( ? (format.%?fmt^?spec) ?
                      |   ?item
                        &   itemFeats$!item
                          : ? (format.%?fmt^?spec) ?
                      )
                    & ( !formats:? !fmt^!spec ?
                      | !formats !fmt^!spec:?formats
                      )
                    & ~
                  )
                  ?
            | 
            )
          & ( sufficient
            =   max n
              .     0:?max:?n
                  &   !sjt
                    :   ?
                        ( ?
                        ,   ?
                          + (     ?
                                + (   ?
                                    * ( (%@|%@^%)
                                      & 1+!n:?n
                                      )
                                    * (1|?&~)
                                  & ( !n:>!max:?max
                                    | 
                                    )
                                  & 0:?n
                                  & ~
                                  )
                                + ?
                                ?
                            . ?
                            )
                          + ?
                        )
                        ?
                | !arg:~<!max&?
            )
          & (   !toolprop
              :   ?
                + ( ( ?toolShort
                    .   sufficient$!nitems
                      :   ?
                          ( format
                          ,   ?
                            + ( ?+(!fmt^!spec|!fmt)+? ?
                              . ?
                              )
                            + ?
                          )
                          ?
                    )
                  & ( !pairs:? (?.!toolShort) ?
                    |   ToolTitle$!toolShort:?toolFull
                      & (!toolFull.!toolShort) !pairs:?pairs
                    )
                  & ~
                  )
                + ?
            | 
            )
          &   makeSelectFormField
            $ (Tool.TOOL.options.makeOptionList$(!pairs.))
      )
      ( makeHiddenFields
      =   ret par val
        .   :?ret
          &   whl
            ' ( !arg:(?par.?globval) ?arg
              & @(lst$(globval,MEM,LIN):"globval=" ?val ";\n")
              &     !ret
                    ( input
                    .     (type.hidden)
                          (name.!par)
                          (value.!val)
                      , 
                    )
                : ?ret
              )
          & !ret
      )
      ( makeHiddenFields
      =   ret par val
        .   :?ret
          &   whl
            ' ( !arg:(?par.?val) ?arg
              &     !ret
                    ( input
                    .     (type.hidden)
                          (name.!par)
                          (value.str$!val)
                      , 
                    )
                : ?ret
              )
          & !ret
      )
      ( percentEncode
      =   c
        .     @(!arg:%@?c ?arg)
            & "%" d2x$(asc$!c) percentEncode$!arg
          | 
      )
      ( queryEncode
      =   
        .   str
          $ ( vap
            $ ( ( 
                =   
                  .   !arg:" "&"+"
                    |   !arg
                      : ( ~<a:~>z
                        | ~<A:~>Z
                        | ~<0:~>9
                        | "-"
                        | "_"
                        | "."
                        | "~"
                        )
                    | str$(percentEncode$!arg)
                )
              . !arg
              )
            )
      )
      ( helplink
      =   usedonly linktext offset title
        .   ( !arg:? (usedonly.?usedonly) ?
            | y:?usedonly
            )
          & ( !arg:? (linktext.?linktext) ?
            | help hjælp:?linktext
            )
          & ( !arg:? (offset.?offset) ?
            | :?offset
            )
          & ( !arg:? (title.?title) ?
            | :?title
            )
          & ( a
            .     ( href
                  .   str
                    $ ( "help?UIlanguage="
                        !LaNg
                        "&usedonly="
                        !usedonly
                        "&TyPeFaCe="
                        queryEncode$!TyPeFaCe
                        (!offset:|"#" !offset)
                      )
                  )
                  (!title:|(title.!title))
              , localized$!linktext
            )
      )
      "
/**
 * update
 *
 * Create an HTML form that allows a user to choose a tool from a pick list.
 * The user must also fill out a password.
 *
 * The input can either be an empty string or two fields: a message to be 
 * displayed above the form and the name of a tool, which will then be 
 * selected when the browser shows the pick list.
 *
 * Called from update.java
 */"
      ( update
      =     L ToolID Title msg selected
          , contactEmail handle
          , passwordAsHandle
        .     0:?tabind
            & readTable$tooladm
            &   
              : ?msg
              : ?selected
              : ?contactEmail
              : ?handle
            & (!arg:? (msg.?msg) ?|)
            & ( !arg:? (selected.?selected) ?
              | 
              )
            & 
            & (   !arg
                : ? (passwordAsHandle.?passwordAsHandle) ?
              | (.):?passwordAsHandle
              )
            & ( !arg:? (contactEmail.?contactEmail) ?
              | 
              )
            & (!arg:? (handle.?handle) ?|)
            & :?L
            &   !tooladm
              :   ?
                + (   ? (ToolID.?ToolID) ?
                    : ? (Title.?Title) ?
                  & !L (!Title.!ToolID):?L
                  )
                + 0
            &   toML
              $ ( !HTMLbodyContainer
                $ ( (!msg:|paragraph$!msg)
                      form
                    $ ( register
                      .     paragraph
                          $ ( makeSelectFormField
                            $ (   localized
                                $ ("Choose a tool" "Vælg et værktøj")
                              . name
                              .   (options.makeOptionList$(!L.!selected))
                                  (required."*")
                              )
                            )
                            paragraph
                          $ ( makePasswordFormField
                            $ (   localized
                                $ ( "Password (If you are not owner)"
                                    "Adgangskode (Hvis du ikke er \"ejer\")"
                                  )
                              . password
                              . desc
                              .   localized
                                $ ( "Use this field if you don't own the tool and the owner has given you the password. When you update the tool metadata, you become the new owner of the tool."
                                    "Brug feltet hvis du ikke er ejer af værktøjet og du har fået adgangskoden fra ejeren. Når du opdaterer værktøjsoplysningerne bliver du automatisk den nye ejer af værktøjet."
                                  )
                              )
                            )
                          submit$next
                          helplink$(usedonly.n)
                            makeHiddenFields
                          $ ( (   !passwordAsHandle:(.)
                                & 
                              | (passwordAsHandle.!passwordAsHandle)
                              )
                              ( !contactEmail:
                              | (contactEmail.!contactEmail)
                              )
                              ( !handle:
                              | (handle.!handle)
                              )
                            )
                      . POST
                      )
                  )
                )
          | 
      )
      ( denumerizeSum
      =   A M Z
        .     whl
            ' ( !arg:(?A+#%*?M+?Z|?A+?M^#%+?Z)
              & !A+!M+!Z:?arg
              )
          & !arg
      )
      ( removeNumFactors
      =   A M Z
        .     whl
            ' ( !arg:?A+#%*?M+?Z
              & !A+!M+!Z:?arg
              )
          & !arg
      )
      ( sort
      =   S L e f
        .   :?L
          &   whl
            ' ( !arg:%?e ?arg
              & (!e.) !L:?L
              )
          &   whl
            ' ( :?S
              &   whl
                ' (!L:%?e %?f ?L&!e+!f !S:?S)
              & !L !S:% %:?L
              )
          & :?L
          & whl'(!S:(?e.)+?S&!e !L:?L)
          & :?S
          & whl'(!L:%?e ?L&!e !S:?S)
          & !S
      )
      "
/*
 * wrapper
 *
 * Generate a web service wrapper from tool metadata.
 * Usage: wrapper$(PHP.<toolID>)
 * (Other languages may be supported in the future.)
 */"
      ( wrapper
      =     combineFeats combineToolIncarnations getBoilerPlate
          , getFeatName getFeatSpecTable getFeatTable listAlts
          , makeName DATA DATATEXT FEATURES FEATURETEXT Features
          , IO Iopt Oopt STYLES STYLETEXT basejobpost2 boilerPlate
          , boolfunc boolvar data declarations ech featname fname
          , fname1 fname2 fval helperFunctions httpparm iolist
          , lastWord mainfunc name o sptable stringfunc stringvar
          , toolParameters toolParmTests toolprop value values var
          , voidfunc i tooladm features svalues
          , getFeatValues toolid output TUPTUO reverselist
          , annotationStyles basistextStyles facets fileFormats
          , flatFileTypes imageStyles linguae presentations sndStyles
          , tagSets textStyles tokenisationStyles
        .     !arg
            : ( (?arg.?toolid)
              | ?&:?toolid
              )
          & :?TUPTUO
          & (output=.str$!arg !TUPTUO:?TUPTUO)
          & ( reverselist
            =   L E
              .   :?L
                &   whl
                  ' (!arg:%?E ?arg&!E !L:?L)
                & str$!L
            )
          & (   !arg:PHP
              &   "function "
                : ?stringfunc
                : ?boolfunc
                : ?voidfunc
              & "$":?stringvar:?boolvar:?var
              &     "<?php
header(\"Content-type:text/plain; charset=UTF-8\");
/*
 * This "
                    !arg
                    " script is generated by CLARIN-DK's tool registration form 
 * (http://localhost/texton/register). It should, with no or few adaptations
 * work out of the box as a dummy for your web service. The output returned
 * to the CLARIN-DK workflow manager is just a listing of the HTTP parameters
 * received by this web service from the CLARIN-DK workflow manager, and not
 * the output proper. For that you have to add your code to this script and
 * deactivate the dummy functionality. (The comments near the end of this
 * script explain how that is done.)
 *
 * Places in this script that require your attention are marked 'TODO'.
 */
"
                : ?boilerPlate
              &   "    }
catch (SystemExit $e) 
    { 
    header('HTTP/1.0 404 An error occurred: ' . $ERROR);
    logit('An error occurred' . $ERROR);
    echo $ERROR;
    }
?>
"
                : ?lastWord
            |   !arg:java
              & "public String ":?stringfunc
              & "public bool ":?boolfunc
              & "public void ":?voidfunc
              & "String ":?stringvar
              & "bool ":?boolvar
              & :?var
              & :?boilerPlate:?lastWord
            )
          & ( listAlts
            =     alt featF opts rsr rsrc stl style alts
                , term Single
              .   !arg:(?alts.?IO.?featname)
                &   whl
                  ' ( !alts:(%(%?alt ?opts):?term)+?alts
                    &   (   :!(glf$('($term.?))) ?
                          & 
                        | on
                        )
                      : ?Single
                    & (   !Single:
                        & (   !alt:%*%
                            & ( featF
                              = (!IO.!featname.!rsr.F)+!DATA:?DATA
                              )
                          |   !opts:% ?
                            & ( featF
                              = (!IO.!featname.!rsr.F)+!DATA:?DATA
                              )
                          )
                      | (featF=)
                      )
                    &   whl
                      ' ( !alt:%?rsrc*?alt
                        & (   !rsrc:?rsr^%?style
                            &   whl
                              ' ( !style:%?stl+?style
                                &   (!IO.!featname.!rsr)\L!stl+!STYLES
                                  : ?STYLES
                                )
                          | !rsrc:?rsr
                          )
                        & (!IO.!featname)\L!rsr+!FEATURES:?FEATURES
                        & !featF
                        )
                    & ( !Single:on
                      |   whl
                        ' ( !opts:%?rsrc ?opts
                          & (   !rsrc:?rsr^%?style
                              &   whl
                                ' ( !style:%?stl+?style
                                  &   (!IO.!featname.!rsr)\L!stl+!STYLES
                                    : ?STYLES
                                  )
                            | !rsrc:?rsr
                            )
                          & (!IO.!featname)\L!rsr+!FEATURES:?FEATURES
                          & (!IO.!featname.!rsr.F)+!DATA:?DATA
                          )
                      )
                    )
                & 
            )
          & ( makeName
            =   name camel c
              .   :?name
                & (camel=.!arg)
                &   whl
                  ' ( @(!arg:%?c ?arg)
                    &     (     !c
                              : ( ~<0:~>9
                                | "_"
                                | ~<a:~>z
                                | ~<A:~>Z
                                )
                            & camel$!c:?c
                            & (camel=.!arg)
                            & !c
                          | (camel=.upp$!arg)&
                          )
                          !name
                      : ?name
                    )
                & rev$(str$!name)
            )
          & readTable$toolprop
          & readTable$tooladm
          & readTable$fileFormats
          & readTable$facets
          & readTable$presentations
          & readTable$linguae
          & readTable$features
          & readTable$periods
          & readTable$tagSets
          & ( getBoilerPlate
            =   id field val
              .   !arg:(?id.?field)
                &   !tooladm
                  :   ?
                    + ( ? (ToolID.!id) ?
                      : ? (!field.?val) ?
                      )
                    + ?
                & !val
            )
          & ( getFeatName
            =   fname
              .     !features
                  :   ?
                    + ( ? (short.!arg) ?
                      : ? (name.?fname) ?
                      )
                    + ?
                & localized$!fname
            )
          & ( getFeatTable
            =   table
              .     !features
                  :   ?
                    + ( ? (short.!arg) ?
                      : ? (table.?table) ?
                      )
                    + ?
                & !table
            )
          & ( getFeatValues
            =   featname value fval fvalAlt
              .   !arg:(?featname.?value)
                &   !(getFeatTable$!featname)
                  : ? (%?fval ? @?fvalAlt.!value.?) ?
                & !fval (!fvalAlt:|" (" !fvalAlt ")")
            )
          & ( getFeatSpecTable
            =   table val
              .   !arg:(?arg.?val)
                &   !features
                  :   ?
                    + ( ? (short.!arg) ?
                      :   ?
                          ( specificationTable
                          . ? (? !val ?.?table) ?
                          )
                          ?
                      )
                    + ?
                & !table
            )
          & ( combineFeats
            =   A B M Z b c
              .     whl
                  ' ( !arg:?A (?B,?b) ?M (!B,?c) ?Z
                    & !A (!B,!b+!c) !M !Z:?arg
                    )
                & !arg
            )
          & ( combineToolIncarnations
            =   A Z name featK featL Tools feats
              .     whl
                  ' ( !arg:?A+(?name.?featK)+(!name.?featL)+?Z
                    & !A+(!name.!featK !featL)+!Z:?arg
                    )
                & 0:?Tools
                &   whl
                  ' ( !arg:(?name.?feats)+?arg
                    & !Tools+(!name.combineFeats$!feats):?Tools
                    )
                & !Tools
            )
          & combineToolIncarnations$!toolprop:?toolprop
          &   whl
            ' ( !toolprop:(?name.?Features)+?toolprop
              & (   !toolid:(|!name)
                  & (     !Features
                        :   ?
                            (?fname1,?+#*(?+(%?*%? ?)+?.?)+?)
                            ?
                            (?fname2,?+#*(?+(%?*%? ?)+?.?)+?)
                            ?
                      &   log
                        $ ( str
                          $ ( "Tool "
                              !name
                              ": inputs differ on two features: "
                              !fname1
                              " and "
                              !fname2
                              ". This is currently not supported."
                            )
                          )
                    |     !Features
                        :   ?
                            (?fname1,?+#*(?.?+(%*% ?)+?)+?)
                            ?
                            (?fname2,?+#*(?.?+(%*% ?)+?)+?)
                            ?
                      &   log
                        $ ( str
                          $ ( "Tool "
                              !name
                              ": outputs differ on two features: "
                              !fname1
                              " and "
                              !fname2
                              ". This is currently not supported."
                            )
                          )
                    | 
                    )
                  & :?Iopt:?Oopt
                  & 0:?DATA
                  & 0:?FEATURES
                  & 0:?STYLES
                  & (     !Features
                        :   ?
                            ( ?
                            ,   ?
                              + (   %*% ?:?in
                                  & ~(:!(glf$('($in.?))) ?)
                                . ?
                                )
                              + ?
                            )
                            ?
                      & "All inputs combined in one file, so IF."
                      & (I...F)+!DATA:?DATA
                    |     !Features
                        : (   ?
                              (?,?+#*(?+(%*% ?)+?.?)+?:?fval)
                              ?
                          |   ?
                              (?,?+#*(?+(% %)+?.?)+?:?fval)
                              ?
                          )
                      & (   !fval:?+#*(?+%@^?+?.?)+?
                          & "IF in some cases, IfeatvalF in other cases"
                          & " (1/2)":?Iopt
                          & (I...F)+!DATA:?DATA
                        | "Never IF, always IfeatvalF"
                        )
                    |   "Always IF, never IfeatvalF"
                      & (I...F)+!DATA:?DATA
                    )
                  & (     !Features
                        : (   ?
                              (?,?+#*(?.?+(%*% ?)+?)+?:?fval)
                              ?
                          |   ?
                              (?,?+#*(?.?+(% %)+?)+?:?fval)
                              ?
                          )
                      & (   !fval:?+#*(?.?+%@^?+?)+?
                          & "OF in some cases, OfeatvalF in other cases"
                          & " (1/2)":?Oopt
                          & (O...F)+!DATA:?DATA
                        | "Never OF, always OfeatvalF"
                        )
                    |   "Always OF, never OfeatvalF"
                      & (O...F)+!DATA:?DATA
                    )
                  &   whl
                    ' ( !Features:(?fname,?iolist) ?Features
                      &   whl
                        ' ( !iolist:#*(?i.?o)+?iolist
                          & listAlts$(!i.I.!fname)
                          & listAlts$(!o.O.!fname)
                          )
                      )
                  &     "/*
ToolID         : "
                        !name
                        "
PassWord       : "
                        getBoilerPlate$(!name.PassWord)
                        "
Version        : "
                        getBoilerPlate$(!name.Version)
                        "
Title          : "
                        getBoilerPlate$(!name.Title)
                        "
Path in URL    : "
                          ( 
                          =   path
                            .   @( str$(getBoilerPlate$(!arg.ServiceURL))
                                 : ? "://" ? "/" ?path
                                 )
                              & !path
                          )
                        $ !name
                        \t
                        "*** TODO make sure your web service listens on this path and that this script is readable for the webserver. ***
Publisher      : "
                        getBoilerPlate$(!name.Publisher)
                        "
ContentProvider: "
                        getBoilerPlate$(!name.ContentProvider)
                        "
Creator        : "
                        getBoilerPlate$(!name.Creator)
                        "
InfoAbout      : "
                        getBoilerPlate$(!name.InfoAbout)
                        "
Description    : "
                        getBoilerPlate$(!name.Description)
                        "
ExternalURI    : "
                        getBoilerPlate$(!name.ExternalURI)
                        "
XMLparms       : "
                        getBoilerPlate$(!name.XMLparms)
                        "
PostData       : "
                        getBoilerPlate$(!name.PostData)
                        "
Inactive       : "
                        getBoilerPlate$(!name.Inactive)
                        "
*/

/*******************
* helper functions *
*******************/
$toollog = '../log/"
                        makeName$!name
                        ".log'; /* Used by the logit() function. TODO make sure the folder exists and is writable. Adapt if needed */
                
/*  TODO Set $dodelete to false if temporary files in /tmp should not be deleted before returning. */
$dodelete = true;
$tobedeleted = array();


function loginit()  /* Wipes the contents of the log file! TODO Change this behaviour if needed. */
    {
    global $toollog,$ftemp;
    $ftemp = fopen($toollog,'w');
    if($ftemp)
        {
        fwrite($ftemp,$toollog . \"\\n\");
        fclose($ftemp);
        }
    }
    
function logit($str) /* TODO You can use this function to write strings to the log file. */
    {
    global $toollog,$ftemp;
    $ftemp = fopen($toollog,'a');
    if($ftemp)
        {
        fwrite($ftemp,$str . \"\\n\");
        fclose($ftemp);
        }
    }
    
class SystemExit extends Exception {}
try {
    "
                        !boolfunc
                        "hasArgument ("
                        !stringvar
                        "parameterName)
        {
        return isset($_REQUEST[\""
                        !stringvar
                        "parameterName\"]);
        }

    "
                        !stringfunc
                        "getArgument ("
                        !stringvar
                        "parameterName)
        {
        return isset($_REQUEST[\""
                        !stringvar
                        "parameterName\"]) ? $_REQUEST[\""
                        !stringvar
                        "parameterName\"] : \"\";
        }

    "
                        !boolfunc
                        "existsArgumentWithValue ("
                        !stringvar
                        "parameterName, "
                        !stringvar
                        "parameterValue)
        {
        /* Check whether there is an argument <parameterName> that has value 
           <parameterValue>. 
           There may be any number of arguments with name <parameterName> !
        */
        $query  = explode('&', $_SERVER['QUERY_STRING']);

        foreach( $query as $param )
            {
            list($name, $value) = explode('=', $param);
            if("
                        !stringvar
                        "parameterName == urldecode($name) && "
                        !stringvar
                        "parameterValue == urldecode($value))
                return true;
            }
        return false;
        }

    function tempFileName($suff) /* TODO Use this to create temporary files, if needed. */
        {
        global $dodelete;
        global $tobedeleted;
        $tmpno = tempnam('/tmp', $suff);
        if($dodelete)
            $tobedeleted[$tmpno] = true;
        return $tmpno;
        }
        
    function requestFile($requestParm) // e.g. \"IfacettokF\"
        {
        logit(\"requestFile({$requestParm})\");

        if(isset($_REQUEST[$requestParm]))
            {
            $urlbase = isset($_REQUEST[\"base\"]) ? $_REQUEST[\"base\"] : \"http://localhost/toolsdata/\";

            $item = $_REQUEST[$requestParm];
            $url = $urlbase . urlencode($item);
            logit(\"requestParm:$requestParm\");
            logit(\"urlbase:$urlbase\");
            logit(\"item:$item\");
            logit(\"url[$url]\");

            $handle = fopen($url, \"r\");
            if($handle == false)
                {
                logit(\"Cannot open url[$url]\");
                return \"\";
                }
            else
                {
                $tempfilename = tempFileName(\""
                        makeName$!name
                        "_{$requestParm}_\");
                $temp_fh = fopen($tempfilename, 'w');
                if($temp_fh == false)
                    {
                    fclose($handle);
                    logit(\"handle closed. Cannot open $tempfilename\");
                    return \"\";
                    }
                else
                    {
                    while (!feof($handle)) 
                        {
                        $read = fread($handle, 8192);
                        fwrite($temp_fh, $read);    
                        }
                    fclose($temp_fh);
                    fclose($handle);
                    return $tempfilename;
                    }
                }
            }
        logit(\"empty\");
        return \"\";
        }    
"
                    : ?helperFunctions
                  &     "
/***************
* declarations *
***************/

/*
 * TODO Use the variables defined below to configure your tool for the right 
 * input files and the right settings.
 * The input files are local files that your tool can open and close like any
 * other file.
 * If your tool needs to create temporary files, use the tempFileName() 
 * function. It can mark the temporary files for deletion when the webservice
 * is done. (See the global dodelete variable.)
 */
        "
                        !stringvar
                        "base = \"\";"
                        \t
                        "/* URL from where this web service downloads input. The generated script takes care of that, so you can ignore this variable. */
        "
                        !stringvar
                        "job = \"\";"
                        \t
                        "/* Only used if this web service returns 201 and POSTs result later. In that case the uploaded file must have the name of the job. */
        "
                        !stringvar
                        "post2 = \"\";"
                        \t
                        "/* Only used if this web service returns 201 and POSTs result later. In that case the uploaded file must be posted to this URL. */
        "
                        !stringvar
                        "echos = \"\";"
                        \t
                        "/* List arguments and their actual values. For sanity check of this generated script. All references to this variable can be removed once your web service is working as intended. */
"
                    : ?declarations
                  & :?toolParmTests
                  &     "
        if( hasArgument(\"base\") )
            {
            "
                        !var
                        "base = getArgument(\"base\");
            }
        if( hasArgument(\"job\") )
            {
            "
                        !var
                        "job = getArgument(\"job\");
            }
        if( hasArgument(\"post2\") )
            {
            "
                        !var
                        "post2 = getArgument(\"post2\");
            }
        "
                        !var
                        "echos = \"base=$base job=$job post2=$post2 \";
"
                    : ?basejobpost2
                  & "
/*********
* input  *
*********/
":?DATATEXT
                  &   whl
                    ' ( !DATA:#*(?IO.?featname.?value.F)+?DATA
                      & "Restriction: There is exactly one output file."
                      &     (!featname:|I)
                            !featname
                            !value
                            F
                        : ?httpparm
                      & (   !IO:I
                          &     !declarations
                                "        "
                                !stringvar
                                !httpparm
                                " = \"\";"
                                \t
                                "/* "
                                ( Input
                                  (   !featname:
                                    & " (ONLY used if there is exactly ONE input to this workflow step)"
                                  |   " with "
                                      low$(getFeatName$!featname)
                                      " "
                                      getFeatValues$(!featname.!value)
                                  )
                                )
                                " */\n"
                            : ?declarations
                          &   !toolParameters ", " !stringvar !httpparm
                            : ?toolParameters
                          &     !DATATEXT
                                "        if( hasArgument(\""
                                !httpparm
                                "\") )
            {        
            "
                                !var
                                !httpparm
                                " = requestFile(\""
                                !httpparm
                                "\");
            if("
                                !var
                                !httpparm
                                " == '')
                {
                header(\"HTTP/1.0 404 Input "
                                ( !featname:
                                |   "with "
                                    low$(getFeatName$!featname)
                                    " '"
                                    getFeatValues$(!featname.!value)
                                    "' "
                                )
                                "not found ("
                                !httpparm
                                " parameter). \");
                return;
                }
            "
                                !var
                                "echos = "
                                !var
                                "echos . \""
                                !httpparm
                                "="
                                !var
                                !httpparm
                                " \";
            }
"
                            : ?DATATEXT
                        | 
                        )
                      )
                  &   "
/************************
* input/output features *
************************/
"
                    : ?FEATURETEXT
                  &   whl
                    ' ( !FEATURES:#*(?IO.?data)\L?svalues+?FEATURES
                      & ( 
                        |     !declarations
                              "    "
                              !stringvar
                              !IO
                              !data
                              " = \"\";\n"
                          : ?declarations
                        )
                      &     !FEATURETEXT
                            "        if( hasArgument(\""
                            !IO
                            !data
                            "\") )
            {
"
                        : ?FEATURETEXT
                      & :?ech
                      &   whl
                        ' ( !svalues:%?values+?svalues
                          &   whl
                            ' ( !values:%@?value^?*?values
                              &     !declarations
                                    "        "
                                    !stringvar
                                    !IO
                                    !data
                                    !value
                                    " = false;"
                                    \t
                                    "/* "
                                    ( getFeatName$!data
                                      " in "
                                      ( !IO:I&input
                                      | output
                                      )
                                      " is "
                                      getFeatValues$(!data.!value)
                                    )
                                    " if true */
"
                                : ?declarations
                              &     !ech
                                    " . \""
                                    !IO
                                    !data
                                    !value
                                    "="
                                    !var
                                    !IO
                                    !data
                                    !value
                                    " \""
                                : ?ech
                              &     !FEATURETEXT
                                    "            "
                                    !var
                                    !IO
                                    !data
                                    !value
                                    " = existsArgumentWithValue(\""
                                    !IO
                                    !data
                                    "\", \""
                                    !value
                                    "\");\n"
                                : ?FEATURETEXT
                              )
                          )
                      &     !FEATURETEXT
                            "            "
                            !var
                            "echos = "
                            !var
                            echos
                            !ech
                            ";
            }
"
                        : ?FEATURETEXT
                      )
                  &   "
/*******************************
* input/output features styles *
*******************************/
"
                    : ?STYLETEXT
                  &   whl
                    ' (   !STYLES
                        : #*(?IO.?featname.?data)\L?svalues+?STYLES
                      & ( 
                        |     !declarations
                              "        "
                              !stringvar
                              !IO
                              !featname
                              !data
                              " = \"\";\n"
                          : ?declarations
                        )
                      &     !STYLETEXT
                            "        if( hasArgument(\""
                            !IO
                            !featname
                            !data
                            "\") )
            {
"
                        : ?STYLETEXT
                      & :?ech
                      &   whl
                        ' ( !svalues:%?values+?svalues
                          &   whl
                            ' ( !values:%@?value^?*?values
                              &     !declarations
                                    "        "
                                    !stringvar
                                    !IO
                                    !featname
                                    !data
                                    !value
                                    " = false;"
                                    \t
                                    "/* Style of "
                                    low$(getFeatName$!featname)
                                    " "
                                    getFeatValues$(!featname.!data)
                                    " in "
                                    ( !IO:I&input
                                    | output
                                    )
                                    " is "
                                    (   getFeatSpecTable$(!featname.!data)
                                      : ?sptable
                                    &   ( !!sptable
                                        |   readTable$!sptable
                                          & !!sptable
                                        )
                                      : ? (?fval.!value.?) ?
                                    & !fval
                                    )
                                    " if true */
"
                                : ?declarations
                              &     !ech
                                    " . \""
                                    !IO
                                    !featname
                                    !data
                                    !value
                                    "="
                                    !var
                                    !IO
                                    !featname
                                    !data
                                    !value
                                    " \""
                                : ?ech
                              &     !STYLETEXT
                                    "            "
                                    !stringvar
                                    !IO
                                    !featname
                                    !data
                                    !value
                                    " = existsArgumentWithValue(\""
                                    !IO
                                    !featname
                                    !data
                                    "\", \""
                                    !value
                                    "\");\n"
                                : ?STYLETEXT
                              )
                          )
                      &     !STYLETEXT
                            "            "
                            !var
                            "echos = "
                            !var
                            echos
                            !ech
                            ";
            }
"
                        : ?STYLETEXT
                      )
                  &   output
                    $ ( !boilerPlate
                        !helperFunctions
                        "\n    "
                        !voidfunc
                        (str$("do_" makeName$!name):?mainfunc)
                        "()
        {
        global $dodelete;
        global $tobedeleted;"
                        !declarations
                        !basejobpost2
                        !DATATEXT
                        !FEATURETEXT
                        !STYLETEXT
                        \n
                        "//* DUMMY CODE TO SANITY CHECK GENERATED SCRIPT (TODO Remove one of the two solidi from the beginning of this line to activate your own code)"
                        "\n        "
                        !stringvar
                        makeName$!name
                        "file = tempFileName(\""
                        makeName$!name
                        "-results\");
        $command = \"echo $echos >> "
                        !stringvar
                        makeName$!name
                        "file\";
        logit($command);

        if(($cmd = popen($command, \"r\")) == NULL)
            {
            throw new SystemExit(); // instead of exit()
            }

        while($read = fgets($cmd))
            {
            }

        pclose($cmd);
/*/
// YOUR CODE STARTS HERE.
//        TODO your code!
// YOUR CODE ENDS HERE. OUTPUT EXPECTED IN "
                        !var
                        makeName$!name
                        "file
//*/
        $tmpf = fopen("
                        !var
                        makeName$!name
                        "file,'r');

        if($tmpf)
            {
            //logit('output from "
                        makeName$!name
                        ":');
            while($line = fgets($tmpf))
                {
                //logit($line);
                print $line;
                }
            fclose($tmpf);
            }

        if($dodelete)
            {
            foreach ($tobedeleted as $filename => $dot) 
                {
                if($dot)
                    unlink($filename);
                }
            unset($tobedeleted);
            }
        }
    loginit();
    "
                        !mainfunc
                        "();\n"
                        !lastWord
                      )
                | 
                )
              )
          & reverselist$!TUPTUO
      )
      "
/**
  * register
  *
  * Register a tool - integrated or not.
  * Produces an initially empty html form that dynamically adapts to user's
  * need to register multiple values for the same feature.
  * The form consists of two parts: a part for general information, most of
  * which can be deposited in the repository in a later phase, and a part that
  * is mainly used for integrated tools. The second part collects very precise
  * and formalised information that enables the Tools module to compute
  * workflows with tools and resources that fit together. Only some of the
  * information from this part can be deposited in the repository: a condensed
  * list of supported languages, dataformats and facets, in both input and 
  * output. Missing in the deposited metadata are the restrictions on 
  * combinations of input and output features and between features. 
  * For example there is no formal way for the deposited metadata to express
  * that the input facet 'Part Of Speech' can be combined with input languages
  * Danish and English, but not with Russian as an input language. Nor can
  * deposited metadata formally express that input language Danish implies 
  * output language Danish, and input lnaguage Russian either output language
  * Russian or English. (Implying that the tool can translate from Russian to
  * English.) 
  * Such relations must be written in natural language in the description of
  * the tool.
  *
  * Affected tables: 
  *         tooladm.table   (general part), 
  *         toolprop.table  (for integrated tools)
  * Input: a list of HTTP-parameters converted to the form 
  *     (<parameter>.<value>) (<parameter>.<value>) (<parameter>.<value>) ...
  *
  * Output: a XHTML-form
  *
  * Input and output form a closed circuit: the form is generated by the 
  * register function and the input from the filled-out form is sent to the
  * register function.
  *
  * Called from register.java
  */"
      ( register
      =     Metadata featureListing staticFields
          , ToolName ToolVersion FullToolName PassWord password
          , ToolURL ToolPublisher ContentProvider passwordAsHandle
          , ToolCreator InfoAbout ToolDescription mail2
          , ToolExternalURI ToolXMLparms
          , ToolPostData ToolInactive
          , formFields storeTool handle
          , unfoldInputAndOutput foldInputAndOutput askFeature
          , nth AA ZZ feats windfw ContactEmail contactEmail
          , featjursPreexisting featjursURL feat error Submit
          , createBoilerPlate force
          , validationComments
          , storeToolButton replaceToolButton
          , deleteToolButton UpdateButton PHPbutton
        .   clean$
          & :?servicedSources:?servicedGoals
          &   localized$("Save metadata" "Gem oplysninger")
            : ?storeToolButton
          &   localized$("Replace metadata" "Erstat oplysninger")
            : ?replaceToolButton
          &   localized$("Delete metadata" "Slet oplysninger")
            : ?deleteToolButton
          &   localized$("Show more entry fields" "Vis flere inputfelter")
            : ?UpdateButton
          & localized$("PHP wrapper" PHP-kode):?PHPbutton
          & ( createBoilerPlate
            =     ToolName ToolVersion FullToolName
                , URL Publisher ContentProvider
                , Creator InfoAbout Description
                , ExternalURI XMLparms url-password
                , PostData Inactive pval toggles
                , liste a z urlparm var val like
                , PassWord url-ToolName
                , ContactEmail url-contactEmail
              .     ~(!arg:? (name.?) ?)
                  &   !arg
                    : ? (contactEmail.~:?url-contactEmail) ?
                  & "User hasn't specified a name yet, but email is known. This
                     generates a form independent of already registered tools."
                  & ( 
                    . 
                    . !url-contactEmail
                    . !arg (ml2.!url-contactEmail) (nctv.on)
                    )
                |   "Either the name http parameter is similar to an existing 
                     tool's name, or it is the name of a new tool."
                  & ( like
                    =   
                      .   sim$(trim$!sjt,trim$!arg):1
                        & ?
                    )
                  & log$(createBoilerPlate !arg)
                  & "TODO RESET ALL OF urlparm IF TOOL NOT FOUND"
                  & !arg:?urlparm
                  &   !urlparm
                    : ? (name.?url-ToolName) ?
                    : ( ? (password.~:?url-password) ?
                      | ?&:?url-password
                      )
                    : ? (contactEmail.~:?url-contactEmail) ?
                  & :?ContactEmail
                  & (     !tooladm
                        :   ?
                          + (   ?
                                ( ToolID
                                .   like$!url-ToolName
                                  : ?ToolName
                                  : ?url-ToolName
                                )
                                ?
                            : ( ? (PassWord.?PassWord) ?
                              | ?
                              )
                            : ( ? (ContactEmail.?ContactEmail) ?
                              | ?
                              )
                            : ? (Version.?ToolVersion) ?
                            : ? (Title.?FullToolName) ?
                            : ? (ServiceURL.?URL) ?
                            : ? (Publisher.?Publisher) ?
                            : ? (ContentProvider.?ContentProvider) ?
                            : ? (Creator.?Creator) ?
                            : ? (InfoAbout.?InfoAbout) ?
                            : ? (Description.?Description) ?
                            : ? (ExternalURI.?ExternalURI) ?
                            : ? (XMLparms.?XMLparms) ?
                            : ? (PostData.?PostData) ?
                            : ? (Inactive.?Inactive) ?
                            )
                          + ?
                      & !urlparm:?a (name.?) ?z
                      & !a (name.!url-ToolName) !z:?urlparm
                      & "The name http parameter was similar to an existing tool's name.
                         Use the existing tool's name instead and fetch all that is known
                         about this tool."
                    |   "The name http parameter is not seen before, so 
                         we create an empty form for an inactive tool."
                      & !url-ToolName:?ToolName
                      & !url-contactEmail:?ContactEmail
                      &   
                        : ?PassWord
                        : ?url-password
                        : ?ToolVersion
                        : ?FullToolName
                        : ?URL
                        : ?Publisher
                        : ?ContentProvider
                        : ?Creator
                        : ?InfoAbout
                        : ?Description
                        : ?ExternalURI
                        : ?XMLparms
                        : ?PostData
                      & on:?Inactive
                    )
                  & ( !url-contactEmail:!ContactEmail
                    |   ( !url-password:!PassWord:~
                        | !PassWord:!ContactEmail:
                        )
                      & !url-contactEmail:?ContactEmail
                    )
                  & "You only are allowed to edit a tool that
                        1) is yours (email) 
                     or 2) you know the password for
                     or 3) has empty password AND email fields (orphan tool)
                     
                     The password is reset and the tool becomes yours."
                  &     (psswrd.)
                        (ml2.!ContactEmail)
                        (vrsion.!ToolVersion)
                        (fllNm.!FullToolName)
                        (pblshr.!Publisher)
                        (cntPrvdr.!ContentProvider)
                        (crtr.!Creator)
                        (docuri.!InfoAbout)
                        (url.!URL)
                        (dscrptn.!Description)
                        (xuri.!ExternalURI)
                    : ?liste
                  &     (xmlprms.!XMLparms)
                        (pstdt.!PostData)
                        (|(nctv.!Inactive))
                    : ?toggles
                  &   (     !urlparm
                          : ? (handle.?handle) ?
                          : ? (nth.?) ?
                        & "When the user enters the form, the list of http
                           parameters is still short:
                                 handle,contactEmail,name,password,bsubmit
                           A good indication that the user hasn't toggled
                           anything is the absence of the 'nth' parameter.
                           User's input value of Inactive overrules
                           registered input."
                        & ( !urlparm:? (nctv.?) ?
                          | (nctv.) !urlparm
                          )
                      |   "Registered value of Inactive overrules user's input."
                        &   !urlparm
                          : ( ?a (nctv.?) ?z
                            | ?z&:?a
                            )
                        & (nctv.!Inactive) !a !z
                      )
                    : ?urlparm
                  & ( !urlparm:? (url.?) ?
                    |   whl
                      ' ( !toggles:(?var.?val) ?toggles
                        & ( !urlparm:? (!var.?) ?
                          | !urlparm (!var.trim$!val):?urlparm
                          )
                        )
                    )
                  &   whl
                    ' ( !liste:(?var.?val) ?liste
                      & trim$!val:?val
                      & (   !urlparm
                          :   ?a
                              (   (!var.) ?z
                                & "Replace empty value by non-empty value."
                                & !a (!var.!val) !z:?urlparm
                              |   (!var.?pval) ?z
                                &   !a (!var.trim$!pval) !z
                                  : ?urlparm
                              )
                        | !urlparm (!var.!val):?urlparm
                        )
                      )
                  & (!ToolName.!PassWord.!ContactEmail.!urlparm)
            )
          & ( staticFields
            =   staticField
              .   ( staticField
                  =     urlvars prompt urlvar
                      , internalvar fieldType attrs
                    .     !arg
                        : ( ?urlvars
                          . ?prompt
                          . ?urlvar
                          . ?internalvar
                          . ?fieldType
                          . ?attrs
                          )
                      &   ( checkParmsSimple$(!urlvars.!urlvar)
                          | 
                          )
                        : ?!internalvar
                      &   !fieldType
                        $ (!prompt.!urlvar.(val.!!internalvar) !attrs)
                  )
                &     fieldset
                    $ (   localized
                        $ ( Boilerplate
                            "Generelle oplysninger for alle værktøjer"
                          )
                      .     paragraph
                          $ (   staticField
                              $ ( !arg
                                . "ToolID:"
                                . name
                                . ToolName
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ("short unique name" "kort unikt navn")
                                    )
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "Title:"
                                . fllNm
                                . FullToolName
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "full name of the tool"
                                          "Værktøjets fulde navn"
                                        )
                                    )
                                    (size.40)
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "Version:"
                                . vrsion
                                . ToolVersion
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "may only contain ascii letters dots  and digits"
                                          "må kun indeholde ascii-bogstaver, punktum og cifre"
                                        )
                                    )
                                    (required."*")
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Publisher:"
                                . pblshr
                                . ToolPublisher
                                . makeTextFormField
                                . required
                                . "*"
                                )
                                staticField
                              $ ( !arg
                                . "Content provider:"
                                . cntPrvdr
                                . ContentProvider
                                . makeTextFormField
                                . required
                                . "*"
                                )
                                staticField
                              $ ( !arg
                                . "Creator:"
                                . crtr
                                . ToolCreator
                                . makeTextFormField
                                . (size.25) (required."*")
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Email:"
                                . ml2
                                . ContactEmail
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "protection against unauthorized update"
                                          "Beskyttelse mod uautoriseret redigering af oplysninger. Email adressen bliver ikke offentliggjort eller lagret i repositoriet ved deponering af værktøjets oplysninger og kan ændres ved at overdrage redigeringsrettigheden til en anden person. (Se forklaring på Password-feltet.)"
                                        )
                                    )
                                    (readonly.yes)
                                )
                                staticField
                              $ ( !arg
                                . "Password:"
                                . psswrd
                                . PassWord
                                . makeTextFormField
                                . desc
                                .   localized
                                  $ ( "If you want to transfer the edit right of the tool to somebody else, enter a one-time password that you share with the other person. The other person must be logged in via WAYF and enter the password to gain access and the edit right."
                                      "Hvis du vil overdrage redigeringsrettigheden til en anden person, skriv en engangsadgangskode og giv den til den anden person. For at modtage redigeringsrettigheden, skal den anden person logge sig på via WAYF og indtaste adgangskoden. Når hun eller han erstatter værktøjets oplysninger, bliver hans eller hendes email adresse noteret i Email-feltet og er hun eller han blevet den primære kontaktperson hvis der er spørgsmål eller problemer ang. værktøjet."
                                    )
                                )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "InfoAbout:"
                                . docuri
                                . InfoAbout
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "URI of documentation"
                                          "Dokumentationens URI"
                                        )
                                    )
                                    (size.40)
                                    (required."*")
                                )
                                staticField
                              $ ( !arg
                                . "External Service URL:"
                                . xuri
                                . ToolExternalURI
                                . makeTextFormField
                                .   ( desc
                                    .   localized
                                      $ ( "fill out if the tool (also) functions as a web service"
                                          "udfyld hvis værktøjet (også) fungerer som webservice"
                                        )
                                    )
                                    (size.40)
                                )
                            )
                            paragraph
                          $ ( staticField
                            $ ( !arg
                              . "Description:"
                              . dscrptn
                              . ToolDescription
                              . makeTextAreaFormField
                              . required
                              . "*"
                              )
                            )
                      )
                      fieldset
                    $ (   localized
                        $ ("Webservice metadata" Webserviceoplysninger)
                      .     paragraph
                          $ ( staticField
                            $ ( !arg
                              . "Service URL of the tool:"
                              . url
                              . ToolURL
                              . makeTextFormField
                              .   ( desc
                                  .   localized
                                    $ ( "Something like \"https://abc.foo/wordreverser\". Only needed for integrated tools. To wipe URL: replace with one or more blank characters."
                                        "Noget i stil med \"https://abc.foo/wordreverser\". Kun krævet for integrerede værktøjer. For at udviske URL: erstat med blanktegn."
                                      )
                                  )
                                  (size.40)
                              )
                            )
                            paragraph
                          $ (   staticField
                              $ ( !arg
                                . "Requires HTTP POST method:"
                                . pstdt
                                . ToolPostData
                                . makeCheckboxFormField
                                . 
                                )
                                staticField
                              $ ( !arg
                                . "parameters as XML (if POST):"
                                . xmlprms
                                . ToolXMLparms
                                . makeCheckboxFormField
                                . desc
                                .   localized
                                  $ ( "Check if parameters must be sent in XML format"
                                      "Marker hvis parametre skal sendes i XML-format"
                                    )
                                )
                                staticField
                              $ ( !arg
                                . "Inactive:"
                                . nctv
                                . ToolInactive
                                . makeCheckboxFormField
                                .   ( desc
                                    .   localized
                                      $ ( "Check if the tool is not integrated. Also check this box if an integrated tool temporarily cannot be used. (You need to be logged in to toggle this swicth.)"
                                          "Marker hvis værktøjet er midlertidigt ude af drift eller slet ikke integreret. (Du skal være logget på før du kan ændre dette felt.)"
                                        )
                                    )
                                    (   !handle:
                                      & (disabled.disabled)
                                    | 
                                    )
                                )
                            )
                      )
            )
          & ( featureListing
            =   listing featname inouts in outp K listIO
              .   ( listIO
                  =   in io I S L M s opt addFeature listing
                    .   ( addFeature
                        =     in K L featname io
                            , I S listing M s optional
                          .     !arg
                              : ( ?in
                                . ?K
                                . ?L
                                . ?featname
                                . ?io
                                . ?I
                                . ?S
                                . ?listing
                                . ?optional
                                )
                            &     (str$(!featname !K "." !L !io).!I)
                                  ( !optional:
                                  | (   str
                                      $ (!featname !K "." !L !io !optional)
                                    . on
                                    )
                                  )
                                  (   !in:(1|)
                                    & 
                                  | ( str$(!featname !K "." !L !io More)
                                    . on
                                    )
                                  )
                                  !listing
                              : ?listing
                            & 0:?M
                            & ( !S:1
                              |   whl
                                ' ( !S:%?s+?S
                                  & NEWSPEC
                                  & 1+!M:?M
                                  &     (   str
                                          $ ( !featname
                                              !K
                                              "."
                                              !L
                                              "."
                                              !M
                                              !io
                                              Spc
                                            )
                                        . !s
                                        )
                                        ( !S:0&
                                        | (   str
                                            $ ( !featname
                                                !K
                                                "."
                                                !L
                                                "."
                                                !M
                                                !io
                                                Spc
                                                More
                                              )
                                          . on
                                          )
                                        )
                                        !listing
                                    : ?listing
                                  )
                              )
                            & !listing
                        )
                      & 0:?L
                      & !arg:(?in.?io.?listing)
                      & !in:(%?in ?opt|?opt)
                      &   whl
                        ' ( !in:%?I^?S*?in
                          & 1+!L:?L
                          &     addFeature
                              $ ( !in
                                . !K
                                . !L
                                . !featname
                                . !io
                                . !I
                                . !S
                                . !listing
                                . 
                                )
                            : ?listing
                          )
                      & ( !opt:
                        |       (str$(!featname !K "." !L !io More).on)
                                !listing
                            : ?listing
                          & NEWSPEC
                          &   whl
                            ' ( !opt:%?I^?S ?opt
                              & 1+!L:?L
                              & NEWSPEC
                              &     addFeature
                                  $ ( !opt
                                    . !K
                                    . !L
                                    . !featname
                                    . !io
                                    . !I
                                    . !S
                                    . !listing
                                    . Optional
                                    )
                                : ?listing
                              )
                        )
                      & !listing
                  )
                & :?listing
                & ( 
                  |   ( Single
                      .       !arg
                            :   ?
                                ( ?
                                ,   ?
                                  + (   %*%:?in
                                      & ~(:!(glf$('($in.?))) ?)
                                    . ?
                                    )
                                  + ?
                                )
                                ?
                          & on
                        | 
                      )
                    : ?listing
                  )
                &   whl
                  ' ( !arg:(?featname,?inouts) ?arg
                    & 0:?K
                    &   whl
                      ' ( !inouts:#*(?in.?outp)+?inouts
                        & 1+!K:?K
                        & listIO$(!in.Input.!listing):?listing
                        & listIO$(!outp.Output.!listing):?listing
                        & ( 1:!(glf$('($in.?)))*?
                          |     (str$(!featname !K Single).on)
                                !listing
                            : ?listing
                          )
                        & ( !inouts:0
                          |     (str$(!featname !K More).on)
                                !listing
                            : ?listing
                          )
                        )
                    )
                & !listing
            )
          & ( windfw
            =   nth Nth toolprop ZZ ToolName featjursPreexisting
              .   !arg:(?toolprop.?ToolName.?nth:?Nth)
                & !toolprop:?+(!ToolName.?featjursPreexisting)+?ZZ
                &   whl
                  ' ( !Nth:>0
                    & !ZZ:(!ToolName.?featjursPreexisting)+?ZZ
                    & !Nth+-1:?Nth
                    )
                & (!featjursPreexisting.!ZZ.!nth+-1*!Nth)
            )
          & ( unfoldInputAndOutput
            =   feat apair a z II OO zpair
              .   map
                $ ( ( 
                    =   
                      .   !arg:(?feat,?arg)
                        &   whl
                          ' ( !arg:?apair+#*(%?a+%?z.?OO)+?zpair
                            & !apair+(!a.!OO)+(!z.!OO)+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(?II.%?a+%?z)+?zpair
                            & !apair+(!II.!a)+(!II.!z)+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(^?.^?)+?zpair
                            & !apair+!zpair:?arg
                            )
                        & (!feat,!arg)
                    )
                  . !arg
                  )
            )
          & ( foldInputAndOutput
            =     feat apair a b II OO zpair
                , mpair aval zval
              .   map
                $ ( ( 
                    =   
                      .   !arg:(?feat,?arg)
                        &   whl
                          ' ( !arg:?apair+#%*(?II.?OO)+?zpair
                            & !apair+(!II.!OO)+!zpair:?arg
                            )
                        &   whl
                          ' (   !arg
                              :   ?apair
                                + #*(?a.?OO)
                                + ?mpair
                                + #*(?b.!OO)
                                + ?zpair
                            &     !apair
                                + (denumerizeSum$(!a+!b).!OO)
                                + !mpair
                                + !zpair
                              : ?arg
                            )
                        &   whl
                          ' (   !arg
                              :   ?apair
                                + #*(?II.?a)
                                + ?mpair
                                + #*(!II.?b)
                                + ?zpair
                            &     !apair
                                + (!II.denumerizeSum$(!a+!b))
                                + !mpair
                                + !zpair
                              : ?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(^?.^?)+?zpair
                            & !apair+!zpair:?arg
                            )
                        &   whl
                          ' (   !arg
                              : ?apair+#*(?aval*^?*?zval.?OO)+?zpair
                            &     !apair
                                + (denumerizeSum$(!aval*!zval).!OO)
                                + !zpair
                              : ?arg
                            )
                        &   whl
                          ' (   !arg
                              : ?apair+#*(?II.?aval*^?*?zval)+?zpair
                            &     !apair
                                + (!II.denumerizeSum$(!aval*!zval))
                                + !zpair
                              : ?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(1.?OO)+?zpair
                            & !apair+(.!OO)+!zpair:?arg
                            )
                        &   whl
                          ' ( !arg:?apair+#*(?II.1)+?zpair
                            & !apair+(!II.)+!zpair:?arg
                            )
                        & ( !arg:0&:?arg
                          | 
                          )
                        & (!feat,!arg)
                    )
                  . !arg
                  )
            )
          & ( askFeature
            =     inoutpairs feat urlparms formstuff
                , formFields Metadata featname
                , askFieldSet shortfeatname
                , featdescription feattable specificationTables
              .   ( askFieldSet
                  =     sameFeaturePairOnceMore NrInOutAlternative
                      , featname inout featurePair inoutpairs
                      , featurePairMore FieldSet optionalFeature ret
                      , NrRequiredAndOptional optionals requireds
                      , shouldIAskOptionalFeature
                      , urlparms feattable featdescription formstuff
                      , askOptional aFeature Input Output
                    .   ( sameFeaturePairOnceMore
                        = .!arg:(?arg.?)&(.!arg)
                        )
                      & ( askOptional
                        =   urlparms featinoutOptional
                          .   !arg:(?urlparms.?featinoutOptional)
                            &   (   checkParmsSimple
                                  $ (!urlparms.!featinoutOptional)
                                | 
                                )
                              : ?!featinoutOptional
                            &   makeCheckboxFormField
                              $ ( optional
                                . !featinoutOptional
                                . val
                                . !!featinoutOptional
                                )
                        )
                      & ( aFeature
                        =     NrRequiredAndOptional NrInOutAlternative
                            , NrSpecification featname requireds
                            , inout featinout featinoutMore
                            , featinoutOptional urlparms FieldSet
                            , feattable featdescription row
                            , specifications specificationTables
                            , sameFeatureOnceMore optionals featNSingle
                            , sameSpecificationOnceMore full
                            , specificationTable aSpecification
                            , featinoutSpec featinoutOptMore ret
                          .   ( sameFeatureOnceMore
                              =     requireds optionals FieldSet
                                  , NrRequiredAndOptional
                                .     !arg
                                    : ( ?requireds
                                      . ?optionals
                                      . ?NrRequiredAndOptional
                                      . ?FieldSet
                                      . ?
                                      )
                                  & ( !requireds
                                    . !optionals
                                    . !NrRequiredAndOptional
                                    . !FieldSet
                                    )
                              )
                            & ( aSpecification
                              =   :?sameSpecificationOnceMore
                                & 1+!NrSpecification:?NrSpecification
                                &     str
                                    $ ( !featname
                                        !NrInOutAlternative
                                        "."
                                        !NrRequiredAndOptional
                                        "."
                                        !NrSpecification
                                        !inout
                                        Spc
                                      )
                                  : ?featinoutSpec
                                &   str$(!featinoutSpec More)
                                  : ?featinoutOptMore
                                & (       checkParms
                                        $ ( !urlparms
                                          . !featinoutSpec
                                          .   !!specificationTable
                                            |   readTable$!specificationTable
                                              & !!specificationTable
                                          )
                                      : ?!featinoutSpec
                                    & NEWSPEC
                                    &     ( !!featinoutSpec:~:~1
                                          | 0
                                          )
                                        + !specifications
                                      : ?specifications
                                  | :?!featinoutSpec
                                  )
                                &     !row
                                        makeSelectFormField
                                      $ (   str
                                          $ ( (     !!feattable
                                                  :   ?
                                                      (?full.!!featinout.?)
                                                      ?
                                                & localized$!full
                                              |   "featinout:"
                                                  !featinout
                                                  "=="
                                                  !!featinout
                                                  " and feattable "
                                                  !feattable
                                                  " looks like this:"
                                                  !!feattable
                                              )
                                              " style"
                                            )
                                        . !featinoutSpec
                                        . options
                                        .   makeOptionList
                                          $ (!!specificationTable.!!featinoutSpec)
                                        )
                                      (       checkParmsSimple
                                            $ (!urlparms.!featinoutOptMore)
                                          : ?!featinoutOptMore
                                        & (   !!featinoutOptMore:on
                                            &   '$aSpecification
                                              : ( 
                                                = ?sameSpecificationOnceMore
                                                )
                                            &   makeHiddenFields
                                              $ (!featinoutOptMore.on)
                                          | 
                                          )
                                      |   makeCheckboxFormField
                                        $ ( localized$(more mere)
                                          . !featinoutOptMore
                                          . 
                                          )
                                      )
                                  : ?row
                                & !sameSpecificationOnceMore
                              )
                            &   !arg
                              : ( ?requireds
                                . ?optionals
                                . ?NrRequiredAndOptional
                                . ?FieldSet
                                . ?featname
                                . ?NrInOutAlternative
                                . ?inout
                                . ?urlparms
                                . ?feattable
                                . ?featdescription
                                . ?specificationTables
                                )
                            &   1+!NrRequiredAndOptional
                              : ?NrRequiredAndOptional
                            &     str
                                $ ( !featname
                                    !NrInOutAlternative
                                    "."
                                    !NrRequiredAndOptional
                                    !inout
                                  )
                              : ?featinout
                            & "e.g. facet3.2InputMore
                                shown after second input of third inputs/output(s) combination"
                            & str$(!featinout More):?featinoutMore
                            &   str$(!featinout Optional)
                              : ?featinoutOptional
                            & :?!featinoutOptional
                            &   (   checkParms
                                  $ (!urlparms.!featinout.!!feattable)
                                | 
                                )
                              : ?!featinout
                            &       makeSelectFormField
                                  $ ( !inout
                                    . !featinout
                                    .   ( options
                                        .   makeOptionList
                                          $ (!!feattable.!!featinout)
                                        )
                                        (desc.!featdescription)
                                    )
                                    optionalFeature
                                  $ (!urlparms.!featinoutOptional)
                                  (       checkParmsSimple
                                        $ (!urlparms.!featinoutMore)
                                      : ?!featinoutMore
                                    & (   !!featinoutMore:on
                                        &   '$aFeature
                                          : (=?sameFeatureOnceMore)
                                        &   makeHiddenFields
                                          $ (!featinoutMore.on)
                                      | 
                                      )
                                  |     makeCheckboxFormField
                                      $ ( localized$(more mere)
                                        . !featinoutMore
                                        . 
                                        )
                                      (   !inout:Input
                                        & !NrRequiredAndOptional:>1
                                        &     str
                                            $ ( !featname
                                                !NrInOutAlternative
                                                Single
                                              )
                                          : ?featNSingle
                                        &   makeCheckboxFormField
                                          $ (   localized
                                              $ ( "All inputs in single file"
                                                  "Input samlet i én fil"
                                                )
                                            . !featNSingle
                                            .   ( val
                                                .       !urlparms
                                                      :   ?
                                                          (!featNSingle.on)
                                                          ?
                                                    & on
                                                  | 
                                                )
                                                ( desc
                                                .   localized
                                                  $ ( "Check if there are e.g. >1 input facet or >1 input language, but everything is combined in a single input file."
                                                      "Check hvis der fx er > 1 input facet eller > 1 input sprog, men alt er kombineret i én inputfil."
                                                    )
                                                )
                                            )
                                      | 
                                      )
                                  )
                              : ?row
                            & 0:?specifications
                            & NEWSPEC
                            & (   !specificationTables
                                :   ?
                                    ( ? (%@:!!featinout) ?
                                    .   ?specificationTable
                                      & 0:?NrSpecification
                                      & !aSpecification
                                    )
                                    ?
                              | 
                              )
                            & NEWSPEC
                            &     !!featinout
                                ^ ( !specifications:~0:~
                                  | 1
                                  )
                              : ?!featinout
                            & (   !!featinoutOptional:
                                &   flg$('$requireds)
                                  : (=?.?requireds)
                                & !requireds*!!featinout:?requireds
                              | !optionals !!featinout:?optionals
                              )
                            & (   !inout:Input
                                &     str
                                    $ (!featname !NrInOutAlternative Single)
                                  : ?featNSingle
                                &   !urlparms
                                  : ? (!featNSingle.on) ?
                                &   glf$('(%.$requireds))
                                  : (=?requireds)
                              | 
                              )
                            & !FieldSet paragraph$!row:?FieldSet
                            &   '$shouldIAskOptionalFeature
                              : (=?optionalFeature)
                            &     sameFeatureOnceMore
                                $ ( !requireds
                                  . !optionals
                                  . !NrRequiredAndOptional
                                  . !FieldSet
                                  . !featname
                                  . !NrInOutAlternative
                                  . !inout
                                  . !urlparms
                                  . !feattable
                                  . !featdescription
                                  . !specificationTables
                                  )
                              : ( ?requireds
                                . ?optionals
                                . ?NrRequiredAndOptional
                                . ?FieldSet
                                )
                            & tbl$(!featinoutMore,0)
                            & tbl$(!featinoutOptMore,0)
                            & tbl$(!featinoutOptional,0)
                            & tbl$(!featinout,0)
                            & tbl$(!featinoutSpec,0)
                            & ( !requireds
                              . !optionals
                              . !NrRequiredAndOptional
                              . !FieldSet
                              )
                        )
                      &   !arg
                        : ( ?inoutpairs
                          . ?NrInOutAlternative
                          . ?featname
                          . ?urlparms
                          . ?feattable
                          . ?featdescription
                          )
                      & 1+!NrInOutAlternative:?NrInOutAlternative
                      &   str$(!featname !NrInOutAlternative)
                        : ?featurePair
                      & str$(!featurePair More):?featurePairMore
                      & :?FieldSet
                      & (optionalFeature=.)
                      &   '$askOptional
                        : (=?shouldIAskOptionalFeature)
                      & (   Input Output
                          :   ?
                              ( %@?inout
                              & :?optionals
                              & 1:?requireds
                              & 0:?NrRequiredAndOptional
                              &     aFeature
                                  $ ( !requireds
                                    . !optionals
                                    . !NrRequiredAndOptional
                                    . !FieldSet
                                    . !featname
                                    . !NrInOutAlternative
                                    . !inout
                                    . !urlparms
                                    . !feattable
                                    . !featdescription
                                    . !specificationTables
                                    )
                                : ( ?requireds
                                  . ?optionals
                                  . ?NrRequiredAndOptional
                                  . ?FieldSet
                                  )
                              & !requireds:~
                              & (   !inout:Input
                                  &   flg$('$requireds)
                                    : (=?flag.?requireds)
                                  & !requireds !optionals:?Input
                                  &   glf$('($flag.$Input))
                                    : (=?Input)
                                | !requireds !optionals:?Output
                                )
                              & (shouldIAskOptionalFeature=.)
                              & (optionalFeature=.)
                              & ~
                              )
                              ?
                        |   !Input:~0
                          & !Output:~0
                          & (!Input.!Output)+!inoutpairs:?inoutpairs
                        | 
                        )
                      &     fieldset$(.!FieldSet)
                            (       checkParmsSimple
                                  $ (!urlparms.!featurePairMore)
                                : ?!featurePairMore
                              & (   !!featurePairMore:on
                                  &   '$askFieldSet
                                    : (=?sameFeaturePairOnceMore)
                                  & makeHiddenFields$(!featurePairMore.on)
                                | 
                                )
                            |   makeCheckboxFormField
                              $ (   localized
                                  $ ( "Add an input/output combination"
                                      "Tilføj en input/output-kombination"
                                    )
                                . !featurePairMore
                                . 
                                )
                            )
                            (     sameFeaturePairOnceMore
                                $ ( !inoutpairs
                                  . !NrInOutAlternative
                                  . !featname
                                  . !urlparms
                                  . !feattable
                                  . !featdescription
                                  )
                              : (?formstuff.?inoutpairs)
                            & !formstuff
                            )
                        : ?ret
                      & tbl$(!featurePairMore,0)
                      & tbl$(!featurePair,0)
                      & (!ret.!inoutpairs)
                  )
                & !arg:(?urlparms.?feat.?formFields.?Metadata)
                &   !feat
                  : ? (name.?featname) ?
                  : ? (short.?shortfeatname) ?
                  : ? (description.?featdescription) ?
                  : ? (table.?feattable) ?
                  : ( ? (specificationTable.?specificationTables) ?
                    | ?
                    )
                & 0:?inoutpairs
                & readTable$!feattable
                & (   !formFields
                        fieldset
                      $ ( localized$!featname
                        .       askFieldSet
                              $ ( !inoutpairs
                                . 0
                                . !shortfeatname
                                . !urlparms
                                . !feattable
                                . localized$!featdescription
                                )
                            : (?formstuff.?inoutpairs)
                          & log$(inoutpairs !inoutpairs)
                          & !formstuff
                        )
                  .   !Metadata
                      ( !inoutpairs:0&
                      | (!shortfeatname,!inoutpairs)
                      )
                  )
            )
          & ( validationComments
            =     Submit otherName
                , ToolName ToolVersion FullToolName PassWord
                , ToolURL ToolPublisher ContentProvider
                , ToolCreator InfoAbout ToolDescription
                , ToolExternalURI ToolXMLparms mayNotBeEmpty
                , ToolPostData ToolInactive Nazn dNazn
              .     !arg
                  : ( ?ToolName
                    . ?PassWord
                    . ?ToolVersion
                    . ?FullToolName
                    . ?ToolURL
                    . ?ToolPublisher
                    . ?ContentProvider
                    . ?ToolCreator
                    . ?InfoAbout
                    . ?ToolDescription
                    . ?ToolExternalURI
                    . ?ToolXMLparms
                    . ?ToolPostData
                    . ?ToolInactive
                    . ?Submit
                    )
                & ( mayNotBeEmpty
                  =   
                    .   "'"
                        !arg
                        "' "
                        localized$("may not be empty" "må ikke være tom")
                        (br.,)
                  )
                & ( (   !ToolName:
                      & mayNotBeEmpty$ToolID
                    |   @( !ToolName
                         : allowedChar$('$NCNameStartChar) !NCName
                         )
                      & `~
                    |   str
                      $ ( "ToolID '"
                          !ToolName
                            localized
                          $ ( "' contains invalid characters. (Must be an xml:id)"
                              "' indeholder ugyldige karakterer. (Skal være et xml:id)"
                            )
                        )
                    )
                  | !ToolName:&mayNotBeEmpty$ToolID
                  |   !FullToolName:
                    & mayNotBeEmpty$Title
                  |   !ToolURL:
                    & !ToolInactive:
                    &     localized
                        $ ( "'Service URL' may not be empty if the tool is integrated and active. If the tool must be integrated in the infrastructure, but not just now, you must check the field 'Inactive'."
                            "'Service URL' må ikke være tom hvis værktøjet er et aktivt integreret værktøj. Hvis værktøjet ikke skal være integreret i infrastrukturen, skal du markere feltet 'Inactive'."
                          )
                        (br.,)
                  |     !tooladm
                      :   ?
                        + ( ? (ToolID.!ToolName) ?
                          : ? (Inactive.) ?
                          : ? (ServiceURL.<>!ToolURL) ?
                          )
                        + ?
                    & !Submit:!storeToolButton
                    &     str
                        $ (   localized
                            $ ( "There is already an integrated tool with the name '"
                                "Der findes et integreret værktøj med navn '"
                              )
                            !ToolName
                              localized
                            $ ( "' with another Service URL. If you are sure it is the same tool, you can change the Service URL by temporarily deactivating the tool. (Check the 'Inactive'-field, save, change the Service URL, uncheck 'Inactive', and save.)"
                                "' med en anden Service URL end den indtastede. Hvis du er sikker på at det er samme værktøj, kan du ændre Service URL ved først midlertigt at deaktivere værktøjet. (Klik 'Inactive'-feltet, gem, ændr Service URL og klik 'Inactive'-feltet igen, gem.)"
                              )
                          )
                        (br.,)
                  |   !ToolURL:~
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!ToolURL) ?
                          :   ?
                              (ToolID.?otherName:<>!ToolName)
                              ?
                          )
                        + ?
                    &     str
                        $ ( localized$("Cannot save '" "Kan ikke gemme '")
                            !ToolName
                              localized
                            $ ("' on Service URL \"" "' på Service URL \"")
                            !ToolURL
                              localized
                            $ ( "\" (already taken by the tool '"
                                "\" (allerede i brug af værktøjet '"
                              )
                            !otherName
                            "')."
                          )
                        (br.,)
                  |   ( Nazn
                      =   #
                          ( 
                          | ? (%@:~<a:~>z)
                          | `
                          )
                          (|#)
                      )
                    & '("." ()$Nazn):(=?dNazn)
                    & (   @( !ToolVersion
                           :   !Nazn
                               ( 
                               |   !dNazn
                                   ( 
                                   | !dNazn (|!dNazn)
                                   )
                               )
                           )
                        & `~
                      |   localized
                        $ ( "'Version' must match the regular expression [d]+[a-z]*[d]*(.[d]+[a-z]*[d]*){0,3}"
                            "'Version' skal matche det regulære udtryk [d]+[a-z]*[d]*(.[d]+[a-z]*[d]*){0,3}"
                          )
                      )
                  |   !ToolPublisher:
                    & mayNotBeEmpty$Publisher
                  |   !ContentProvider:
                    & mayNotBeEmpty$"Content provider"
                  |   !ToolCreator:
                    & mayNotBeEmpty$Creator
                  |   !InfoAbout:
                    &     localized
                        $ ( "'InfoAbout' (tool documentation): URL may not be empty"
                            "'InfoAbout' (værktøjets dokumentation): URL må ikke være tom"
                          )
                        (br.,)
                  |   !ToolDescription:
                    & mayNotBeEmpty$Description
                  |   !ToolPostData:
                    & !ToolXMLparms:on
                    &   ( "XMLparms ("
                          !ToolXMLparms
                            localized
                          $ ( ") must not be checked if 'POST' is not checked"
                              ") skal være umarkeret hvis 'POST' er umarkeret"
                            )
                        )
                        (br.,)
                  )
            )
          & ( storeTool
            =     A M Z Metadata admdata
                , ToolName ToolVersion FullToolName PassWord
                , ToolURL ToolPublisher ContentProvider
                , ToolCreator InfoAbout ToolDescription
                , ToolExternalURI ToolXMLparms removeEmptyValues
                , ToolPostData ToolInactive sortFacets
                , ContactEmail otherToolprop thisToolProp
                , Combine IOFeatComb IOcomb IOcombine Ocomb
                , subset unfact unfactorize force
              .     !arg
                  : ( ?Metadata
                    . ?ToolName
                    . ?PassWord
                    . ?ContactEmail
                    . ?ToolVersion
                    . ?FullToolName
                    . ?ToolURL
                    . ?ToolPublisher
                    . ?ContentProvider
                    . ?ToolCreator
                    . ?InfoAbout
                    . ?ToolDescription
                    . ?ToolExternalURI
                    . ?ToolXMLparms
                    . ?ToolPostData
                    . ?ToolInactive
                    . ?ZZ
                    . ?force
                    )
                & lst$(Metadata,path$Metadata,NEW)
                & (   ( !ToolInactive:on
                      | !handle:~
                      )
                    &   (   !ZZ:<0
                          & (   !toolprop:?A+!Metadata+?Z
                              & ( !force:no&!toolprop
                                | !A+!Metadata+!Z
                                )
                            | !Metadata+!toolprop
                            )
                        |   !toolprop:?AA+(?.?)+!ZZ
                          & ( !AA+!ZZ:?A+!Metadata+?Z
                            | !AA+!Metadata+!ZZ
                            )
                        )
                      : ?toolprop
                    &   whl
                      ' ( !toolprop:?A+(?.)+?Z
                        & !A+!Z:?toolprop
                        )
                    & removeNumFactors$!toolprop:?toolprop
                    & ( removeEmptyValues
                      =   a b nw
                        .     !arg:?a_?b
                            &     (removeEmptyValues$!a)
                                _ (removeEmptyValues$!b)
                              : ?nw
                            & !(glf$('($arg.$nw))):?arg
                            & ( !arg:*?arg&!arg
                              | !arg:+?arg&!arg
                              | !arg:?a^&!a
                              | !arg:^?&
                              )
                          | !arg
                      )
                    & lst$(toolprop,path$toolpropAA,NEW)
                    & removeEmptyValues$!toolprop:?toolprop
                    & ( sortFacets
                      =   toolpropFacetsSorted Name facets
                        .   0:?toolpropFacetsSorted
                          &   whl
                            ' ( !arg:#*(?Name.?facets)+?arg
                              &     (!Name.sort$!facets)
                                  + !toolpropFacetsSorted
                                : ?toolpropFacetsSorted
                              )
                          & !toolpropFacetsSorted
                      )
                    & sortFacets$!toolprop:?toolprop
                    & removeNumFactors$!toolprop:?toolprop
                    & ( unfact
                      =     ToolName F A Z a z f
                          , O x m T y
                        .   !arg:(?ToolName.?F)
                          & (   !F:?A (?f,%?a+%?z) ?Z
                              &   unfact$(!ToolName.!A (!f,!a) !Z)
                                + unfact$(!ToolName.!A (!f,!z) !Z)
                            |   !F:?A (?f,(%?a+%?z.?O)) ?Z
                              &     unfact
                                  $ (!ToolName.!A (!f,(!a.!O)) !Z)
                                +   unfact
                                  $ (!ToolName.!A (!f,(!z.!O)) !Z)
                            |   !F:?A (?f,(?O.%?a+%?z)) ?Z
                              &     unfact
                                  $ (!ToolName.!A (!f,(!O.!a)) !Z)
                                +   unfact
                                  $ (!ToolName.!A (!f,(!O.!z)) !Z)
                            |     !F
                                :   ?A
                                    (?f,(?O.?x*?m^(%?a+%?z)*?y ?T))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!O.!x*!m^!a*!y !T))
                                        !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!O.!x*!m^!z*!y !T))
                                        !Z
                                    )
                            |     !F
                                :   ?A
                                    (?f,(?x*?m^(%?a+%?z)*?y ?T.?O))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x*!m^!a*!y !T.!O))
                                        !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x*!m^!z*!y !T.!O))
                                        !Z
                                    )
                            |     !F
                                :   ?A
                                    (?f,(%?x ?m^(%?a+%?z) ?T.?O))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x !m^!a !T.!O))
                                        !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    .   !A
                                        (!f,(!x !m^!z !T.!O))
                                        !Z
                                    )
                            |     !F
                                :   ?A
                                    (?f,(?O.%?x ?m^(%?a+%?z) ?T))
                                    ?Z
                              &     unfact
                                  $ ( !ToolName
                                    . !A (!f,(!O.!x !m^!a !T)) !Z
                                    )
                                +   unfact
                                  $ ( !ToolName
                                    . !A (!f,(!O.!x !m^!z !T)) !Z
                                    )
                            | !arg
                            )
                      )
                    & ( subset
                      =   toolprop ToolName Fe A fe subs
                        .   !arg:(?toolprop.?ToolName)
                          & !toolprop:?A+(!ToolName.?Fe)+?toolprop
                          & 0:?subs
                          &   whl
                            ' ( !toolprop:(!ToolName.?fe)+?toolprop
                              & !subs+(!ToolName.!fe):?subs
                              )
                          & ((!ToolName.!Fe)+!subs.!A+!toolprop)
                      )
                    &   subset$(!toolprop.!ToolName)
                      : (?thisToolProp.?otherToolprop)
                    & ( unfactorize
                      =   A
                        .     !arg:%?A+?arg
                            & unfact$!A+unfactorize$!arg
                          | 0
                      )
                    & unfactorize$!thisToolProp:?thisToolProp
                    & removeNumFactors$!thisToolProp:?thisToolProp
                    & ( Combine
                      =     A M Z AA ZZ Name Facet val1
                          , Vals1 Vals2
                        .     whl
                            ' (   !arg
                                :   ?A
                                  + (?Name.?val1)
                                  + ?M
                                  + ( ?
                                    .   ?AA
                                        ( (?Facet,?Vals2) ?ZZ
                                        &   !val1
                                          : !AA (!Facet,?Vals1) !ZZ
                                        )
                                    )
                                  + ?Z
                              &     !A
                                  + ( !Name
                                    . !AA (!Facet,!Vals1+!Vals2) !ZZ
                                    )
                                  + !M
                                  + !Z
                                : ?arg
                              )
                          & !arg
                      )
                    & Combine$!thisToolProp:?thisToolProp
                    & ( Ocomb
                      =   a i1 i2 o m z
                        .     !arg:?a+(?i1.?o)+?m+(?i2.!o)+?z
                            & Ocomb$(!a+(!i1+!i2.!o)+!m+!z)
                          | !arg
                      )
                    & ( IOcomb
                      =   a i o1 o2 m z
                        .     !arg:?a+(?i.?o1)+?m+(!i.?o2)+?z
                            & IOcomb$(!a+(!i.!o1+!o2)+!m+!z)
                          | Ocomb$!arg
                      )
                    & ( IOFeatComb
                      =   F vs
                        .     !arg:(?F,?vs) ?arg
                            & (!F,IOcomb$!vs) IOFeatComb$!arg
                          | 
                      )
                    & ( IOcombine
                      =   Name facets
                        .     !arg:(?Name.?facets)+?arg
                            & (!Name.IOFeatComb$!facets)+IOcombine$!arg
                          | 0
                      )
                    & IOcombine$!thisToolProp:?thisToolProp
                    & ( ~&log$DOEHIERIETS
                      | !thisToolProp+!otherToolprop:?toolprop
                      )
                    & saveToolTable$toolprop
                    & (     !tooladm
                          : ?A+(? (ToolID.!ToolName) ?)+?Z
                        & !A+!Z:?tooladm
                      | 
                      )
                    &     !tooladm
                        + (   (ToolID.!ToolName)
                              (PassWord.!PassWord)
                              (ContactEmail.!ContactEmail)
                              (Version.!ToolVersion)
                              (Title.!FullToolName)
                              (ServiceURL.!ToolURL)
                              (Publisher.!ToolPublisher)
                              (ContentProvider.!ContentProvider)
                              (Creator.!ToolCreator)
                              (InfoAbout.!InfoAbout)
                              (Description.!ToolDescription)
                              (ExternalURI.!ToolExternalURI)
                              (XMLparms.!ToolXMLparms)
                              (PostData.!ToolPostData)
                              (Inactive.!ToolInactive)
                          : ?admdata
                          )
                      : ?tooladm
                    & saveToolTable$tooladm
                    & "O.k."
                  |   str
                    $ ( "You need to be logged in to save or replace an active tool. (handle=\""
                        !handle
                        "\")"
                      )
                  )
            )
          & "Body of Register starts here"
          & log$NEW
          & log$INGESTLOGJE
          & 0:?tabind
          & :?hiddenData:?formFields:?Metadata
          & readTable$facets
          & readTable$toolprop
          & readTable$tooladm
          & readTable$features
          & ( !arg:? (handle.?handle) ?
            | :?handle
            )
          & ( !arg:? (passwordAsHandle.?passwordAsHandle) ?
            | (.):?passwordAsHandle
            )
          & ( !arg:? (mail2.?mail2) ?
            | :?mail2
            )
          & (     createBoilerPlate$!arg
                : (?ToolName.?password.?contactEmail.?arg)
              & staticFields$!arg:?formFields
              &     ( h1
                    .   
                      ,     !ToolName:
                          &   localized
                            $ ("Register a new tool" "Registrer et nyt værktøj")
                        |   localized
                          $ ( "Update tool metadata"
                              "Opdater værktøjsoplysninger"
                            )
                    )
                    !formFields
                : ?formFields
              & "
            Decide in how far the features as received in the request string
            (the arg variable) or the features as defined in toolprop.table
            should be used in the ensuing process (storage as needed and
            creation of the form to be returned to the caller):
            One of the submit buttons pressed or tool not defined in 
            toolprop.table (i.e. tool is not integrated): use info from request
            string.
            Otherwise: use metadata from toolprop.table.
            "
              &   (     !arg
                      :   ?
                          ( bsubmit
                          . @(?:(prev|next) #?nth)
                          )
                          ?
                    & "
                  If user wants to navigate to the next or previous incarnation
                  wind to the requested incarnation of tool and read tools'
                  properties from toolprop.table. ZZ is the part of
                  toolprop.table coming after this incarnation of this tool.
                  This variable is later used to decide whether a 'next' button
                  is needed and also to locate the old version of the
                  incarnation if the user wants to remove or replace it.
                  "
                    &   windfw$(!toolprop.!ToolName.!nth)
                      : (?featjursPreexisting.?ZZ.?nth)
                    &   featureListing
                      $ (unfoldInputAndOutput$!featjursPreexisting)
                  |   !arg:? (nth.?nth) ?
                    & "
                  The cardinal number of the incarnation is known.
                  "
                    &   windfw$(!toolprop.!ToolName.!nth)
                      : (?featjursPreexisting.?ZZ.?nth)
                    & (   !arg:? (bsubmit.?) ?
                        & "
                      User presses one of the 'submit' buttons 
                      (!storeToolButton, !replaceToolButton,
                       !deleteToolButton, !UpdateButton, !PHPbutton).
                      The features as shown in the form should overrule the
                      properties as recorded in toolprop.table for this
                      incarnation of the tool, so ignore the preexisting
                      properties.
                      "
                        & !arg
                      |   featureListing
                        $ (unfoldInputAndOutput$!featjursPreexisting)
                      )
                  |     windfw$(!toolprop.!ToolName.0)
                      : (?featjursPreexisting.?ZZ.?nth)
                    & "
                  The cardinal number of the incarnation is not known.
                  Navigate to the first incarnation of the tool.
                  "
                    &   featureListing
                      $ (unfoldInputAndOutput$!featjursPreexisting)
                  |   -1:?nth
                    & "
                  The tool hasn't any features (yet).
                  "
                    & !arg
                  )
                : ?featjursURL
              & "
            Add 'previous' and 'next' buttons as needed.
            "
              & ( !nth:<0
                |   (   !nth:>0
                      &   !formFields submit$(str$(prev !nth+-1))
                        : ?formFields
                    | 
                    )
                  & (   !ZZ:(!ToolName.?)+?
                      &   !formFields submit$(str$(next !nth+1))
                        : ?formFields
                    | 
                    )
                )
              & !formFields helplink$:?formFields
              & !features:?feats
              & "
            Step through the (short) list of features (facet, format, language)
            For each feature, create an input field and collect in the
            formFields variable. The Metadata variable collects the same data
            in a format similar to the format in the toolprop.table.
            "
              & ( 
                |   ( !featjursURL:? (Single.?Single) ?
                    | :?Single
                    )
                  &     !formFields
                          fieldset
                        $ (   localized
                            $ ( "Single/Multiple input(s)"
                                "Én eller flere inputfiler"
                              )
                          .   paragraph
                            $ ( makeCheckboxFormField
                              $ (   localized
                                  $ ( "All inputs in single file"
                                      "Alt input i én fil"
                                    )
                                . Single
                                .   (val.!Single)
                                    ( desc
                                    .   localized
                                      $ ( "Check if there are e.g. >1 input facet or >1 input language, but everything is combined in a single input file."
                                          "Check hvis der fx er > 1 input facet eller > 1 input sprog, men alt er kombineret i én inputfil."
                                        )
                                    )
                                )
                              )
                          )
                    : ?formFields
                )
              &   whl
                ' ( !feats:%?feat+?feats
                  &     askFeature
                      $ (!featjursURL.!feat.!formFields.!Metadata)
                    : (?formFields.?Metadata)
                  )
              & "Metadata: space separated list of (!shortfeatname,!inoutpairs)"
              & foldInputAndOutput$!Metadata:?Metadata
              & no:?force
              & ( 
                |   !Single:on
                  &     map
                      $ ( ( 
                          =   feat vals nvals i o
                            .   !arg:(?feat,?vals)
                              & 0:?nvals
                              &   whl
                                ' ( !vals:(?i.?o)+?vals
                                  & (   !i:%*% ?
                                      & !(glf$('(%.$i))):?i
                                      & yes:?force
                                    | 
                                    )
                                  & !nvals+(!i.!o):?nvals
                                  )
                              & ( !nvals:0&
                                | (!feat,!nvals)
                                )
                          )
                        . !Metadata
                        )
                    : ?Metadata
                  & !Metadata
                | 
                )
              & (!ToolName.!Metadata):?Metadata
              & (   ( !arg:? (bsubmit.?Submit) ?
                    | :?Submit
                    )
                  & (   !Submit:!PHPbutton
                      & wrapper$(PHP.!ToolName)
                    |     (     !Submit
                              : ( !storeToolButton
                                | !replaceToolButton
                                )
                            & (   validationComments
                                $ ( !ToolName
                                  . !PassWord
                                  . !ToolVersion
                                  . !FullToolName
                                  . !ToolURL
                                  . !ToolPublisher
                                  . !ContentProvider
                                  . !ToolCreator
                                  . !InfoAbout
                                  . !ToolDescription
                                  . !ToolExternalURI
                                  . !ToolXMLparms
                                  . !ToolPostData
                                  . !ToolInactive
                                  . !Submit
                                  )
                              |   storeTool
                                $ ( !Metadata
                                  . !ToolName
                                  . !PassWord:?password
                                  . !ContactEmail:?contactEmail
                                  . !ToolVersion
                                  . !FullToolName
                                  . !ToolURL
                                  . !ToolPublisher
                                  . !ContentProvider
                                  . !ToolCreator
                                  . !InfoAbout
                                  . !ToolDescription
                                  . !ToolExternalURI
                                  . !ToolXMLparms
                                  . !ToolPostData
                                  . !ToolInactive
                                  .     !Submit:!storeToolButton
                                      & -1
                                    | !ZZ
                                  . !force
                                  )
                              )
                          |   !Submit:!deleteToolButton
                            & (   !toolprop:?AA+(!ToolName.?)+!ZZ
                                & !AA+!ZZ:?toolprop
                                & saveToolTable$toolprop
                                &   str
                                  $ ( "Deleted current incarnation of tool "
                                      !ToolName
                                    )
                              |     !tooladm
                                  :   ?AA
                                    + (? (ToolID.!ToolName) ?)
                                    + ?ZZ
                                & !AA+!ZZ:?tooladm
                                & saveToolTable$tooladm
                                &   str
                                  $ ( "Deleted administrative metadata of tool "
                                      !ToolName
                                    )
                              )
                          | Updated
                          )
                        : ?error
                      & log$(error !error)
                      &   toML
                        $ ( !HTMLbodyContainer
                          $ ( ( !formFields:
                              |   form
                                $ ( register
                                  .   ( !handle:
                                      | makeHiddenFields$(handle.!handle)
                                      )
                                      !formFields
                                      submit$!storeToolButton
                                      ( !nth:<0&
                                      |   submit$!replaceToolButton
                                          makeHiddenFields$(nth.!nth)
                                      )
                                        makeHiddenFields
                                      $ ( (password.!password)
                                          (   !passwordAsHandle:(.)
                                            & 
                                          | ( passwordAsHandle
                                            . !passwordAsHandle
                                            )
                                          )
                                          ( !mail2:
                                          | (mail2.!mail2)
                                          )
                                          (contactEmail.!contactEmail)
                                        )
                                      submit$!deleteToolButton
                                      submit$!UpdateButton
                                      submit$!PHPbutton
                                      helplink$(usedonly.n)
                                  . POST
                                  )
                              )
                              (p.,!error (br.,))
                              (hr.,)
                            )
                          )
                    )
                | str$("unknown button: " !Submit)
                )
            |   !arg:? (name.?ToolName) ?
              &   update
                $ ( (msg."Forkert adgangskode!")
                    (selected.!ToolName)
                    (password.!password)
                    (contactEmail.!contactEmail)
                    (handle.!handle)
                  )
            |   toML
              $ ( !HTMLbodyContainer
                $ ( paragraph
                  $ ( str
                    $ (   localized
                        $ ( "Email address missing."
                            "Der mangler en email-adresse."
                          )
                        " ('mail2' HTTP parameter)"
                      )
                    )
                  )
                )
            )
      )
      ( removePercentEncodings
      =   A g h
        .   @( !arg
             :   ?A
                 "%"
                 ( %@
                 : ( ~<0:~>9
                   | ~<a:~>f
                   | ~<A:~>F
                   )
                 : ?g
                 )
                 ( %@
                 : ( ~<0:~>9
                   | ~<a:~>f
                   | ~<A:~>F
                   )
                 : ?h
                 )
                 ?arg
             )
          & !A chr$(x2d$(str$(!g !h))) removePercentEncodings$!arg
      )
      "
/*
 * storeUpload
 *
 * Administrate the storage of a copy of a file from repositorium in a place 
 * where a webservice can fetch it - the staging area of the Tools service.
 *
 * Adds an entry to a five-column table Uploads.table. 
 * The first column is unique number generated by adding 1 to the highest 
 * currently occupied number, second is the resource identifier of a 
 * resource that has been copied to a local place, where a webservice can GET
 * it. The third field 
 * contains the name of the resource as the webservice perceives it. It is a
 * concatenation of 'Uploaded' and the number in the first field.)
 * E.g. 
 *      ( 9
 *      . dkclarin:59004
 *      . 19325730679
 *      . 
 *      .
 *      )
 * The resource identifier is going to be used in the new resource's metadata.
 * The missing fifth and sixth fields are later filled out.
 * If the user provides a file by file upload, the second and third column are the same.
 *
 * Input: 
 *      item id (like dkclarin:59004/components/component/dkclarin:59003/content)
 *      date
 *      fk (optional)
 *
 * Affected tables:
 *      Uploads.table
 *
 * Output:
 *      The local file name of the resource (= fourth field)
 *
 * Called from create.java
 */"
      ( storeUpload
      =   nr item fname visibility date enam txe ext
        .   1:?nr
          &   !arg
            : ( ?arg
              .   (?date.?visibility)
                | ?date&:?visibility
              )
          & (   @(!arg:?item "/components/component/" ?)
              & :?ext
            |   !arg:?item
              & (   @(rev$!item:?txe "." ?enam)
                  & (   @( !txe
                         :   ?
                             ( "/"
                             | "\\"
                             | ":"
                             | " "
                             | "?"
                             | "*"
                             | "["
                             | "]"
                             | ";"
                             | "|"
                             | "="
                             | ","
                             )
                             ?
                         )
                      & :?ext
                    |   rev$!enam:?item
                      & str$("." rev$!txe):?ext
                    )
                | :?ext
                )
            )
          & (readTable$Uploads|:?Uploads)
          & (   !Uploads:(?nr.?) ?
              & !nr+1:?nr
            | :?Uploads
            )
          & str$(removePercentEncodings$!item):?item
          & str$(!item "-" !nr):?fname
          &     str
              $ ( vap
                $ ( ( 
                    =   
                      .       !arg
                            : ( "/"
                              | "\\"
                              | ":"
                              | " "
                              | "?"
                              | "*"
                              | "["
                              | "]"
                              | ";"
                              | "|"
                              | "="
                              | ","
                              | "%"
                              | "&"
                              )
                          & "_"
                        | !arg
                    )
                  . !fname
                  )
                )
            : ?fname
          & str$(!fname !ext):?fname
          &   (!nr.str$(!item !ext).!fname..) !Uploads
            : ?Uploads
          & saveTable$Uploads
          & !fname
      )
      " If something went wrong, e.g. an URL that could not be fetched, call unstore. Called from create.java "
      ( unstore
      =   A Z
        .   log$(unstore !arg)
          & readTable$Uploads
          & !Uploads:?A (?.?.!arg..) ?Z
          & !A !Z:?Uploads
          & saveTable$Uploads
      )
      ( percentEncodeURL
      =   pEU
        .   ( pEU
            =   A h
              .   @(!arg:?A (%@:>"~":?h) ?arg)
                & d2x$(asc$!h):?h
                & !A "%" upp$!h pEU$!arg
            )
          & str$(pEU$!arg)
      )
      ( element
      =   name attr content
        .   !arg:(?name.?attr.?content)
          & \r\n (!name.atts$!attr,\r\n !content \r\n) \r\n
      )
      ( select
      =   car cdr a z writeList
        .     ( writeList
              =   pat a z el
                .   !arg:(?pat.?el.?arg)
                  & (   !arg:!pat
                      &   element$(!el..select$!a)
                          writeList$(!pat.!el.!z)
                    | element$(!el..select$!arg)
                    )
              )
            & !arg:%+%
            & writeList$(%?a+%?z.or.!arg)
          | !arg:%*%&writeList$(%?a*%?z.and.!arg)
          |   !arg:%?car %?cdr
            & " " select$!car " " element$(opt..select$!cdr)
          |   !arg:%?car^%?cdr
            & NEWSPEC
            & " " select$!car " " element$(spec..select$!cdr)
          | !arg:(0|1)&
          | !arg
      )
      ( XMLdeclaration
      = ("?"."xml version=\"1.0\" encoding=\"UTF-8\"") \r\n
      )
      ( shared
      =   gspc isp ispc ispcs
        .   !arg:(?gspc.?ispcs)
          & 0:?ispc
          & NEWSPEC
          & (   !gspc+!ispcs
              :   ?
                + ( 2*%@?isp+?
                  & !isp+!ispc:?ispc
                  & ~
                  )
            | !ispc:~0
            | 1
            )
      )
      ( unify
      =     source goal gfield gvalue gopt sopt
          , A Z other gspc sspc gvalues svalues
          , uni R zgvalue asvalue zsvalue tail
        .   !arg:(?source.?goal)
          & ( !goal:&!source
            |   !goal:(?gfield,?gvalues) ?goal
              & (   ~(!source:? (!gfield,?) ?)
                  & unify$(!source.!goal):?other
                  & (!gfield,!gvalues) !other
                |   !source:?A (!gfield,?svalues) ?Z
                  & NEWSPEC
                  &   !gvalues
                    :     ?
                        + ( %(`%?gvalue^?gspc ?gopt)*?zgvalue
                          &   !svalues
                            :   ?
                              +   ?asvalue
                                * (!gvalue^?sspc ?sopt)
                                * ( ?zsvalue
                                  & ( !gopt:!sopt
                                    | !gopt:
                                    | !sopt:
                                    )
                                  & ( !gspc:1
                                    | !sspc:1
                                    |   shared$(!gspc.!sspc)
                                      : ~1
                                      : ?sspc
                                    )
                                  & "asvalue, sopt and zsvalue are empty"
                                  & ( uni
                                    =     ss gs g gp go
                                        , a sp so z tail
                                      .     !arg:(?ss.?gs)
                                          &   1
                                            : (!ss|!gs)
                                        |   !gs:%(%?g^?gp ?go)*?gs
                                          & NEWSPEC
                                          & (   ~(!ss:?*(!g^? ?)*?)
                                              & uni$(!ss.!gs):?tail
                                              & !g*!tail
                                            |     !ss
                                                : ?a*(!g^?sp ?so)*?z
                                              & ( !go:!so
                                                | !go:
                                                | !so:
                                                )
                                              & ( !gp:1
                                                | !sp:1
                                                |   shared$(!gp.!sp)
                                                  : ~1
                                                  : ?sp
                                                )
                                              &   uni$(!a*!z.!gs)
                                                : ?tail
                                              & (!g^!sp !so)*!tail
                                            )
                                    )
                                  &   uni$(!asvalue*!zsvalue.!zgvalue)
                                    : ?tail
                                  & NEWSPEC
                                  & (!gvalue^!sspc !sopt)*!tail:?R
                                  &   unify$(!A !Z.!goal)
                                    : ?other
                                  )
                              + ?
                          )
                        + ?
                        ?
                  & (!gfield,!R) !other
                )
            )
      )
      ( fold
      =   A M Z B a f v1 v2 z
        .       !arg
              :   ?A
                * ( `%?B*?Z
                  &   !B
                    :   ?a
                        (?f,?v1)
                        ( ?z
                        & !Z:?M*(!a (!f,?v2) !z)*?Z
                        )
                  )
            & fold$(!A*(!a (!f,!v1*!v2) !z)*!M*!Z)
          |     !arg
              : ?A*(?a (?f,?v1) ?M (!f,?v2) ?z)*?Z
            & fold$(!A*(!a (!f,!v1*!v2) !M !z)*!Z)
          | !arg
      )
      ( supplyMissingFields
      =     features x outfeat infeat childfeaturevalue
          , childfeaturevalues featurename featurevalue
          , nfeatures xs v getChildVal cleanSum
        .     !arg:(?outfeat.?infeat.?features)
            & :?nfeatures
            &   whl
              ' (   !features
                  : (?featurename,?featurevalue) ?features
                & ( !outfeat:? (!featurename,?) ?
                  |     !nfeatures
                        ( !featurename
                        ,   ( cleanSum
                            =   A M Z
                              .   (   !arg:#%+?arg
                                    & cleanSum$!arg
                                  |   !arg:?A+#%*?M+?Z
                                    & cleanSum$(!A+!M+!Z)
                                  )
                                | !arg
                            )
                          & ( getChildVal
                            =   val A v
                              .     !arg:(?val.?arg)
                                  & !arg:((?A.?)|?A)
                                  & fold$!A:?A
                                  & !A:? (!val,?v) ?
                                  & !v
                                | 0
                            )
                          &   getChildVal$(!featurename.!infeat)
                            : ?childfeaturevalues
                          & 0:?xs
                          &   whl
                            ' (   !childfeaturevalues
                                : %?childfeaturevalue^?+?childfeaturevalues
                              &   !featurevalue
                                :   ?
                                  + (?+!childfeaturevalue^?+? ?.?x)
                                  + ?
                              & ( !xs:?+!x+?
                                | !x+!xs:?xs
                                )
                              )
                          & !xs
                        )
                    : ?nfeatures
                  )
                )
            &   map
              $ ( (=.!arg:~(?,)|)
                . !nfeatures
                )
          | !outfeat
      )
      ( differentOutput
      =     fields otherPath otherPaths otherFields
          , same other A Z apathfld apathflds
        .   !arg:(?fields.?otherPaths)
          & 0:?same:?other
          &   whl
            ' (   !otherPaths
                : ((?,(?otherFields.?)):?otherPath)+?otherPaths
              & !fields:?apathflds
              &   whl
                ' ( !apathflds:%?apathfld ?apathflds
                  & !otherFields:?A !apathfld ?Z
                  & !A !Z:?otherFields
                  )
              & (   !apathflds:
                  & !otherFields:
                  & !same+!otherPath:?same
                | !other+!otherPath:?other
                )
              )
          & !other:~0
          & (!same.!other)
      )
      ( unfoldIfDivertingOutputs
      =     tool ou apath A Z fields
          , pathsWithSameOutputAsApath pathsWithOtherOutputAsApath
          , goal inputprop
        .       !arg
              : ( ?tool
                , (?ou.?inputprop.((?,(?fields.?)):?apath)+?Z)
                )
            &   differentOutput$(!fields.!Z)
              : (?pathsWithSameOutputAsApath.?pathsWithOtherOutputAsApath)
            &   (!tool,(!ou.!inputprop.!apath+!pathsWithSameOutputAsApath))
              +   unfoldIfDivertingOutputs
                $ (!tool,(!ou.!inputprop.!pathsWithOtherOutputAsApath))
          |   !arg:(?goal.%?A+%?Z)
            &   (!goal.unfoldIfDivertingOutputs$!A)
              + (!goal.unfoldIfDivertingOutputs$!Z)
          | !arg
      )
      ( nofoldCount
      =   tool ou inputprop childstuff A Z goal inputprop
        .     !arg:%?A*%?Z
            & nofoldCount$!A*nofoldCount$!Z
          |   !arg:%?A+%?Z
            & nofoldCount$!A+nofoldCount$!Z
          |   !arg:(?goal.?childstuff)
            & nofoldCount$!childstuff
          |   !arg:(?tool,(?ou.?inputprop.?childstuff))
            & nofoldCount$!childstuff:?childstuff
          | 1
      )
      ( unfoldCount
      =     tool ou ou2 inputprop childstuff A Z goal
          , inputprop feature
        .     !arg:%?A*%?Z
            & unfoldCount$!A*unfoldCount$!Z
          |   !arg:%?A+%?Z
            & unfoldCount$!A+unfoldCount$!Z
          |   !arg:(?goal.?childstuff)
            & unfoldCount$!childstuff
          |     !arg
              : ( ?tool
                , ( ?A (?feature,%?ou+%?ou2) ?Z
                  . ?inputprop
                  . ?childstuff
                  )
                )
            &     unfoldCount
                $ ( !tool
                  , ( !A (!feature,!ou) !Z
                    . !inputprop
                    . !childstuff
                    )
                  )
              +   unfoldCount
                $ ( !tool
                  , ( !A (!feature,!ou2) !Z
                    . !inputprop
                    . !childstuff
                    )
                  )
          |   !arg:(?tool,(?ou.?inputprop.?childstuff))
            & unfoldCount$!childstuff:?childstuff
          | 1
      )
      ( graphCount
      =   ou parent siblings child A seen ret sibl
        .   !arg:(?parent.?siblings.?child)
          & (   !child:%*%:?seen
              & 1:?sibl
              &   whl
                ' ( !child:%?A*?arg
                  &   graphCount$(!parent !seen.!sibl.!A)
                    : (?sibl.?ret)
                  )
              & !seen
            |   !arg:%+%:?seen
              & 0:?ret
              &   whl
                ' ( !arg:%?A+?arg
                  & !ret+(!seen.!A.graphCount$!A):?ret
                  )
              & !ret
            | !arg:(?.?child)&graphCount$!child
            |   !arg:(?,(?ou.?.?child))
              & graphCount$!child:?seen
              & ( 
                |   whl
                  ' ( !ou:? ((?,%+%):?A) ?ou
                    & !seen*!A:?seen
                    )
                )
              & !seen
            | 1
            )
      )
      ( leaveFeat
      =   A
        .     !arg:%?A*%?arg
            & leaveFeat$!A*leaveFeat$!arg
          | !arg:(?,(?.?.?.?arg))&leaveFeat$!arg
          | !arg:(?,(?.?.?arg))&!arg
          |   !arg:(?.(?,?):?arg)
            & leaveFeat$!arg
          | !arg:(@,?) ?
      )
      ( subtract
      =   all org
        .   !arg:(?all.?org)
          &   map
            $ ( ( 
                =   f
                  .   !arg:(?f,?)
                    & ( !org:? (!f,?) ?&
                      | !arg
                      )
                )
              . !all
              )
      )
      ( ItExplodes
      =     spotSum OUT WAY M bignumber
          , seen ID depend getID prun
          , depends in pruns sums sumsizes
        .   :?seen
          & :?sumsizes
          & -1:?ID
          & !arg:?in
          & ( getID
            =   m l
              .   !ID+1:?ID
                & mod$(!ID,26):?m
                & div$(!ID,26):?l
                & str$(chr$(!m+asc$a) !l)
            )
          & ( spotSum
            =   a b L M
              .   !seen:? (!arg.?L) ?&!L
                |   !arg:%*%
                  & :?b
                  &   whl
                    ' ( !arg:%?a*?arg
                      & (   !seen:? (!a.?L) ?
                          & !b !L:?b
                        |   spotSum$!a:?L
                          & ( !L:
                            |   (factor,getID$.!L):?L
                              & (!a.!L) !seen:?seen
                              & !b !L:?b
                            )
                        )
                      )
                  & ( !b:
                    |   (!arg.prod,getID$.!b):?b
                      & !b !seen:?seen
                      & !b:(?.?b)
                      & !b
                    )
                |   !arg:%+%
                  &   ( !arg
                      . sum,getID$:?M
                      .   :?b
                        &   whl
                          ' ( !arg:%?a+?arg
                            & (   !seen:? (!a.?L) ?
                                & !b !L:?b
                              |     (term,getID$.spotSum$!a)
                                  : ?L
                                & (!a.!L) !seen:?seen
                                & !b !L:?b
                              )
                            )
                        & !b:? [?L
                      )
                    : ?b
                  & !b !seen:?seen
                  & (!M.!L) !sumsizes:?sumsizes
                  & !b:(?.?b)
                  & !b
                |   !arg:(?,(?.?.?.?arg))
                  & spotSum$!arg
                | 
            )
          & ( prun
            =   a b L
              .     !arg:(?a,?L.?b) ?arg
                  & (!a,!L.prun$!b):?b
                  &   (   !b:(prod,?.?,?.?b)
                        & !b
                      |   !b:(factor,?L.term,?.)
                        & 
                      |   !b:(factor,?L.term,?.?b)
                        & (factor,!L.!b)
                      |   !b:(term,?L.prod,?.)
                        & (term,!L.)
                      | !b:(factor,?.)&
                      |   !b:(term,?L.term,?.)
                        & (term,!L.)
                      | !b
                      )
                      prun$!arg
                | !arg
            )
          & ( depend
            =   a b L d M e f s N
              .     !arg:(?a,?L.?b) ?arg
                  & (!a,!L.depend$!b):?b
                  &   (   !b:(prod,?M.?s)
                        & 1:?e
                        & 1:?N
                        &   map
                          $ ( ( 
                              =   f n
                                .       !arg
                                      : ((?.?f.?n),?.?)
                                    & ( !e:?*!f*?
                                      | !N*!n:?N
                                      )
                                    & !f*!e:?e
                                  | 
                              )
                            . !s
                            )
                        & ((prod.!e.!N),!M.!s)
                      |     !b
                          : ( factor,?M
                            . (sum.?e.?N),?L
                            . ?f
                            )
                        & ( (factor.!L !e.!N),!M
                          . sum !e,!L
                          . !f
                          )
                      |   !b:(sum,?M.?s)
                        & 0:?N
                        & 0:?e
                        &   map
                          $ ( ( 
                              =   f n
                                .       !arg
                                      : ((?.?f.?n),?.?)
                                    & !N+!n:?N
                                    & ( !f:
                                      | !f+!e:?e
                                      )
                                  | 
                              )
                            . !s
                            )
                        & (   (sum.!e:~0|.!N)
                            , !M
                          . !s
                          )
                      |   !b:(?a,?M.)
                        & ((!a..1),!M.)
                      |     !b
                          : (?a,?M.(?s.?e.?N),?f.?d)
                        & ( (!a.!e.!N),!M
                          . (!s.!e.!N),!f
                          . !d
                          )
                      | !b
                      )
                      depend$!arg
                | !arg
            )
          & 0:?bignumber
          &   whl
            ' ( !in:#*(?OUT.?WAY)+?in
              & spotSum$!WAY:?sums
              & prun$!sums:?pruns
              & depend$!pruns:?depends
              & !depends:((?.?.?bignumber),?.)
              & (~|!bignumber:<250000)
              )
          & log$(bignumber !bignumber)
          & !bignumber:~<140000
      )
      ( selectCommonTracks
      =   sum spotSum eliminate OUT WAY TERM result term
        .   ( spotSum
            =   a sum
              .     !arg:%*%
                  & (   !arg:?*(?,(?.?.?.%+%:?sum))*?
                      & !sum
                    |   !arg:%?a*%?arg
                      & (spotSum$!a|spotSum$!arg)
                    )
                | !arg:%+%:?sum&!sum
                |   !arg:(?,(?.?.?.?arg))
                  & spotSum$!arg
            )
          & ( eliminate
            =   term O R T o i W S J P F D s
              .   !arg:(?arg.?term)
                & (   !arg:(?O.?W)
                    & ( !O
                      .     !W:%*%:?S
                          & 1:?R
                          &   whl
                            ' ( !S:%?s*?S
                              &     !R
                                  * (   !s:(?T,(?o.?i.?J))
                                      & (!T,(!o.!i.eliminate$(!J.!term)))
                                    | !s
                                    )
                                : ?R
                              )
                          & !R
                        |   !W:%+%
                          & ( !W:?+!term+?&!term
                            |   !W:?S
                              & 0:?R
                              &   whl
                                ' ( !S:%?P+?S
                                  & 1:?D
                                  &   whl
                                    ' ( !P:%?F*?P
                                      &     !D
                                          * (   !F:(?T,(?o.?i.?J))
                                              & ( !T
                                                , ( !o
                                                  . !i
                                                  . eliminate$(!J.!term)
                                                  )
                                                )
                                            | !F
                                            )
                                        : ?D
                                      )
                                  & !R+!D:?R
                                  )
                              & !R
                            )
                        |   !W:(?T,(?o.?i.?J))
                          & (!T,(!o.!i.eliminate$(!J.!term)))
                        | !W
                      )
                  | !arg
                  )
            )
          & 0:?result
          &   whl
            ' ( !arg:#*(?OUT.?WAY)+?arg
              & (   spotSum$!WAY:?sum
                  & 0:?TERM
                  &   whl
                    ' ( !sum:%?term+?sum
                      &   !TERM+eliminate$((!OUT.!WAY).!term)
                        : ?TERM
                      )
                  & !TERM+!arg:?arg
                | !result+(!OUT.!WAY):?result
                )
              )
          & !result
      )
      ( createNewGoal
      =   toolFeatures rfield rvals rins rin newGoal RI
        .   !arg:(?newGoal.?toolFeatures)
          &   whl
            ' ( !toolFeatures:(?rfield,?rvals) ?toolFeatures
              & 0:?rins
              &   whl
                ' ( !rvals:(?rin.?)+?rvals
                  &   whl
                    ' ( !rin:%?RI+?rin
                      & ( !rins:?+!RI+?
                        | !RI+!rins:?rins
                        )
                      )
                  )
              & (!rfield,!rins) !newGoal:?newGoal
              )
          & !newGoal
      )
      (NA=|"?"|0)
      ( product
      =   a
        .   !arg:%?a %?arg&!a*product$!arg
          | !arg
      )
      ( matchGoalWithFeatures
      =     goal toolFeatures
          , newGoal pathfields gfield gvaluesAlts ngoal
          , Ar Zr gvaluePoss gspc ispc gvaluesAlt
          , input A Z oinput gval done
          , matchAlternative matchOutputAlternative
          , nnewGoal toolfeat
        .   ( matchOutputAlternative
            =     outAlt gvaluesAlt len gvaluePoss gspc ispc
                , PathPart
              .   !arg:(?outAlt.?gvaluesAlt)
                & !outAlt:? [?len
                & !gvaluesAlt:? [!len
                & 1:?PathPart
                &   whl
                  ' ( !gvaluesAlt:%@?gvaluePoss^?gspc*?gvaluesAlt
                    &   !outAlt
                      :     !gvaluePoss
                          ^ ( (   ~1:?ispc
                                &   shared$(!gspc.!ispc)
                                  : ( ~1:?ispc
                                    | ?&!gspc:1
                                    )
                              |   ?ispc
                                : ( 1
                                  | ?&!gspc:1
                                  )
                              )
                            & !PathPart*!gvaluePoss^!ispc:?PathPart
                            )
                        * ?outAlt
                    )
                & 1:!gvaluesAlt:!outAlt
                & !PathPart
            )
          & ( matchAlternative
            =     toolfeat gvaluesAlt toolAlt input gfield
                , oinput A Z done newGoal
                , PathPart outAlt
              .   !arg:(?toolfeat.?gvaluesAlt.?gfield.?newGoal)
                & 0:?done
                &   whl
                  ' ( !toolfeat:%?toolAlt+?toolfeat
                    & (   !toolAlt
                        : ( ?input
                          .   !NA
                            |     ?
                                + ( `%?outAlt
                                  &     matchOutputAlternative
                                      $ (!outAlt.!gvaluesAlt)
                                    : ?PathPart
                                  )
                                + ?
                              &   (     !pathfields
                                      : ?A (!gfield,?gval) ?Z
                                    &   !A
                                        ( !gfield
                                        ,   !gval:?+!PathPart+?
                                          | !gval+!PathPart
                                        )
                                        !Z
                                  | !pathfields (!gfield,!PathPart)
                                  )
                                : ?pathfields
                              &   (     !newGoal
                                      : ?A (!gfield,?oinput) ?Z
                                    & !A (!gfield,!oinput+!input) !Z
                                  | !newGoal (!gfield,!input)
                                  )
                                : ?newGoal
                              & 1+!done:?done
                          )
                      | 
                      )
                    )
                & !done:~0
                & !newGoal
            )
          & !arg:(?goal.?toolFeatures)
          & :?newGoal
          & :?pathfields
          & 0:?done
          &   whl
            ' ( !goal:(?gfield,?gvaluesAlts) ?ngoal
              & "Each goal field must be satisfied."
              & (   ( ~(!toolFeatures:? (!gfield,?) ?)
                    | !goal:(sml,nsl)
                    )
                  & "Assume that tool leaves field unchanged: percolate output requirement to input."
                  & !pathfields (!gfield,!gvaluesAlts):?pathfields
                  & !newGoal (!gfield,!gvaluesAlts):?newGoal
                |   !toolFeatures:?Ar (!gfield,?toolfeat) ?Zr
                  & "toolfeat is a sum of alternative (input.output) specs."
                  & !Ar !Zr:?toolFeatures
                  & 0:?done
                  & "gvaluesAlts is a sum of alternative goal specifications for a single feature. 
                     A term can be the product of multiple feature values, e.g. @(lem*pos*syn) for the feature 'facet'."
                  &   whl
                    ' ( !gvaluesAlts:%?gvaluesAlt+?gvaluesAlts
                      & (   "matchAlternative can fail"
                          &     matchAlternative
                              $ (!toolfeat.!gvaluesAlt.!gfield.!newGoal)
                            : ?newGoal
                          & 1:?done
                        | 
                        )
                      )
                  & "If this test fails, none of the goal feature values is satisfied by the current tool.
                       Consequence: whl loop is exited and 'goal' does not get nil, causing matchGoalWithFeatures to fail."
                  & !done:1
                )
              & !ngoal:?goal
              )
          & "Each field must match"
          & !goal:
          & createNewGoal$(!newGoal.!toolFeatures):?nnewGoal
          & ( !newGoal:!nnewGoal
            |   (   !tool
                  : (json2org|PruLePo|lempos)
                | 
                )
              & !nnewGoal:?newGoal
            )
          & (!pathfields.sort$!newGoal)
      )
      "
/**
 * Check that pipes having multiple tasks running in parallel have compatible features and feature specialisations.
 */"
      ( illegalSolution
      =     goal pipes toolA toolB outputA outputB inputA inputB
          , vA featA vB agree explicitlySanctioned
          , WRONGPIPES OKPIPES pipe npipes
        .   !arg:(?goal.?pipes)
          & ( agree
            =   a ea b eb E
              .   !arg:(%?a^?ea.%?b^?eb)
                & !a:!b
                & NEWSPEC
                & ( !ea:1
                  | !eb:1
                  | !ea:?+(%@?E&!eb:?+!E+?)+?
                  )
            )
          & ( explicitlySanctioned
            =   feat v goal v2
              .   !arg:(?feat,?v.?goal)
                &   !goal
                  :   ?
                    * ( ?
                        (!feat,?v2&agree$(!v.!v2))
                        ?
                      )
                    * ?
            )
          & 0:?OKPIPES
          & 0:?WRONGPIPES
          & ( 
            |   !pipes:?+[?npipes
              & log$(illegalSolution npipes !npipes)
            )
          &   whl
            ' ( !pipes:%?pipe+?pipes
              & (     !pipe
                    :   ?
                      * (?toolA,(?outputA.?inputA.?))
                      * ?
                      * ( ?toolB
                        ,   (?outputB.?inputB)
                          &   !outputA
                            :   ?
                                ( ?featA
                                ,   ?vA
                                  & !outputB:? (!featA,?vB) ?
                                  & ~(agree$(!vA.!vB))
                                  & ( ~( explicitlySanctioned
                                       $ (!featA,!vA.!goal)
                                       )
                                    | ~( explicitlySanctioned
                                       $ (!featA,!vB.!goal)
                                       )
                                    )
                                )
                                ?
                        )
                      * ?
                  &     ( !featA vA !vA vB !vB outputB !outputB
                        . !pipe
                        )
                      + !WRONGPIPES
                    : ?WRONGPIPES
                | !pipe+!OKPIPES:?OKPIPES
                )
              )
          & !WRONGPIPES:~0
          & (!WRONGPIPES.!OKPIPES)
      )
      ( refold
      =     A M Z AM MM ZM AZ MZ ZZ ag zg feat
          , val valZ feats featsZ tool g gZ substitute
          , ZMM
        .   ( substitute
            =   a b s d
              .   !arg:(?arg.?s.?d)
                & ( !arg:!s&!d
                  |   !arg:?a_?b
                    & (substitute$(!a.!s.!d))_(substitute$(!b.!s.!d))
                  | !arg
                  )
            )
          &   whl
            ' (   !arg
                :   ?A
                  + `%?M
                  + ( ?Z
                    &   !Z
                      :   ?AZ
                        + ( `%?MZ
                          &   !M
                            :   ?AM
                              * `%?MM
                              * ( ?ZM
                                & !MZ:!AM*?ZMM*!ZM
                                & !MM:~!ZMM
                                & !MM:(?g.?tool,?feats)
                                & !ZMM:(?gZ.!tool,?featsZ)
                                &   !g
                                  :   ?ag
                                      (?feat,?val)
                                      ( ?zg
                                      &   !gZ
                                        : !ag (!feat,?valZ) !zg
                                      & !val:~!valZ
                                      &     substitute
                                          $ (!feats.!feat,!val.)
                                        :   substitute
                                          $ (!featsZ.!feat,!valZ.)
                                      )
                                )
                          )
                        + ?ZZ
                    )
              &     !A
                  +   !AM
                    *   substitute
                      $ (!MM.!feat,!val.!feat,!val+!valZ)
                    * !ZM
                  + !AZ
                  + !ZZ
                : ?arg
              )
          & !arg
      )
      "20111024 collect worked only if the first argument was output from a 
       previous step, not if it was the very first input."
      ( collect
      =     f v outp a featprod alts opts partOf V remainder
          , actualOptions A Z common partOfFunc vs strictPartOf
        .   !arg:(?arg.?f,?v.?vs)
          & ( partOf
            =   a z S Z spc
              .   !arg:(1.?a)&!a
                |     !arg
                    : ( %@?S^?spc*?Z
                      .   ?a
                        * `( !S
                           ^ ( !spc
                             | ?&1:!spc
                             | 1
                             )
                           )
                        * ?z
                      )
                  & partOf$(!Z.!a*!z)
            )
          & ( strictPartOf
            =   a z S Z
              .   !arg:(1.?a)&!a
                |   !arg:(%?S*?Z.?a*`!S*?z)
                  & strictPartOf$(!Z.!a*!z)
            )
          & (     fct$!vs
                :   ?
                  * %(%?V+!V^%&!v:? ?*!V^?*? ?)
                  * ?
              & '$strictPartOf:(=?partOfFunc)
            | '$partOf:(=?partOfFunc)
            )
          & ( actualOptions
            =   a z S Z spc spc2
              .   !arg:(1.?)&1
                |   !arg:(%@?S^?spc*?Z.?z)
                  & NEWSPEC
                  & (     !z
                        :   ?a
                            `( !S
                             ^ ( !spc
                               | ?spc2&1:!spc
                               )
                             )
                            ?z
                      & !S^!spc2*actualOptions$(!Z.!a !z)
                    | actualOptions$(!Z.!z)
                    )
            )
          & 0:?outp
          & (!v:%?v %?opts|1:?opts)
          & !arg:?alts
          &   whl
            ' ( !alts:%?a+?alts
              & (   !a:(?featprod.?)*?
                  & (     fold$!featprod
                        :   ?
                          * ( ?
                              ( !f
                              ,   ?
                                + ( `%?V
                                  & partOfFunc$(!v.!V):?remainder
                                  & partOf$(!remainder.!opts)
                                  )
                                + ?
                              )
                              ?
                            )
                          * ?
                      & !a+!outp:?outp
                    | 
                    )
                |   !a:?featprod
                  & (     fold$!featprod
                        :   ?A
                            ( !f
                            ,   ?V
                              & partOf$(!v.!V):?remainder
                              &   !v*actualOptions$(!remainder.!opts)
                                : ?common
                            )
                            ?Z
                      & (!A (!f,!common) !Z)+!outp:?outp
                    | 
                    )
                | !a+!outp:?outp
                )
              )
          & !outp
      )
      ( distribute
      =     Res prop input a f vs z aa v
          , incarnationInput
        .   !arg:(?prop.?input)
          & (   !prop:?a (?f,%+%:?vs) ?z
              & 0:?Res
              & !vs:?aa
              &   whl
                ' ( !aa:`%?v+?aa
                  &   collect$(!input.!f,!v.!vs)
                    : ?incarnationInput
                  &     ( !incarnationInput:0
                        |   distribute
                          $ (!a (!f,!v) !z.!incarnationInput)
                        )
                      + !Res
                    : ?Res
                  )
              & !Res
            | !arg
            )
      )
      (assert=.!arg)
      ( restrictOutputParms
      =     pathh toolFeatures outp tool ou prop in nou
          , v e es A f a b Z
        .   !arg:(?pathh.?toolFeatures)
          &   whl
            ' ( !pathh:(?tool,(?ou.?prop.?in))+?pathh
              &     map
                  $ ( ( 
                      =   f vs val nvs i v e
                        .       !arg
                              : ( ?f
                                ,   ( %+%:?vs
                                    |   ?v^(%+%:?es)
                                      & 0:?vs
                                      &   whl
                                        ' ( !es:%?e+?es
                                          & !v^!e+!vs:?vs
                                          )
                                    )
                                  &   !toolFeatures
                                    : ? (!f,?val) ?
                                )
                            & 0:?nvs
                            &   whl
                              ' ( !vs:%?v^?e+?vs
                                & (     !val
                                      : ( 0
                                        |   ?
                                          + ( (?i.?+?*!v^(?+!e+?)*?+?)
                                            &   !prop
                                              :   ?
                                                  (!f,?+?*!i^?*?+?)
                                                  ?
                                            )
                                          + ?
                                        )
                                    & !nvs+!v^!e:?nvs
                                  | 
                                  )
                                )
                            & (!f,!nvs)
                          | !arg
                      )
                    . !ou
                    )
                : ?nou
              & :?outp
              &   whl
                ' ( !nou:?A (?f,%?a+%?b) ?Z
                  &     !outp
                        (!tool,(!A (!f,!a) !Z.!prop.!in))
                    : ?outp
                  & !A (!f,!b) !Z:?nou
                  )
              & !outp (!tool,(!nou.!prop.!in)):?outp
              )
          & !outp
      )
      ( fp
      =     tool source goal restriction superset makeSmell
          , fulfil memoizedSteps activeTools Calls smell
          , memos reslt duplic impassages notttcnt getSuperGoals
          , sourcegoalmatch unfulfillable notThisTool fulfilGoal
          , isfulfilled hasfulfilled fulfilGoalProduct unfoldGoal
          , getActiveTools getGoals getImplicatedGoals
        .   0:?smell
          & ( makeSmell
            =   A Z o
              .     !arg:?A (sml,(?o.nsl)) ?Z
                  &   !A
                      (sml,(!o.str$(S (1+!smell:?smell))))
                      !Z
                | !arg
            )
          & ( isfulfilled
            =   source src goal gl tool pipe pipes
              .   !arg:(?source.?goal.?tool)
                & product$!source:?src
                & product$!goal:?gl
                & 0:?pipes
                & (   !memoizedSteps
                    :   ?
                      + ( !src
                        . !gl
                        .   ?
                          + ( (!tool,?):?pipe
                            & !pipe+!pipes:?pipes
                            & ~
                            )
                          + ?
                        )
                      + ?
                  | !pipes:~0&(!source.!goal.!pipes)
                  )
            )
          & ( hasfulfilled
            =   source src goal gl term a b m,pipe
              .   !arg:(?source.?goal.?pipe)
                &   ( product$!source:?src
                    . product$!goal:?gl
                    . !pipe
                    )
                  : ?term
                & (   !memoizedSteps:?+!term+?
                    & 1+!duplic:?duplic
                  |   !memoizedSteps:?a+(!src.!gl.?m)+?b
                    & (   !m:?+!pipe+?
                        & 1+!duplic:?duplic
                      | !a+(!src.!gl.!m+!pipe)+!b:?memoizedSteps
                      )
                  | !term+!memoizedSteps:?memoizedSteps
                  )
                & !arg
            )
          & ( fulfilGoal
            =     tools forkk goaly
                , toolspath pathsonetool tool ltools path1
                , toolFeatures pathh pathfields newGoal infeat
                , memopaths restriction
                , goal source I IO O Os sourcePlus
              .   "Check whether source and goal already have been connected by tool and stored as a step."
                & !arg:(?source.?goaly.?tools.?restriction.?forkk)
                & !forkk:~0
                &     (     (unfulfillable..find)$(str$!goaly)
                          : ? (?.!source) ?
                        & 1+!impassages:?impassages
                        & 0
                      |   unify$(!source.fold$!goaly):?sourcePlus
                        & 1+!sourcegoalmatch:?sourcegoalmatch
                        & sort$!sourcePlus
                      |     (!restriction:~0|!tools)
                          : ?ltools
                        & 0:?toolspath
                        &   whl
                          ' ( !forkk:~0
                            & !ltools:(?tool.?)+?
                            & 0:?pathsonetool
                            & (     (notThisTool..find)$(str$!goaly)
                                  : ? (?.!tool.!source) ?
                                & whl'(!ltools:(!tool.?)+?ltools)
                                & 1+!notttcnt:?notttcnt
                              |     isfulfilled$(!source.!goaly.!tool)
                                  : (?source.?goal.?memopaths)
                                & 1+!memos:?memos
                                & whl'(!ltools:(!tool.?)+?ltools)
                                &   denumerizeSum$(!toolspath+!memopaths)
                                  : ?toolspath
                                & 1+!pathsonetool:?pathsonetool
                              |   whl
                                ' (   !ltools
                                    :   ?
                                      + (!tool.~:?toolFeatures)
                                      + ?ltools
                                  &   makeSmell$!toolFeatures
                                    : ?toolFeatures
                                  & (   !tool
                                      : ( Tesseract-OCR
                                        | CuneiForm
                                        )
                                    | 
                                    )
                                  & (       matchGoalWithFeatures
                                          $ (!goaly.!toolFeatures)
                                        : (?pathfields.?newGoal)
                                      & (       fulfil
                                              $ ( !tools
                                                . !source
                                                . !newGoal
                                                . !indent+1
                                                . 0
                                                )
                                            : ?pathh
                                          &   removeNumFactors$!pathh
                                            : ?infeat
                                          &   distribute$(!newGoal.!infeat)
                                            : ?IO
                                          & 0:?memopaths
                                          &   whl
                                            ' ( !IO:(?I.?Os)+?IO
                                              &   whl
                                                ' ( !Os:%?O+?Os
                                                  &   ( !tool
                                                      , (   sort
                                                          $ ( !pathfields
                                                                supplyMissingFields
                                                              $ ( !pathfields
                                                                . !O
                                                                . !toolFeatures
                                                                )
                                                            )
                                                        . !I
                                                        . !O
                                                        )
                                                      )
                                                    : ?pathh
                                                  & (   assert
                                                      ' ( !pathh
                                                        : ~( ?
                                                           + ( ?
                                                             , (   ?
                                                                   ( ?
                                                                   ,   %+%
                                                                     | %^(%+%)
                                                                   )
                                                                   ?
                                                               . ?
                                                               . ?
                                                               )
                                                             )
                                                           + ?
                                                           )
                                                        )
                                                    |     restrictOutputParms
                                                        $ (!pathh.!toolFeatures)
                                                      : ?pathh
                                                    )
                                                  &   whl
                                                    ' (   !pathh
                                                        : %?path1 ?pathh
                                                      & (   !toolspath
                                                          : ?+!path1+?
                                                        |       !toolspath
                                                              + !path1
                                                            : ?toolspath
                                                          &     !memopaths
                                                              + !path1
                                                            : ?memopaths
                                                        )
                                                      )
                                                  )
                                              )
                                          &   1+!pathsonetool
                                            : ?pathsonetool
                                          &   hasfulfilled
                                            $ (!source.!pathfields.!memopaths)
                                          & ( !goaly:!pathfields
                                            |   hasfulfilled
                                              $ (!source.!goaly.!memopaths)
                                            )
                                        | 0:?pathh
                                        )
                                    | "Tool's output does not match goal"
                                    )
                                  )
                              )
                            & (   !pathsonetool:0
                                &   (notThisTool..insert)
                                  $ (str$!goaly.!tool.!source)
                              | 
                              )
                            )
                        & "forkk will become zero if no tools can fulfil goaly!"
                        & (   !toolspath:0
                            &   (unfulfillable..insert)
                              $ (str$!goaly.!source)
                          | 
                          )
                        & !toolspath
                      | 0
                      )
                    * !forkk
                  : ?forkk
                & 1+!forkk+-1
            )
          & ( fulfilGoalProduct
            =   goalterm tools forkk goaly restriction source
              .   "Check whether source and goal already have been connected by tool and stored as a step."
                & !arg:(?source.?goalterm.?tools.?restriction)
                & 1:?forkk
                & (   "Test if % prepended. If no, split product."
                    & 1:!(glf$('($goalterm.?)))*?
                    &   whl
                      ' ( !forkk:~0
                        & !goalterm:%?goaly*?goalterm
                        &     fulfilGoal
                            $ (!source.!goaly.!tools.!restriction.!forkk)
                          : ?forkk
                        )
                  |     fulfilGoal
                      $ (!source.!goalterm.!tools.!restriction.!forkk)
                    : ?forkk
                  )
                & 1+!forkk+-1
            )
          & " unfoldGoal:
              Construct all 2^n combinations of n options,
              and unfold all alternatives.
              Output: a list of disambiguated goals."
          & ( unfoldGoal
            =     A Z AA ZZ AAA ZZZ M1 M2 prod
                , gfield gopts convertOptionsToAlternatives
              .   ( convertOptionsToAlternatives
                  =   gopt gopts gvaluesAlts
                    .   !arg:%?gvaluesAlts ?gopts
                      &   whl
                        ' ( !gopts:%?gopt ?gopts
                          &   !gvaluesAlts+!gvaluesAlts*!gopt
                            : ?gvaluesAlts
                          )
                      & !gvaluesAlts
                  )
                &   whl
                  ' (   !arg
                      :   ?A
                        +   ?AA
                          * ( ?AAA
                              (?gfield,(% %|%+%):?M1)
                              ?ZZZ
                            )
                          * ?ZZ
                        + ?Z
                    & convertOptionsToAlternatives$!M1:?M1
                    & !A+!Z:?arg
                    &   whl
                      ' ( !M1:%?M2+?M1
                        &   !arg+!AA*(!AAA (!gfield,!M2) !ZZZ)*!ZZ
                          : ?arg
                        )
                    )
                &   whl
                  ' (   !arg
                      :   ?A
                        +   ?AA
                          * ( ?AAA
                              ( ?gfield
                              ,   %?M1*%?M2:?prod
                                & "Test if % prepended. If yes, do nothing to split product."
                                & 1:!(glf$('($prod.?)))*?
                              )
                              ?ZZZ
                            )
                          * ?ZZ
                        + ?Z
                    &     !A
                        +   !AA
                          * (!AAA (!gfield,!M1) !ZZZ)
                          * (!AAA (!gfield,!M2) !ZZZ)
                          * !ZZ
                        + !Z
                      : ?arg
                    )
                & !arg
            )
          & ( fulfil
            =     tools source goal sourcePlus forkk found
                , goals goalterm nnnpathh indent accPipelines
                , Pipeline WRONGPIPES OKPIPES restriction
              .   !arg:(?tools.?source.?goal.?indent.?restriction)
                & "Restrict path length to max 20"
                & !indent:<20
                & 1+!Calls:?Calls
                & 0:?accPipelines
                & unfoldGoal$!goal:?goals
                & 0:?found
                &   whl
                  ' ( !goals:%?goalterm+?goals
                    & (     (     unify$(!source.fold$!goalterm)
                                : ?sourcePlus
                              & sort$!sourcePlus
                            |       fulfilGoalProduct
                                  $ (!source.!goalterm.!tools.!restriction)
                                : ?forkk
                              &   (     !forkk
                                      : ( 0
                                        | 1
                                        | ?+[>2000
                                        )
                                    & 0
                                  |     illegalSolution$(!goalterm.!forkk)
                                      : (?WRONGPIPES.?OKPIPES)
                                    & (!goalterm.!OKPIPES)
                                  | (!goalterm.!forkk)
                                  )
                                : ~0
                                : ?nnnpathh
                              & refold$!nnnpathh
                            )
                          : ?Pipeline
                        & 1+!found:?found
                        & !Pipeline+!accPipelines:?accPipelines
                      | 
                      )
                    )
                & ( !accPipelines:~0
                  | !found:~0&0
                  )
            )
          & ( getActiveTools
            =   T F L
              .   0:?L
                & readTable$tooladm
                &   whl
                  ' ( !arg:(?T.?F)+?arg
                    & (     !tooladm
                          :   ?
                            + ( ? (ToolID.!T) ?
                              : ? (ServiceURL.~) ?
                              : ? (Inactive.) ?
                              )
                            + ?
                        & (!T.!F)+!L:?L
                      | 
                      )
                    )
                & !L
            )
          & ( getGoals
            =     AllFs Inca FS Ios allOs Os O
                , X A FN a b Y Z add%
              .   ( add%
                  =   dun incar
                    .   0:?dun
                      &   whl
                        ' ( !arg:%?incar+?arg
                          &     !dun
                              +   map
                                $ ( ( 
                                    =   v f
                                      .   !arg:(?f,?v)
                                        & ( !f
                                          ,     !v:%*%
                                              & !(glf$('(%.$v)))
                                            | !v
                                          )
                                    )
                                  . !incar
                                  )
                            : ?dun
                          )
                      & !dun
                  )
                & 0:?AllFs
                &   whl
                  ' ( !arg:%?Inca+?arg
                    & :?FS
                    &   whl
                      ' ( !Inca:(?FN,?Ios) ?Inca
                        & 0:?allOs
                        &   whl
                          ' ( !Ios:(?.?Os)+?Ios
                            &   whl
                              ' ( !Os:%?O+?Os
                                & !O+!allOs:?allOs
                                )
                            & 
                            )
                        & !FS (!FN,!allOs):?FS
                        )
                    &   whl
                      ' ( !FS:?X+#*(?A (?FN,%?a+%?b) ?Z)+?Y
                        &     !X
                            + (!A (!FN,!a) !Z)
                            + (!A (!FN,!b) !Z)
                            + !Y
                          : ?FS
                        )
                    & !FS+!AllFs:?AllFs
                    )
                & add%$(removeNumFactors$!AllFs)
            )
          & ( getImplicatedGoals
            =   allios tools,restriction ios restrictedTools
              .   !arg:(?tools.?restriction)
                & 0:?allios:?restrictedTools
                & (   !tools
                    :   ?
                      + ( !restriction
                        .   ?ios
                          & !ios+!allios:?allios
                          &   (!restriction.!ios)+!restrictedTools
                            : ?restrictedTools
                          & ~
                        )
                      + ?
                  | 
                  )
                & (getGoals$!allios.!restrictedTools)
            )
          & ( getSuperGoals
            =   goal nwg
              .   !arg:?goal:?nwg
                &   map
                  $ ( ( 
                      =   feat vals A Z Val
                        .     !arg:(?feat.?vals)
                            & !goal:?A (!feat,?Val) ?Z
                            &   map
                              $ ( ( 
                                  =   val alts sp
                                    .   !arg:(?val.?alts)
                                      & (   !Val:!val^?sp
                                          &   map
                                            $ ( ( 
                                                =   a z
                                                  .         ( !A
                                                              ( !feat
                                                              ,       !sp
                                                                    : 1
                                                                  & !arg
                                                                |     !arg
                                                                    :   ?a
                                                                      * !val
                                                                      * ?z
                                                                  &   !a
                                                                    * !Val
                                                                    * !z
                                                              )
                                                              !Z
                                                            )
                                                          + !nwg
                                                        : ?nwg
                                                      & 
                                                    | 
                                                )
                                              . !alts
                                              )
                                        | 
                                        )
                                  )
                                . !vals
                                )
                          | 
                      )
                    . !SuperSets
                    )
                & !nwg
            )
          & !arg:(?source.?goal.?restriction.?superset)
          & readTable$toolprop
          & getActiveTools$!toolprop:?activeTools
          & (   !goal:
              &   getImplicatedGoals$(!activeTools.!restriction)
                : (?goal.?restriction)
            | 0:?restriction
            )
          & ( !superset:
            |   readTable$SuperSets
              & getSuperGoals$!goal:?goal
            )
          &   0
            : ?memoizedSteps
            : ?memos
            : ?duplic
            : ?sourcegoalmatch
            : ?impassages
            : ?notttcnt
          & new$hash:?unfulfillable
          & new$hash:?notThisTool
          & 0:?Calls
          & log$"Calling fulfil"
          &   fulfil$(!activeTools.!source.!goal.0.!restriction)
            : ?reslt
          &   log
            $ ( "Calls to fulfil"
                !Calls
                memos
                !memos
                duplic
                !duplic
                sourcegoalmatch
                !sourcegoalmatch
                impassages
                !impassages
                notttcnt
                !notttcnt
              )
          & !reslt
      )
      ( extractIOfeaturesFromHTTParg
      =   fs IorO f name short p A v Z feat spec io V
        .   "Collects features of the input(s) or of the output. Each feature
             is mentioned once. If there are more than one input, one feature
             will have more than one value. These values are the factors in a
             product."
          & !arg:(?fs.?IorO.?arg)
          & :?io
          &   whl
            ' ( !fs:%?f+?fs
              &   !f
                : ? (name.?name) ?
                : ? (short.?short) ?
              & localized$!name:?name
              & str$(!IorO !short):?p
              &   whl
                ' ( !arg:?A (!p.?v) ?Z
                  & !A !Z:?arg
                  & NEWSPEC
                  & ( !v:%?feat^%?spec
                    |   !v:@(?:?feat "^" ?spec)
                      & !feat^!spec:?v
                    | 
                    )
                  & ( !v:
                    |     !io
                        : ( ?A (!short,?V) ?Z
                          | ?A (!name,?V) ?Z
                          )
                      & ( !V:?*!v*?
                        |   ( !A (!short,!V*!v) !Z
                            | !A (!name,!V*!v) !Z
                            )
                          : ?io
                        )
                    |   ( (!short,!v) !io
                        | (!name,!v) !io
                        )
                      : ?io
                    )
                  )
              )
          & sort$!io
      )
      ( has
      =   rstr S
        .   !arg:(?arg.?rstr)
          & ( !arg:?*(!rstr,?)*?
            |   !arg:?*(?,(?.?.?.?S))*?arg
              & (has$(!S.!rstr)|has$(!arg.!rstr))
            )
      )
      ( filter
      =   pipes desiredtool fpipes o pipe1
        .   !arg:(?pipes.?desiredtool)
          & 0:?fpipes
          &   whl
            ' ( !pipes:(?o.?pipe1)+?pipes
              & (   has$(!pipe1.!desiredtool)
                  & ( !fpipes:?+(?.!o.!pipe1)+?
                    | (!o.!pipe1)+!fpipes:?fpipes
                    )
                | 
                )
              )
          & !fpipes
      )
      ( haz
      =   rstr S F T notfound
        .   !arg:(?arg.?rstr)
          & :?notfound
          &   whl
            ' ( :!notfound
              & !arg:%?T+?arg
              &   whl
                ' ( :!notfound
                  & !T:%?F*?T
                  & (   ( !F:(!rstr,?)
                        |   !F:(?,(?.?.?.?S))
                          & haz$(!S.!rstr)
                        )
                      & false:?notfound
                    | 
                    )
                  )
              )
          & !notfound:false
      )
      "noValueConflict: checks that all features in two feature sets are
       compatible, either by not being present, or by having the same
       values. Subspecifications are ignored."
      ( noValueConflict
      =   A B f e g
        .   !arg:(?A.?B)
          & ( !A:!B
            | ~( !A
               :   ?
                   ( ?f&!B:? (!f,?g) ?
                   , ?*(%@?e^?&~(!g:?*%@!e^?*?))*?
                   )
                   ?
               )
            )
      )
      "supplement: NF and OF can be very different features bundles.
       If OF has a feature that NF hasn't, then it is added to NF.
       If OF has a feature element with the same unsubspecified value as a feature element of NF, 
       then the NF feature element inherits the subspecifications of the OF feature.
       A feature (F,a*b*c) has elements a, b and c.
      "
      ( supplement
      =   f v NF OF e A Z G
        .   !arg:(?NF.?OF)
          &   map
            $ ( ( 
                =   a z f vO vN vn e v G A Z
                  .   !arg:(?f,?vO)
                    & (   !NF:?A (!f,?vN:?vn) ?Z
                        & (   !vN:?vn
                            &   whl
                              ' ( !vO:?*%@?v^(~1:?e)*?vO
                                & !vn:?a*%@!v^?G*?z
                                & (   !G:1
                                    & !a*!v^!e*!z:?vn
                                  | 
                                  )
                                )
                            & ( !vn:!vN
                              | !A (!f,!vn) !Z:?NF
                              )
                          | 
                          )
                      | !arg !NF:?NF
                      )
                    & 
                )
              . !OF
              )
          & sort$!NF
      )
      ( containedBy
      =   short long fea val e E rem
        .   !arg:(?short.?long)
          & ( !short:
            |   !short:(?fea,@?val^?e) ?short
              & !long:? (!fea,!val^?E) ?
              & (   !e:(1|!E)
                  & containedBy$(!short.!long):?rem
                  & (!fea,!val^!E) !rem
                |   !E:1
                  & containedBy$(!short.!long):?rem
                  & (!fea,!val^!e) !rem
                )
            |   !short:(?fea,%*%:?val) ?short
              & !long:? (!fea,!val) ?
              & containedBy$(!short.!long):?rem
              & (!fea,!val) !rem
            )
      )
      ( Tubst
      =   OI I A o i sub prog,H h h1 H1 O rpl
        .   ( rpl
            =   vals fea gold A B exp aa zz
              .   !arg:(?vals.?fea.?gold)
                & (   !vals:%?A*%?B
                    & (   :!(glf$('($vals.?))) ?
                        & rpl$(!A.!fea.!gold):?A
                        & rpl$(!B.!fea.!gold):?B
                        & !A*!B
                      | !vals
                      )
                  |   !vals:%?A %?B
                    & rpl$(!A.!fea.!gold):?A
                    & (rpl$(!B.!fea.!gold):?B|)
                    & !A !B
                  |   !vals:@?A^?B
                    & (   !gold:?*(? (!fea,!vals) ?)*?
                        & !vals
                      |     !gold
                          : ?*(? (!fea,?aa*!A^?exp*?zz) ?)*?
                        &   ( !B:!exp
                            | !exp:1&!B
                            | !B:1&!exp
                            )
                          : ?B
                        & !aa*!A^!B*!zz
                      | !A^!B
                      )
                  )
            )
          & !arg:(?arg.?OI)
          & (   !arg:(((?,?) ?)*?:?H.?arg)
              & Tubst$(!arg.!OI):?arg
              & 1:?h
              &   whl
                ' ( !H:%?H1*?H
                  & (     !arg
                        : (   ?
                            * ( ?
                              , (   ?O
                                  & containedBy$(!H1.!O):?h1
                                . ?
                                )
                              )
                            * ?
                          |   ?
                            * ( `%?O
                              & ~(!O:(?,(?.?)))
                              & containedBy$(!H1.!O):?h1
                              )
                            * ?
                          )
                      & !h*!h1:?h
                    | !h*(!H1 problem !arg):?h
                    )
                  )
              & (!h:1&HA!|!h.!arg)
            |   !arg:%?A*%?arg
              & Tubst$(!A.!OI)*Tubst$(!arg.!OI)
            |   !arg:(%@?prog,(?o.?i.?sub))
              &   !OI
                :   ?
                  *   !prog
                    ^ ( ?
                      +   #
                        * ( ?O
                          .   ?I
                            & noValueConflict$(!O.!o)
                            & noValueConflict$(!I.!i)
                          )
                      + ?
                      )
                  * ?
              & Subst$(!sub.!OI):?sub
              & ( !prog
                , ( !O
                  .   ( 
                      =   I subs gold
                        .   !arg:(?I.?subs)
                          & (     !subs
                                : (((?,?) ?)*?:?gold.?)
                              &   map
                                $ ( ( 
                                    =   fea vals
                                      .   !arg:(?fea,?vals)
                                        & (!fea,rpl$(!vals.!fea.!gold))
                                    )
                                  . !I
                                  )
                            | !I
                            )
                      )
                    $ (!I.!sub)
                  . !sub
                  )
                )
            | !arg
            )
      )
      ( Subst
      =   OI H h h1 H1 O
        .   !arg:(?arg.?OI)
          & "arg is a pipe line.

             OI is a product of tool names with exponents. 
             Each exponent is a term or sum of terms. 
             A term is a dotted pair (output features.input features).
             A term can have a numeral factcor."
          & (   !arg:(((?,?) ?)*?:?H.?arg)
              & "If single input, H is e.g 
              
                (ambig,una)
                (app,nrm)
                (facet,lem*mrf*pos^Uni*stx)
                (format,txtann)
                (lang,da)
                (period,c21)
                (pres,nml)
            .   dapipe
              , (   (ambig,una)
                    (app,nrm)
                    (facet,lem*mrf*pos^Uni*stx)
                    (format,txtann)
                    (lang,da)   
              
              [...]


              or 
              "
              & Tubst$(!arg.!OI):?arg
              & 1:?h
              &   whl
                ' ( !H:%?H1*?H
                  & (     !arg
                        : (   ?
                            * ( ?
                              , (   ?O
                                  & containedBy$(!H1.!O):?h1
                                . ?
                                )
                              )
                            * ?
                          |   ?
                            * ( `%?O
                              & ~(!O:(?,(?.?)))
                              & containedBy$(!H1.!O):?h1
                              )
                            * ?
                          )
                      & !h*!h1:?h
                    |   !h*(!H1 substproblem !arg endsubstproblem)
                      : ?h
                    )
                  )
              & (!h:1&HA!|!h.!arg)
            | !arg
            )
      )
      ( IntersectionOLD
      =   x y f v I e g w V W h
        .   !arg:(?x.?y)
          & :?I
          &   (   !x
                :   ?
                    (?f,@?v^?e:?V)
                    ( ?
                    & (   !y:? (!f,@?w^?g:?W) ?
                        & ( !w:~!v
                          |   !e:~1
                            & !g:~1
                            & !e:~!g
                          |   (   (!e:~1|!g:~1)
                                & !e*!g:%?h^?
                              | 1:?h
                              )
                            & (!f,!v^!h) !I:?I
                          )
                      | (!f,!v^!e) !I:?I
                      )
                    & ~
                    )
              |   !y
                :   ?
                    ( ?f
                    ,   @?v^?e:?V
                      & ~(!I:? (!f,!V) ?)
                    )
                    ( ?
                    & (   !x:? (!f,@?w^?g:?W) ?
                        & ( !w:~!v
                          |   !e:~1
                            & !g:~1
                            & !e:~!g
                          |   (   (!e:~1|!g:~1)
                                & !e*!g:%?h^?
                              | 1:?h
                              )
                            & (!f,!v^!h):?V
                            & ( !I:? !V ?
                              | !V !I:?I
                              )
                          )
                      |   (!f,!v^!e):?V
                        & (!I:? !V ?|!V !I:?I)
                      )
                    & ~
                    )
              | !I
              )
            : ?I
          & sort$!I:?I
          & !I
      )
      ( Intersection
      =   x y f v I e g w V W h
        .   !arg:(?x.?y)
          &     map
              $ ( ( 
                  =   
                    .   !arg:(?f,?vs)
                      & (   !y:? (!f,?ys) ?
                          & 1:?ns
                          &   whl
                            ' ( !vs:%@?v^?e*?vs
                              & (   !ys:?*!v^?g*?
                                  &     (   !e:~1
                                          & !g:~1
                                          & !e:~!g
                                          & 1
                                        |   (   ( !e:~1
                                                | !g:~1
                                                )
                                              & !e*!g:%?h^?
                                            | 1:?h
                                            )
                                          & !v^!h
                                        )
                                      * !ns
                                    : ?ns
                                | 
                                )
                              )
                          & ( !ns:1&
                            | (!f,!ns)
                            )
                        | !arg
                        )
                  )
                . !x
                )
            : ?I
          &     !I
                  map
                $ ( ( 
                    =   
                      .   !arg:(?f,?vs)
                        & (   !x:? (!f,?xs) ?
                            & 1:?ns
                            &   whl
                              ' ( !vs:%@?v^?e*?vs
                                & (   !xs:?*!v^?g*?
                                    &     (   !e:~1
                                            & !g:~1
                                            & !e:~!g
                                            & 1
                                          |   (   ( !e:~1
                                                  | !g:~1
                                                  )
                                                & !e*!g:%?h^?
                                              | 1:?h
                                              )
                                            & !v^!h
                                          )
                                        * !ns
                                      : ?ns
                                  | 
                                  )
                                )
                            & ( !ns:1&
                              |   (!f,!ns):?V
                                & ( !I:? !V ?&
                                  | !V
                                  )
                              )
                          | !I:? !arg ?&
                          | !arg
                          )
                    )
                  . !y
                  )
            : ?I
          & sort$!I
      )
      ( percolateForgottenFeatures
      =     pipes F updateOFwithNF NN
          , harmonizeSubspecsOnSimilarFeatures
          , Results pipe1 pipe2 pipe3
          , fromMethods fromInputTowardOutput fromToolOrSource
          , toMethods fromOutputTowardInput toTool
          , UpdateResultsFromMethods oUts
          , validateInputsForEachTool
        .   ( UpdateResultsFromMethods
            =   results methods nres result A method
              .   !arg:(?results.?methods)
                & 1:?nres
                &   whl
                  ' ( !results:%?result*?results
                    &     (   !methods:?A*!result*?methods
                            & !A*!methods:?methods
                            & !result
                          |   !methods:%?method*?methods
                            &   map
                              $ ( ( 
                                  =   F v e E nvs vs
                                    .   !arg:(?F,?vs)
                                      & 1:?nvs
                                      &   whl
                                        ' ( !vs:%@?v^?e*?vs
                                          &     !nvs
                                              * (   !e:1
                                                  &   !v
                                                    ^ (     !method
                                                          :   ?
                                                              (!F,?*!v^?E*?)
                                                              ?
                                                        & !E
                                                      | 1
                                                      )
                                                | !v^!e
                                                )
                                            : ?nvs
                                          )
                                      & (!F,!nvs)
                                  )
                                . !result
                                )
                          )
                        * !nres
                      : ?nres
                    )
                & (   !nres:1
                    & log$UpdateResultsFromMethods/nres1
                    & get'
                  | 
                  )
                & !nres
            )
          & ( sig
            =   
              .   !arg:%@?a^?*?arg&!a*sig$!arg
                | 1
            )
          & ( UpdateResultsFromMethods
            =     r[esults methods nres result A method
                , Sig SR SM
              .   ( Sig
                  =   
                    .   map
                      $ ( ( 
                          =   f v
                            .   !arg:(?f,?v)
                              & (!f,sig$!v)
                          )
                        . !arg
                        )
                  )
                & !arg:(?results.?methods)
                & 1:?nres
                &   whl
                  ' ( !results:%?result*?results
                    & Sig$!result:?SR
                    &     (   !methods:?A*!result*?methods
                            & !A*!methods:?methods
                            & !result
                          |     !methods
                              :   ?A
                                * `( (?,?) ?:?method
                                   & Sig$!method:?SM
                                   &     map
                                       $ ( ( 
                                           =   
                                             .   !SM:~(? !arg ?)
                                               | 
                                           )
                                         . !SR
                                         )
                                     : 
                                   )
                                * ?methods
                            & !A*!methods:?methods
                            &   map
                              $ ( ( 
                                  =   F v e E nvs vs
                                    .   !arg:(?F,?vs)
                                      & 1:?nvs
                                      &   whl
                                        ' ( !vs:%@?v^?e*?vs
                                          &     !nvs
                                              * (   !e:1
                                                  &   !v
                                                    ^ (     !method
                                                          :   ?
                                                              (!F,?*!v^?E*?)
                                                              ?
                                                        & !E
                                                      | 1
                                                      )
                                                | !v^!e
                                                )
                                            : ?nvs
                                          )
                                      & (!F,!nvs)
                                  )
                                . !result
                                )
                          )
                        * !nres
                      : ?nres
                    )
                & !nres
            )
          & "updateOFwithNF: let OF inherit subspecs from NF if OF and NF have same feature value, but OF is not subspecified. 
             If a feature has different values in OF and NF, replace OF's value with NF's
             Add any features in NF that OF does not have."
          & ( updateOFwithNF
            =   OF NF
              .   !arg:(?OF.?NF)
                &   map
                  $ ( ( 
                      =   f nvs ovs v e E A Z a z nsg
                        .   !arg:(?f,?nvs)
                          & sig$!nvs:?nsg
                          & (   !OF:?A (!f,?ovs) ?Z
                              & (   sig$!ovs:!nsg
                                  &   whl
                                    ' ( !nvs:?*%@?v^%?e*?nvs
                                      & !ovs:?a*!v^?E*?z
                                      & ( ( !e:!E
                                          | !E:~1
                                          )
                                        | !a*!v^!e*!z:?ovs
                                        )
                                      )
                                  & !A (!f,!ovs) !Z:?OF
                                | !A (!f,!nvs) !Z:?OF
                                )
                            | !arg !OF:?OF
                            )
                      )
                    . !NF
                    )
                & sort$!OF
            )
          & ( harmonizeSubspecsOnSimilarFeatures
            =   OF NF
              .   !arg:((@?,~(?.?)) ?:?NF.?OF)
                & (supplement$(!NF.!OF).updateOFwithNF$(!OF.!NF))
            )
          & ( oUts
            =   R F
              .   1:?R
                &   whl
                  ' (   !arg
                      :   ( (?,(?F.?))
                          | (?,?) ?:?F
                          )
                        * ?arg
                    & !F*!R:?R
                    )
                & !R
            )
          & ( Results
            =   L R OF LF RF
              .     !arg:(%?L*%?R.?OF)
                  & Results$(!R.!OF):(?R.?RF)
                  &   harmonizeSubspecsOnSimilarFeatures$(!L.!OF)
                    : (?L.?LF)
                  & (!L*!R.Intersection$(!RF.!LF))
                | harmonizeSubspecsOnSimilarFeatures$!arg
            )
          & ( fromToolOrSource
            =   OF LF RF tool meta output sub
              .     !arg:(?tool,(?output.?meta.?sub).?OF)
                  & fromInputTowardOutput$(!sub.!OF):(?sub.?RF)
                  &   harmonizeSubspecsOnSimilarFeatures$(!output.!RF)
                    : (?output.?LF)
                  & ( !tool,(!output.supplement$(!meta.!RF).!sub)
                    . !LF
                    )
                | harmonizeSubspecsOnSimilarFeatures$!arg
            )
          & ( fromMethods
            =   L R OF LF RF
              .   !arg:(?arg.?OF)
                & (   !arg:%?L*%?R
                    & fromMethods$(!R.!OF):(?R.?RF)
                    & fromToolOrSource$(!L.!OF):(?L.?LF)
                    & (!L*!R.Intersection$(!RF.!LF))
                  | fromToolOrSource$(!arg.!OF)
                  )
            )
          & ( fromInputTowardOutput
            =   results methods OF NF
              .     !arg:((?results.?methods).?OF)
                  & fromMethods$(!methods.!OF):(?methods.?NF)
                  & (   UpdateResultsFromMethods$(!results.oUts$!methods)
                      : ?results
                    | 
                    )
                  & ((!results.!methods).!NF)
                | Results$!arg
            )
          & ( toTool
            =   OF LF RF tool meta output sub
              .   !arg:(?arg.?OF)
                & (   !arg:(?tool,(?output.?meta.?sub))
                    &   harmonizeSubspecsOnSimilarFeatures$(!output.!OF)
                      : (?output.?LF)
                    & fromOutputTowardInput$(!sub.!LF):(?sub.?RF)
                    & ( !tool,(!output.supplement$(!meta.!LF).!sub)
                      . !RF
                      )
                  |   !arg:(|(?,?) ?)
                    & harmonizeSubspecsOnSimilarFeatures$(!arg.!OF)
                  )
            )
          & ( toMethods
            =   L R OF LF RF
              .   !arg:(?arg.?OF)
                & (   !arg:%?L*%?R
                    & toMethods$(!R.!OF):(?R.?RF)
                    & toTool$(!L.!OF):(?L.?LF)
                    & (!L*!R.Intersection$(!RF.!LF))
                  | toTool$(!arg.!OF)
                  | !arg:(@,?)&(!arg.!OF)
                  )
            )
          & ( fromOutputTowardInput
            =   results methods OF NF
              .   !arg:(?arg.?OF)
                & (   !arg:(?results.?methods)
                    & Results$(!results.!OF):(?results.?NF)
                    & toMethods$(!methods.!NF):(?methods.?NF)
                    & ((!results.!methods).!NF)
                  | Results$(!arg.!OF)
                  )
            )
          & ( validateInputsForEachTool
            =   recr
              .   "Every input spec shall be identical to an output
                   spec of an immediately preceding tool."
                & ( recr
                  =   a b A aa t
                    .     !arg:%?a*%?b
                        & recr$!a
                        & recr$!b
                      | !arg:(?t,(?.?.(?,?) ?))
                      | !arg:(?,~(?.?)) ?
                      |   !arg:(?t,(?.?.?a:?aa.?b))
                        & recr$!b
                        &   whl
                          ' ( !a
                            :   ( %?A
                                &   !b
                                  : (?*(?,(!A.?))*?|?*!A*?)
                                )
                              * ?a
                            )
                        & ( !a:1
                          |   ~
                            &   log
                              $ ( "In feature bundle"
                                  !A
                                  str$(\n "of tool")
                                  !t
                                  str$(\n "with input")
                                  !aa
                                    str
                                  $ ( \n
                                      "mismatch with outputs of preceding tools"
                                    )
                                  oUts$!b
                                  "arg (suppressed)"
                                )
                            & !arg:?CULPRIT
                            & lst$(CULPRIT,path$CULPRIT,RAW,NEW)
                            & lst$(pipe1,path$pipe1WRONG,NEW)
                            & ~
                          )
                  )
                & !arg:(?.?arg)
                & recr$!arg
            )
          & 0:?pipes
          & 0:?NN
          &   whl
            ' ( !arg:%?pipe1+?arg
              & 1+!NN:?NN
              & fromInputTowardOutput$(!pipe1.):(?pipe2.?F)
              & fromOutputTowardInput$(!pipe2.!F):(?pipe3.?)
              & ( !pipe3:0&log$ZERO
                |   validateInputsForEachTool$!pipe3
                  & ( !pipes:?+!pipe3+?
                    | !pipe3+!pipes:?pipes
                    )
                | 
                )
              )
          & !pipes
      )
      ( Pipelines
      =     i o restriction FP fP superset userInput
          , prunePipes calls nth windFW
          , A Z reorderedworkflowlist topologicalOrderedTools
        .   ( windFW
            =   nth ZZ pipes pipe
              .   !arg:(?pipes.?nth)
                & ( !nth:&!pipes
                  |   !pipes:?ZZ
                    & UNKNOWNS!:?pipe
                    &   whl
                      ' ( !nth:>0
                        & !ZZ:%?pipe+?ZZ
                        & !nth+-1:?nth
                        )
                    & !pipe
                  )
            )
          & ( prunePipes
            =     As Ax NNN Z ax incarnationpipes parms
                , newpipes pipe pipes pipesN restriction
                , wantThis unfoldTree sources
              .   ( unfoldTree
                  =     tool ou ou2 inputprop childstuff
                      , A Z goal b
                      , inputprop feature stop a ret
                      , As stp sp
                      , projectOnto rt af bf compatibleFeatureSets
                    .   "Returns sum. Each term is a dot separated structure:
                 (<stop list> . <user provided output specs> . <sum of unambiguous trees>)
             The stop list is a product of (<key>.<value>) pairs, where the key is an (ambiguous) tree and the value
             is a disambiguated solution. The stop list is passed down to the leafs and also up again as part of the
             return value. In that way some consistency is assured and many inviable solutions are never attempted.
             The ambiguities (declared as terms in sums) in the original tree can be in feature values and in tool choices.
             
             The argument consists of a product of already found unfoldings and the (sub)tree to unfold, separated by a dot.
             Each factor in the product of already found unfoldings consists of the tree to unfold (the key) and the tree
             it was unfolded to (the value). Factors can have an exponent.
             
             Expects that the variable 'sources' is a list of input feature/value pairs. 
             (A single pair can contain more than one value. That is the case if there are more than one inputs.)"
                      & ( compatibleFeatureSets
                        =   A B C D F V
                          .   ~(!arg:%*%)
                            |   1:?B
                              &   whl
                                ' (   !arg
                                    : ((?,?) ?:?A)^?*?arg
                                  & subtract$(!A.!sources)*!B:?B
                                  )
                              & ~( !B
                                 :   %?C
                                   * ( %?D
                                     &   !C
                                       :   ?
                                           ( ?F
                                           ,   ?V
                                             &   !D
                                               : ?*(? (!F,~!V) ?)*?
                                           )
                                           ?
                                     )
                                 )
                        )
                      & !arg:(?stop.?arg)
                      & 1+!calls:?calls:<567890
                      & (   @(!calls:? 000)
                          & log$(calls !calls)
                        | 
                        )
                      & (   !arg:%?A*%?arg
                          & "Multiply each term in unfolded first factor with each term in unfolded remaining factors."
                          & 0:?ret
                          & unfoldTree$(!stop.!A):(?stp.?a)
                          & unfoldTree$(!stop*!stp.!arg):(?sp.?b)
                          & leaveFeat$!a:?af^?
                          & leaveFeat$!b:?bf^?
                          & (   compatibleFeatureSets$(!af*!bf)
                              & !ret+(!sp.!a*!b):?ret
                            | 
                            | log$(NOTCOMPATIBLE !af AND !bf)
                            )
                          & !ret
                        |   !calls:<567890
                          & !arg:%+%
                          & log$SUMDETECTED
                          & (   !stop:?*(!arg.?projectOnto)^?*?
                              & "This removes perhaps some solutions that assume incompatible input specs."
                              & (!stop.!projectOnto)
                            |   0:?ret
                              & !arg:?As
                              &   whl
                                ' ( !As:%?A+?As
                                  & unfoldTree$(!stop.!A):?Z
                                  & !calls:<567890
                                  &   whl
                                    ' ( !Z:(?stp.?a)+?Z
                                      &   !ret+((!arg.!a)*!stop.!a)
                                        : ?ret
                                      )
                                  )
                              & !ret
                            )
                        |   !calls:<567890
                          & !arg:(?goal.?childstuff)
                          & unfoldTree$(!stop.!childstuff):?Z
                          & !calls:<567890
                          & 0:?ret
                          &   whl
                            ' ( !Z:(?stp.?A)+?Z
                              & !ret+(!stp.!goal.!A):?ret
                              )
                          & !ret
                        |   !calls:<567890
                          &   !arg
                            : ( ?tool
                              , ( ?A (?feature,%+%:?ou) ?Z
                                . ?inputprop
                                . ?childstuff
                                )
                              )
                          & (   !stop:?*(!ou.?projectOnto)*?
                              &   unfoldTree
                                $ ( !stop
                                  .   !tool
                                    , ( !A (!feature,!projectOnto) !Z
                                      . !inputprop
                                      . !childstuff
                                      )
                                  )
                            |   !calls:<567890
                              & !ou:?ou2
                              & 0:?ret
                              &   whl
                                ' ( !ou2:%?a+?ou2
                                  &     unfoldTree
                                      $ ( !stop*(!ou.!a)
                                        .   !tool
                                          , ( !A (!feature,!a) !Z
                                            . !inputprop
                                            . !childstuff
                                            )
                                        )
                                    : ?rt
                                  & !ret+!rt:?ret
                                  )
                              & !calls:<567890
                              & !ret
                            )
                        |   !calls:<567890
                          &   !arg
                            : (?tool,(?ou.?inputprop.?childstuff))
                          & unfoldTree$(!stop.!childstuff):?Z
                          & 0:?ret
                          &   whl
                            ' ( !Z:(?stp.?A)+?Z
                              &   !ret+(!stp.!tool,(!ou.!inputprop.!A))
                                : ?ret
                              )
                          & !ret
                        | !calls:<567890&(!stop.!arg)
                        )
                  )
                & "wantThis either returns the argument (if it is wanted) or
                   zero (if it isn't). So it does not FAIL."
                & ( wantThis
                  =     sig nsig clashing NoValueConflicts copySpecs
                      , signatures unifySignatures nittyGritty
                    .   "signatures: create a product of tool names with
                         exponents that descibe output and input features, as
                         dotted pairs.

                         clashing: check whether a tool exists with two
                         signatures with a common feature that would be equal
                         if subspecifications were stripped off.
                        "
                      & ( signatures
                        =   A prog o i sub
                          .     !arg:(((?,?) ?)*?.?arg)
                              & signatures$!arg
                            |   !arg:%?A*%?arg
                              & signatures$!A*signatures$!arg
                            |   !arg:(%@?prog,(?o.?i.?sub))
                              & !prog^(!o.!i)*signatures$!sub
                            | 1
                        )
                      & ( NoValueConflicts
                        =   i I o O
                          .   !arg:((?o.?i),(?O.?I))
                            & noValueConflict$(!i.!I)
                            & noValueConflict$(!o.!O)
                        )
                      & ( copySpecs
                        =   Ao Ai Bo Bi
                          .   !arg:((?Ao.?Ai),(?Bo.?Bi))
                            & (supplement$(!Ao.!Bo).supplement$(!Ai.!Bi))
                        )
                      & ( nittyGritty
                        =   oi1 oi2 A M Z
                          .       !arg
                                :   ?A
                                  + #*((?.?):?oi1)
                                  + ?M
                                  +   #
                                    * ( (?.?):?oi2
                                      & NoValueConflicts$(!oi1,!oi2)
                                      )
                                  + ?Z
                              &   nittyGritty
                                $ ( !A
                                  +   copySpecs
                                    $ (!oi2,copySpecs$(!oi1,!oi2))
                                  + !M
                                  + !Z
                                  )
                            | !arg
                        )
                      & ( unifySignatures
                        =   tool A sigs
                          .       !arg
                                : ?A*%@?tool^(%+%:?sigs)*?arg
                              &   !A
                                * !tool^nittyGritty$!sigs
                                * unifySignatures$!arg
                            | !arg
                        )
                      & ( clashing
                        =   oi1 oi2 ConflictingSpecs specConflict
                          .   ( specConflict
                              =   A B f e x y
                                .   !arg:(?A.?B)
                                  &   !A
                                    :   ?
                                        ( ?f
                                        ,   ?
                                          * `%@( ?e^?x
                                               &   !B
                                                 : ? (!f,?*!e^?y*?) ?
                                               & !x*!y:%*%
                                               )
                                          * ?
                                        )
                                        ?
                              )
                            & ( ConflictingSpecs
                              =   i I o O
                                .   NoValueConflicts$!arg
                                  & !arg:((?o.?i),(?O.?I))
                                  & ( specConflict$(!i.!I)
                                    | specConflict$(!o.!O)
                                    )
                              )
                            &   !sjt
                              :   ?
                                + #*((?.?):?oi1)
                                + ?
                                +   #
                                  * ( (?.?):?oi2
                                    & ConflictingSpecs$(!oi1,!oi2)
                                    )
                                + ?
                        )
                      & signatures$!arg:?sig
                      & (   !sig:?*?^(%+%:clashing$)*?
                          & "Discard solutions that contain steps that are
                             equal (or at least compatible) at the un-
                             subspecified level, but clash at the spec level."
                          & 0
                        |   unifySignatures$!sig:?nsig
                          & Subst$(!arg.!nsig):?arg
                          & "Either each tool is used in exactly one way, or
                             the different ways ALL differ more than only at
                             the subspec level."
                          & !arg
                        )
                  )
                & !arg:(?pipes.?parms.?sources)
                & 0:?newpipes
                &   whl
                  ' ( !calls:<567890
                    & !pipes:((?.?):?incarnationpipes)+?pipes
                    & "incarnationpipes is (<(user or declared tool) provided output specs> . <sum of unambiguous trees>)"
                    & "TODO 20190917: do not have workflows with two or more tools that do exactly the same thing.
                Strategy: 
                (1) search for a sum. 
                (2) Iterate over that sum. 
                (3) For each term, produce a (possibly still ambiguous) workflow by projecting each sum that contains that
                    term on that term. So if a sum contains the current term, ignore all terms but the current term.
                (4) Repeat this for each new workflow.
                (5) The result is a list of unambiguous workflows in which no task is performed by two different tools."
                    & (   ItExplodes$!incarnationpipes
                        & 100000000:?calls
                      |   
                        & selectCommonTracks$!incarnationpipes:?As
                        & 0:?pipesN
                        &   whl
                          ' ( !As:%?Ax+?As
                            & unfoldTree$(1.!Ax):?Z
                            &   whl
                              ' ( !Z:(?.?ax)+?Z
                                & ( !pipesN:?+!ax+?
                                  | !pipesN+!ax:?pipesN
                                  )
                                )
                            )
                        & "The 1 is the initial stop list, which is formed as a product."
                        & "pipesN is (<user provided output specs> . <unfolded tree>) + ..."
                        & !pipesN:?+[?NNN
                        & (     !parms
                              : ? (desiredtool.?restriction) ?
                            & !restriction:~
                            & filter$(!pipesN.!restriction):?pipesN
                          | 
                          )
                        & percolateForgottenFeatures$!pipesN:?pipesN
                        & !pipesN:?+[?NNN
                        &   whl
                          ' ( !pipesN:%?pipe+?pipesN
                            & wantThis$!pipe:?pipe
                            & ( !pipe:0
                              | !newpipes:?+!pipe+?
                              | !pipe+!newpipes:?newpipes
                              )
                            )
                      )
                    )
                & log$(prunePipesCallsNow !calls)
                & !calls:<567890
                & !newpipes
            )
          & !arg:(?arg.?nth)
          & log$(nth !nth)
          & 0:?indent:?calls
          & ( !arg:? (desiredtool.?restriction) ?
            | :?restriction
            )
          & ( !arg:? (superset.?superset) ?
            | :?superset
            )
          & readTable$features
          & (!recentTasks|readTable$recentTasks)
          & extractIOfeaturesFromHTTParg$(!features.I.!arg):?i
          & extractIOfeaturesFromHTTParg$(!features.O.!arg):?o
          & (!i.!o.!restriction.!superset):?userInput
          & (     !recentTasks
                :   ?A
                    ( !userInput
                    . ?reorderedworkflowlist
                    . ?topologicalOrderedTools
                    )
                    ?Z
              &     ( !userInput
                    . !reorderedworkflowlist
                    . !topologicalOrderedTools
                    )
                    !A
                    !Z
                : ?recentTasks
              &   windFW$(!reorderedworkflowlist.!nth)
                : ?reorderedworkflowlist
              & ( !userInput
                . (!reorderedworkflowlist.!topologicalOrderedTools)
                . allRight
                )
            |   "The next call fails if no workflows found." l
              & log$"Calling fp"
              & fp$!userInput:?FP
              & log$"Calling fp success"
              & ( !userInput
                .     !FP:(?,?) ?
                    & ((!FP.).triviallyFulfilled)
                  | !FP:?+[>1000&(!FP.tooMany)
                  |   ( !restriction:
                      |   !FP
                        :   ?
                          + (?.?fP&haz$(!fP.!restriction))
                          + ?
                      )
                    & (   prunePipes$(!FP.!arg.!i):?FP
                        &   makeWorkflowsSequential$!FP
                          : (?reorderedworkflowlist.?topologicalOrderedTools)
                        & ( !recentTasks:?recentTasks [30 ?
                          | 
                          )
                        &     ( !userInput
                              . !reorderedworkflowlist
                              . !topologicalOrderedTools
                              )
                              !recentTasks
                          : ?recentTasks
                        & saveTable$recentTasks
                        &   windFW$(!reorderedworkflowlist.!nth)
                          : ?reorderedworkflowlist
                        & ( (!reorderedworkflowlist.!topologicalOrderedTools)
                          . allRight
                          )
                      | (!FP.tooComplex)
                      )
                  | (!FP.onlyWithoutRestriction)
                )
            )
      )
      " convert2URLs receives a list of job steps, each step describing the 
step's tool, its output and its inputs. The inputs not only tell the type of
each input, but also which step produced that input. The first step's input is
taken from the Items list. Following steps can, but need not take an item in
the Items list as input. Step descriptions in the JobStack can look like this:
  ( step1                                 STEP
  . pdf2htmlEX                            TOOL
  .   (facet,txt^ocr)                     ------
      (format,html)                       
      (lang,da)                           INPUT
      (pres,nml)                          -----
  .   (facet,txt)                         ------
      (format,pdf)                        
      (lang,da)                           OUTPUT
      (pres,nml)                          ------
  )
...
  ( step8                                  STEP
  . CST-Lem                                TOOL
  .   (facet,lem)                          ------
      (format,flat)
      (lang,da)                            INPUT
      (pres,alf)                           ------
  .   (pres,nml)                           ------
      (lang,da)
      (format,txtann)                      OUTPUT
      (facet,(pos^Par.step7))
      (facet,(tok.step5))                  ------
  )
"
      ( convert2URLs
      =     requestString Items items file files newJobs feats
          , base post2 val vals JobStack Val item meta In
          , jobIDoffset A OffSet addOutputsToRequestString
          , extension ID forceFeed jobNr jobID maxjobID
          , Short Long DiscerningFeature getDisFe
          , DATE Tool URL dep discerningFeature
          , feat in ou spec v nfiles fileTerm notIncompatible
          , inputs moreinputs firstinput other fh oh
          , compact compatible simpleInput someinputs
          , getDepsAndAddInputsToRequestString
        .   "getDisFe establishes the feature that the given tool has to look
             for among the input Items, if it needs an item from that list.
             It is not useful for steps that only take input from earlier
             steps."
          & ( getDisFe
            =   f
              .     !arg:? (?f,?) ? (!f,?) ?
                  & (!f.n)
                | (.1)
            )
          & ( Short
            =   
              .   (   !features
                    :   ?
                      + ( ? (name.? !arg ?) ?
                        : ? (short.?arg) ?
                        )
                      + ?
                  | 
                  )
                & !arg
            )
          & ( Long
            =   
              .   (   !features
                    :   ?
                      + ( ? (short.!arg) ?
                        : ? (name.?arg) ?
                        )
                      + ?
                  | 
                  )
                & localized$!arg
            )
          & ( compact
            =   A B C D E x
              .       whl
                    ' ( !arg:?A+(#*%?x.?B)+?C+(#*!x.?D)+?E
                      & !A+(!x.!B+!D)+!C+!E:?arg
                      )
                  &   whl
                    ' ( !arg:?A+#%*%?x+?C
                      & !A+!x+!C:?arg
                      )
                  & 0:?E
                  &   whl
                    ' ( !arg:?A+(?B.?C)+?arg
                      & !E+!A+(!B.compact$!C):?E
                      )
                  & !arg+!E:?arg
                | FOUT
            )
          & ( OffSet
            =   ID
              .   !jobIDoffset:&!arg
                |   @(!arg:step #?ID)
                  & str$(step !ID+!jobIDoffset)
                | !arg
            )
          & ( simpleInput
            =   a b c d e,f g h i j k
              .     !arg
                  : (   ?
                      + (I.?.?.?+(F.?)+?)
                      + ?
                      + (I.?.?.?+(F.?)+?)
                      + ?
                    | ?+(F.?)+?
                    )
                |     !arg
                    :   ?a
                      + (I.?b+(?c.?d+(?e.?f+(F.?g)+?h)+?i)+?j)
                      + ?k
                  & !a+(F.!g)+(I.!b+(!c.!d+(!e.!f+!h)+!i)+!j)+!k
            )
          & ( forceFeed
            =   requestString item file
              .   0:?requestString
                & !arg:?items
                &   whl
                  ' ( !items:(Item.%?item ?) ?items
                    & !Uploads:? (?.!item.?file.?) ?
                    &     !requestString
                        + ( !files !file:?files
                          & (F.!file)
                          )
                      : ?requestString
                    )
                & !requestString
            )
          & ( notIncompatible
            =   feats In f
              .   !arg:(?feats.?In)
                & ~( !feats
                   :   ?
                       (?f.?v)
                       ( ?
                       & !In:? (!f,(!v^?.?)) ?
                       )
                   )
            )
          & ( compatible
            =   f r v rs fv
              .   !arg:(?.~(? (?,@) ?))
                |   !arg:(?f.? (?r,@?v) ?rs)
                  & ( ~(!f:? (!r.?fv) ?)
                    | !v:!fv
                    | !v:!fv^?
                    | !fv:!v^?
                    )
                  & compatible$(!f.!rs)
            )
          & ( addOutputsToRequestString
            =   ou requestString extension feat val spec
              .   !arg:(?ou.?requestString)
                & xml:?extension
                &   whl
                  ' ( !ou:(?feat,%@?val^?spec) ?ou
                    & NEWSPEC
                    &     !requestString
                        + ( O
                          . Short$!feat
                          . !val
                          .     !spec:1
                              & NEWSPEC
                              & 0
                            | !spec
                          )
                      : ?requestString
                    & (   !feat:(format|Format)
                        &   ( !val:flat&txt
                            |     !val
                                : ( xm
                                  | txtbasis
                                  | txtann
                                  | teip5
                                  )
                              & xml
                            | !val
                            )
                          : ?extension
                      | 
                      )
                    )
                & (!extension.!requestString)
            )
          & ( getDepsAndAddInputsToRequestString
            =   in nfiles requestString newJobs
              .   !arg:(?in.?nfiles.?requestString.?newJobs)
                &     map
                    $ ( ( 
                        =     feat vals Val spec file
                            , val dep FiLfeats fileitem
                          .   !arg:(?feat,?vals)
                            & :?dep
                            &   whl
                              ' ( !vals:%?Val*?vals
                                &   !Val
                                  : ( ( %@?val^?spec
                                      .     @?file
                                          & OffSet$!file:?file
                                          &   !dep (!file,pending)
                                            : ?dep
                                          &   ( F
                                              .   (   !newJobs
                                                    :   ?
                                                        ( !jobNr
                                                        . !file
                                                        . ?
                                                        . ?
                                                        . ?
                                                        . ?file
                                                        )
                                                        ?
                                                  |   log
                                                    $ ( OOPS
                                                        !jobNr
                                                        file
                                                        !file
                                                      )
                                                  )
                                                & !file
                                              )
                                            : ?fileTerm
                                        |   (FiL.?FiLfeats)
                                          &   !Items
                                            :   ?
                                                ( Item
                                                .   %?item ?feats
                                                  &   !Uploads
                                                    :   ?
                                                        ( ?
                                                        . !item
                                                        . ?fileitem
                                                        .   ?meta
                                                          :   ?
                                                              (DATE.?DATE)
                                                              ?
                                                        .   ?feats
                                                          &   compatible
                                                            $ (!feats.!FiLfeats)
                                                        )
                                                        ?
                                                )
                                                ?
                                          & !dep !fileitem:?dep
                                          & (F.!fileitem):?fileTerm
                                      )
                                    |   %@?val^?spec
                                      & 0:?fileTerm
                                    )
                                & NEWSPEC
                                &     !requestString
                                    + (   !nfiles:1
                                        & !fileTerm
                                      | 0
                                      )
                                    + ( I
                                      . Short$!feat
                                      . !val
                                      .   (   !nfiles:n
                                            & !fileTerm
                                          | 0
                                          )
                                        + (   !spec:1
                                            & NEWSPEC
                                            & 0
                                          | (!spec.0)
                                          )
                                      )
                                  : ?requestString
                                )
                            & !dep
                        )
                      . !in
                      )
                  : ?dep
                & (!dep.!requestString)
            )
          & 0:?maxjobID
          & readTable$features
          & readTable$tooladm
          & readTable$toolprop
          &   !arg
            : (?jobNr.?jobIDoffset.?JobStack.?base.?post2.?Items)
          & readTable$Uploads
          & :?newJobs
          & (readTable$jobs|:?jobs)
          &   whl
            ' ( !JobStack:(?jobID.?Tool.?ou.?in) ?JobStack
              & OffSet$!jobID:?jobID
              & 1+!maxjobID:?maxjobID
              &   !tooladm
                :   ?
                  + ( ? (ToolID.!Tool) ?
                    : ? (ServiceURL.?URL) ?
                    )
                  + ?
              &     (base.!base)
                  + (post2.!post2)
                  + (job.str$(!jobNr "-" !jobID))
                : ?requestString
              & getDisFe$!in:(?discerningFeature.?nfiles)
              &   addOutputsToRequestString$(!ou.!requestString)
                : (?extension.?requestString)
              & !in:?In
              &     getDepsAndAddInputsToRequestString
                  $ (!in.!nfiles.!requestString.!newJobs)
                : (?dep.?requestString)
              &     !newJobs
                    ( !jobNr
                    . !jobID
                    .     !dep
                          ( :?files
                          & ( !requestString:?+(F.?)+?
                            |   !Items:?items
                              &   whl
                                ' (   !items
                                    : (Item.%?item ?feats) ?items
                                  &   !Uploads
                                    :   ?
                                        ( ?
                                        . !item
                                        . ?file
                                        .   ?meta
                                          : ? (DATE.?DATE) ?
                                        . ?feats
                                        )
                                        ?
                                  &     !requestString
                                      + (   !discerningFeature:
                                          & !files !file:?files
                                          & (F.!file)
                                        |     !feats
                                            :   ?
                                                (!discerningFeature.?v)
                                                ?
                                          &     getShort
                                              $ (!discerningFeature.!v)
                                            : ?v
                                          &   Long$!discerningFeature
                                            : ?DiscerningFeature
                                          & notIncompatible$(!feats.!In)
                                          & compatible$(!feats.!In)
                                          &   !In
                                            :   ?
                                                (   !discerningFeature
                                                  | !DiscerningFeature
                                                ,   ?+?*!v^?*?+?
                                                  | (?+?*!v^?*?+?.?)
                                                  | ?+?*!v*?+?
                                                  | (?+?*!v*?+?.?)
                                                )
                                                ?
                                          & !v:%@?v^?
                                          & !files !file:?files
                                          & ( I
                                            . !discerningFeature
                                            . !v
                                            . F
                                            . !file
                                            )
                                        | 0
                                        )
                                    : ?requestString
                                  )
                            )
                          & (     !requestString
                                : (   ?
                                    + (I.?+(?.?+(?.?+(F.?)+?)+?)+?)
                                    + ?
                                  | ?+(F.?)+?
                                  )
                              &   simpleInput$!requestString
                                : ?requestString
                            |   !requestString+forceFeed$!Items
                              : ?requestString
                            )
                          & !files
                          )
                      : ?inputs
                    . !URL
                    . compact$!requestString:?requestString
                    .   "Output from tool:"
                      & @(!jobID:? #?ID)
                      &   str
                        $ ( (     !inputs
                                : ? (@(?:step ?),?) ?
                              &   !requestString
                                : (   ?
                                    + (F.@(?:?inputs "-step" #% ?))
                                    + ?
                                  |     ?
                                      + ( I
                                        .   ?
                                          + ( ?
                                            .   ?someinputs
                                              + ( ?
                                                .   ?
                                                  + ( F
                                                    . @( ?
                                                       :   ?firstinput
                                                           "-step"
                                                           #%
                                                           ?
                                                       )
                                                    )
                                                  + ?
                                                )
                                              + ?moreinputs
                                            )
                                          + ?
                                        )
                                      + ?
                                    & :?inputs
                                    &   !someinputs+!moreinputs
                                      : ?moreinputs
                                    &   whl
                                      ' (   !moreinputs
                                          :   ?
                                            + ( ?
                                              .   ?
                                                + ( F
                                                  . @( ?
                                                     : ( ?other "-step" #% ?
                                                       | ?other
                                                       )
                                                     )
                                                  )
                                                + ?
                                              )
                                            + ?moreinputs
                                        & @( !firstinput
                                           : ?fh [%@(!other:?oh !sjt)
                                           )
                                        &     str
                                            $ (   ( !fh:
                                                  | !oh:
                                                  |   @(!fh:!oh "-" #?)
                                                    & :?oh
                                                  )
                                                & (     !inputs
                                                      : ( 
                                                        | !firstinput
                                                        )
                                                    &   (   @( !firstinput
                                                             : ? !fh ?
                                                             )
                                                          & 
                                                        | !fh
                                                        )
                                                        (   @( !firstinput
                                                             : ? !oh ?
                                                             )
                                                          & 
                                                        | !oh
                                                        )
                                                        !firstinput
                                                  | !inputs "_" !other
                                                  )
                                              |   (   !inputs:
                                                    & !fh "_"
                                                  | 
                                                  )
                                                  !oh
                                              )
                                          : ?inputs
                                        )
                                  )
                              & !inputs
                            |   ( !inputs:@
                                |     2
                                    *   mod
                                      $ ( div$(!DATE*(1+clk$),1)
                                        , 4231764527
                                        )
                                  + !jobNr*100
                                  + !ID
                                )
                                "-"
                                !jobNr
                            )
                            "-"
                            !jobID
                            "."
                            !extension
                          )
                    )
                : ?newJobs
              )
          & !jobs !newJobs:?jobs
          & saveTable$jobs
          & !maxjobID
      )
      "
/**
 * getNextJobID
 *
 * Given the jobNr of a workflow, return the next job that is not pending 
 * (=waiting for an another job to produce some of its inputs).
 * Argument: jobNr
 * Returns: jobID (if job found in jobs.table)
 *          empty string (if job not found in jobs.table)
 * Called from create.java and workflow.java
 */"
      ( getNextJobID
      =   A Z jobID dep g test err
        .     -11:?err
            & !arg:(?arg.?test)
            & -12:?err
            & @(!arg:? #?arg)
            & -13:?err
            & readTable$jobs
            & -14:?err
            & (     !jobs
                  :   ?A
                      ( !arg
                      . @?jobID
                      . ~(? (?,pending) ?):?dep
                      . ?g
                      )
                      ?Z
                & -15:?err
                & (   !test:justtesting
                    & -16:?err
                    & log$(getNextJobID !arg !jobID)
                    & -17:?err
                    & !jobID
                  |       !A
                          (!arg.!jobID starting.!dep.!g)
                          !Z
                      : ?jobs
                    & -18:?err
                    & (   log$(starting !arg !jobID)
                        & -19:?err
                        & (   saveTable$jobs
                            & -20:?err
                            & (   log$(getNextJobID !arg !jobID)
                                & !jobID
                              | !err
                              )
                          | !err
                          )
                      | !err
                      )
                  | 
                  )
              | 
              )
          | !err
      )
      ( goodRunningThreads
      =   
        .   (|log$(goodRunningThreads !runningThreads))
          & (!runningThreads:<8&y|n)
      )
      "
/**
 * getJobArg
 *
 * Consults tables jobs.table and tooladm.table to answer several requests
 * Arguments: jobNr, jobID and one of the following requests:
 *      endpoint        the URL where the integrated tool lives
 *      filename        the name to be given to the output
 *      method          POST or GET
 *      requestString   the request string as HTTP-parameters or as XML
 *      isXML           y or n
 * Called from workflow.java
 */"
      ( getJobArg
      =     JobNr jobID jobby res A B Res makeList
          , req servurl xmlparms
        .   str
          $ (   !arg:(@(?:? #?JobNr).?jobID.?arg)
              & (!jobs|readTable$jobs)
              & !jobs:? (!JobNr.!jobID ?.?jobby) ?
              &   !arg
                : ( endpoint&!jobby:(?.?arg.?)
                  |   method
                    & !jobby:(?.?arg.?)
                    & readTable$tooladm
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!arg) ?
                          : ? (PostData.?arg) ?
                          )
                        + ?
                    &   ( !arg:on&POST
                        | GET
                        )
                      : ?arg
                  |   requestString
                    &   1+!runningThreads
                      : ?runningThreads
                      : ( >!maxRunningThreads:?maxRunningThreads
                        | ?
                        )
                    &   log
                      $ ( str
                        $ ( "getJobArg:runningThreads:"
                            !runningThreads
                            " maxRunningThreads:"
                            !maxRunningThreads
                          )
                        )
                    & !jobby:(?.?servurl.?req.?)
                    & readTable$tooladm
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!servurl) ?
                          : ? (XMLparms.?xmlparms) ?
                          )
                        + ?
                    & (   !xmlparms:on
                        & ( makeList
                          =   X el sub res
                            .   :?res
                              &   whl
                                ' ( !arg:%?X+?arg
                                  &     !res
                                        (   !X:(?el.?sub)
                                          & (!el.,makeList$!sub)
                                        | !X
                                        )
                                    : ?res
                                  )
                              & !res
                          )
                        & makeList$(parms.!req):?res
                        & str$!res:?arg
                      |   ( makeList
                          =   A B prefix res
                            .   !arg:(?prefix.?arg)
                              & :?res
                              &   whl
                                ' ( !arg:%?A+?arg
                                  &     !res
                                        (   !A:(?A.?B)
                                          &   ( !prefix:
                                              | (!prefix,!A)
                                              )
                                                makeList
                                              $ (!prefix !A.!B)
                                        | !prefix:
                                        | (!prefix,!A)
                                        )
                                    : ?res
                                  )
                              & !res
                          )
                        & makeList$(.!req):?res
                        & !res:(?A,?B) ?res
                        & !A "=" !B:?Res
                        &   whl
                          ' ( !res:(?A,?B) ?res
                            & !Res "&" !A "=" !B:?Res
                            )
                        & str$!Res:?arg
                      )
                  | filename&!jobby:(?.?.?.?arg)
                  )
              & !arg
            | SOMETHINGWRONG
            )
      )
      "
/**
  * waitingJob
  *
  * Make a job 'waiting'.
  * 
  * Input: JobNr and jobID
  *
  * Affected tables:
  *     jobs.table
  *
  * Called from workflow.java
  */"
      ( waitingJob
      =   A Z JobNr jobID ZZ jobstatus
        .     readTable$jobs
            & log$("waitingJob " !arg)
            & !arg:(@(?:? #?JobNr).?jobID)
            &   whl
              ' (   !jobs
                  : ?A (!JobNr.!jobID ?jobstatus.?ZZ) ?Z
                & !jobstatus:(|starting)
                &   !A (!JobNr.!jobID waiting.!ZZ) !Z
                  : ?jobs
                )
            & saveTable$jobs
            & 
          | "Expecting (? #JobNr.jobID)"
      )
      ( tekstXML
      =     OLACTITLE DATE EMAIL TBA AVAILABILITY Description
          , OUTPUTFACET XMLID ITEMS TOOLURIS SPANGRP
          , ret linguae BODYCONTENT niceDate noColon
          , ToolID Title ToolContentProvider Version toolURL full
          , CTB LANGUAGE type appdesc
        .     !arg
            : ( ?OLACTITLE
              . ?DATE
              . ?EMAIL
              . ?CTB
              . ?TBA
              . ?AVAILABILITY
              . ?OUTPUTFACET
              . ?XMLID
              . ?ITEMS
              . ?TOOLURIS
              . ?SPANGRP
              . ?toolURL
              . ?LANGUAGE
              )
          & ( niceDate
            =   yyyy mm dd
              .     @( !arg
                     :   (% % % %:?yyyy)
                         (% %:?mm)
                         (% %:?dd)
                     )
                  & str$(!yyyy "-" !mm "-" !dd)
                | !arg
            )
          & ( noColon
            =   A Z
              .     whl
                  ' ( @(!arg:?A "::" ?Z)
                    & str$(!A "_" !Z):?arg
                    )
                &   whl
                  ' ( @(!arg:?A ":" ?Z)
                    & str$(!A "_" !Z):?arg
                    )
                & !arg
            )
          &   
            : ?Title
            : ?ToolContentProvider
            : ?Version
            : ?ToolID
            : ?Description
          & (   !SPANGRP
              : ? ("?".@(?:? xml ? version ?)) ?SPANGRP
            | 
            )
          & (     !SPANGRP
                :   ?
                    ( spanGrp
                    .   ? (ana.@(?:"#" ?XMLID)) ?
                      | ?
                    )
                    ?
              & :?BODYCONTENT
              & annotation:?type
            |   !SPANGRP:?BODYCONTENT
              & :?SPANGRP
              & text:?type
            )
          &     (   readTable$tooladm
                  &   !tooladm
                    :   ?
                      + ( ? (ServiceURL.!TOOLURIS) ?
                        : ? (ToolID.?ToolID) ?
                        : ? (Title.?Title) ?
                        : ? (ContentProvider.?ToolContentProvider) ?
                        : ? (Version.?Version) ?
                        : ? (Description.?Description) ?
                        )
                      + ?
                  & !Title
                | !toolURL
                )
                ". "
                !Description
            : ?appdesc
          &     ("?"."xml version=\"1.0\" encoding=\"UTF-8\"")
                \n
                ( TEI
                .     (xmlns."http://www.tei-c.org/ns/1.0")
                      ( "xmlns:schemaLocation"
                      .   "https://www.clarin.dk/schemas/tei/TEIDKCLARIN_ANNO/xml.xsd"
                        |   !type:text
                          & "http://www.clarin.eu/cmd http:/infra.clarin.dk/cmd/dkclarin-text-md-schema.xsd"
                        | "http://www.clarin.eu/cmd http://infra.clarin.dk/cmd/dkclarin-textann-md-schema.xsd"
                      )
                  ,   \n
                      ( teiHeader
                      .   (type.!type)
                        ,   ( fileDesc
                            .   
                              ,   ( titleStmt
                                  .   
                                    ,   (title.,!OLACTITLE ", TEI-format")
                                        (sponsor.,DK-CLARIN)
                                        ( respStmt
                                        .   
                                          ,   (resp.,"a_annotation")
                                              ( name
                                              .   
                                                ,   ( note
                                                    .   (type.method)
                                                      , !ToolID
                                                    )
                                                    ( date
                                                    .   (when.niceDate$!DATE)
                                                      , 
                                                    )
                                              )
                                        )
                                  )
                                  (   !type:text
                                    & ( extent
                                      . ,(num.(type.words),)
                                      )
                                  | 
                                  )
                                  ( publicationStmt
                                  .   
                                    ,   (distributor.,!EMAIL)
                                        (idno.(type.ctb),!CTB)
                                        ( availability
                                        .   (status.free)
                                          , (ab.(type.public),)
                                        )
                                  )
                                  ( notesStmt
                                  . ,(note.,localized$!OUTPUTFACET)
                                  )
                                  ( sourceDesc
                                  .   
                                    , ( biblStruct
                                      .   
                                        , ( monogr
                                          .   
                                            ,   ( title
                                                .   ("xml:lang".da)
                                                  , monogr
                                                )
                                                ( imprint
                                                .   
                                                  ,   ( publisher
                                                      .   (n.n/a)
                                                        , !ToolContentProvider
                                                      )
                                                      ( date
                                                      .   ( when
                                                          . niceDate$!DATE
                                                          )
                                                        , 
                                                      )
                                                )
                                          )
                                      )
                                  )
                            )
                            ( "!--"
                            .   toML
                              $ ( encodingDesc
                                .   
                                  ,   (samplingDecl.,(ab.,samplingDecl))
                                      (projectDesc.,(ab.,!TBA))
                                      ( !type:text&
                                      | ( appInfo
                                        .   
                                          , ( application
                                            .     ( ident
                                                  .   !ToolID
                                                      ( !Version:
                                                      | "_" !Version
                                                      )
                                                  )
                                                  (type."a_annotation")
                                                  (subtype.!OUTPUTFACET)
                                                  (version.!Version)
                                                  ("xml:id".!XMLID)
                                              ,   (desc.,!appdesc)
                                                  ( ptr
                                                  .   (target.noColon$!ITEMS)
                                                    , 
                                                  )
                                                  ( ref
                                                  .   (target.!TOOLURIS)
                                                    , 
                                                  )
                                            )
                                        )
                                      )
                                )
                            )
                            ( profileDesc
                            .   
                              ,   ( creation
                                  .   
                                    , ( date
                                      .     (cert.high)
                                            (when.niceDate$!DATE)
                                        , 
                                      )
                                  )
                                  ( !LANGUAGE:
                                  | ( langUsage
                                    .   
                                      , ( language
                                        .   (ident.!LANGUAGE)
                                          ,     readTable$linguae
                                              &   !linguae
                                                :   ?
                                                    (?full.!LANGUAGE.?)
                                                    ?
                                              & localized$!full
                                            | 
                                        )
                                    )
                                  )
                                  ( textDesc
                                  .   
                                    ,   (channel.(mode.w),2)
                                        (constitution.,)
                                        (derivation.,)
                                        ( domain
                                        . (type.specific),general
                                        )
                                        (factuality.,)
                                        (interaction.,)
                                        (preparedness.,)
                                        (purpose.,)
                                  )
                                  (particDesc.,(person.,))
                            )
                            ( revisionDesc
                            .   
                              , ( change
                                .     (when.niceDate$!DATE)
                                      (who.!EMAIL)
                                  ,     !type:text
                                      & !appdesc
                                    | created
                                )
                            )
                      )
                      \n
                      ( text
                      .   
                        ,   ( body
                            .   
                              ,     !BODYCONTENT:~
                                  & (   !BODYCONTENT
                                      : (   ?
                                            ( text
                                            .   ?
                                              ,   ?
                                                  (body.?,?BODYCONTENT)
                                                  ?
                                            )
                                            ?
                                        | ? (body.?,?BODYCONTENT) ?
                                        |   ?
                                            (body.?)
                                            ?BODYCONTENT
                                            (.body.)
                                            ?
                                        )
                                    | 
                                    )
                                  & !BODYCONTENT
                                | ( ab
                                  .   
                                    ,     !SPANGRP:
                                        & "empty body/no text"
                                      | 
                                  )
                            )
                            \n
                            !SPANGRP
                      )
                )
            : ?ret
          & !ret
      )
      "
/**
 * relationFile
 *
 * Create a relation file ready for deposition together with an annotation.
 *
 * Input: JobNr and jobID
 * Output: String that can be saved as a semicolon separated file.
 * Consulted tables:
 *      relations.table     (for relation type, ctb and ctbid
 *      CTBs.table          (for ContentProvider and CTBID)
 *
 * Called from workflow.java
 */"
      ( relationFile
      =     A Z JobNr jobID
          , ContentProvider CTBID ctb ctbid rel reltype
        .     !arg:(@(?:? #?JobNr).?jobID)
            & readTable$relations
            & readTable$CTBs
            &   !CTBs
              : ? (!JobNr.!jobID.?ContentProvider.?CTBID) ?
            & :?rel
            &   whl
              ' (   !relations
                  : ?A (!JobNr.!jobID.?reltype.?ctb.?ctbid) ?Z
                & !A !Z:?relations
                &     !rel
                      !reltype
                      ";"
                      !ContentProvider
                      ";"
                      !CTBID
                      ";"
                      !ctb
                      ";"
                      !ctbid
                      ";;\n"
                  : ?rel
                )
            & (|saveTable$relations)
            & str$!rel
          | 
      )
      ( isTEIoutput
      =   format JobNr jobID
        .   readTable$jobs
          & !arg:(@(?:? #?JobNr).?jobID)
          & (@(!jobID:?jobID " " ?)|)
          & (     !jobs
                :   ?
                    ( !JobNr
                    . !jobID ?
                    . ?
                    . ?
                    .   ?
                      + ( O
                        .   ?
                          + ( format
                            .   ( txtann
                                | txtbasis
                                | teip5
                                )
                              : ?format
                            . ?
                            )
                          + ?
                        )
                      + ?
                    . ?
                    )
                    ?
              &   log
                $ (str$("isTEIoutput(" !JobNr "." !jobID ")=[" !format "]"))
              & !format
            | 
            )
      )
      ( inject
      =     userProvidedMetadata autogenerated final recurse
          , Required/optional/automatic val Line tree
          , PlaceInHeader id addOrInsert remove Metadata
          , replaceOrInsert addOrInsertOneOrMoreNames metadataType
        .   ( remove
            =     PlaceInHeader tree subtree
                , place A Z a attval
              .   !arg:(?PlaceInHeader.?tree)
                & (   !PlaceInHeader:%?place ?PlaceInHeader
                    & (   !PlaceInHeader:
                        & (   !place:(?place,?attval)
                            &   whl
                              ' (   !tree
                                  :   ?A
                                      (!place.? !attval ?,?)
                                      ?Z
                                & !A !Z:?tree
                                )
                          |   whl
                            ' ( !tree:?A (!place.?,?) ?Z
                              & !A !Z:?tree
                              )
                          )
                        & !tree
                      |   (   !place:(?place,?attval)
                            &   !tree
                              :   ?A
                                  (!place.? !attval ?:?a,?subtree)
                                  ?Z
                          | !tree:?A (!place.?a,?subtree) ?Z
                          )
                        &   !A
                            (!place.!a,remove$(!PlaceInHeader.!subtree))
                            remove$(!place !PlaceInHeader.!Z)
                      )
                  | !tree
                  )
            )
          & ( replaceOrInsert
            =     PlaceInHeader val tree subtree
                , place plac at A E Z a z attval
              .   !arg:(?PlaceInHeader.?val.?tree)
                & (   !PlaceInHeader:%?place ?PlaceInHeader
                    & (   !place:(?place.?at)
                        & (     !tree
                              :   ?A
                                  (!place.?a (!at.?) ?z,?E)
                                  ?Z
                            &   !A
                                (!place.!a (!at.!val) !z,!E)
                                !Z
                          | !tree (!place.(!at.!val),)
                          )
                      |   !place:(?plac,?attval)
                        &   !tree
                          :   ?A
                              (!plac.? !attval ?:?a,?subtree)
                              ?Z
                        &   !A
                            ( !plac
                            .   !a
                              ,   replaceOrInsert
                                $ (!PlaceInHeader.!val.!subtree)
                            )
                            !Z
                      |   !tree:?A (!place.?a,?subtree) ?Z
                        &   !A
                            ( !place
                            .   !a
                              ,   replaceOrInsert
                                $ (!PlaceInHeader.!val.!subtree)
                            )
                            !Z
                      |   !tree
                          (   !place:(?plac,?attval)
                            & ( !plac
                              .   !attval
                                , replaceOrInsert$(!PlaceInHeader.!val.)
                              )
                          | ( !place
                            . ,replaceOrInsert$(!PlaceInHeader.!val.)
                            )
                          )
                      )
                  | !val
                  )
            )
          & ( recurse
            =   A Z a attval place subtree
              .   !PlaceInHeader:%?place ?PlaceInHeader
                & (   !place:(?place,?attval)
                    & (     !tree
                          :   ?A
                              (!place.? !attval ?:?a,?subtree)
                              ?Z
                        &   !A
                            (!place.!a,!arg$(!PlaceInHeader.!val.!subtree))
                            !Z
                      |   !tree
                          (!place.!attval,!arg$(!PlaceInHeader.!val.))
                      )
                  |   !tree:?A (!place.?a,?subtree) ?Z
                    &   !A
                        (!place.!a,!arg$(!PlaceInHeader.!val.!subtree))
                        !Z
                  | !tree (!place.,!arg$(!PlaceInHeader.!val.))
                  )
            )
          & ( final
            =   A Z a attval b
              .     !PlaceInHeader:@
                  & (     !tree
                        :   ?A
                            (!PlaceInHeader.?a,?b)
                            (~((!PlaceInHeader.?) ?):?Z)
                      &   !A
                          (!PlaceInHeader.!a,!b)
                          (!PlaceInHeader.!a,!val)
                          !Z
                    | !tree (!PlaceInHeader.,!val)
                    )
                |   !PlaceInHeader:(?PlaceInHeader,?attval)
                  & (     !tree
                        :   ?A
                            (!PlaceInHeader.? !attval ?:?a,?b)
                            ( ~( (!PlaceInHeader.? !attval ?,?)
                                 ?
                               )
                            : ?Z
                            )
                      &   !A
                          (!PlaceInHeader.!a,!b)
                          (!PlaceInHeader.!a,!val)
                          !Z
                    | !tree (!PlaceInHeader.!attval,!val)
                    )
            )
          & ( addOrInsert
            =   PlaceInHeader val tree
              .   !arg:(?PlaceInHeader.?val.?tree)
                & ( final$
                  | recurse$addOrInsert
                  | !val
                  )
            )
          & ( addOrInsertOneOrMoreNames
            =     PlaceInHeader val tree parnt
                , A Z a b c d e
              .   !arg:(?PlaceInHeader.?val.?tree)
                & (   !PlaceInHeader:@?parnt name
                    & (     !tree
                          :   ?A
                              (!parnt.?a,?b (name.?c,?d) ?e)
                              (~((!parnt.?) ?):?Z)
                        &   !A
                            (!parnt.!a,!b (name.!c,!d) !e)
                            (!parnt.!a,!b (name.!c,!val) !e)
                            !Z
                      |   !tree:?A (!parnt.?a,?b) ?Z
                        &   !A
                            (!parnt.!a,(name.,!val) !b)
                            !Z
                      | !tree (!parnt.,(name.,!val))
                      )
                  | final$
                  | recurse$addOrInsertOneOrMoreNames
                  | !val
                  )
            )
          & !arg:(?userProvidedMetadata.?autogenerated.?metadataType)
          & readTable$!metadataType:?Metadata
          &   whl
            ' (   !userProvidedMetadata
                : (?id.?val) ?userProvidedMetadata
              & trim$!val:?val
              & (     !Metadata
                    :   ?
                        ( ?
                        ,   ?
                            ( !id
                            . ?
                            . ?Required/optional/automatic
                            . ?
                            . ?PlaceInHeader
                            . ?
                            . ?
                            . ?
                            )
                            ?
                        )
                        ?
                  &   (     !Required/optional/automatic
                          : ( ? r ?
                            | ? o ?&!val:~
                            )
                        &   replaceOrInsert
                          $ (!PlaceInHeader.!val.!autogenerated)
                      |     !Required/optional/automatic
                          : (   ? (o|zeroOrMore) ?
                              : ~(? a ?)
                            & !val:
                            )
                        &   remove$(!PlaceInHeader.!autogenerated)
                          : ?autogenerated
                      |     !Required/optional/automatic
                          : ( ? oneOrMore ?
                            | ? zeroOrMore ?&!val:~
                            )
                        &   remove$(!PlaceInHeader.!autogenerated)
                          : ?autogenerated
                        &   whl
                          ' ( @( !val
                               : ( ?Line \n ?val
                                 | ?Line&:?val
                                 )
                               )
                            & trim$!Line:?Line
                            & ( !Line:
                              |     (     !Required/optional/automatic
                                        : ? oneOrMore ?
                                      & addOrInsertOneOrMoreNames
                                    | addOrInsert
                                    )
                                  $ (!PlaceInHeader.!Line.!autogenerated)
                                : ?autogenerated
                              )
                            & !val:~
                            )
                        & !autogenerated
                      |   !Required/optional/automatic:? a ?
                        &   replaceOrInsert
                          $ (!PlaceInHeader.!val.!autogenerated)
                      )
                    : ?autogenerated
                | 
                )
              )
          & !autogenerated
      )
      ( Filename
      =   base
        .   str
          $ ( ( @(!arg:?base ".xml")&!base
              | !arg
              )
              ".withmetadata.xml"
            )
      )
      (RelationsFile=.str$(!arg ".relations.csv"))
      "
/**
 * doneJob
 *
 * Marks a job as 'done' in jobs.table
 * Constructs a CTBID from date, JobNr and jobID
 * Makes sure there is a row in table CTBs connecting
 *      JobNr, jobID, email and CTBID
 * Creates isDependentOf and isAnnotationOf relations
 * Affected tables:
 *      jobs.table
 *      CTBs.table
 *      relations.table
 * Arguments: jobNR, JobID, spangroup with annotation and date. 
 *
 * Called from workflow.java
 */"
      ( doneJob
      =     A Z JobNr jobID ZZ jobid2 a z files facet S
          , prevTitle findOLACTITLEinPreviousSteps
          , ctb ctbid CTBID filename
          , toolURL parms file TITLE DATE
          , OLACTITLE DATE EMAIL TBA AVAILABILITY
          , SPANGRP SPANGRPfil SPANGRPfilWithMetadata
          , OUTPUTFACET XMLID ITEMS ZZ LANGUAGE identifier
          , userProvidedMetadata autogenerated extent
          , facets type2facet ensureRelation updateOLACTITLE
        .     readTable$jobs
            &   
              : ?TITLE
              : ?DATE
              : ?OLACTITLE
              : ?EMAIL
              : ?TBA
              : ?AVAILABILITY
              : ?OUTPUTFACET
              : ?XMLID
              : ?ITEMS
              : ?SPANGRP
              : ?LANGUAGE
            &   !arg
              : (@(?:? #?JobNr).%@?jobID ?.?SPANGRPfil.?DATE)
            & -1+!runningThreads:?runningThreads
            &   log
              $ ( str
                $ ( "doneJob:runningThreads:"
                    !runningThreads
                    " maxRunningThreads:"
                    !maxRunningThreads
                  )
                )
            & log$(JobNr !JobNr jobID !jobID DATE !DATE)
            & str$(!DATE "-" !JobNr "-" !jobID):?CTBID
            & (readTable$CTBs|:?CTBs)
            &   ( !SPANGRPfil:
                | get$(!SPANGRPfil,X ML)
                )
              : ?SPANGRP
            & nestML$!SPANGRP:?SPANGRP
            & ( extent
              =   n recur
                .   0:?n
                  & ( recur
                    =   S
                      .     !arg:? (w.?) ?
                          &   whl
                            ' ( !arg:? (w.?) ?arg
                              & 1+!n:?n
                              )
                        |   whl
                          ' ( !arg:? (?.?,?S) ?arg
                            & recur$!S
                            )
                    )
                  & recur$!arg
                  & !n
              )
            & ( identifier
              =   jobs
                .     readTable$jobs
                    &   !jobs
                      :   ?
                          (!JobNr.!jobID ?.?.?.?.?filename)
                          ?
                    & !filename
                  | 
              )
            & readTable$Uploads
            & readTable$facets
            & (readTable$relations|:?relations)
            & ( ensureRelation
              =   
                .   !relations:? !arg ?
                  | !relations !arg:?relations
              )
            & ( updateOLACTITLE
              =   ELTIT TIT sam TITLE prevTitle OLACTITLE
                .   !arg:(?TITLE.?prevTitle.?OLACTITLE)
                  & (   rev$!TITLE:?ELTIT
                      & @( rev$!prevTitle
                         : ? (?sam&@(!ELTIT:?TIT !sam))
                         )
                      & ( !sam:
                        | !TIT::?TITLE
                        | str$("-" rev$!TIT):?TITLE
                        )
                    | 
                    )
                  & ( !TITLE
                    .   (!OLACTITLE:|!OLACTITLE " ")
                        !TITLE
                    )
              )
            & ( findOLACTITLEinPreviousSteps
              =     jobs Uploads JobNr jobID files
                  , file TITLE prevTitle OLACTITLE
                .     !arg
                    : (?jobs.?Uploads.?JobNr.?jobID.?prevTitle.?OLACTITLE)
                  & (     !jobs
                        : ? (!JobNr.!jobID ?.?files.?) ?
                      &   whl
                        ' ( !files:%?file ?files
                          & (     !Uploads
                                :   ?
                                    ( ?
                                    . ?
                                    . !file
                                    . ? (TITLE.?TITLE) ?
                                    . ?
                                    )
                                    ?
                              &     updateOLACTITLE
                                  $ (!TITLE.!prevTitle.!OLACTITLE)
                                : (?prevTitle.?OLACTITLE)
                            |     findOLACTITLEinPreviousSteps
                                $ ( !jobs
                                  . !Uploads
                                  . !JobNr
                                  . !file
                                  . !prevTitle
                                  . !OLACTITLE
                                  )
                              : (?prevTitle.?OLACTITLE)
                            )
                          )
                    | 
                    )
                  & (!prevTitle.!OLACTITLE)
              )
            &   whl
              ' (   !jobs
                  :   ?A
                      ( !JobNr
                      .   !jobID
                          (|starting|waiting)
                      . ?ZZ:?files
                      . ?toolURL
                      . ?parms
                      . ?filename
                      )
                      ?Z
                &     !A
                      ( !JobNr
                      . !jobID done
                      . !files
                      . !toolURL
                      . !parms
                      . !filename
                      )
                      !Z
                  : ?jobs
                & ( !CTBs:? (!JobNr.!jobID.!EMAIL.!CTBID) ?
                  |     (!CTBs|)
                        (!JobNr.!jobID.!EMAIL.!CTBID)
                    : ?CTBs
                  )
                & :?prevTitle
                &   whl
                  ' ( !files:%?file ?files
                    &     findOLACTITLEinPreviousSteps
                        $ ( !jobs
                          . !Uploads
                          . !JobNr
                          . !file
                          . !prevTitle
                          . !OLACTITLE
                          )
                      : (?prevTitle.?OLACTITLE)
                    & (     !CTBs
                          : ? (!JobNr.!file.?ctb.?ctbid) ?
                        &   ensureRelation
                          $ (!JobNr.!jobID.isDependentOf.!ctb.!ctbid)
                        & ( !ITEMS:? !ctb "::" !ctbid ?
                          |     !ITEMS
                                (!ITEMS:|" ")
                                !ctb
                                "::"
                                !ctbid
                            : ?ITEMS
                          )
                      | 
                      )
                    )
                & (   !parms:?+(O.?+(facet.?facet.?)+?)+?
                    & (   readTable$subtype2facet
                        &   !subtype2facet
                          : ? (?OUTPUTFACET.!facet) ?
                      |   readTable$type2facet
                        &   !type2facet
                          : ? (?OUTPUTFACET.!facet) ?
                      | !facets:? (?OUTPUTFACET.!facet.?) ?
                      )
                  | 
                  )
                & ( !parms:?+(O.?+(lang.?LANGUAGE.?)+?)+?
                  | 
                  )
                )
            &   whl
              ' (   !jobs
                  :   ?A
                      ( !JobNr
                      . %@?jobid2 ?S
                      . ?a (!jobID,pending) ?z
                      . ?ZZ
                      )
                      ?Z
                &     !A
                      (!JobNr.!jobid2 !S.!a !jobID !z.!ZZ)
                      !Z
                  : ?jobs
                )
            & saveTable$CTBs
            & saveTable$jobs
            & saveTable$relations
            & ( !SPANGRP:? (TEI.?) ?&
              |   Filename$!SPANGRPfil:?SPANGRPfilWithMetadata
                &     tekstXML
                    $ ( !OLACTITLE|
                      . !DATE|
                      . !EMAIL
                      . !CTBID
                      . TBA
                      . AVAILABILITY
                      . !OUTPUTFACET
                      . XMLID
                      . str$!ITEMS
                      . !toolURL
                      . !SPANGRP|
                      . !toolURL
                      . !LANGUAGE
                      )
                  : ?autogenerated
                &   put
                  $ (   str
                      $ ( toML
                        $ (   readTable$jobAbout
                            &   !jobAbout
                              :   ?
                                  ( !JobNr
                                  .   ?
                                      ( userProvidedMetadata
                                      . ?userProvidedMetadata
                                      )
                                      ?
                                  )
                                  ?
                            & ( "Code below is WRONG. fpi is CTB and already decided. We cannot just change it. The relations files must mention correct CTBs."
                              |     !userProvidedMetadata
                                  : ?A (fpi.) ?Z
                                &   !A (fpi.identifier$) !Z
                                  : ?userProvidedMetadata
                              |   !userProvidedMetadata
                                : ? (fpi.?) ?
                              |     (fpi.identifier$)
                                    !userProvidedMetadata
                                : ?userProvidedMetadata
                              | 
                              )
                            & (     !userProvidedMetadata
                                  : ?A (fpi.?) ?Z
                                & !A !Z:?userProvidedMetadata
                              | 
                              )
                            &   inject
                              $ (   (     !autogenerated
                                        :   ?
                                            ( TEI
                                            .   ?
                                              ,   ?
                                                  ( teiHeader
                                                  .     ?
                                                        (type.text)
                                                        ?
                                                    , ?
                                                  )
                                                  ?
                                            )
                                            ?
                                      & (fen.extent$!SPANGRP)
                                    | 
                                    )
                                    !userProvidedMetadata
                                . !autogenerated
                                . TEImetadata
                                )
                          | !autogenerated
                          )
                        )
                    , !SPANGRPfilWithMetadata
                    , NEW
                    )
                & !SPANGRPfilWithMetadata
              )
          | 
      )
      ( inputResources
      =   
        .   readTable$Uploads
          &   map
            $ ( ( 
                =   item TITLE
                  .       !Uploads
                        :   ?
                            ( ?
                            . ?item
                            . !arg
                            . ? (TITLE.?TITLE) ?
                            . ?
                            )
                            ?
                      & (item.,(id.,!item) (title.,!TITLE))
                    | 
                )
              . !arg
              )
      )
      ( toolName
      =   
        .   readTable$tooladm
          &   !tooladm
            :   ?
              + ( ? (ServiceURL.!arg) ?
                : ? (Title.?arg) ?
                )
              + ?
          & !arg
      )
      "
/**
 * abortJob
 *
 * Aborts, given a JobNr and a jobID, the specified job and all
 * pending jobs that depend on the output from the (now aborted) job.
 * Rather than removing the aborted jobs from the jobs.table list, they are
 * marked 'aborted'.
 *
 * Called from workflow.java
 */"
      ( abortJob
      =   abort JobNr jobID todelete
        .   readTable$jobs
          & log$("abortJob " !arg)
          & !arg:(@(?:? #?JobNr).?jobID)
          & (!JobNr.!jobID):?todelete
          & ( abort
            =     JobNr jobID jobid2 A Z ZZ a z
                , URL tool items todelete
              .   !arg:(?JobNr.?jobID) ?todelete
                & log$(abort !arg)
                &   !jobs
                  :   ?A
                      ( !JobNr
                      . !jobID ~aborted
                      .   ?items
                        & inputResources$!items:?items
                      . ?URL&toolName$!URL:?tool
                      . ?ZZ
                      )
                      ?Z
                & log$(going to abort !JobNr !jobID)
                &     !A
                      (!JobNr.!jobID aborted.!items.!URL.!ZZ)
                      !Z
                  : ?jobs
                & log$(aborted !JobNr !jobID)
                &   whl
                  ' (   !jobs
                      :   ?A
                          ( !JobNr
                          . %?jobid2 ?
                          . ?a (!jobID,pending) ?z
                          . ?URL&toolName$!URL:?tool
                          . ?ZZ
                          )
                          ?Z
                    & log$(depending !JobNr !jobid2)
                    &     !A
                          (!JobNr.!jobid2.!a !jobID !z.!URL.!ZZ)
                          !Z
                      : ?jobs
                    & (!JobNr.!jobid2) !todelete:?todelete
                    & log$(todelete !todelete)
                    )
                & log$(delete !todelete)
                & !todelete
            )
          &   whl
            ' ( log$(iterDO !todelete)
              & abort$!todelete:?todelete
              )
          & saveTable$jobs
      )
      ( deleteDepending
      =   jobNr jobID
        .   !arg:(?jobNr.?jobID)
          & !( 
             ' (     map
                   $ ( ( 
                       =   
                         .   !arg:($jobNr.$jobID.?)
                           | 
                       )
                     . $CTBs
                     )
                 : ?CTBs
               &     map
                   $ ( ( 
                       =   
                         .   !arg:($jobNr.$jobID.?)
                           | 
                       )
                     . $relations
                     )
                 : ?relations
               &     map
                   $ ( ( 
                       = .!arg:($jobNr.?)|
                       )
                     . $jobAbout
                     )
                 : ?jobAbout
               )
             )
      )
      ( addurl
      =   URL
        .     !arg:(?arg.?URL)
            & !URL:
            & !arg
          |   ( @(!URL:http ?)
              | str$("http://" !URL):?URL
              )
            & (a.(href.!URL),!arg)
      )
      ( jobMetaData
      =     userProvidedMetadata Metadata Heading Fields
          , listOfFields Val XPath HTML workflow
          , ID TextInUI Required Control Place
          , Notes HelpText Pattern URL type
        .     readTable$jobAbout
            & (     !jobAbout
                  :   ?
                      ( !arg
                      .   ? (human.?workflow) ?
                        :   ?
                            (userProvidedMetadata.?userProvidedMetadata)
                            ?
                      )
                      ?
                & readTable$TEImetadata:?Metadata
                &   ( !userProvidedMetadata:&TEI
                    | UserProvided
                    )
                  : ?type
                & ( XPath
                  =   el at
                    .     !arg:%?el ?arg
                        & (   !el:(?el.?at)
                            & "/" !el "/@" !at
                          | "/" !el XPath$!arg
                          )
                      | 
                  )
                & ( listOfFields
                  =   
                    .   map
                      $ ( ( 
                          =   
                            .     !arg
                                : ( ?ID
                                  . ?TextInUI
                                  . ?Required
                                  . ?Control
                                  . ?Place
                                  . ?Notes
                                  . ?HelpText
                                  . ?Pattern
                                  . ?URL
                                  )
                              & (     !userProvidedMetadata
                                    : ? (!ID.?Val) ?
                                  &   ( dt
                                      .   
                                        ,   addurl
                                          $ (localized$!TextInUI.!URL)
                                      )
                                      (dd.,"XPath: " XPath$!Place)
                                      ( dd
                                      .   
                                        ,   localized$(Value Værdi)
                                            ": "
                                            ( strong
                                            .   
                                              ,   !Val:~
                                                | " "
                                            )
                                      )
                                | 
                                )
                          )
                        . !arg
                        )
                  )
                & :?HTML
                &   whl
                  ' (   !Metadata
                      : ? (?Heading,?Fields) ?Metadata
                    &     !HTML
                          (h2.,localized$!Heading)
                          (dl.,listOfFields$!Fields)
                      : ?HTML
                    )
                & (!HTML.!type)
              | (.)
              )
          | (.)
      )
      ( letterData
      =     Steps menneskesprog workflow JobNr jobs I O
          , aborted done filelist filename items JobId URL tool
        .   ( menneskesprog
            =     desc featdesc feature featvals featname
                , table specificationTables features
              .   !arg:(?arg.?features)
                & :?desc
                &   whl
                  ' ( !arg:(?feature.?featvals.?)+?arg
                    &   !features
                      :   ?
                        + ( ? (short.!feature) ?
                          : ? (name.?featname) ?
                          : ? (table.?table) ?
                          : (   ?
                                (specificationTable.?specificationTables)
                                ?
                            | ?&:?specificationTables
                            )
                          )
                        + ?
                    &     describefeature
                        $ (!featvals.!table.!specificationTables)
                      : ?featdesc
                    & ( !featdesc:
                      |     !desc
                            (!desc:|", ")
                            localized$!featname
                            "="
                            !featdesc
                        : ?desc
                      )
                    )
                & str$!desc
            )
          & ( Steps
            =     x items tool JobNr JobId
                , format I O format stage
              .       !arg
                    : ( ?JobNr
                      . @(?:? #?JobId)
                      . ?x
                      . ?items
                      . ?tool
                      . ?I
                      . ?O
                      . ?stage
                      )
                  & ( step
                    .   
                      ,   (JobNr.,!JobNr)
                          (JobId.,!JobId)
                          (name.,!x)
                          (tool.,!tool)
                          (items.,!items)
                          (input.,menneskesprog$(!I.!features))
                          (output.,menneskesprog$(!O.!features))
                          ( format
                          .   
                            ,     !O:?+(format.?format.?)+?
                                & !format
                              | 
                          )
                          (stage.,!stage)
                    )
                | 
            )
          & readTable$features
          & readTable$jobAbout
          & (   !jobAbout
              : ? (!JobNr.? (human.?workflow) ?) ?
            | :?workflow
            )
          & !arg:?JobNr
          & readTable$jobs
          & :?filelist
          &   whl
            ' ( :?aborted:?done
              &   !jobs
                :   ?
                    ( !JobNr
                    .   %@?JobId
                        (   aborted:?aborted
                          & :?done
                        |   done:?done
                          & :?aborted
                        |   ( 
                            | starting
                            | waiting
                            )
                          & :?aborted:?done
                        )
                    .   ?items
                      & inputResources$!items:?items
                    . ?URL&toolName$!URL:?tool
                    .   ?+(I.?I)+?:?+(O.?O)+?
                      | ?&:?I:?O
                    . ?filename
                    )
                    ?jobs
              &     !filelist
                    ( !JobNr
                    . !JobId
                    .   !aborted:aborted&fejl
                      | !filename
                    . !items
                    . !tool
                    . !I
                    . !O
                    .     ( !aborted:aborted
                          |   !jobs
                            : ? (!JobNr.?.? !JobId ?.?) ?
                          )
                        & 
                      | LAST
                    )
                : ?filelist
              )
          &   (workflow.,!workflow)
              (steps.,map$(Steps.!filelist))
      )
      ( doneAllJobSub
      =   JobNr
        .   readTable$jobs
          & log$("doneAllJobSub " !arg)
          & @(!arg:? #?JobNr)
          & readTable$CTBs
          & readTable$relations
          & readTable$jobAbout
          &     map
              $ ( ( 
                  =   JobId
                    .     !arg:(!JobNr.%@?JobId ?.?.?.?.?)
                        & deleteDepending$(!JobNr.!JobId)
                        & 
                      | !arg
                  )
                . !jobs
                )
            : ?jobs
          & saveTable$jobs
          & saveTable$CTBs
          & saveTable$relations
          & saveTable$jobAbout
      )
      (FilenameNoMetadata=.!arg)
      (FilenameRelations=.str$(!arg ".relations.csv"))
      ( readme
      =     jobNr date yyyy mm dd letter File Files
          , inputs results
        .     !arg
            : ( ?jobNr
              . @( ?date
                 :   (% % % %:?yyyy)
                     (% %:?mm)
                     (% %:?dd)
                 )
              . ?letter
              )
          & readTable$Uploads
          & :?Files:?inputs:?results
          &   whl
            ' ( @(!letter:? "file:" ?File ";" ?letter)
              & (@(!File:? "*" ?File)|)
              &     !Files
                    "    "
                    !File
                    (   !Uploads:? (?.!File.?) ?
                      & !inputs !File ",\r\n  ":?inputs
                      & " (input)"
                    |   @(!File:? ".xml")
                      & !results !File ",\r\n  ":?results
                      & 
                    | 
                    )
                    \r\n
                : ?Files
              )
          &   str
            $ ( README
                \r\n
                !yyyy
                "."
                !mm
                "."
                !dd
                \r\n\r\n
                "job "
                !jobNr
                \r\n\r\n
                "zip-filen ("
                !jobNr
                ".zip) indeholder:"
                \r\n
                ( !inputs:
                |   "- "
                    !inputs
                    "som er "
                    ( !inputs:@ @&inputfilen
                    | inputfilerne
                    )
                    \r\n\r\n
                )
                ( !results:
                |   "- "
                    !results
                    "som er "
                    ( !results:@ @&resultatet
                    | resultater
                    )
                    ", dvs. "
                    ( !results:@ @&inputteksten
                    | inputtekst
                    )
                    " klargjort til deponering."
                    \r\n
                    "  "
                    ( !results:@ @&"Denne fil"
                    | "Disse filer"
                    )
                    " kan deponeres i CLARIN.DK’s repositorie eller bruges som input"
                    \r\n
                    "  til annotering vha. CLARIN.DK’s værktøjer."
                    \r\n\r\n
                )
                "- index.html som indeholder detaljer om klargøringsprocessen, herunder de"
                \r\n
                "  metadata der blev angivet i interfacet samt beskrivelser af de anvendte"
                \r\n
                "  værktøjer."
                \r\n\r\n
                (   !inputs:
                  &   "- CMDI.xml som er CMDI metadatafilen som kan uploades sammen med din dataresurse."
                      \r\n\r\n
                |   "- resten er filerne er mellemtrin som du kan se bort fra hvis processen er"
                    \r\n
                    "  forløbet korrekt. Hvis der er fejl i den klargjorte tekst, er det sikrest"
                    \r\n
                    "  at rette i et af mellemtrinnene og uploade denne fil til klargøring igen."
                    \r\n
                    "  Det er ikke tilrådeligt at rette i tekstdelen i "
                    ( !results:@ @&filen
                    | filerne
                    )
                    "\r\n  "
                    !results
                    "da hvert enkelt ord er unik nummereret hvilket er krævet i den videre"
                    \r\n
                    "  lingvistiske processering. Metadataene kan man dog rolig rette i."
                    \r\n\r\n
                    "  Filerne er genereret i følgende rækkefølge:"
                    \r\n
                    !Files
                )
                \r\n\r\n
                "Hvis du har brug for hjælp til at deponere dine data eller har andre spørgsmål"
                \r\n
                "er du velkommen til at henvende dig til info@clarin.dk"
                \r\n
              )
      )
      ( letter
      =     workflow steps resources files inps Steps html
          , metadata explain type shortletter
        .   ( inps
            =   a
              .     !arg:%?a ?arg
                  &   (a.(href.!a),!a)
                      (br.,)
                      inps$!arg
                | 
            )
          & ( explain
            =   explanation
              .     !fileFormats:? (?.!arg.?explanation) ?
                  & !explanation:~
                  & " (" localized$!explanation ") "
                | 
            )
          & ( Steps
            =     body JobNr JobId filename tool
                , items I O format id title fil
                , Href2 Href2nometa Href2relations
                , stage steps shortletter type
              .   !arg:(?steps.?shortletter.?type)
                & log$("STEPS:type=" !type)
                &     map
                    $ ( ( 
                        =   relationsfil
                          .     !arg
                              : ( step
                                .   
                                  ,   (JobNr.,?JobNr)
                                      (JobId.,?JobId)
                                      (name.,?filename)
                                      (tool.,?tool)
                                      (items.,?items)
                                      (input.,?I)
                                      (output.,?O)
                                      (format.,?format)
                                      (stage.,?stage)
                                )
                            &   whl
                              ' (   !items
                                  :   ( item
                                      .   
                                        ,   ? (id.,?id) ?
                                          : ? (title.,?title) ?
                                      )
                                      ?items
                                & ( !resources:? !title ?
                                  |   !resources !title:?resources
                                    & (     !Uploads
                                          : ? (?.!title.?fil.?) ?
                                        & ( !shortletter:y
                                          |     !files
                                                "file:"
                                                !fil
                                                "*"
                                                !title
                                                ";"
                                            : ?files
                                          )
                                      | 
                                      )
                                  )
                                )
                            & (   @(!filename:fejl ?)
                                & log$fejl
                                &   ( h2
                                    .   
                                      ,   localized
                                        $ ( "The following step(s) failed:"
                                            "Følgende trin fejlede:"
                                          )
                                    )
                                    ( dl
                                    .   
                                      ,   ( dt
                                          .   
                                            , ( strong
                                              .   
                                                ,   str
                                                  $ (   localized
                                                      $ ("Step " "Trin ")
                                                      !JobId
                                                    )
                                              )
                                          )
                                          (dd.,!tool)
                                    )
                              |   ( !shortletter:~y
                                  | !stage:LAST
                                  )
                                &   ( !type:TEI&
                                    | Filename$!filename
                                    )
                                  : ?Href2
                                &   FilenameNoMetadata$!filename
                                  : ?Href2nometa
                                &   FilenameRelations$!filename
                                  : ?Href2relations
                                &   RelationsFile$!filename
                                  : ?relationsfil
                                &   ( dt
                                    .   
                                      , ( strong
                                        .   
                                          ,   str
                                            $ ( localized$("Step " "Trin ")
                                                !JobId
                                                (   !shortletter:y
                                                  & 
                                                |   !stage:LAST
                                                  &   localized
                                                    $ (" (last)" " (sidste)")
                                                | 
                                                )
                                              )
                                        )
                                    )
                                    ( dd
                                    .   
                                      ,     @(!O:? TEI ?)
                                          & ( 
                                            | !format:~teip5
                                            )
                                          & (     !format
                                                : ( txtbasis
                                                  | teip5
                                                  )
                                              & !type:TEI
                                              &     !files
                                                    "file:"
                                                    !Href2relations
                                                    ";file:"
                                                    !Href2nometa
                                                    ";"
                                                : ?files
                                              &   str$(!tool ": ")
                                                  ( a
                                                  .   (href.!Href2relations)
                                                    , !relationsfil
                                                  )
                                                  ", "
                                                  ( a
                                                  .   (href.!Href2nometa)
                                                    ,   localized
                                                      $ ( "with original metadata"
                                                          "med oprindelig metadata"
                                                        )
                                                  )
                                            |     !format
                                                : ( txtann
                                                  | txtbasis
                                                  | teip5
                                                  )
                                              &     !files
                                                    "file:"
                                                    ( !Href2:
                                                    | !Href2 ";file:"
                                                    )
                                                    !Href2relations
                                                    ";file:"
                                                    !Href2nometa
                                                    ";"
                                                : ?files
                                              &   str$(!tool ": ")
                                                  ( !Href2:
                                                  |   ( a
                                                      .   (href.!Href2)
                                                        ,   localized
                                                          $ ( "including metadata"
                                                              "inklusiv metadata"
                                                            )
                                                      )
                                                      ","
                                                  )
                                                  ( a
                                                  .   (href.!Href2relations)
                                                    , !relationsfil
                                                  )
                                                  ", "
                                                  ( a
                                                  .   (href.!Href2nometa)
                                                    ,   localized
                                                      $ ( "without metadata"
                                                          "uden metadata"
                                                        )
                                                  )
                                            | !Href2:
                                            |       !files
                                                    "file:"
                                                    !Href2
                                                    "*"
                                                    !filename
                                                    ";"
                                                : ?files
                                              &   str$(!tool ": ")
                                                  ( a
                                                  .   (href.!filename)
                                                    , basistekst
                                                  )
                                                  explain$!format
                                            )
                                        |       !files
                                                "file:"
                                                !Href2nometa
                                                "*"
                                                !filename
                                                ";"
                                            : ?files
                                          &   str$(!tool ": ")
                                              ( a
                                              .   (href.!filename)
                                                , data
                                              )
                                              explain$!format
                                    )
                                    ( !I:!O:
                                    | ( dl
                                      .   
                                        ,   ( !I:
                                            |   (dt.,Input)
                                                (dd.,!I)
                                            )
                                            ( !O:
                                            |   (dt.,Output)
                                                (dd.,!O)
                                            )
                                      )
                                    )
                              | 
                              )
                        )
                      . !steps
                      )
                  : ?body
                & (dl.,!body)
            )
          & !arg:(?arg.?shortletter)
          & "shortletter: y or n"
          &   ( 
              =   zippedresults zipfile
                .   ( readTable$zippedresults
                    | :?zippedresults
                    )
                  &     str
                      $ ( !arg
                          ( !shortletter:y&"-final"
                          | "-all"
                          )
                          ".zip"
                        )
                    : ?zipfile
                  & ( !zippedresults:? !zipfile ?
                    | !zipfile !zippedresults:?zippedresults
                    )
                  & saveTable$zippedresults
              )
            $ !arg
          & jobMetaData$!arg:(?metadata.?type)
          & "type == () | TEI | UserProvided"
          & readTable$fileFormats
          & readTable$Uploads
          &   (letterData$!arg|doneAllJobSub$!arg)
            : (workflow.,?workflow) (steps.,?steps)
          & :?resources:?files
          &     toML
              $ ( html
                .   
                  ,   ( head
                      .   
                        ,   (meta.charset.UTF-8)
                            ( title
                            .   
                              ,   localized
                                $ ( "Results from CLARIN-DK tools"
                                    "Resultater fra Tools"
                                  )
                            )
                      )
                      ( body
                      .   (class.bodycanvas)
                        ,   (h1.,localized$(Results Resultater))
                            (h2.,Workflow)
                            (p.,!workflow)
                            (h2.,localized$(Steps Trin))
                            (dl.,Steps$(!steps.!shortletter.!type))
                            ( !shortletter:y&
                            |   ( h2
                                .   
                                  ,   localized
                                    $ ( "Input to the workflow:"
                                        "Workflowets input:"
                                      )
                                )
                                (p.,inps$!resources)
                            )
                            !metadata
                      )
                )
            : ?html
          & str$(!files !html)
      )
      ( poll
      =     jobs n step secs steplinks links
          , serviceurl title tooladm DOWNLOAD
          , runningParagraphs JobNr hours minutes
        .   ( steplinks
            =     links jobs file step outp ServiceURL JobNr
                , seenInputs Title
              .   !arg:(?JobNr.?jobs)
                &   !jobs
                  :   ?
                      (   (!JobNr.step1 ?.?file.?.?.?outp)
                          ?
                      : ?jobs
                      )
                & :?seenInputs
                &     map
                    $ ( ( 
                        =   files
                          .     !arg:(!JobNr.?.?files.?.?.?)
                              &   map
                                $ ( ( 
                                    =   
                                      .       !Uploads
                                            : ? (?.?.!arg.?) ?
                                          & (   !seenInputs:? !arg ?
                                              & 
                                            |     !arg !seenInputs
                                                : ?seenInputs
                                              &   paragraph
                                                $ ( "input:"
                                                    ( a
                                                    .   ( href
                                                        .   str
                                                          $ ( !wwwServer
                                                              "/texton/data/"
                                                              !arg
                                                            )
                                                        )
                                                      , !arg
                                                    )
                                                  )
                                            )
                                        | 
                                    )
                                  . !files
                                  )
                            | 
                        )
                      . !jobs
                      )
                  : ?links
                &   whl
                  ' (   !jobs
                      :   ?
                          (!JobNr.?step done.?.?ServiceURL.?.?file)
                          ?jobs
                    &   !tooladm
                      :   ?
                        + ( ? (ServiceURL.!ServiceURL) ?
                          : ? (Title.?Title) ?
                          )
                        + ?
                    &     !links
                            paragraph
                          $ ( str$(!step ":")
                              ( a
                              .   ( href
                                  . str$(!wwwServer "/texton/data/" !file)
                                  )
                                , !file
                              )
                              " ("
                              !Title
                              ")"
                            )
                      : ?links
                    )
                & ( !links:% %
                  | !jobs:? (!JobNr.?) ?
                  |     !links
                          paragraph
                        $ ( "output:"
                            ( a
                            .   ( href
                                . str$(!wwwServer "/texton/data/" !file)
                                )
                              , !outp
                            )
                          )
                    : ?links
                  )
                & !links
            )
          & ( !arg:(?JobNr.?secs)
            | @(!arg:? #?JobNr)&5:?secs
            )
          & readTable$jobs
          & readTable$tooladm
          & readTable$Uploads
          &   div$(!deleteAfterMillisec*86400000^-1*24*60.1)
            : ?minutes
          &   toML
            $ (   steplinks$(!JobNr.!jobs):?links
                &     ( 
                      =   jobs n JobNr
                        .   0:?n
                          & !arg:(?jobs.?JobNr)
                          &   whl
                            ' ( !jobs:? (!JobNr.?) ?jobs
                              & 1+!n:?n
                              )
                          & !n
                      )
                    $ (!jobs.!JobNr)
                  : ?n
                &     map
                    $ ( ( 
                        =   serviceurl title step
                          .       !arg
                                : ( !JobNr
                                  .   %@?step
                                      ( 
                                      | starting
                                      | waiting
                                      )
                                  . ~(? (?,pending) ?)
                                  . ?serviceurl
                                  . ?
                                  . ?
                                  )
                              &   !tooladm
                                :   ?
                                  + ( ? (ServiceURL.!serviceurl) ?
                                    : ? (Title.?title) ?
                                    )
                                  + ?
                              &   paragraph
                                $ (   localized
                                    $ ( "Currently running "
                                        "I øjeblikket kører "
                                      )
                                    !step
                                    " "
                                    localized$(of af)
                                    " "
                                    !n
                                    " ("
                                    !title
                                    ")"
                                  )
                            | 
                        )
                      . !jobs
                      )
                  : ?runningParagraphs
                & ( DOWNLOAD
                  =   
                    .   ( a
                        .   ( href
                            .   !wwwServer
                                "/texton/zipresults?shortletter=n&amp;JobNr="
                                !arg
                            )
                          ,   localized
                            $ ( "Download input and all results"
                                "Download input og alle resultater"
                              )
                        )
                        localized$(" OR " " ELLER ")
                        ( a
                        .   ( href
                            .   !wwwServer
                                "/texton/zipresults?shortletter=y&amp;JobNr="
                                !arg
                            )
                          ,   localized
                            $ ("Download final results" "Download slutresultater")
                        )
                  )
                & (   !runningParagraphs:
                    &   !HTMLbodyContainer
                      $ ( paragraph$(DOWNLOAD$!JobNr)
                          !links
                            paragraph
                          $ ( localized$("Done! " "Færdig! ")
                              (br.,)
                                localized
                              $ ( "To download the results, see the links at the top of this page."
                                  "Se links øverst på denne side hvis du vil downloade resultaterne."
                                )
                              (br.,)
                                localized
                              $ ( "Click the following link to immediately DELETE your input and the results from the workflow from the server. "
                                  "Tryk på næste link for at fjerne din input og arbejdsgangens resultater fra serveren. "
                                )
                              ( a
                              .   ( href
                                  . !wwwServer "/texton/cleanup?JobNr=" !JobNr
                                  )
                                ,   localized
                                  $ ( "DELETE input and results from server"
                                      "FJERN input og resultaterne fra serveren"
                                    )
                              )
                            )
                        )
                  |   refreshingXHTMLbodyContainer
                    $ ( !secs str$(!wwwServer "/texton/mypoll?job=" !JobNr)
                      .     paragraph
                          $ ( str
                            $ (   localized
                                $ ( "Reload this page to track the status of your job. Or wait. This page auto-reloads after "
                                    "Genindlæs denne side hvis du vil følge status på arbejdsgangen. Eller vent. Siden genindlæses automatisk efter "
                                  )
                                !secs
                                localized$(" seconds." " sekunder.")
                              )
                            )
                          !links
                          !runningParagraphs
                      )
                  )
              |   !HTMLbodyContainer
                $ (     ( 
                        =   zippedresults zipfile
                          .   readTable$zippedresults
                            &     str
                                $ (!arg ("-all"|"-final") ".zip")
                              : ?zipfile
                            & !zippedresults:? !zipfile ?
                        )
                      $ !JobNr
                    &   paragraph
                      $ ( DOWNLOAD$!JobNr
                            localized
                          $ (   str
                              $ ( " The zipped results are kept for no more than "
                                  !minutes
                                  " minutes! "
                                )
                                str
                              $ ( " De zippede resultater bliver bevaret is højst "
                                  !minutes
                                  " minutter!"
                                )
                            )
                        )
                  |   paragraph
                    $ ( localized
                      $ (   str
                          $ ( "The results have been deleted after "
                              !hours
                              " hours. "
                            )
                            str
                          $ ( "Resultaterne er blevet slettet efter "
                              !hours
                              " timer. "
                            )
                        )
                      )
                  )
              )
      )
      ( setLanguageNotPermanently
      =   
        .   ( !arg:? (UIlanguage.?arg) ?
            |   "reset to default"
              & readTable$UIlanguage:%?arg ?
            )
          & setLang$!arg
      )
      ( setTypefaceNotPermanently
      =   
        .   (   !arg:? (TyPeFaCe.?arg) ?
              & log$(TyPeFaCe !arg)
            |   "reset to default"
              & readTable$Typeface:%?arg ?
            )
          & setTypeFace$!arg
      )
      ( buildItemList
      =   item
        .   map
          $ ( ( 
              =   item
                .     !arg:(item|Item.?item)
                    & (@(!item:\" ?item \")|)
                    & (Item.!item)
                  | 
              )
            . !arg
            )
      )
      ( buildItemListFromForeignData
      =     A Z N name Items FieldName nofonts
          , Name ContentType Size feats
          , DestinationDir LocalFileName
          , language date analyseContentType
        .   ( analyseContentType
            =     R spec nofonts ct DestinationDir LocalFileName
                , isDiplom input getInput isTabSeparated
              .     !arg
                  : (?arg.?nofonts.?DestinationDir.?LocalFileName)
                & log$(analyseContentType !arg nofonts !nofonts)
                & @( !arg
                   : ((%? "/" %?:?ct) ";" ?|?ct)
                   )
                & ( getInput
                  = .@(get$(str$(!DestinationDir !LocalFileName),STR))
                  )
                & ( isDiplom
                  =   N lang input
                    .   0:?lang
                      & !arg:?input
                      &     vap
                          $ ( ( 
                              =   N la
                                .     vap$((=.!arg).!arg."|")
                                    : ? [?N
                                    : (   ( %@
                                          : @( ?
                                             :   ?
                                                 (L|l)
                                                 anguage
                                                 ?
                                             )
                                          )
                                          ( %@
                                          : @( ?
                                             :   ?
                                                 ( (   (   (D|d)
                                                           an
                                                       |   (L|l)
                                                           at
                                                       | mlg
                                                       | swe
                                                       )
                                                     : ?la
                                                   |   Svensk
                                                     & swe:?la
                                                   )
                                                 &   low$!la+!lang
                                                   : ?lang
                                                 )
                                                 ?
                                             )
                                          )
                                      | ?
                                      )
                                  & !N
                              )
                            . !input
                            . \n
                            )
                        : ? (~<17:?N) !N !N ?
                      &   (app.unn)
                          (facet.tok)
                          (format.dipl)
                          (   !lang:#*%@?lang
                            & ( lang
                              .   !lang:lat&la
                                | !lang:dan&da
                                | !lang:mlg&gml
                                | !lang:swe&sv
                              )
                          | 
                          )
                          (period.c13)
                          (pres.nml)
                  )
                & ( isTabSeparated
                  =   L H e empty
                    .   :?e
                      & (   @(!arg:? \t ? \n ? \t ? \n ?)
                          & -1:?L:?H
                          &   vap
                            $ ( ( 
                                =   K
                                  .     vap$((=..).!arg.\t)
                                      : ? [?K
                                    & (   !K:1
                                        & trim$!arg:
                                        & e:?e
                                      |   !e:?empty
                                        & (   !L:-1
                                            & !K:?L
                                          | !K:<!L:?L
                                          | 
                                          )
                                        & (   !H:-1
                                            & !K:?H
                                          | !K:>!H:?H
                                          | 
                                          )
                                      )
                                )
                              . !arg
                              . \n
                              )
                          & !L:!H
                          & (4:<!L:?L|)
                          & (format.str$(!L col !empty))
                        |     vap$((=.trim$!arg).!arg.\n)
                            : ~(? @(?:? " " ?) ?)
                            : ?L
                          & ( !L:% %&(format.1col)
                            |   @(!L:"https://alf.hum.ku.dk/korp" ?)
                              & (facet.kwic) (format.url)
                            | (facet.txt) (format.flat)
                            )
                        )
                  )
                &   !ct
                  : (   application/pdf
                      &     (   !nofonts:true
                              & (app.rom)
                            | (app.nrm)
                            )
                            (facet.txt)
                            ( format
                            .     !nofonts:true
                                & img^pdf
                              | pdf
                            )
                        : ?R
                    |   "application/vnd.ms-powerpoint"
                      &     (app.nrm)
                            (facet.txt)
                            (format.ppt)
                        : ?R
                    |   "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                      &     (app.nrm)
                            (facet.txt)
                            (format.pptx)
                        : ?R
                    |   "application/vnd.oasis.opendocument.presentation"
                      &     (app.nrm)
                            (facet.txt)
                            (format.odp)
                        : ?R
                    |   "application/vnd.ms-excel"
                      &     (app.nrm)
                            (facet.txt)
                            (format.xls)
                        : ?R
                    |   "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                      &     (app.nrm)
                            (facet.txt)
                            (format.xlsx)
                        : ?R
                    |   "application/vnd.oasis.opendocument.spreadsheet"
                      &     (app.nrm)
                            (facet.txt)
                            (format.ods)
                        : ?R
                    |   ( application/x-download
                        | application/octet-stream
                        )
                      & getInput$:?input
                      & ( @( !input
                           : ( ("%PDF" ?|"%pdf" ?)
                             &     (   !nofonts:true
                                     & (app.rom)
                                   | (app.nrm)
                                   )
                                   (facet.txt)
                                   ( format
                                   .     !nofonts:true
                                       & img^pdf
                                     | pdf
                                   )
                               : ?R
                             )
                           )
                        | isDiplom$!input:?R
                        | isTabSeparated$!input:?R
                        | :?R
                        )
                    |   application/msword
                      & @( get$(str$(!DestinationDir !LocalFileName),STR)
                         : (   ? rtf [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.rtf)
                               : ?R
                           |   ? xml [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.xml)
                               : ?R
                           |   PK ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.docx)
                               : ?R
                           |   ? [<9
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.doc)
                               : ?R
                           |   ?
                             & (app.nrm) (facet.txt):?R
                           )
                         )
                    |   "application/vnd.oasis.opendocument.text"
                      & @( get$(str$(!DestinationDir !LocalFileName),STR)
                         : (   PK ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.odt)
                               : ?R
                           |   ?
                             & (app.nrm) (facet.txt):?R
                           )
                         )
                    |   application/octet-stream
                      & @( get$(str$(!DestinationDir !LocalFileName),STR)
                         : (   ? rtf [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.rtf)
                               : ?R
                           |   ? xml [<10 ?
                             &     (app.nrm)
                                   (facet.txt)
                                   (format.xml)
                               : ?R
                           |   ?
                             & (app.nrm) (facet.txt):?R
                           )
                         )
                    |   "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                      &     (app.nrm)
                            (facet.txt)
                            (format.docx)
                        : ?R
                    |   application/json
                      & (format.json) (app.drty):?R
                    |   text/html
                      &     (app.nrm)
                            (facet.txt)
                            (format.html)
                        : ?R
                    |   text/rtf
                      &     (app.nrm)
                            (facet.txt)
                            (format.rtf)
                        : ?R
                    |   text/plain
                      & getInput$:?input
                      &   ( isDiplom$!input
                          | isTabSeparated$!input
                          |   (app.nrm)
                              (facet.txt)
                              (format.flat)
                          )
                        : ?R
                    | text/x-conll&(format.flat):?R
                    |   @( ?
                         :   image/
                             (   ( gif
                                 | jpeg
                                 | pjpeg
                                 | png
                                 | tiff
                                 | "vnd.microsoft.icon"
                                 )
                               : ?spec
                             | "svg+xml"&svg:?spec
                             )
                         )
                      &     (app.rom)
                            (facet.txt)
                            (format.img^!spec)
                        : ?R
                    |   @( ?
                         :   audio/
                             ( ( basic
                               | L24
                               | mp4
                               | mpeg
                               | ogg
                               | vorbis
                               | "vnd.rn-realaudio"
                               | "vnd.wave"
                               | webm
                               )
                             : ?spec
                             )
                         )
                      & (format.snd^!spec):?R
                    |   @( ?
                         :   video/
                             ( ( mpeg
                               | mp4
                               | ogg
                               | quicktime
                               | webm
                               | x-matroska
                               | x-ms-wmv
                               | x-flv
                               )
                             : ?spec
                             )
                         )
                      & (format.vid^!spec):?R
                    |   text/xml
                      & (       get
                              $ ( str$(!DestinationDir !LocalFileName)
                                , X ML
                                , TRM
                                )
                            : ? (TEI.?) ?
                          &     (app.nrm)
                                (facet.txt)
                                (format.teip5)
                            : ?R
                        | (format.xm):?R
                        )
                    | :?R
                    )
                & (   !R
                    : ? (format.json|dipl) ?
                  | !R (ambig.una):?R
                  )
                & log$("analyseContentType returns:" !R)
                & !R
            )
          & :?Items
          &   (   !arg:? (language.?language) ?
                & readTable$linguae
                & !linguae:? (?.!language.?) ?
                & (lang.!language)
              | 
              )
            : ?language
          & ( !arg:? (DATE.?date) ?
            | :?date
            )
          &   whl
            ' ( !arg
              :   ?
                  ( ( FieldName,?FieldName
                    . Name,?Name
                    . ContentType,%?ContentType ?nofonts
                    . Size,?Size
                    . DestinationDir,?DestinationDir
                    . LocalFileName,?LocalFileName
                    )
                  &     analyseContentType
                      $ (!ContentType.!nofonts.!DestinationDir.!LocalFileName)
                    : ?feats
                  &   !Uploads
                    : ?A (?N.?name.!LocalFileName.?.?) ?Z
                  &     !A
                        ( !N
                        . !name
                        . !LocalFileName
                        . (TITLE.!name) (DATE.!date)
                        . !language !feats
                        )
                        !Z
                    : ?Uploads
                  &   !Items (Item.str$(removePercentEncodings$!Name))
                    : ?Items
                  )
                  ?arg
              )
          & saveTable$Uploads
          & !Items
      )
      ( analyzeInput
      =     item feats Items item
          , parms presels n val
          , retrieveFeatures errors
        .   !arg:(?parms.?Items.?errors)
          & readTable$features
          & ( retrieveFeatures
            =   Items item feats n val presels errors
              .   !arg:(?Items.?errors)
                & :?presels
                &   whl
                  ' ( !Items:(Item.%?item ?feats) ?Items
                    & (   !feats:
                        & itemFeats$!item:?feats
                      |   !errors:
                        &     str
                            $ ( 404~~~
                                  toML
                                $ ( !BodyContainer
                                  $ ( paragraph
                                    $ (str$("Item " !item " not found"))
                                    )
                                  )
                              )
                          : ?errors
                      | 
                      )
                    &   whl
                      ' ( !feats:(?n.?val) ?feats
                        & getShort$(!n.!val):?val
                        & !presels (!n.!val.!item):?presels
                        )
                    )
                & (!presels.!errors)
            )
          & retrieveFeatures$(!Items.!errors):(?presels.?errors)
          & (!Items.!presels.!errors)
      )
      ( initialiseSpecifyGoalShowWorkflowsChosenWorkflow
      =     itms errors hiddenData
          , Items tabind Tool parms BodyContainer
        .   startclock$
          & :?errors:?hiddenData:?Items
          & 0:?tabind
          & ?:?Tool
          & !arg:?parms
          & ( !parms:? (itms.?itms) ?
            | 1:?itms
            )
          & readTable$ItemGroupsCache
          &     map
              $ ( ( 
                  =   a v nt CLOCK wfs items
                    .     !arg:(@(?:?a ";" ?nt).?v)
                        & ( !nt:!itms&(!a.!v)
                          | 
                          )
                      |   !arg:(Item|itms.?)
                        & !arg !hiddenData:?hiddenData
                        & !arg
                      |   !arg:(CLOCK.?CLOCK)
                        &   !ItemGroupsCache
                          :   ?
                              (!CLOCK.? (!itms.?items.?wfs) ?)
                              ?
                        &   map$((=.Item.!arg).!items)
                          : ?Items
                        & !arg !hiddenData:?hiddenData
                        & !arg
                      | !arg
                  )
                . !parms
                )
            : ?parms
          & !HTMLbodyContainer:?BodyContainer
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & "Consult the 'Uploads'-table to find out what we know about the input(s)."
          & readTable$Uploads
          & ( !errors
            . !hiddenData
            . !Items
            . !tabind
            . !Tool
            . !parms
            . !BodyContainer
            )
      )
      "
/**
 * specifyGoal
 *
 * Prepare a workflow.
 * Functions as a wizard, taking input from various stages.
 * The function creates a resource by choice of goal
 * Arguments:
 *      - http parameters
 * http parameters:
 *      mail2=<address>
 *      action=batch | batch=on | batch=off
 *      bsubmit=next step|Submit|View details
 *      (item=<itemid>)+
 *      (Item=<itemid>)+
 *      I<feature>=<featurevalue>
 *      O<feature>=<featurevalue>
 * features are (currently): facet, format and lang
 * feature values are complex strings consisting of a feature value and,
 * optionally, a specialisation of the feature values, separated from the
 * former by a caret.
 *
 * Called from enact.java
 */"
      ( specifyGoal
      =     Tool item parms Items items presels
          , errors batch desiredTools sourcesAndGoals BodyContainer
          , handle A itms rstr
          , "We are at the start. Show an input form."
        .   ( desiredTools
            =   L ToolID Title S
              .   readTable$tooladm
                & 0:?S
                & :?L
                & (   !tooladm
                    :   ?
                      + (   ~(? (Inactive.on) ?)
                          : ? (ToolID.?ToolID) ?
                          : ? (Title.?Title) ?
                        & !S+(low$!Title.!Title.!ToolID):?S
                        & ~
                        )
                      + ?
                  | 
                  )
                &   whl
                  ' ( !S:(?.?Title.?ToolID)+?S
                    & !L (!Title.!ToolID):?L
                    )
                &   fieldset
                  $ (     localized
                        $ ( "Restrict list of workflow candidates. (Optional if you specified your goal in the fields above.)"
                            "Indskrænk listen med kandiderende arbejdsgange. (Kan springes over hvis du har specificeret dit mål i rubrikken ovenover.)"
                          )
                        (br.,)
                          localized
                        $ ( "If you did not specify a goal (i.e. "
                            "Værktøjet er det sidste i arbejdsgangene hvis du "
                          )
                        (strong.,localized$(ALL INTET))
                          localized
                        $ ( " fields are empty), the WMS computes all workflows that have the selected tool as the last step."
                            " har specificeret i rubrikken ovenover."
                          )
                    .   paragraph
                      $ ( makeSelectFormField
                        $ (   localized
                            $ ( "Workflow must utilize the tool:"
                                "Arbejdsgang skal inkludere værktøjet:"
                              )
                          . desiredtool
                          . options
                          . makeOptionList$(!L.)
                          )
                        )
                    )
            )
          & ( sourcesAndGoals
            =     f fs picklists name short
                , servicedGoalsTable cmptblWrkflws
                , servicedSourcesTable namecell
                , description itms Types linkedWorkflows
                , table presel L selectServicedValues
                , preselvalsrows items item spec
                , goalpicklists preselvals presels
                , createArgs featurehelpcell
                , B C D E R hide n nt p prod x
                , mentionBookmarkedWorkflows linksAndLinked
                , allLinked features links
              .   ( cmptblWrkflws
                  =   itemGroups presels
                    .   !arg:(?itemGroups.?presels)
                      & (!wrkflws|readTable$wrkflws)
                      &   map
                        $ ( ( 
                            =   n itm knownInputFeatures fitm
                              .   !arg:(?n.?itm:%?fitm ?)
                                & ( !n
                                  . !itm
                                  .       map
                                        $ ( ( 
                                            =   f v
                                              .       !arg
                                                    : (?f.?v.!fitm)
                                                  & (!f.!v)
                                                | 
                                            )
                                          . !presels
                                          )
                                      : ?knownInputFeatures
                                    &   map
                                      $ ( ( 
                                          =   name i o wf
                                            .     !arg
                                                : (?name.(?i.?o).?wf)
                                              & (       map
                                                      $ ( ( 
                                                          =   a b
                                                            .       !arg
                                                                  : (?a.?b)
                                                                &   !i
                                                                  :   ?
                                                                      (!a,!b)
                                                                      ?
                                                                & !arg
                                                              | 
                                                          )
                                                        . !knownInputFeatures
                                                        )
                                                    : !knownInputFeatures
                                                  & !name
                                                | 
                                                )
                                          )
                                        . !wrkflws
                                        )
                                  )
                            )
                          . !itemGroups
                          )
                  )
                & ( selectServicedValues
                  =   short table pat
                    .     !arg:(?short.?table.(=?pat))
                        & readTable$toolprop
                        & readTable$tooladm
                        & readTable$features
                        & "Important! Next map fuction has local variable 'abbr', spelled just like that. '!abbr' occurs in pattern 'pat'."
                        &   map
                          $ ( ( 
                              =   tool Full abbr YYy
                                .   !arg:(?Full.?abbr.?YYy)
                                  & (   !( 
                                         ' ( $toolprop
                                           :   ?
                                             + (   ?tool
                                                 &   $tooladm
                                                   :   ?
                                                     + (   ?
                                                           (ToolID.!tool)
                                                           ?
                                                       :   ?
                                                           (Inactive.)
                                                           ?
                                                       )
                                                     + ?
                                               .   ?
                                                   ($short,?+$pat+?)
                                                   ?
                                               )
                                             + ?
                                           )
                                         )
                                      & (!Full.!abbr.!YYy)
                                    | 
                                    )
                              )
                            . !table
                            )
                      | !table
                  )
                & ( namecell
                  =   featurs short name table
                    .   !arg:(?featurs.?short.?name)
                      &   cell
                        $ (     !featurs
                              :   ?
                                + ( ? (short.!short) ?
                                  : ? (description.?description) ?
                                  : ? (table.?table) ?
                                  )
                                + ?
                            &   helplink
                              $ ( (title.localized$!description)
                                  (offset.!table)
                                  (linktext.!name)
                                )
                          | !name
                          )
                  )
                & ( featurehelpcell
                  =   featurs short inorout help
                    .   !arg:(?featurs.?short.?inorout)
                      &   cell
                        $ (     !featurs
                              :   ?
                                + ( ? (short.!short) ?
                                  : ? (!inorout.?help) ?
                                  )
                                + ?
                            & ( div
                              .   (class.tooltip)
                                ,   (small.,(small.,chu$10068))
                                    ( span
                                    .   (class.tooltiptext)
                                      , localized$!help
                                    )
                              )
                          | 
                          )
                  )
                & ( linksAndLinked
                  =   stable exr L itmgrp
                    .   !arg:(?stable.?exr)
                      & !exr:?itmgrp
                      & (!itmgrp:";" ?itmgrp|)
                      & (   !stable:%? [?L
                          & (   "item_group_" !itmgrp:?id
                              & ( a
                                .   (href.str$("#" !id))
                                  ,   str
                                    $ ( !L
                                        " "
                                        localized$(workflow arbejdsgang)
                                        ( !L:1&
                                        | localized$(s e)
                                        )
                                      )
                                )
                            .   ( p
                                .   (id.str$!id)
                                  ,   !itmgrp:&
                                    |   str
                                      $ (   localized
                                          $ ( "Workflows compatible with input in column"
                                              "Arbejdsgange der passer til input i kolonne"
                                            )
                                          " "
                                          !itmgrp
                                        )
                                )
                                  map
                                $ ( ( 
                                    =   low full idval o
                                      .   !arg:(?low.?full.?idval)
                                        &   \r\n
                                            ( input
                                            .     (type.submit)
                                                  (name.str$(bview- !full))
                                                  (value.🔍)
                                              , 
                                            )
                                            \r\n
                                            ( input
                                            .     (type.submit)
                                                  ( name
                                                  . str$(bsubmit- !full)
                                                  )
                                                  (value.►)
                                              , 
                                            )
                                            \r\n
                                            !full
                                            ( div
                                            .   (class.tooltip)
                                              ,   ∴
                                                  ( span
                                                  .   (class.tooltiptextL)
                                                    ,     !wrkflws
                                                        :   ?
                                                            ( !full
                                                            . (?.?o)
                                                            . ?
                                                            )
                                                            ?
                                                      & inoutdesc$!o
                                                  )
                                            )
                                            (br.,)
                                            (br.,)
                                    )
                                  . !stable
                                  )
                            )
                        | (.)
                        )
                  )
                & ( mentionBookmarkedWorkflows
                  =   items allLinked
                    .   !arg:?items
                      & :?allLinked
                      & ( ( tr
                          .   (style."background-color: #ddd;")
                            ,     cell
                                $ ( localized
                                  $ ( "Bookmarked workflows"
                                      "Markerede arbejdsgange"
                                    )
                                  )
                                  cell
                                $ ( ( div
                                    .   (class.tooltip)
                                      ,   (small.,(small.,chu$10068))
                                          ( span
                                          .   (class.tooltiptext)
                                            ,   localized
                                              $ ( "You can ignore all form fields below if you choose a bookmarked workflow."
                                                  "Du kan ignorere alle formularfelter hernede hvis du vælger en markeret workflow."
                                                )
                                          )
                                    )
                                  | 
                                  )
                                  map
                                $ ( ( 
                                    =     nt wrkfls exr stable
                                        , links linked
                                      .   !arg:(?nt.?arg.?wrkfls)
                                        & (   !items:% %
                                            & (exr=";" !nt)
                                          | :?exr
                                          )
                                        &   cell
                                          $ ( !wrkfls:
                                            |       listToThreeColumnTable
                                                  $ !wrkfls
                                                : ?stable
                                              & (       linksAndLinked
                                                      $ (!stable.!exr)
                                                    : (?links.?linked)
                                                  &     !linkedWorkflows
                                                        (!nt.!linked)
                                                    : ?linkedWorkflows
                                                  & !links
                                                | ( select
                                                  .     ( tabindex
                                                        .   1+!tabind
                                                          : ?tabind
                                                        )
                                                        ( name
                                                        .   str
                                                          $ (workflow !exr)
                                                        )
                                                    ,   makeOptionListSimple
                                                      $ (!stable.bookmarked-)
                                                  )
                                                )
                                            )
                                    )
                                  . !items
                                  )
                          )
                        . !allLinked
                        )
                  )
                & !arg:(?presels.?createArgs)
                & :?linkedWorkflows
                & readTable$features
                & !features:?fs
                & :?preselvalsrows
                &     map
                    $ ( ( 
                        =   
                          .       !arg
                                : (FieldName,?.Name,?arg.?)
                              & !arg
                            | 
                        )
                      . !createArgs
                      )
                  : ?items
                & 1:?prod
                &   whl
                  ' ( !fs:%?f+?fs
                    &   !f
                      : ? (name.?name) ?
                      : ? (short.?short) ?
                      : ? (description.?description) ?
                      : ? (table.?table) ?
                    & ( !f:? (hide.?hide) ?
                      | :?hide
                      )
                    & readTable$!table
                    & :?preselvals
                    & !presels:?L
                    &   whl
                      ' ( !L:? (!short.?presel.?item) ?L
                        & ( !items:? !item ?
                          | !items !item:?items
                          )
                        & !preselvals (!presel.!item):?preselvals
                        & !item^!presel*!prod:?prod
                        )
                    &     !preselvalsrows
                          (!short.localized$!name.!!table.!preselvals.!hide)
                      : ?preselvalsrows
                    )
                &   whl
                  ' ( !prod:?A*%?B^%?x*?C*%?D^!x*?E
                    & !A*(!B !D)^!x*!C*!E:?prod
                    )
                & :?items
                & !prod:?p
                & 0:?R
                &   whl
                  ' ( !p:(? [?n:%?itms)^%?*?p
                    & (!n.!itms)+!R:?R
                    )
                &   whl
                  ' ( !R:(?.?itms)+?R
                    & (.!itms) !items:?items
                    )
                & 0:?nt
                &     map
                    $ ( ( 
                        =   
                          .     !arg:(.?arg)
                              & (!nt+1:?nt.!arg)
                            | 
                        )
                      . !items
                      )
                  : ?items
                &     map
                    $ ( ( 
                        =   seen a b c d e
                          .   !arg:(?a.?b.?c.?d.?e)
                            & 0:?seen
                            & ( !a
                              . !b
                              . !c
                              .   map
                                $ ( ( 
                                    =   presel item comb
                                      .     !arg:(?presel.?item)
                                          &   !prod
                                            :   ?
                                              * (? !item ?:?comb)^?
                                              * ?
                                          & (   !seen:?+!comb+?
                                              & 
                                            |   !comb+!seen:?seen
                                              & (!presel.!comb)
                                            )
                                        | !arg
                                    )
                                  . !d
                                  )
                              . !e
                              )
                        )
                      . !preselvalsrows
                      )
                  : ?preselvalsrows
                & "Notice: this function does not have local variable 'abbr' !"
                &     map
                    $ ( ( 
                        =   exr
                          .       !arg
                                : (?short.?name.?table.?preselvals.)
                              & (   !servicedSources
                                  :   ?
                                      (!short.?servicedSourcesTable)
                                      ?
                                |       selectServicedValues
                                      $ ( !short
                                        . !table
                                        . ( 
                                          = ?+?*!abbr^?*?+? ?.?
                                          )
                                        )
                                    : ?servicedSourcesTable
                                  &     (!short.!servicedSourcesTable)
                                        !servicedSources
                                    : ?servicedSources
                                )
                              & (   !items:% %
                                  & (exr=";" !nt)
                                | :?exr
                                )
                              &   row
                                $ ( namecell$(!features.!short.!name)
                                      featurehelpcell
                                    $ (!features.!short.sourcehelp)
                                      map
                                    $ ( ( 
                                        =   
                                          .   !arg:(?nt.?arg)
                                            &   cell
                                              $ (     !preselvals
                                                    :   ?
                                                        (%?presel^?spec.!arg)
                                                        ?
                                                  & NEWSPEC
                                                  & (   !spec:1
                                                      & NEWSPEC
                                                      &   makeSelectFormField
                                                        $ ( 
                                                          .   str
                                                            $ (I !short !exr)
                                                          . options
                                                          .   makeOptionList
                                                            $ ( !servicedSourcesTable
                                                              . !presel
                                                              )
                                                          )
                                                    |   makeSelectFormField
                                                      $ ( 
                                                        .   str
                                                          $ (I !short !exr)
                                                        . options
                                                        .     !features
                                                            :   ?
                                                              + (   ?
                                                                    ( short
                                                                    . !short
                                                                    )
                                                                    ?
                                                                :   ?
                                                                    ( specificationTable
                                                                    .   ?
                                                                        (   ?
                                                                            ( %@
                                                                            : !presel
                                                                            )
                                                                            ?
                                                                        . ?Types
                                                                        )
                                                                        ?
                                                                    )
                                                                    ?
                                                                )
                                                              + ?
                                                          & readTable$!Types
                                                          &   makeOptionList
                                                            $ ( !!Types
                                                              . !spec
                                                              .   str
                                                                $ (!presel "^")
                                                              )
                                                        )
                                                    )
                                                |   makeSelectFormField
                                                  $ ( 
                                                    . str$(I !short !exr)
                                                    . options
                                                    .   makeOptionList
                                                      $ ( !servicedSourcesTable
                                                        . 
                                                        )
                                                    )
                                                )
                                        )
                                      . !items
                                      )
                                  )
                            | 
                        )
                      . !preselvalsrows
                      )
                  : ?picklists
                &     map
                    $ ( ( 
                        =   
                          .       !arg
                                : (?short.?name.?table.?preselvals.)
                              & (   !servicedGoals
                                  : ? (!short.?servicedGoalsTable) ?
                                |       selectServicedValues
                                      $ ( !short
                                        . !table
                                        . (=?.?+?*!abbr^?*?+? ?)
                                        )
                                    : ?servicedGoalsTable
                                  &     (!short.!servicedGoalsTable)
                                        !servicedGoals
                                    : ?servicedGoals
                                )
                              &   row
                                $ ( namecell$(!features.!short.!name)
                                      featurehelpcell
                                    $ (!features.!short.goalhelp)
                                      cell
                                    $ ( makeSelectFormField
                                      $ ( 
                                        . str$(O !short)
                                        . options
                                        .   makeOptionList
                                          $ (!servicedGoalsTable.)
                                        )
                                      )
                                  )
                            | 
                        )
                      . !preselvalsrows
                      )
                  : ?goalpicklists
                & cmptblWrkflws$(!items.!presels):?items
                & ( !items
                  .     fieldset
                      $ (     !items:? (?.?.% ?) ?
                            &   localized
                              $ ( "Text Tonsorium can enact a pre-existing, bookmarked workflow or compute and enact a workflow that fulfils your goal."
                                  "Text Tonsorium kan afvikle en allerede eksisterende og markeret arbejdsgang eller beregne og udføre en arbejdsgang som opfylder dit mål."
                                )
                          |   !items:% %
                            &   localized
                              $ ( "Text Tonsorium has analysed the types of your inputs. Choose one of them and specify the desired output (your goal)."
                                  "Text Tonsorium har analyseret dine inputs. Vælg en inputstype og fortsæt med at specificere den ønskede output (dit mål)."
                                )
                          |   localized
                            $ ( "Text Tonsorium has analysed the type of your input. Please specify the desired output (your goal)."
                                "Text Tonsorium har analyseret din input. Fortsæt med at specificere den ønskede output (dit mål)."
                              )
                        .   Table
                          $ ( id,inputs
                            .   row
                              $ ( cell$()
                                  cell$()
                                    map
                                  $ ( ( 
                                      =   nt wrkfls
                                        .   !arg:(?nt.?arg.?wrkfls)
                                          &     map
                                              $ ( ( 
                                                  = .!arg (br.,)
                                                  )
                                                . !arg
                                                )
                                            : ?arg (br.,)
                                          & cell$!arg
                                      )
                                    . !items
                                    )
                                )
                            .   (   !items:? (?.?.% ?) ?
                                  &   mentionBookmarkedWorkflows$!items
                                    : (?links.?allLinked)
                                  & !links
                                | :?allLinked
                                )
                                (   !items:% %
                                  & 0:?nt
                                  &   row
                                    $ (   cell
                                        $ ( localized
                                          $ ( "Inputs are dissimilar. Select a column."
                                              "Inputs er ulige. Vælg en kolonne."
                                            )
                                          )
                                        cell$()
                                          map
                                        $ ( ( 
                                            =   nt wrkfls
                                              .     !arg
                                                  : (?nt.?arg.?wrkfls)
                                                &   cell
                                                  $ ( input
                                                    .     (type.radio)
                                                          (name.itms)
                                                          (value.!nt)
                                                          (   !nt:1
                                                            & ( checked
                                                              . checked
                                                              )
                                                          | 
                                                          )
                                                      , 
                                                    )
                                            )
                                          . !items
                                          )
                                      )
                                | 
                                )
                                !picklists
                            )
                        )
                        fieldset
                      $ (   (strong.,localized$("Your goal" "Dit mål"))
                            (br.,)
                            localized$("Fill out only " "Udfyld ")
                            (strong.,localized$(two to))
                            localized$(" or " " eller ")
                            (strong.,localized$(three tre))
                              localized
                            $ ( " fields and leave the other fields "
                                " felter og lad de øvrige felter være "
                              )
                            (strong.,localized$(blank blank))
                              localized
                            $ ( ". In general, more filled out fields = fewer workflow candidates."
                                ". Generelt gælder: jo flere udfyldte feldter, desto færre foreslåede arbejdsgange."
                              )
                            (br.,)
                              localized
                            $ ( "You can skip these fields and choose a tool instead, see below. In that case, the tool will be the last in the workflow."
                                "Du kan lade felterne stå tomme, og i stedet vælge et værktøj i rubrikken forneden. I så fald er værktøjet det sidste i arbejdsgangen."
                              )
                        .     Table
                            $ ( id,goal
                              . row$(cell$() cell$() cell$)
                              . !goalpicklists
                              )
                              makeCheckboxFormField
                            $ (   localized
                                $ ( "Compute workflows for similar goals"
                                    "Beregn arbejdsgange for lignende mål"
                                  )
                              . superset
                              .   (val.on)
                                  ( desc
                                  .   localized
                                    $ ( "Check this box if your requirements are MINIMAL requirements. For example, if your requirement is to have PoS tags, you may also want to see workflows that produce PoS tags AND lemmas, at the same time."
                                        "Marker hvis dit mål er minimal, fx hvis du udover PoS tags også godt vil se lemmaer, i kombination med PoS tags."
                                      )
                                  )
                              )
                        )
                  . !linkedWorkflows
                  )
            )
          & ( "We are at the start. Show an input form."
            =     formFields presels nt CLOCK sourceAndGoal
                , itemGroupsExt linkedWorkflows
                , hiddenData Items
              .   !arg:(?presels.?hiddenData.?Items)
                & log$"We are at the start. Show an input form."
                & (   !Items:
                    &   str
                      $ ( 200~~~
                            toML
                          $ ( !BodyContainer
                            $ ( paragraph
                              $ ( localized
                                $ ( "No input is specified, or the input is not accessible."
                                    "Inputtet er ikke specificeret, eller inputtet er ikke tilgængeligt."
                                  )
                                )
                              )
                            )
                        )
                  |     sourcesAndGoals$(!presels.!arg)
                      : (?itemGroupsExt.?sourceAndGoal.?linkedWorkflows)
                    &   (   !itemGroupsExt:(@.@.?)
                          & !Items !hiddenData
                        |   readTable$ItemGroupsCache
                          & (   !ItemGroupsCache
                              : ? (?CLOCK.!itemGroupsExt) ?
                            |       (clk$:?CLOCK.!itemGroupsExt)
                                    !ItemGroupsCache
                                : ?ItemGroupsCache
                              & saveTable$ItemGroupsCache
                            )
                          & (CLOCK.!CLOCK) !hiddenData
                        )
                      : ?hiddenData
                    & !sourceAndGoal desiredTools$:?formFields
                    &   str
                      $ ( 200~~~
                            toML
                          $ ( !BodyContainer
                            $ ( !formFields:
                              |     form
                                  $ ( showworkflows
                                    .   makeHiddenFields$!hiddenData
                                        !formFields
                                        submit$"next step"
                                        helplink$
                                    )
                                  (br.,)
                                  ( !linkedWorkflows:
                                  |   ( h1
                                      .   
                                        ,   localized
                                          $ ( "Bookmarked workflows"
                                              "Markerede arbejdsgange"
                                            )
                                      )
                                        map
                                      $ ( ( 
                                          =   nt linkedWorkflows
                                            .     !arg
                                                : (?nt.?linkedWorkflows)
                                              &   form
                                                $ ( chosenworkflow
                                                  .     makeHiddenFields
                                                      $ ( !hiddenData
                                                          (itms.!nt)
                                                        )
                                                      !linkedWorkflows
                                                  )
                                          )
                                        . !linkedWorkflows
                                        )
                                  )
                              )
                            )
                        )
                  )
            )
          & log$NEW
          & log$CREATELOGJE
          &   initialiseSpecifyGoalShowWorkflowsChosenWorkflow$!arg
            : ( ?errors
              . ?hiddenData
              . ?Items
              . ?tabind
              . ?Tool
              . ?parms
              . ?BodyContainer
              )
          & "First build a list of items."
          & (   !Items:
              & buildItemListFromForeignData$!parms:?Items
            | 
            )
          &   analyzeInput$(!parms.!Items.!errors)
            : (?Items.?presels.?errors)
          & ( !errors:~
            |   "Shall we treat all resources in one job (non-batch) or shall we
               send each input through a different (though similar) job?"
              &   (     !parms
                      : ( ? (action.batch) ?
                        | ? (batch.on) ?
                        |   ~(? (action.?) ?)
                          & ~(? (batch.?) ?)
                        )
                    & on
                  | off
                  )
                : ?batch
              & (   !arg:? (handle.?handle) ?
                  & (handle.!handle) !hiddenData:?hiddenData
                | 
                )
              & !hiddenData (batch.!batch):?hiddenData
              & "Does the user want to decide which tool to use or does she want
                   to let the infrastructure work out a way to reach a set goal?"
              &     !hiddenData
                    (   !arg:? (desiredtool.?rstr) ?
                      & (desiredtool.!rstr)
                    | 
                    )
                    (   !arg:? (superset.?rstr) ?
                      & (superset.!rstr)
                    | 
                    )
                : ?hiddenData
              & unpackIOparms$!parms:?parms
              & checkIOparms$!parms
              & readTable$tooladm
              &   "We are at the start. Show an input form."
                $ (!presels.!hiddenData.!Items)
            )
      )
      ( supplementParmsAndHiddenData
      =   Submit batch,handle parms rstr nth
        .   "Shall we treat all resources in one job (non-batch) or shall
             we send each input through a different (though similar) job?"
          & !arg:(?parms.?hiddenData)
          &   (     !parms
                  : ( ? (action.batch) ?
                    | ? (batch.on) ?
                    |   ~(? (action.?) ?)
                      & ~(? (batch.?) ?)
                    )
                & on
              | off
              )
            : ?batch
          & (   !parms:? (handle.?handle) ?
              & (handle.!handle) !hiddenData:?hiddenData
            | 
            )
          & !hiddenData (batch.!batch):?hiddenData
          &     !hiddenData
                (   !parms:? (desiredtool.?rstr) ?
                  & (desiredtool.!rstr)
                | 
                )
                (   !parms:? (superset.?rstr) ?
                  & (superset.!rstr)
                | 
                )
            : ?hiddenData
          & unpackIOparms$!parms:?parms
          & checkIOparms$!parms
          & readTable$tooladm
          & (   !parms:? (bsubmit.?Submit) ?
              & (!parms.!Submit.!hiddenData.!batch)
            |   !parms:? (@(?:bview- ?nth).?) ?
              &   localized$(localized$("View details" "Se detaljer"))
                : ?Submit
              & ( (nth.!nth) !parms
                . !Submit
                . !hiddenData
                . !batch
                )
            |   !parms:? (@(?:bsubmit- ?nth).?) ?
              & Submit:?Submit
              & ( (nth.!nth) !parms
                . !Submit
                . !hiddenData
                . !batch
                )
            )
      )
      ( NotFulfillable
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ (   paragraph
                    $ ( localized
                      $ ( "Your goal cannot be fulfilled with the currently integrated tools."
                          "Dit mål kan ikke opfyldes med de værktøjer der p.t. er integreret i infrastrukturen."
                        )
                      )
                    (p.,!arg)
                  )
                )
            )
      )
      ( FulfillableWithoutRestriction
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ ( paragraph
                  $ (   localized
                      $ ( "None of the found workflows involves the tool '"
                          "Ingen af de fundne arbejdsgange anvender værktøjet '"
                        )
                      ToolTitle$!arg
                      "'."
                    )
                  )
                )
            )
      )
      ( TooExpensive
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ ( paragraph
                  $ ( localized
                    $ ( "The computation takes too much time. It may succeed if you narrow your goal."
                        "Beregningen tager for lang tid. Måske vil det lykkes hvis du definerer dit mål lidt nærmere."
                      )
                    )
                  )
                )
            )
      )
      ( UnexpectedReturnCode
      =   
        .   str
          $ ( 404~~~
                toML
              $ ( !BodyContainer
                $ ( paragraph
                  $ ( localized$("Unexpected return code '" "Uvented kode '")
                      !arg
                      "'."
                    )
                  )
                )
            )
      )
      ( canConsumeMetadata
      =   a b
        .     !arg
            : ( ?
              ,   txtbasis^?
                | txtann^?
                | teip5^?
              )
          |   !arg:?a_?b
            & (canConsumeMetadata$!a|canConsumeMetadata$!b)
      )
      "
/**
 * showworkflows
 *
 * Called from enact.java
 */"
      ( showworkflows
      =     Tool parms Items NothingToDo Submit
          , presels errors BodyContainer topologicalOrderedTools
          , PIPE A Z TooManyWorkflows updateUploads
          , ShowAllPipes rstr reorderedworkflowlist
          , val allpipes batch returnCode restriction sources
        .   ( ShowAllPipes
            =     hiddenData reorderedworkflowlist
                , "visualizedWorkFlow(s)"
              .     !arg
                  : ( ?hiddenData
                    . ?reorderedworkflowlist
                    . ?topologicalOrderedTools
                    )
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ (   !reorderedworkflowlist:%+%
                            &     makeWorkflowRadioButtons
                                $ ( !reorderedworkflowlist
                                  . !topologicalOrderedTools
                                  )
                              : ?"visualizedWorkFlow(s)"
                            &   (h3.,localized$(Workflows Arbejdsgange))
                                ( p
                                .   
                                  ,   ( a
                                      .   (href."#below")
                                        , localized$(Below Forneden)
                                      )
                                        localized
                                      $ ( " are the workflows that fulfil the goal set by you."
                                          " er arbejdsgangene som løser din opgave."
                                        )
                                      (br.,)
                                        localized
                                      $ ( "You can use the table if you first want to learn which tools can be combined."
                                          "Du kan bruge tabellen hvis du først vil undersøge hvilke værktøjer lader sig kombinere."
                                        )
                                )
                                  form
                                $ ( chosenworkflow
                                  .   (br.,)
                                      makeHiddenFields$!hiddenData
                                      !"visualizedWorkFlow(s)"
                                  )
                          |   !reorderedworkflowlist:(?,(?.?struct))
                            &   makeWorkflowVisualisation$!struct
                              : ?"visualizedWorkFlow(s)"
                            &   (h3.,Workflow)
                                ( p
                                .   
                                  ,   localized
                                    $ ( "This is the workflow that fulfils the goal set by you."
                                        "Dette er arbejdsgangen som løser din opgave."
                                      )
                                )
                                  form
                                $ ( chosenworkflow
                                  .   submit$Submit
                                      helplink$()
                                      (br.,)
                                      makeHiddenFields$!hiddenData
                                      !"visualizedWorkFlow(s)"
                                  )
                          )
                        )
                    )
            )
          & ( NothingToDo
            =   hiddenData pipes rstr "visualizedWorkFlow(s)"
              .   !arg:?hiddenData
                & ( !hiddenData:? (desiredtool.?rstr) ?
                  | :?rstr
                  )
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ ( ( h3
                            .   
                              ,   localized
                                $ ("Nothing to do" "Der er intet at lave")
                            )
                            ( p
                            .   
                              ,     !rstr:
                                  &   localized
                                    $ ( "The goal is trivially fulfilled by the input. Go to the previous screen and specify your goal (or even the input) in more detail."
                                        "Inputtet opfylder allerede målet. Gå tilbage til forrige skærm og specificer dit mål (og eventuelt også inputtet) nærmere."
                                      )
                                |     localized
                                    $ ( "The goal is trivially fulfilled by the input. Go to the previous screen and either specify your goal in more detail, or do not specify a goal at all. If you choose the second option, an implicit goal will be derived from the tool that you specified."
                                        "Inputtet opfylder allerede målet. Gå tilbage til forrige skærm og specificer dit mål nærmere, eller lad være med at specificere et mål. Hvis du vælger det sidste, bliver målet implicit bestemt af det værktøj du har valgt."
                                      )
                                    " ("
                                    ToolTitle$!rstr
                                    ")"
                            )
                          )
                        )
                    )
            )
          & ( TooManyWorkflows
            =   
              .   str
                $ ( 404~~~
                      toML
                    $ ( !BodyContainer
                      $ ( paragraph
                        $ ( localized
                          $ ( "There are unmanageable many possible workflows leading to your goal. Try to specify more details for your goal."
                              "Der er uoverskuelig mange mulige workflows der fører til dit mål. Prøv at specificere dit mål nærmere."
                            )
                          )
                        )
                      )
                  )
            )
          & log$WORKFLOWLISTLOGJE
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & :?PIPE
          &   initialiseSpecifyGoalShowWorkflowsChosenWorkflow$!arg
            : ( ?errors
              . ?hiddenData
              . ?Items
              . ?tabind
              . ?Tool
              . ?parms
              . ?BodyContainer
              )
          & "First build a list of items."
          & buildItemList$!parms:?Items
          &   analyzeInput$(!parms.!Items.!errors)
            : (?Items.?presels.?errors)
          & ( !errors:~
            |     supplementParmsAndHiddenData$(!parms.!hiddenData)
                : (?parms.?Submit.?hiddenData.?batch)
              & "Add any info about the input that the user has provided, e.g. language of the resource."
              & ( updateUploads
                =     A nr Item stagingName
                    , meta feats Z parms
                  .   !arg:?parms
                    & readTable$Uploads:?Uploads
                    & readTable$features:?features
                    &   map
                      $ ( ( 
                          =   
                            .     !arg:(Item.?Item)
                                &   !Uploads
                                  :   ?A
                                      (?nr.!Item.?stagingName.?meta.?feats)
                                      ?Z
                                &     !A
                                      ( !nr
                                      . !Item
                                      . !stagingName
                                      . !meta
                                      .   map
                                        $ ( ( 
                                            =   key val
                                              .       !arg
                                                    : ( @(?:I ?key)
                                                      . ~:?val
                                                      )
                                                  &   !features
                                                    :   ?
                                                      + ( ?
                                                          (short.!key)
                                                          ?
                                                        )
                                                      + ?
                                                  & (!key.!val)
                                                | 
                                            )
                                          . !parms
                                          )
                                      )
                                      !Z
                                  : ?Uploads
                              | 
                          )
                        . !parms
                        )
                    & saveTable$Uploads
                )
              & updateUploads$!parms
              & 0:?allpipes
              &     localized
                  $ ("No workflows found." "Ingen arbejdsgange fundet.")
                : ?returnCode
              & :?restriction
              & (     Pipelines$(!parms.)
                    : ( (?sources.?)
                      . (?reorderedworkflowlist.?topologicalOrderedTools)
                      . ?returnCode
                      )
                  & "allRight
                     onlyWithoutRestriction
                     triviallyFulfilled
                     tooComplex
                     tooMany"
                  & (   !returnCode:allRight
                      & !Submit:"next step"
                      &   ShowAllPipes
                        $ ( !hiddenData
                          . !reorderedworkflowlist
                          . !topologicalOrderedTools
                          )
                    |   !returnCode:onlyWithoutRestriction
                      &   !parms
                        : ? (desiredtool.?restriction) ?
                      & FulfillableWithoutRestriction$!restriction
                    |   !returnCode:triviallyFulfilled
                      & !Submit:"next step"
                      & NothingToDo$!hiddenData
                    |   !returnCode:tooComplex
                      & TooExpensive$
                    |   !returnCode:tooMany
                      & TooManyWorkflows$
                    )
                | NotFulfillable$!returnCode
                )
            )
      )
      "
/**
 * chosenworkflow
 *
 * Called from enact.java
 */"
      ( chosenworkflow
      =     Tool item parms Items
          , val mail2 ERR
          , Submit
          , JobStack JobNr presels
          , errors batch
          , jobIDoffset subjobs
          , nth BodyContainer
          , PIPE lookForLanguage
          , makejobstack
          , NoNeedForMetadata
          , ApplyThePipelineToTheInput
          , ShowOnlyTheCurrentPipe AddMetadata
          , "The user has selected a workflow."
          , errorInMetadata
          , MetadataInParms
          , rememberMetadata
        .   ( lookForLanguage
            =   knownInputFeats AA ZZ LocalFileName language
              .   !arg:(?LocalFileName.?arg)
                & (   !arg:?AA (language.?language) ?ZZ
                    & readTable$linguae
                    & !linguae:? (?.!language.?) ?
                    & (!language.!AA !ZZ)
                  |     !Uploads
                      :   ?
                          (?.?.!LocalFileName.?.?knownInputFeats)
                          ?
                    & !knownInputFeats:? (lang.?language) ?
                    & (!language.!arg)
                  | (.!arg)
                  )
            )
          & ( ShowOnlyTheCurrentPipe
            =   formFields struct nth bm
              .   !arg:(?struct.?nth.?bm.?err)
                & makeWorkflowVisualisation$!struct:?formFields
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ ( ( !nth:#<1
                            |     (br.,)
                                  submit$Submit
                                  (br.,)
                                  (br.,)
                                  submit$Bookmark
                                    makeTextFormField
                                  $ (   localized
                                      $ ( "Name for this workflow"
                                          "Navn for denne arbejdsgang"
                                        )
                                    . bm
                                    .   (val.!bm)
                                        ( desc
                                        .   localized
                                          $ ( "A unique name that tells you and other users what the workflow is about."
                                              "Et unikt navn som giver mening for dig og for andre brugere."
                                            )
                                        )
                                        (size.40)
                                        ( required
                                        . span
                                        .   ( style
                                            . "color:blue; width: auto; line-height: normal;"
                                            )
                                          , "*"
                                        )
                                    )
                                  ( !bm:
                                  |   !err:
                                    & "(" localized$(saved gemt) ")"
                                  |   localized
                                    $ ("Already in use!" "Allerede brugt!")
                                  )
                                  !formFields
                              : ?formFields
                            )
                          & ( !formFields:
                            |   form
                              $ ( chosenworkflow
                                .   !formFields
                                    ( !nth:#<1&
                                    |   makeHiddenFields
                                      $ ((nth.!nth) !hiddenData)
                                    )
                                )
                            )
                          )
                        )
                    )
            )
          & ( AddMetadata
            =     formFields nth val
                , parms ERR metadataType hiddenData
              .   !arg:(?metadataType.?nth.?parms.?ERR.?hiddenData)
                &     ( style
                      .   (type.text/css)
                        , "div.row{display:table-row;} .row * {vertical-align: middle;} .row label{display: table-cell; text-align: right; padding: 5px;} span.autogen{font-style:italic; width:auto; display: table-cell; text-align: left; padding: 5px;} .row input{display: table-cell;} .row textarea{display: table-cell;} span.required{width: 20px;}"
                      )
                        map
                      $ ( ( 
                          =     tekst inputs
                              , "Tekst i grænsefladen"
                              , "Required / optional  / automatic"
                              , "Placering i header" Noter Hjælpetekst id
                              , "line / lines / box / empty" URL
                              , table typeOfError
                            .     !arg:(?tekst,?inputs)
                                &   fieldset
                                  $ ( localized$!tekst
                                    .   map
                                      $ ( ( 
                                          =   
                                            .     !arg
                                                : ( ?id
                                                  . ?"Tekst i grænsefladen"
                                                  . ?"Required / optional  / automatic"
                                                  . ?"line / lines / box / empty"
                                                  . ?"Placering i header"
                                                  . ?Noter
                                                  . ?Hjælpetekst
                                                  . ?
                                                  . ?URL
                                                  )
                                              & (     !"Required / optional  / automatic"
                                                    :   ?
                                                        ( o
                                                        | r
                                                        | oneOrMore
                                                        | zeroOrMore
                                                        )
                                                        ?
                                                  & ( div
                                                    .   (class.row)
                                                      ,   (     !"line / lines / box / empty"
                                                              : select ?table
                                                            &   readTable
                                                              $ !table
                                                            &   makeSelectFormField
                                                              $ (   addurl
                                                                  $ (   localized
                                                                      $ !"Tekst i grænsefladen"
                                                                    . !URL
                                                                    )
                                                                . !id
                                                                .   ( options
                                                                    .   makeOptionList
                                                                      $ ( !!table
                                                                        .       !parms
                                                                              :   ?
                                                                                  ( !id
                                                                                  . ?val
                                                                                  )
                                                                                  ?
                                                                            & !val
                                                                          | 
                                                                        )
                                                                    )
                                                                    ( desc
                                                                    .   localized
                                                                      $ !Hjælpetekst
                                                                    )
                                                                    ( required
                                                                    .       !"Required / optional  / automatic"
                                                                          :   ?
                                                                              ( r
                                                                              | oneOrMore
                                                                              )
                                                                              ?
                                                                        & ( span
                                                                          .   ( style
                                                                              . "color:blue; width: auto; line-height: normal;"
                                                                              )
                                                                            , "*"
                                                                          )
                                                                      | 
                                                                    )
                                                                )
                                                          |   (     !"line / lines / box / empty"
                                                                  : ( box
                                                                    | lines
                                                                    )
                                                                & makeTextAreaFormField
                                                              | makeTextFormField
                                                              )
                                                            $ (     addurl
                                                                  $ (   localized
                                                                      $ !"Tekst i grænsefladen"
                                                                    . !URL
                                                                    )
                                                                  (     !"Required / optional  / automatic"
                                                                      :   ?
                                                                          a
                                                                          ?
                                                                    & ( span
                                                                      .   ( style
                                                                          . "font-style:italic; width:auto;"
                                                                          )
                                                                        ,   str
                                                                          $ ( " ("
                                                                                localized
                                                                              $ ( "autogenerated if left blank"
                                                                                  "automatisk genereret hvis ikke udfyldt"
                                                                                )
                                                                              ") "
                                                                            )
                                                                      )
                                                                  | 
                                                                  )
                                                              . !id
                                                              .   ( val
                                                                  .       !parms
                                                                        :   ?
                                                                            ( !id
                                                                            . ?val
                                                                            )
                                                                            ?
                                                                      & !val
                                                                    | 
                                                                  )
                                                                  ( desc
                                                                  .   localized
                                                                    $ !Hjælpetekst
                                                                  )
                                                                  ( required
                                                                  .       !"Required / optional  / automatic"
                                                                        :   ?
                                                                            ( r
                                                                            | oneOrMore
                                                                            )
                                                                            ?
                                                                      & ( span
                                                                        .   ( style
                                                                            . "color:blue; width: auto; line-height: normal;"
                                                                            )
                                                                          , "*"
                                                                        )
                                                                    | 
                                                                  )
                                                              )
                                                          )
                                                          (     !ERR
                                                              : ( !id
                                                                . ?typeOfError
                                                                . ?
                                                                )
                                                            & ( span
                                                              .   ( style
                                                                  . "color:red;"
                                                                  )
                                                                , !typeOfError
                                                              )
                                                          | 
                                                          )
                                                    )
                                                |     !"Required / optional  / automatic"
                                                    : ? a ?
                                                  &   !"Tekst i grænsefladen"
                                                    : ~
                                                  & ( div
                                                    .   (class.row)
                                                      ,   makeStaticTextFormField
                                                        $ (   localized
                                                            $ !"Tekst i grænsefladen"
                                                          . span
                                                          .   (class.autogen)
                                                            ,   str
                                                              $ ( " ("
                                                                    localized
                                                                  $ ( autogenerated
                                                                      "automatisk genereret"
                                                                    )
                                                                  ") "
                                                                )
                                                          )
                                                    )
                                                | 
                                                )
                                          )
                                        . !inputs
                                        )
                                    )
                              | 
                          )
                        . readTable$!metadataType
                        )
                  : ?formFields
                &   str
                  $ ( 200~~~
                        toML
                      $ ( !BodyContainer
                        $ ( !formFields:
                          |   ( h1
                              .   
                                ,   localized
                                  $ ("Add metadata" "Tilføj metadata")
                              )
                              (br.,)
                                form
                              $ ( chosenworkflow
                                .   !formFields
                                    ( !nth:<1&
                                    |     makeHiddenFields
                                        $ ((nth.!nth) !hiddenData)
                                        (br.,)
                                        submit$Submit
                                    )
                                )
                          )
                        )
                    )
            )
          & ( makejobstack
            =   NOS stepNo stepping
              .   ( stepping
                  =     a b ID NO I O input
                      , step ad bd deps stp c
                      , nc x y
                    .   !arg:(?arg.?deps)
                      & (   !arg:%?a %?b
                          & stepping$(!a.!deps):(?a.?ad)
                          & stepping$(!b.!ad):(?b.?bd)
                          & (!a !b.!bd)
                        |   !arg:(%?a,%?b)
                          & stepping$(!a.!deps):(?a.?ad)
                          & stepping$(!b.!deps):(?b.?bd)
                          & (!a !b.!ad !bd)
                        |   !arg:(.?NO.?I.?O)
                          & !NOS:? (!NO.?step) ?
                          & (.!step.!O)
                        |   !arg:(?ID.?NO.?I.?O)
                          &   str$(step (1+!stepNo:?stepNo))
                            : ?step
                          & ( !NO:
                            | (!NO.!step) !NOS:?NOS
                            )
                          & (     !deps
                                : (?stp.!I:(?a,?b) ?c)
                              & (!a,(!b.!stp)):?I
                              &   whl
                                ' ( !c:%?a ?c
                                  & !a !I:?I
                                  )
                              & ((!step.!ID.!O.!I).!step.!O)
                            |   (     !I
                                    : ?a (?b,%*%:?input) ?c
                                  & "Make sure input isn't all in one file. (Input has % flag if that were the case)."
                                  & "This fails 
                                         :%? ? 
                                     This succeeds
                                         :? ?

                                     On fail: treat as single-input workflow step.
                                    "
                                  & :!(glf$('($input.?))) ?
                                  & :?nc
                                  &   whl
                                    ' ( !input:%?ad*?input
                                      &     !nc
                                            (     !deps
                                                :   ?x
                                                    ( ?stp
                                                    . ? (!b,!ad) ?
                                                    )
                                                    ?y
                                              & !x !y:?deps
                                              & (!b,(!ad.!stp))
                                            | ( !b
                                              , ( !ad
                                                . FiL
                                                . !a (!b.!ad) !c
                                                )
                                              )
                                            )
                                        : ?nc
                                      )
                                  & !a !nc !c:?I
                                |   !I:(?b,?input) ?c
                                  &   (!b,(!input.FiL.!I)) !c
                                    : ?I
                                )
                              & ((!step.!ID.!O.!I).!step.!O)
                            )
                        )
                  )
                & :?NOS
                & 0:?stepNo
                & stepping$(!arg.):(?arg.?)
                & !arg
            )
          & ( ApplyThePipelineToTheInput
            =     struct batch jobIDoffset parms
                , retrieveMetadataFromParms
                , Items item subjobs mail2 JobId metadataType
              .     !arg
                  : (?metadataType.?struct.?batch.?Items.?mail2.?parms)
                & ( retrieveMetadataFromParms
                  =   metadataType parms
                    .   !arg:(?metadataType.?parms)
                      &   map
                        $ ( ( 
                            =   inputs
                              .     !arg:(?,?inputs)
                                  &   map
                                    $ ( ( 
                                        =   id V
                                          .   !arg:(?id.?)
                                            & (     !parms
                                                  : ? (!id.?V) ?
                                                & (!id.!V)
                                              | 
                                              )
                                        )
                                      . !inputs
                                      )
                                | 
                            )
                          . readTable$!metadataType
                          )
                  )
                & makejobstack$!struct:?JobStack
                & ( readTable$jobNr
                  | 0:?jobNr&saveTable$jobNr
                  )
                & !jobNr+1:?jobNr:?JobNr
                & saveTable$jobNr
                & (   !batch:on
                    & 0:?jobIDoffset
                    &   whl
                      ' ( !Items:%?item ?Items
                        &     convert2URLs
                            $ ( !jobNr
                              . !jobIDoffset
                              . !JobStack
                              . toolsdataURL$
                              . toolsUploadURL$
                              . !item
                              )
                          : ?subjobs
                        & !subjobs+!jobIDoffset:?jobIDoffset
                        )
                  |   convert2URLs
                    $ ( !jobNr
                      . 
                      . !JobStack
                      . toolsdataURL$
                      . toolsUploadURL$
                      . !Items
                      )
                  )
                & (readTable$jobAbout|:?jobAbout)
                &     ( !JobNr
                      .   (mail2.!mail2)
                          (human.makeWorkflowVisualisation$!struct)
                          ( userProvidedMetadata
                          . retrieveMetadataFromParms$(!metadataType.!parms)
                          )
                      )
                      !jobAbout
                  : ?jobAbout
                & saveTable$jobAbout
                & log$(getNextJobID JobNr !JobNr)
                & getNextJobID$(!JobNr.justtesting):?JobId
                & log$(JobId !JobId)
                &   str
                  $ ( 200
                      "~"
                      !JobNr
                      "~"
                      !JobId
                      "~"
                      (   !JobId:
                        &   toML
                          $ ( !BodyContainer
                            $ ( paragraph
                              $ ( localized
                                $ ( "There is nothing to do. The goal seems to be fulfilled already. Go back with the \"back\" button."
                                    "Der er intet at lave. Gå tilbage med knappen \"Forrige\"."
                                  )
                                )
                              )
                            )
                      | poll$(!JobNr.1)
                      )
                    )
            )
          & ( NoNeedForMetadata
            =   
              .   str
                $ ( 200~~~
                      toML
                    $ ( !BodyContainer
                      $ ( paragraph
                        $ ( localized
                          $ ( "The chosen workflow does not produce resources that can be deposited and therefore you do not need to enter metadata."
                              "Den valgte workflow producerer ingen deponerbare resurser og du skal derfor ikke indtaste metadata."
                            )
                          )
                        )
                      )
                  )
            )
          & ( errorInMetadata
            =     pattern metadataType
                , "Tekst i grænsefladen" id ERR val Metadata
              .   !arg:(?metadataType.?arg)
                & readTable$!metadataType:?Metadata
                & :?ERR
                &   !Metadata
                  :   ?
                      ( ?
                      ,   ?
                          ( ?id
                          . ?"Tekst i grænsefladen"
                          .     (r|oneOrMore)
                              &   !arg
                                : (   ?
                                      ( !id
                                      .   ?val
                                        & trim$!val:
                                      )
                                      ?
                                  | ~(? (!id.?) ?)
                                  )
                              &   ( !id
                                  . localized$(required krævet)
                                  . localized$!"Tekst i grænsefladen"
                                  )
                                : ?ERR
                            | ?
                          . ?
                          . ?
                          . ?
                          . ?
                          .     %?pattern ?
                              & !arg:? (!id.~:?val) ?
                              & ~(@(!val:!!pattern)&)
                              &   ( !id
                                  . localized$(format format)
                                  . localized$!"Tekst i grænsefladen"
                                  )
                                : ?ERR
                            | &!ERR:~
                          . ?
                          )
                          ?
                      )
                      ?
                & !ERR
            )
          & ( MetadataInParms
            =   id Metadata metadataType
              .   !arg:(?metadataType.?arg)
                & readTable$!metadataType:?Metadata
                &   !Metadata
                  :   ?
                      ( ?
                      ,   ?
                          (   ?id
                            & !arg:? (!id.?) ?
                          . ?
                          )
                          ?
                      )
                      ?
                & !arg
            )
          & ( rememberMetadata
            =   mail2 userProvidedMetadata metadataType
              .   !arg:(?metadataType.?arg)
                & ( MetadataInParms$(!metadataType.!arg)
                  |   (   !arg:? (mail2.?mail2) ?
                        & readTable$jobAbout
                        &   !jobAbout
                          :   ?
                              ( ?
                              .   ?
                                  (mail2.!mail2)
                                  ?
                                  (userProvidedMetadata.?userProvidedMetadata)
                                  ?
                              )
                              ?
                      | :?userProvidedMetadata
                      )
                    & !userProvidedMetadata !parms
                  )
            )
          & ( "The user has selected a workflow."
            =     Submit hiddenData
                , parms nth batch Items mail2 ERR
                , allpipes ViewDetails
                , returnCode struct whichButton
                , restriction sources bm err
                , goals topologicalOrderedTools wf
              .   ( whichButton
                  =   
                    .   !arg:?bm
                      & (     !Submit
                            : ( !ViewDetails (" - " ?nth|)
                              | @(?:(prev|next) ?)
                              )
                          & ShowOnlyTheCurrentPipe$(!struct.!nth.!bm.)
                        |   !Submit:Metadata
                          & (     !parms
                                : ~( ?
                                     ( Iformat
                                     .   ( txtbasis
                                         | txtann
                                         | teip5
                                         )
                                       ^ ?
                                     )
                                     ?
                                   )
                              & canConsumeMetadata$!struct
                              &   rememberMetadata$(TEImetadata.!parms)
                                : ?parms
                              &   AddMetadata
                                $ (TEImetadata.!nth.!parms..!hiddenData)
                            | NoNeedForMetadata$
                            )
                        |   !Submit:Bookmark
                          & ((!sources.!goals).!struct):?wf
                          & ( !wrkflws:
                            | readTable$wrkflws
                            )
                          &   ShowOnlyTheCurrentPipe
                            $ ( !struct
                              . !nth
                              .     !parms:? (bm.?bm) ?
                                  & (   !wrkflws:? (!bm.?) ?
                                      & inuse:?err
                                    |     (!bm.!wf) !wrkflws
                                        : ?wrkflws
                                      & :?err
                                      & saveTable$wrkflws
                                    )
                                  & !bm
                                | 
                              . !err
                              )
                        |   !Submit:Submit
                          & (     !parms
                                : ~( ?
                                     ( Iformat
                                     .   ( txtbasis
                                         | txtann
                                         | teip5
                                         )
                                       ^ ?
                                     )
                                     ?
                                   )
                              & canConsumeMetadata$!struct
                              & (   MetadataInParms$(TEImetadata.!parms)
                                  &   errorInMetadata$(TEImetadata.!parms)
                                    : ?ERR
                                |   ~(MetadataInParms$(TEImetadata.!parms))
                                  &   !parms
                                    :   ?
                                        ( Oformat
                                        .   ( txtbasis
                                            | txtann
                                            | teip5
                                            )
                                          ^ ?
                                        )
                                        ?
                                  &   rememberMetadata$(TEImetadata.!parms)
                                    : ?parms
                                )
                              &   AddMetadata
                                $ (TEImetadata.!nth.!parms.!ERR.!hiddenData)
                            |   ApplyThePipelineToTheInput
                              $ ( TEImetadata
                                . !struct
                                . !batch
                                . !Items
                                . !mail2
                                . !parms
                                )
                            )
                        )
                  )
                &   !arg
                  : (?parms.?Submit.?hiddenData.?batch.?Items.?mail2)
                & 0:?allpipes
                & :?returnCode:?restriction
                &   !parms
                  : ( ? (nth.?nth) ?
                    | ?&1:?nth
                    )
                &   localized$("View details" "Se detaljer")
                  : ?ViewDetails
                & (   !nth:#
                    &   Pipelines$(!parms.!nth)
                      : ( (?sources.?goals.?)
                        . ( (?.?.?.?.?),(?.?struct)
                          . ?topologicalOrderedTools
                          )
                        . ?returnCode
                        )
                    & "!returnCode:(allRight
                                   |triviallyFulfilled
                                   |tooComplex
                                   |tooMany
                                   |onlyWithoutRestriction
                                   )"
                    & (   !returnCode:allRight
                        & whichButton$
                      | UnexpectedReturnCode$!returnCode
                      )
                  |   !wrkflws:? (!nth.?.?struct) ?
                    & whichButton$!nth
                  | NotFulfillable$NoPipelinesFound
                  )
            )
          & (|log$NEW)
          & log$SINGLEWORKFLOWLOGJE
          & :?PIPE
          &   initialiseSpecifyGoalShowWorkflowsChosenWorkflow$!arg
            : ( ?errors
              . ?hiddenData
              . ?Items
              . ?tabind
              . ?Tool
              . ?parms
              . ?BodyContainer
              )
          & "First build a list of items."
          & (   !Items:
              & buildItemList$!parms:?Items
            | 
            )
          &   analyzeInput$(!parms.!Items.!errors)
            : (?Items.?presels.?errors)
          & ( !errors:~
            |     supplementParmsAndHiddenData$(!parms.!hiddenData)
                : (?parms.?Submit.?hiddenData.?batch)
              &   "The user has selected a workflow."
                $ (!parms.!Submit.!hiddenData.!batch.!Items.!mail2)
            )
      )
      "
/**
 * getStatusCode
 *
 *  Given a HTTP status code and an informatory text, return an HTML-file
 * with a heading containing the status code and the official short description
 * of the status code, a paragraph containing the informatory text and a 
 * paragraph displaying a longer text explaining the code (From wikipedia).
 * 
 * This function could just as well have been written in Java.
 * 
 * Called from create.java, register.java,
 * stresstest.java, update.java, upload.java
 */"
      ( getStatusCode
      =   code tekst explanation
        .   readTable$HTTP-status-codes
          & !arg:(?code.?tekst)
          & !HTTP-status-codes:? (!code.?arg.?explanation) ?
          &   toML
            $ ( !HTMLbodyContainer
              $ ( heading$(1.!code " " !arg)
                  paragraph$!tekst
                  paragraph$!explanation
                )
              )
      )
      "
/**
 * keep
 *
 * Check whether a result from a tool in the staging area can be deleted.
 *
 * Results that for some reason are needed by other tasks must be kept.
 * The function looks for outstanding jobs that take the argument as input.
 * Argument: file name, may be preceded by a slash
 *      /19231210291
 *
 * NOTICE: If the file need not be kept, the file's name is deleted from
 * several tables, so calling keep has side effects!
 * Affected tables:
 *      jobs.table
 *      Uploads.table
 *      CTBs.table
 *      relations.table
 *      jobAbout.table
 *
 * Called from data.java and cleanup.java
 */"
      ( readJobTables
      =   
        .   readTable$jobs
          & readTable$Uploads
          & readTable$CTBs
          & readTable$relations
          & readTable$jobAbout
          & readTable$ItemGroupsCache
      )
      ( saveJobTables
      =   
        .   saveTable$jobs
          & saveTable$Uploads
          & saveTable$CTBs
          & saveTable$relations
          & saveTable$jobAbout
          & saveTable$ItemGroupsCache
      )
      ( keep
      =     jobNr jobID jobstatus files toolURL parms file
          , find jobNrParm stagingName stem
        .   ( find
            =   x T L R
              .   !arg:(?x.?T)&!x:!T
                |   !T:?L_?R
                  & (find$(!x.!L)|find$(!x.!R))
            )
          & log$(keep !arg)
          & !arg:(?stagingName.?jobNrParm)
          & (@(!stagingName:? "/" ?stagingName)|)
          & (   (   @(!stagingName:?stem ".withmetadata.xml")
                  & str$(!stem ".xml")
                |   @(!stagingName:?stem ".relations.csv")
                  & !stem
                )
              : ?stagingName
            | 
            )
          & (   @( !stagingName
                 : !jobNrParm ("-all"|"-final") ".zip"
                 )
              & no
            |   !jobNrParm:
              & (     !jobs
                    :   ?
                        ( ( ?jobNr
                          . %?jobID ?jobstatus
                          . ?files
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                        & ( !files:? !stagingName ?
                          | !file:!stagingName
                          |   !parms:?+(I.?parms)+?
                            & find$(!stagingName.!parms)
                          )
                        &   !jobstatus
                          : ( 
                            | waiting
                            | starting
                            )
                        )
                        ?
                  & yes
                |       map
                      $ ( ( 
                          =   jobNr jobID files file
                            .       !arg
                                  : ( ( ?jobNr
                                      . %?jobID ?
                                      . ?files
                                      . ?
                                      . ?
                                      . ?file
                                      )
                                    & ( !files:? !stagingName ?
                                      | !file:!stagingName
                                      )
                                    )
                                & deleteDepending$(!jobNr.!jobID)
                                & 
                              | !arg
                          )
                        . !jobs
                        )
                    : ?jobs
                  &     map
                      $ ( ( 
                          =   Name
                            .     !arg:(?.?Name.!stagingName.?)
                                &     map
                                    $ ( ( 
                                        =   
                                          .       !arg
                                                : ( ?
                                                  .   ?
                                                      (?.? !Name ?)
                                                      ?
                                                  )
                                              & 
                                            | !arg
                                        )
                                      . !ItemGroupsCache
                                      )
                                  : ?ItemGroupsCache
                                & 
                              | !arg
                          )
                        . !Uploads
                        )
                    : ?Uploads
                  & no
                )
            |     !jobs
                :   ?
                    ( (!jobNrParm.?.?files.?.?parms.?file)
                    & ( !files:? !stagingName ?
                      | !file:!stagingName
                      |   !parms:?+(I.?parms)+?
                        & find$(!stagingName.!parms)
                      )
                    )
                    ?
              & ~( !jobs
                 :   ?
                     ( (~!jobNrParm.?.?files.?.?parms.?file)
                     & ( !files:? !stagingName ?
                       | !file:!stagingName
                       |   !parms:?+(I.?parms)+?
                         & find$(!stagingName.!parms)
                       )
                     )
                     ?
                 )
              & no
            | yes
            )
      )
      ( sum2list
      =   L E
        .   :?L
          &   whl
            ' ( !arg:%?E+?arg
              & (.!E) !L:?L
              )
          & :?arg
          & whl'(!L:%?E ?L&!E !arg:?arg)
          & !arg
      )
      "
/**
 * help
 */"
      ( help
      =     tools langlist toolsSorted Title toolNr ToolID
          , features feats cumfeat usedonly usedFeatures
        .   log$HELP
          & ( !arg:? (usedonly.?usedonly) ?
            | y:?usedonly
            )
          & setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          & log$(help !arg)
          & readTable$tooladm
          & readTable$toolprop
          & readTable$features
          & ( toolsSorted
            =   tool sorted tools L Title sort
              .   0:?sorted
                &   whl
                  ' (   !tooladm
                      :   ?
                        + ( ? (Inactive.) ?
                          : ? (Title.?Title) ?
                          : ?tool
                          )
                        + ?tooladm
                    & (low$!Title.!tool)+!sorted:?sorted
                    )
                & :?tools
                &   whl
                  ' ( !sorted:(?L.%?sort)+?sorted
                    & (!L.!sort) !tools:?tools
                    )
                & :?sorted
                &   whl
                  ' ( !tools:%?sort ?tools
                    & !sort !sorted:?sorted
                    )
                & !sorted
            )
          & ( langlist
            =   tp L R langs l a b
              .     !toolprop:?+(!arg.~(? (lang,?) ?))+?
                  & 
                |   !toolprop:?tp
                  & 0:?L
                  &   whl
                    ' (   !tp
                        : ?+(!arg.? (lang,?langs) ?)+?tp
                      &   whl
                        ' ( !langs:(?a.?b)+?langs
                          & !L+!a+!b:?L
                          )
                      )
                  & :?R
                  &   whl
                    ' (!L:#*%@?l+?L&!l !R:?R)
                  & :?L
                  &   whl
                    ' (!R:%?l ?R&", " !l !L:?L)
                  & ( !L:", " ?L&str$!L
                    | 
                    )
            )
          & sum2list$!features:?feats
          & toolsSorted$:?tools
          & ( usedFeatures
            =   ToolID id tools toolprp cumfeat coll fts
              .   ( coll
                  =   R
                    .   1:?R
                      &   map
                        $ ( ( 
                            =   r e
                              .   1:?r
                                &   whl
                                  ' ( !arg:%?e+?arg
                                    & !e*!r:?r
                                    )
                                & !r*!R:?R
                                & 
                            )
                          . !arg
                          )
                      & !R
                  )
                & !arg:(?tools.?toolprp)
                & 0:?cumfeat
                &   whl
                  ' (   !toolprp
                      :   ?
                        + (   ?ToolID
                            &   !tools
                              :   ?
                                  ( ?
                                  .   ? (ToolID.?id) ?
                                    & !id:!ToolID
                                  )
                                  ?
                          . ?fts
                          )
                        + ?toolprp
                    &   map
                      $ ( ( 
                          =   feat in inou in ou
                            .   !arg:(?feat,?inou)
                              &   whl
                                ' ( !inou:(?in.?ou)+?inou
                                  &   !feat\L(coll$!in*coll$!ou)+!cumfeat
                                    : ?cumfeat
                                  )
                          )
                        . !fts
                        )
                    )
                & !cumfeat
            )
          &   (   !usedonly:y
                & usedFeatures$(!tools.!toolprop)
              | 
              )
            : ?cumfeat
          & 0:?toolNr
          &   toML
            $ ( !HTMLbodyContainer
              $ ( (h1.,"Text Tonsorium")
                  ( h1
                  .   
                    ,   "(This page is still "
                        (i.,"Work in progress")
                        ")"
                  )
                  ( p
                  .   
                    ,   localized
                      $ ( "The Text Tonsorium is a workflow management system that not only executes workflows, but also composes workflows from building blocks. Each building block encapsulates a Natural Language Processing tool."
                          "Text Tonsorium er et workflow management system som ikke kun fører data gennem workflows, men også designer workflows ved hjælp af 'byggeklodser'. Hver byggeklods indeholder et sprogteknologisk værktøj."
                        )
                  )
                  ( p
                  .   
                    ,   localized
                      $ ( "The Text Tonsorium may compose many workflows that all lead to your goal. It will then ask you to choose one of the proposed workflows. In general, the more detail you add to your goal, the fewer solutions the Text Tonsorium will find, even zero. "
                          "Ofte beregner Text Tonsorium mange workflows, som alle fører til dit mål, og så skal du vælge en af disse. Som tommelfingerregel gælder det at hvis du udtrykker dit mål i flere detaljer, vil der være færre forslag til workflows, og måske endda ingen."
                        )
                  )
                  ( p
                  .   
                    ,   localized
                      $ ( "In contrast to other workflow management systems, the Text Tonsorium focuses on results rather than on tools, so a general understanding of how the desired result is described is useful. Still, you may like to also know which tools currently are integrated in the Text Tonsorium. This page gives you information about both."
                          "Når du arbejder med Text Tonsorium, skal dit fokus være på det resultat som du vil opnå, og ikke på de værktøjer der er i værktøjskassen. Derfor er det nyttigt at vide hvordan det ønskede resultat bedst kan beskrives. Du vil måske alligevel også vide hvilke værktøjer er integreret i Text Tonsorium. Denne side giver dig information om begge dele."
                        )
                  )
                  (h3.,localized$(Overview Overblik))
                  ( dl
                  .   
                    ,   (dt.,Data)
                        (dd.,Input)
                        (dd.,localized$(Goal Mål))
                        (dt.,localized$(Features Træk))
                        ( dd
                        .   
                          , ( dl
                            .   
                              ,   map
                                $ ( ( 
                                    =   n d t
                                      .     !arg
                                          : ( 
                                            .   ? (name.?n) ?
                                              : ? (description.?d) ?
                                              : ? (table.?t) ?
                                            )
                                        &   ( dt
                                            .   
                                              , ( a
                                                .   (href.str$("#" !t))
                                                  , localized$!n
                                                )
                                            )
                                            (dd.,localized$!d)
                                    )
                                  . !feats
                                  )
                            )
                        )
                        (dt.,Tools)
                        ( dd
                        .   
                          , ( table
                            .   
                              ,   ( thead
                                  .   
                                    ,   (th.,"#")
                                        (th.,"Name of the tool")
                                        (th.,"Supported languages")
                                  )
                                  ( tbody
                                  .   
                                    ,   map
                                      $ ( ( 
                                          =   Title
                                            .     !arg
                                                : ( ?
                                                  .     ?
                                                        (Title.?Title)
                                                        ?
                                                    :   ?
                                                        (ToolID.?ToolID)
                                                        ?
                                                  )
                                              & ( tr
                                                .   
                                                  ,   ( td
                                                      .   
                                                        ,   !toolNr+1
                                                          : ?toolNr
                                                      )
                                                      ( td
                                                      .   
                                                        , ( a
                                                          .   ( href
                                                              .   str
                                                                $ ("#" !ToolID)
                                                              )
                                                            , !Title
                                                          )
                                                      )
                                                      ( td
                                                      . ,langlist$!ToolID
                                                      )
                                                )
                                          )
                                        . !tools
                                        )
                                  )
                            )
                        )
                  )
                    map
                  $ ( ( 
                      =   Description ToolID Title
                        .       !arg
                              : ( ?
                                .   ? (ToolID.?ToolID) ?
                                  : ? (Title.?Title) ?
                                  : ? (Description.?Description) ?
                                )
                            &   ( a
                                .   (id.!ToolID) (name.!ToolID)
                                  , (h2.,!Title)
                                )
                                (p.,!Description)
                          | 
                      )
                    . !tools
                    )
                    map
                  $ ( ( 
                      =   n t s sT description
                        .     !arg
                            : ( 
                              .   ? (name.?n) ?
                                : ? (table.?t) ?
                                : ? (short.?s) ?
                                : ( ? (specificationTable.?sT) ?
                                  | ?&:?sT
                                  )
                                : ? (description.?description) ?
                              )
                          & readTable$!t
                          &   ( a
                              .   (id.!t) (name.!t)
                                , (h2.,localized$!n)
                              )
                              (p.,localized$!description)
                              ( dl
                              .   
                                ,   map
                                  $ ( ( 
                                      =   n d a p f
                                        .   !arg:(?n.?a.?d)
                                          & (     !cumfeat
                                                : ( 
                                                  | ?+!s\L(?*!a^?p*?)+?
                                                  )
                                              &   (dt.,localized$!n)
                                                  ( !d:
                                                  | (dd.,localized$!d)
                                                  )
                                                  (     !sT
                                                      :   ?
                                                          (? !a ?.?f)
                                                          ?
                                                    & readTable$!f
                                                    & ( dd
                                                      .   
                                                        , ( dl
                                                          .   
                                                            ,   map
                                                              $ ( ( 
                                                                  =     full
                                                                        short
                                                                        dsc
                                                                    .       !arg
                                                                          : ( ?full
                                                                            . ?short
                                                                            . ?dsc
                                                                            )
                                                                        &   !cumfeat
                                                                          : ( 
                                                                            |   ?
                                                                              +   !s
                                                                                \L ( ?
                                                                                  *   !a
                                                                                    ^ ( ?
                                                                                      +   ?
                                                                                        * !short
                                                                                        * ?
                                                                                      + ?
                                                                                      )
                                                                                  * ?
                                                                                  )
                                                                              + ?
                                                                            )
                                                                        &   ( dt
                                                                            .   
                                                                              ,   localized
                                                                                $ !full
                                                                            )
                                                                            ( dd
                                                                            .   
                                                                              ,   localized
                                                                                $ !dsc
                                                                            )
                                                                      | 
                                                                  )
                                                                . !!f
                                                                )
                                                          )
                                                      )
                                                  | 
                                                  )
                                            | 
                                            )
                                      )
                                    . !!t
                                    )
                              )
                      )
                    . !feats
                    )
                )
              )
      )
      "
/**
 * cleanup
 *
 * Delete all references to files that no longer exist.
 * Argument: a list of the files that still exist in the Staging area.
 * Affected tables:
 *      Uploads.table
 *      jobs.table
 *      CTBs.table
 *      relations.table
 *      jobAbout.table 
 *
 * Called from cleanup.java
 */"
      ( cleanup
      =     jobNr jobID jobstatus files toolURL parms file
          , A Z a z F deleteDependingJobs existingFiles
          , feats item meta nr stagingName
        .   ( deleteDependingJobs
            =     A Z jobNr jobs
                , file files jobID jobstatus parms toolURL
              .   !arg:(?arg.?jobs)
                &   whl
                  ' (   !jobs
                      :   ?A
                          ( ?jobNr
                          . %?jobID ?jobstatus
                          . ? !arg ?
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                          ?Z
                    & deleteDepending$(!jobNr.!jobID)
                    &     map
                        $ ( ( 
                            =   
                              .       !arg
                                    : ( !jobNr
                                      . %?jobID ?jobstatus
                                      . ?files
                                      . ?toolURL
                                      . ?parms
                                      . ?file
                                      )
                                  & deleteDepending$(!jobNr.!jobID)
                                  & 
                                | !arg
                            )
                          . !A !Z
                          )
                      : ?jobs
                    )
                & !jobs
            )
          & log$(cleanup !arg)
          & readTable$ItemGroupsCache
          & readTable$Uploads
          & readTable$jobs
          & readTable$CTBs
          & readTable$relations
          & readTable$jobAbout
          & !arg:?existingFiles
          &   ( 
              =   existingFiles zippedresults
                .   !arg:?existingFiles
                  & readTable$zippedresults
                  &     map
                      $ ( ( 
                          =   
                            .     !existingFiles:? !arg ?
                                & !arg
                              | 
                          )
                        . !zippedresults
                        )
                    : ?zippedresults
                  & saveTable$zippedresults
              )
            $ !existingFiles
          &     map
              $ ( ( 
                  =   
                    .       !arg
                          : ( ?
                            .   ?
                                ( ?
                                .   ?
                                    ( %@?item
                                    &   !Uploads
                                      : ( ~(? (?.!item.?) ?)
                                        |   ?
                                            ( ?
                                            . !item
                                            .   ?stagingName
                                              & ~( !existingFiles
                                                 : ? !stagingName ?
                                                 )
                                            . ?
                                            )
                                            ?
                                        )
                                    )
                                    ?
                                )
                                ?
                            )
                        & 
                      | !arg
                  )
                . !ItemGroupsCache
                )
            : ?ItemGroupsCache
          &     map
              $ ( ( 
                  =   
                    .   !arg:(?nr.?item.?stagingName.?meta.?feats)
                      & (   ~(!existingFiles:? !stagingName ?)
                          &     map
                              $ ( ( 
                                  =   
                                    .       !arg
                                          : (?.? (?.? !item ?) ?)
                                        & 
                                      | !arg
                                  )
                                . !ItemGroupsCache
                                )
                            : ?ItemGroupsCache
                          &   deleteDependingJobs$(!stagingName.!jobs)
                            : ?jobs
                          & 
                        | !arg
                        )
                  )
                . !Uploads
                )
            : ?Uploads
          &     map
              $ ( ( 
                  =   
                    .     !arg
                        : ( ?jobNr
                          . %?jobID ?jobstatus
                          . ?files
                          . ?toolURL
                          . ?parms
                          . ?file
                          )
                      & (   (   !files
                              :   ?
                                  ( %@?F
                                  & ~(!existingFiles:? !F ?)
                                  )
                                  ?
                            | ~(!existingFiles:? !file ?)
                            )
                          & deleteDepending$(!jobNr.!jobID)
                          & 
                        | !arg
                        )
                  )
                . !jobs
                )
            : ?jobs
          &   whl
            ' (   !CTBs
                :   ?a
                    ( (?jobNr.?jobID.?)
                    & ~(!jobs:? (!jobNr.!jobID ?.?) ?)
                    )
                    ?z
              & !a !z:?CTBs
              )
          &   whl
            ' (   !relations
                :   ?a
                    ( (?jobNr.?jobID.?)
                    & ~(!jobs:? (!jobNr.!jobID ?.?) ?)
                    )
                    ?z
              & !a !z:?relations
              )
          &   whl
            ' (   !jobAbout
                :   ?a
                    ( (?jobNr.?)
                    & ~(!jobs:? (!jobNr.?) ?)
                    )
                    ?z
              & !a !z:?jobAbout
              )
          & saveTable$Uploads
          & saveTable$jobs
          & saveTable$CTBs
          & saveTable$relations
          & saveTable$jobAbout
          & saveTable$ItemGroupsCache
      )
      "
/*
 * stresstest
 *
 * Do a computation that occupies Bracmat for several seconds.
 * Usage: activate the stresstest from several browsers at
 * about the same time, so they have to queue up and wait for
 * the previous to finish.
 *
 * Purpose: check that the transition from Java's multiple threads
 * to the Bracmat JNI's single thread and back goes smooth.
 *
 * Input: a HTTP-parameter 'stress' with a numerical value > 0.
 *
 * The function computes the first 'stress' terms in the decimal 
 * approximation of π.
 *
 * Called from stresstest.java
 */"
      ( stresstest
      =   PI err pi
        .     ( pi
              =   s1,s2,isgn,isgn1,err1,err2,i,j
                .   0:?s1
                  & 1:?isgn
                  & 1:?i
                  &   whl
                    ' ( !i:~>!arg
                      & 2*!i+-1:?j
                      & !s1+!isgn*(!j*5^!j)^-1:?s1
                      & -1*!isgn:?isgn
                      & 1+!i:?i
                      )
                  & 16*((2*!arg+1)*5^(2*!arg+1))^-1:?err1
                  & !isgn:?isgn1
                  & 16*!s1:?s1
                  & 0:?s2
                  & 1:?isgn
                  & 1:?i
                  &   whl
                    ' ( 2*!i+-1:?j
                      & (!j*239^!j)^-1:?err2
                      & 4*!err2:>!err1
                      & !s2+!isgn*!err2:?s2
                      & -1*!isgn:?isgn
                      & 1+!i:?i
                      )
                  & flt$(!isgn1*(!err1+4*!err2),2):?err
                  & !s1+-4*!s2
              )
            &   !arg
              : ? (stress.~/#?arg:>0:<1001) ?
            & (readTable$pies|:?pies)
            & pi$!arg:?PI
            & !pies (!arg.!PI !err):?pies
            & saveTable$pies
            &   toML
              $ ( !HTMLbodyContainer
                $ ( paragraph
                  $ ( str
                    $ ( "Your number:"
                        !arg
                        " Your approximation of pi:"
                        flt$(!PI,!arg)
                        " error "
                        !err
                      )
                    )
                  )
                )
          |   toML
            $ ( !HTMLbodyContainer
              $ (paragraph$(str$("Not understood:" !arg)))
              )
      )
      ( setLanguage
      =   A Z
        .     !arg:? (UIlanguage.?arg) ?
            & (   readTable$UIlanguage
                & (   !UIlanguage:?A !arg ?Z
                    & !arg !A !Z:?UIlanguage
                    & saveTable$UIlanguage
                    & setLang$!arg:?arg
                    &   toML
                      $ ( !HTMLbodyContainer
                        $ (paragraph$(str$("Sprog er nu sat til " !arg)))
                        )
                  |   toML
                    $ ( !HTMLbodyContainer
                      $ (paragraph$(str$("Det forstod jeg ikke:" !arg)))
                      )
                  )
              |   toML
                $ ( !HTMLbodyContainer
                  $ ( paragraph
                    $ "Table UIlanguage listing ISO codes of supported UI languages could not be read."
                    )
                  )
              )
          |   toML
            $ ( !HTMLbodyContainer
              $ (paragraph$"Expected parameter 'UIlanguage'")
              )
      )
      ( countGraphNodes
      =   count tools feats feat i o cnt tcnt fcnt tool
        .   "Unfold toolprop. Each subspecification doubles count due to specification.
             Counts 360 tools that are active (not 'inactive') 20130424"
          & readTable$toolprop
          & readTable$tooladm
          & !toolprop:?tools
          & NEWSPEC
          & ( count
            =   ret term spcno factor spcs
              .   0:?ret
                &   whl
                  ' ( !arg:%?term+?arg
                    & 1:?spcno
                    &   whl
                      ' ( !term
                        :   ?
                          * ( %?factor %?spcs*?term
                            &   whl
                              ' ( !spcs:% ?spcs
                                & !spcno+!spcno:?spcno
                                )
                            )
                        )
                    & !ret+!spcno:?ret
                    )
                & !ret
            )
          & 0:?cnt
          &   whl
            ' (   !tools
                :   ?
                  + (   ?tool
                      & ( ~&"15 nodes are inactive 20130424"
                        |   !tooladm
                          :   ?
                            + ( ? (ToolID.!tool) ?
                              : ? (Inactive.) ?
                              )
                            + ?
                        )
                    . ?feats
                    )
                  + ?tools
              & 1:?tcnt
              &   whl
                ' ( !feats:(?,?feat) ?feats
                  & 0:?fcnt
                  &   whl
                    ' ( !feat:(?i.?o)+?feat
                      & !fcnt+count$!i*count$!o:?fcnt
                      )
                  & !tcnt*!fcnt:?tcnt
                  )
              & !cnt+!tcnt:?cnt
              )
          & !cnt
      )
      ( countGraphNodesTool
      =   count tools feats feat i o cnt tcnt fcnt tool
        .   "Unfold toolprop. Each subspecification doubles count due to specification.
             Counts 360 tools that are active (not 'inactive') 20130424"
          & !arg:?tools
          & NEWSPEC
          & ( count
            =   ret term spcno fix opt,Nspc Nopt
              .   0:?ret
                &   whl
                  ' ( !arg:%?term+?arg
                    & !term:%?fix ?opt
                    & 1:?spcno
                    &   whl
                      ' ( !fix
                        :     %?
                            ^ ( ?+[?Nspc
                              &   !spcno*(!Nspc:~0|1)
                                : ?spcno
                              )
                          * ?fix
                        )
                    & 0:?Nopt
                    &   whl
                      ' ( !opt:%?^(?+[?Nspc) ?opt
                        &   (!Nspc:~0|1)+!Nopt
                          : ?Nopt
                        )
                    & !ret+!spcno*2^!Nopt:?ret
                    )
                & !ret
            )
          & 0:?cnt
          &   whl
            ' ( !tools:#?*(?tool.?feats)+?tools
              & 1:?tcnt
              &   whl
                ' ( !feats:(?,?feat) ?feats
                  & 0:?fcnt
                  &   whl
                    ' ( !feat:(?i.?o)+?feat
                      & !fcnt+count$!i*count$!o:?fcnt
                      )
                  & !tcnt*!fcnt:?tcnt
                  )
              & !cnt+!tcnt:?cnt
              )
          & !cnt
      )
      ( entry
      =   
        .   setLanguageNotPermanently$!arg
          & setTypefaceNotPermanently$!arg
          &   toML
            $ ( ("!DOCTYPE"." html")
                ( html
                .   (lang.en)
                  ,   ( head
                      .   
                        ,   ( meta
                            .     (http-equiv.Content-Type)
                                  (content."text/html; charset=UTF-8")
                              , 
                            )
                            ( title
                            .   
                              ,   localized
                                $ ( "Text Tonsorium - Natural Language Processing toolchains automatically composed and scheduled for you"
                                    "Text Tonsorium - automatisk sammensætning og aktivering af sprogteknologiske værktøjer"
                                  )
                            )
                            ( style
                            .   
                              ,   "label, h1, h2, h3, span, p, td, input, legend, textarea { font-family:"
                                  (   !TyPeFaCe:sans-serif
                                    & "sans-serif, Comic Sans MS"
                                  | "Comic Sans MS, sans-serif"
                                  )
                                  "; } input, textarea { font-size: 12pt; } p {margin: 0} p.indent {text-indent: 20px} body { font-size: 100%; } fieldset {padding: 10px;border-style: solid;border-radius: 5px;} td.textareawide {width:70%} .smallmargin {margin-top:0.5em; margin-bottom:0.5em;} /*Bold Blacks and Vibrant Highlights*/ /*.bodycanvas {background-color:#F5F5F5} .fileupload {background-color:#EC576b} .URLs {background-color:#4EC5C1} .typein {background-color:#E5E338}*/ /*Striking and Energetic .bodycanvas {background-color:#F2EEE2} .fileupload {background-color:#F5CE28} .typein {background-color:#F5CE28} .URLs {background-color:#F5CE28} */ /*blue, gradient*/ .bodycanvas {background: linear-gradient(rgb(254,254,254), rgba(0,210,255,0.2));background-repeat: no-repeat;} .fileupload {background-color:rgba(154,186,206,0.6);padding: 10px;} .typein {background-color:rgba(154,186,206,0.6);padding: 10px;} .URLs {background-color:rgba(154,186,206,0.6);padding: 10px;} /*.typein {background-color:#43C0F6} .URLs {background-color:#F81B84}*/ label {font-weight: bold; display: block; width: 250px; float: left; padding-left: 9px;} label:after { content: \" \" } .alt {padding: 10px;}"
                            )
                            ( meta
                            .     (name.description)
                                  ( content
                                  .   localized
                                    $ ( "This NLP workflow managment system automatically combines the necessary natural language processing tools to achieve your goal, in a way similar to how a trip planner computes the best route from your current position to your destination."
                                        "Dette workflow managment system kombinerer automatisk de sprogteknologiske værktøjer som kan klare det mål du vil opnå, på en måde som ligner hvordan en routeplanner beregner den bedste route fra din nuværende position til din destination."
                                      )
                                  )
                              , 
                            )
                      )
                      ( body
                      .   (class.bodycanvas)
                        ,   ( "!--"
                            . "div style=\"margin:0px auto;width:860px;text-align:left;border:1px solid #336699;\""
                            )
                            ( div
                            .   ( style
                                . "margin:0px auto;width:55em;text-align:left;"
                                )
                              ,   ( div
                                  .   (style."overflow:auto;")
                                    ,   ( div
                                        .   (style."float:right;")
                                          , ( p
                                            .   
                                              ,   helplink$()
                                                  " "
                                                  ( a
                                                  .   ( href
                                                      .   str
                                                        $ ( "/texton/?UIlanguage="
                                                              localized
                                                            $ (da en)
                                                            "&TyPeFaCe="
                                                              queryEncode
                                                            $ !TyPeFaCe
                                                          )
                                                      )
                                                    ,   localized
                                                      $ (dansk English)
                                                  )
                                            )
                                        )
                                        ( div
                                        .   (style."float:left;")
                                          , ( h1
                                            .   (class.smallmargin)
                                              ,   "Text Tonsorium "
                                                  ("!--"."&#128136;")
                                                  "    "
                                                  ( small
                                                  .   
                                                    , ( small
                                                      .   
                                                        ,   localized
                                                          $ ( "A salon de beauté for Natural Language Processing"
                                                              "En skønhedssalon for Sprogteknologi"
                                                            )
                                                      )
                                                  )
                                            )
                                        )
                                  )
                                  ( div
                                  .   
                                    ,   ( p
                                        .   
                                          ,   localized
                                            $ ( " Upload your input using the form on this page. On the next page you specify the desired final result - there are several annotation types, file formats, languages and other traits to choose from. The hard part - picking and orchestrating the Natural Language Processing tools that are needed to achieve your goal - is handled by this service. "
                                                "Upload din input ved hjælp af formularen på denne side. På næste side specificerer du dit mål - der er adskillige indholdstyper, filformater, sprog og andre træk at vælge imellem. Det svære - at finde og orkestrere de sprogteknologiske værktøjer som er nødvendige for at opnå dit mål - bliver håndteret af denne service."
                                              )
                                        )
                                        ( form
                                        .     (enctype.multipart/form-data)
                                              (method.post)
                                              (action.specifyGoal)
                                          , ( fieldset
                                            .   (style."margin-top:10px;")
                                              ,   ( legend
                                                  .   ( style
                                                      . "font-weight: bold;"
                                                      )
                                                    ,   localized
                                                      $ ( "Upload input"
                                                          "Upload input"
                                                        )
                                                  )
                                                  ( div
                                                  .   (class.fileupload)
                                                    ,   ( label
                                                        .   (for.inp)
                                                          ,   localized
                                                            $ ( "Select one or more files"
                                                                "Selektér en eller flere filer"
                                                              )
                                                        )
                                                        ( input
                                                        .     (type.file)
                                                              (name.input)
                                                              (id.inp)
                                                              (size.50)
                                                              ( multiple
                                                              . multiple
                                                              )
                                                          , 
                                                        )
                                                  )
                                                  ( p
                                                  .   (class.smallmargin)
                                                    , ( strong
                                                      .   
                                                        , ( small
                                                          .   
                                                            ,   localized
                                                              $ ( "... or ..."
                                                                  "... eller ..."
                                                                )
                                                          )
                                                      )
                                                  )
                                                  ( div
                                                  .   (class.URLs)
                                                    ,   ( label
                                                        .   (for.area)
                                                          ,     localized
                                                              $ ( "Enter addresses of web pages,"
                                                                  "Indtast adresser af websider,"
                                                                )
                                                              (br.,)
                                                                localized
                                                              $ ( "one URL per line, each starting with http:// or https://"
                                                                  "én URL pr. linje, startende med http:// eller https://"
                                                                )
                                                        )
                                                        ( textarea
                                                        .     (name.URLS)
                                                              (rows.3)
                                                              (cols.68)
                                                              (id.area)
                                                          , 
                                                        )
                                                  )
                                                  ( p
                                                  .   (class.smallmargin)
                                                    , ( strong
                                                      .   
                                                        , ( small
                                                          .   
                                                            ,   localized
                                                              $ ( "... or ..."
                                                                  "... eller ..."
                                                                )
                                                          )
                                                      )
                                                  )
                                                  ( div
                                                  .   (class.typein)
                                                    ,   ( label
                                                        .   (for.free)
                                                          ,   localized
                                                            $ ( "Type or copy and paste some text"
                                                                "Skriv eller kopiér tekst"
                                                              )
                                                        )
                                                        ( textarea
                                                        .     (name.text)
                                                              (rows.3)
                                                              (cols.68)
                                                              (id.free)
                                                          , 
                                                        )
                                                  )
                                                  ( div
                                                  .   (style."margin-top:10px;")
                                                    ,   ( label
                                                        .   ( style
                                                            . "padding-left: 19px;"
                                                            )
                                                          ,   localized
                                                            $ ( "Next step: "
                                                                "Næste trin: "
                                                              )
                                                        )
                                                        ( input
                                                        .     (type.submit)
                                                              ( value
                                                              .   localized
                                                                $ ( "Specify the required result"
                                                                    "Specificer mål"
                                                                  )
                                                              )
                                                          , 
                                                        )
                                                  )
                                                  ( input
                                                  .     (type.hidden)
                                                        (name.UIlanguage)
                                                        ( value
                                                        .   localized
                                                          $ (en da)
                                                        )
                                                    , 
                                                  )
                                                  ( input
                                                  .     (type.hidden)
                                                        (name.TyPeFaCe)
                                                        (value.!TyPeFaCe)
                                                    , 
                                                  )
                                                  ( input
                                                  .     (type.hidden)
                                                        (name.action)
                                                        (value.batch)
                                                    , 
                                                  )
                                            )
                                        )
                                        ( p
                                        .   (class.indent)
                                          , ( small
                                            .   
                                              ,     localized
                                                  $ ( "Find the most recent source code of the Text Tonsorium on "
                                                      "Find den seneste version af kildekoden af Text Tonsorium på "
                                                    )
                                                  ( a
                                                  .   ( href
                                                      . "https://github.com/kuhumcst/texton"
                                                      )
                                                    , GitHub
                                                  )
                                                    localized
                                                  $ ( ", where you can also contact us. "
                                                      ". Der kan du også kontakte os."
                                                    )
                                            )
                                        )
                                        ( p
                                        .   (class.indent)
                                          , ( small
                                            .   
                                              ,   localized
                                                $ ( "This service is free for small amounts of text. Do not send sensitive data to this service and use it at your own risk! "
                                                    "Brug denne side for små mængder af tekst. Upload aldrig følsomme data. Brugen af tjenesten er på egen risiko!"
                                                  )
                                            )
                                        )
                                        ( p
                                        .   (class.indent)
                                          , ( small
                                            .   
                                              ,     localized
                                                  $ ( "Change typeface to "
                                                      "Skift skrifttype til "
                                                    )
                                                  ( a
                                                  .   ( href
                                                      .   str
                                                        $ ( "/texton/?UIlanguage="
                                                            !LaNg
                                                            "&TyPeFaCe="
                                                              queryEncode
                                                            $ (     !TyPeFaCe
                                                                  : "Comic Sans MS"
                                                                & sans-serif
                                                              | "Comic Sans MS"
                                                              )
                                                          )
                                                      )
                                                    ,       !TyPeFaCe
                                                          : "Comic Sans MS"
                                                        & sans-serif
                                                      | "Comic Sans MS"
                                                  )
                                                  ". "
                                                    localized
                                                  $ ("Why " "Hvorfor ")
                                                  ( a
                                                  .   ( href
                                                      . "https://theestablishment.co/hating-comic-sans-is-ableist-bc4a4de87093/"
                                                      )
                                                    , "Comic Sans"
                                                  )
                                                  "? "
                                            )
                                        )
                                        readTable$footer
                                  )
                            )
                      )
                )
              )
      )
      (Uploads=)
      (LaNg=)
  : ?Globals
& (setLang$da|);

r=
  get'"toolsProg.bra"
& rmv$"toolsProg.bak"
& ren$("toolsProg.bra"."toolsProg.bak")
&   put
  $ ( "{toolsProg.bra


    Copyright 2014, Bart Jongejan
    This file is part of the DK-ClarinTools.

    DK-ClarinTools is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    DK-ClarinTools is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with DK-ClarinTools.  If not, see <http://www.gnu.org/licenses/>.





Source code for DK-Clarin tools webservice 

To neatly re-format this source code, load the file in a running instance of
Bracmat:

    get$\"toolsprog.bra\"
    
Now, after you have made changes to the source code in a text editor, reload
the source code in Bracmat using the command:

    !r

This command re-reads the file, renames the previous version from toolsprog.bra
to toolsprog.bak and then saves the source code. Some editors will notice that
the text has changed on disk and offer you to reload the source code.

To change the comment near the start of this file, you need to go to the bottom
of the file and find the text there. A change made to that text takes effect
after saving once and pressing !r two times. Remember to escape quotes \" with
a backslash \\. Comments elsewhere (i.e. text enclosed by braces { and } is NOT
saved. Use string expressions if you want a comment somewhere.

The following commands can be issued by sending an 'expression' HTTP parameter
to the 'bracmatevaluator' servlet.

To get started from a file containing all tables called 'alltablesxxx' (replace
xxx with actual characters in the file name), e.g., alltables.GPL:

importTables$\"alltables.GPL\"

This reads the named file and stores each table in a separate file in a folder
structure
work/
    job/
    meta/
        feature/
        style/

(This folder structure must already exist.) Finally, the same file is
rewritten, so all lay-out is normalized (Bracmat style).
This command reads all single file tables from the folder structure and saves
them to 'alltablesxxx'. The command knows the actual name of the file to write
to because that name is stored in the variable AAA, which is itself stored
alongside all tables, and is therefore known after the last time 
importTables$alltablesxxx was called. It is possible to change context by
reading an 'alltablesyyy' that is different from 'alltablesxxx'.

If <prod> is the empty string \"\", then the table tooladm is anonymized by 
changing all domains in service URLs \"http:\\localhost\" and by changing all
contact emails to \"x@x.xxx\".

To export all tables to a different file, do

exportTables$(<prod>.\"alltableszzz\")

where alltableszzz must be a valid file name that starts with 'alltables'.



To do a clean up, removing almost all that is not defined in this file from 
Bracmat's memory, call the clean function

    clean$
    
Changes made to table files take immediately effect. It is advised to use the
admin page to register new tools. Some changes cannot be made using the admin
page, such as adding a new feature or feature value.
    
Server:
Add following line to /etc/httpd/conf.d/proxy_ajp.conf:
    ProxyPass /toolsdata !
(Restart Apache sudo /etc/init.d/httpd restart)
    
Make sure bracmat is in JBoss's or Tomcat PATH:
    /usr/lib/libbracmat.so -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1 -> /usr/lib/libbracmat.so.1.0
    /usr/lib/libbracmat.so.1.0

The conf/properties.xml file has an entry \"toolsHome\". The value of this entry
is the location of this file, toolsprog.bra.
}

"
    , "toolsProg.bra"
    , NEW BIN
    )
& lst'(toolsProg,"toolsProg.bra",APP BIN)
& put'(\n,"toolsProg.bra",APP BIN)
& lst'(r,"toolsProg.bra",APP BIN);
